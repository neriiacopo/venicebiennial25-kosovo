(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: true, subtree: true });
  function t(r) {
    const s = {};
    return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
  }
  function i(r) {
    if (r.ep) return;
    r.ep = true;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function Nx(n18) {
  return n18 && n18.__esModule && Object.prototype.hasOwnProperty.call(n18, "default") ? n18.default : n18;
}
var OA = { exports: {} }, sg = {}, FA = { exports: {} }, Et = {};
/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Th = Symbol.for("react.element"), S3 = Symbol.for("react.portal"), M3 = Symbol.for("react.fragment"), w3 = Symbol.for("react.strict_mode"), E3 = Symbol.for("react.profiler"), T3 = Symbol.for("react.provider"), A3 = Symbol.for("react.context"), C3 = Symbol.for("react.forward_ref"), R3 = Symbol.for("react.suspense"), P3 = Symbol.for("react.memo"), b3 = Symbol.for("react.lazy"), dw = Symbol.iterator;
function L3(n18) {
  return n18 === null || typeof n18 != "object" ? null : (n18 = dw && n18[dw] || n18["@@iterator"], typeof n18 == "function" ? n18 : null);
}
var kA = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, zA = Object.assign, BA = {};
function uc(n18, e, t) {
  this.props = n18, this.context = e, this.refs = BA, this.updater = t || kA;
}
uc.prototype.isReactComponent = {};
uc.prototype.setState = function(n18, e) {
  if (typeof n18 != "object" && typeof n18 != "function" && n18 != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, n18, e, "setState");
};
uc.prototype.forceUpdate = function(n18) {
  this.updater.enqueueForceUpdate(this, n18, "forceUpdate");
};
function VA() {
}
VA.prototype = uc.prototype;
function Ux(n18, e, t) {
  this.props = n18, this.context = e, this.refs = BA, this.updater = t || kA;
}
var Ox = Ux.prototype = new VA();
Ox.constructor = Ux;
zA(Ox, uc.prototype);
Ox.isPureReactComponent = true;
var pw = Array.isArray, HA = Object.prototype.hasOwnProperty, Fx = { current: null }, GA = { key: true, ref: true, __self: true, __source: true };
function WA(n18, e, t) {
  var i, r = {}, s = null, o = null;
  if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) HA.call(e, i) && !GA.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var u = Array(a), f = 0; f < a; f++) u[f] = arguments[f + 2];
    r.children = u;
  }
  if (n18 && n18.defaultProps) for (i in a = n18.defaultProps, a) r[i] === void 0 && (r[i] = a[i]);
  return { $$typeof: Th, type: n18, key: s, ref: o, props: r, _owner: Fx.current };
}
function I3(n18, e) {
  return { $$typeof: Th, type: n18.type, key: e, ref: n18.ref, props: n18.props, _owner: n18._owner };
}
function kx(n18) {
  return typeof n18 == "object" && n18 !== null && n18.$$typeof === Th;
}
function D3(n18) {
  var e = { "=": "=0", ":": "=2" };
  return "$" + n18.replace(/[=:]/g, function(t) {
    return e[t];
  });
}
var mw = /\/+/g;
function o_(n18, e) {
  return typeof n18 == "object" && n18 !== null && n18.key != null ? D3("" + n18.key) : e.toString(36);
}
function Jp(n18, e, t, i, r) {
  var s = typeof n18;
  (s === "undefined" || s === "boolean") && (n18 = null);
  var o = false;
  if (n18 === null) o = true;
  else switch (s) {
    case "string":
    case "number":
      o = true;
      break;
    case "object":
      switch (n18.$$typeof) {
        case Th:
        case S3:
          o = true;
      }
  }
  if (o) return o = n18, r = r(o), n18 = i === "" ? "." + o_(o, 0) : i, pw(r) ? (t = "", n18 != null && (t = n18.replace(mw, "$&/") + "/"), Jp(r, e, t, "", function(f) {
    return f;
  })) : r != null && (kx(r) && (r = I3(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(mw, "$&/") + "/") + n18)), e.push(r)), 1;
  if (o = 0, i = i === "" ? "." : i + ":", pw(n18)) for (var a = 0; a < n18.length; a++) {
    s = n18[a];
    var u = i + o_(s, a);
    o += Jp(s, e, t, u, r);
  }
  else if (u = L3(n18), typeof u == "function") for (n18 = u.call(n18), a = 0; !(s = n18.next()).done; ) s = s.value, u = i + o_(s, a++), o += Jp(s, e, t, u, r);
  else if (s === "object") throw e = String(n18), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n18).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
  return o;
}
function kd(n18, e, t) {
  if (n18 == null) return n18;
  var i = [], r = 0;
  return Jp(n18, i, "", "", function(s) {
    return e.call(t, s, r++);
  }), i;
}
function N3(n18) {
  if (n18._status === -1) {
    var e = n18._result;
    e = e(), e.then(function(t) {
      (n18._status === 0 || n18._status === -1) && (n18._status = 1, n18._result = t);
    }, function(t) {
      (n18._status === 0 || n18._status === -1) && (n18._status = 2, n18._result = t);
    }), n18._status === -1 && (n18._status = 0, n18._result = e);
  }
  if (n18._status === 1) return n18._result.default;
  throw n18._result;
}
var Li = { current: null }, Kp = { transition: null }, U3 = { ReactCurrentDispatcher: Li, ReactCurrentBatchConfig: Kp, ReactCurrentOwner: Fx };
function XA() {
  throw Error("act(...) is not supported in production builds of React.");
}
Et.Children = { map: kd, forEach: function(n18, e, t) {
  kd(n18, function() {
    e.apply(this, arguments);
  }, t);
}, count: function(n18) {
  var e = 0;
  return kd(n18, function() {
    e++;
  }), e;
}, toArray: function(n18) {
  return kd(n18, function(e) {
    return e;
  }) || [];
}, only: function(n18) {
  if (!kx(n18)) throw Error("React.Children.only expected to receive a single React element child.");
  return n18;
} };
Et.Component = uc;
Et.Fragment = M3;
Et.Profiler = E3;
Et.PureComponent = Ux;
Et.StrictMode = w3;
Et.Suspense = R3;
Et.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = U3;
Et.act = XA;
Et.cloneElement = function(n18, e, t) {
  if (n18 == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n18 + ".");
  var i = zA({}, n18.props), r = n18.key, s = n18.ref, o = n18._owner;
  if (e != null) {
    if (e.ref !== void 0 && (s = e.ref, o = Fx.current), e.key !== void 0 && (r = "" + e.key), n18.type && n18.type.defaultProps) var a = n18.type.defaultProps;
    for (u in e) HA.call(e, u) && !GA.hasOwnProperty(u) && (i[u] = e[u] === void 0 && a !== void 0 ? a[u] : e[u]);
  }
  var u = arguments.length - 2;
  if (u === 1) i.children = t;
  else if (1 < u) {
    a = Array(u);
    for (var f = 0; f < u; f++) a[f] = arguments[f + 2];
    i.children = a;
  }
  return { $$typeof: Th, type: n18.type, key: r, ref: s, props: i, _owner: o };
};
Et.createContext = function(n18) {
  return n18 = { $$typeof: A3, _currentValue: n18, _currentValue2: n18, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n18.Provider = { $$typeof: T3, _context: n18 }, n18.Consumer = n18;
};
Et.createElement = WA;
Et.createFactory = function(n18) {
  var e = WA.bind(null, n18);
  return e.type = n18, e;
};
Et.createRef = function() {
  return { current: null };
};
Et.forwardRef = function(n18) {
  return { $$typeof: C3, render: n18 };
};
Et.isValidElement = kx;
Et.lazy = function(n18) {
  return { $$typeof: b3, _payload: { _status: -1, _result: n18 }, _init: N3 };
};
Et.memo = function(n18, e) {
  return { $$typeof: P3, type: n18, compare: e === void 0 ? null : e };
};
Et.startTransition = function(n18) {
  var e = Kp.transition;
  Kp.transition = {};
  try {
    n18();
  } finally {
    Kp.transition = e;
  }
};
Et.unstable_act = XA;
Et.useCallback = function(n18, e) {
  return Li.current.useCallback(n18, e);
};
Et.useContext = function(n18) {
  return Li.current.useContext(n18);
};
Et.useDebugValue = function() {
};
Et.useDeferredValue = function(n18) {
  return Li.current.useDeferredValue(n18);
};
Et.useEffect = function(n18, e) {
  return Li.current.useEffect(n18, e);
};
Et.useId = function() {
  return Li.current.useId();
};
Et.useImperativeHandle = function(n18, e, t) {
  return Li.current.useImperativeHandle(n18, e, t);
};
Et.useInsertionEffect = function(n18, e) {
  return Li.current.useInsertionEffect(n18, e);
};
Et.useLayoutEffect = function(n18, e) {
  return Li.current.useLayoutEffect(n18, e);
};
Et.useMemo = function(n18, e) {
  return Li.current.useMemo(n18, e);
};
Et.useReducer = function(n18, e, t) {
  return Li.current.useReducer(n18, e, t);
};
Et.useRef = function(n18) {
  return Li.current.useRef(n18);
};
Et.useState = function(n18) {
  return Li.current.useState(n18);
};
Et.useSyncExternalStore = function(n18, e, t) {
  return Li.current.useSyncExternalStore(n18, e, t);
};
Et.useTransition = function() {
  return Li.current.useTransition();
};
Et.version = "18.3.1";
FA.exports = Et;
var be = FA.exports;
const O3 = Nx(be);
/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var F3 = be, k3 = Symbol.for("react.element"), z3 = Symbol.for("react.fragment"), B3 = Object.prototype.hasOwnProperty, V3 = F3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, H3 = { key: true, ref: true, __self: true, __source: true };
function YA(n18, e, t) {
  var i, r = {}, s = null, o = null;
  t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
  for (i in e) B3.call(e, i) && !H3.hasOwnProperty(i) && (r[i] = e[i]);
  if (n18 && n18.defaultProps) for (i in e = n18.defaultProps, e) r[i] === void 0 && (r[i] = e[i]);
  return { $$typeof: k3, type: n18, key: s, ref: o, props: r, _owner: V3.current };
}
sg.Fragment = z3;
sg.jsx = YA;
sg.jsxs = YA;
OA.exports = sg;
var Tt = OA.exports, Iv = {}, qA = { exports: {} }, gr = {}, jA = { exports: {} }, ZA = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(n18) {
  function e(V, q) {
    var Y = V.length;
    V.push(q);
    e: for (; 0 < Y; ) {
      var $ = Y - 1 >>> 1, ae = V[$];
      if (0 < r(ae, q)) V[$] = q, V[Y] = ae, Y = $;
      else break e;
    }
  }
  function t(V) {
    return V.length === 0 ? null : V[0];
  }
  function i(V) {
    if (V.length === 0) return null;
    var q = V[0], Y = V.pop();
    if (Y !== q) {
      V[0] = Y;
      e: for (var $ = 0, ae = V.length, Ee = ae >>> 1; $ < Ee; ) {
        var ne = 2 * ($ + 1) - 1, he = V[ne], Ce = ne + 1, Ie = V[Ce];
        if (0 > r(he, Y)) Ce < ae && 0 > r(Ie, he) ? (V[$] = Ie, V[Ce] = Y, $ = Ce) : (V[$] = he, V[ne] = Y, $ = ne);
        else if (Ce < ae && 0 > r(Ie, Y)) V[$] = Ie, V[Ce] = Y, $ = Ce;
        else break e;
      }
    }
    return q;
  }
  function r(V, q) {
    var Y = V.sortIndex - q.sortIndex;
    return Y !== 0 ? Y : V.id - q.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n18.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    n18.unstable_now = function() {
      return o.now() - a;
    };
  }
  var u = [], f = [], h = 1, d = null, p = 3, g = false, v = false, M = false, S = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function T(V) {
    for (var q = t(f); q !== null; ) {
      if (q.callback === null) i(f);
      else if (q.startTime <= V) i(f), q.sortIndex = q.expirationTime, e(u, q);
      else break;
      q = t(f);
    }
  }
  function C(V) {
    if (M = false, T(V), !v) if (t(u) !== null) v = true, J(L);
    else {
      var q = t(f);
      q !== null && ce(C, q.startTime - V);
    }
  }
  function L(V, q) {
    v = false, M && (M = false, m(U), U = -1), g = true;
    var Y = p;
    try {
      for (T(q), d = t(u); d !== null && (!(d.expirationTime > q) || V && !D()); ) {
        var $ = d.callback;
        if (typeof $ == "function") {
          d.callback = null, p = d.priorityLevel;
          var ae = $(d.expirationTime <= q);
          q = n18.unstable_now(), typeof ae == "function" ? d.callback = ae : d === t(u) && i(u), T(q);
        } else i(u);
        d = t(u);
      }
      if (d !== null) var Ee = true;
      else {
        var ne = t(f);
        ne !== null && ce(C, ne.startTime - q), Ee = false;
      }
      return Ee;
    } finally {
      d = null, p = Y, g = false;
    }
  }
  var b = false, I = null, U = -1, B = 5, R = -1;
  function D() {
    return !(n18.unstable_now() - R < B);
  }
  function j() {
    if (I !== null) {
      var V = n18.unstable_now();
      R = V;
      var q = true;
      try {
        q = I(true, V);
      } finally {
        q ? te() : (b = false, I = null);
      }
    } else b = false;
  }
  var te;
  if (typeof E == "function") te = function() {
    E(j);
  };
  else if (typeof MessageChannel < "u") {
    var X = new MessageChannel(), Q = X.port2;
    X.port1.onmessage = j, te = function() {
      Q.postMessage(null);
    };
  } else te = function() {
    S(j, 0);
  };
  function J(V) {
    I = V, b || (b = true, te());
  }
  function ce(V, q) {
    U = S(function() {
      V(n18.unstable_now());
    }, q);
  }
  n18.unstable_IdlePriority = 5, n18.unstable_ImmediatePriority = 1, n18.unstable_LowPriority = 4, n18.unstable_NormalPriority = 3, n18.unstable_Profiling = null, n18.unstable_UserBlockingPriority = 2, n18.unstable_cancelCallback = function(V) {
    V.callback = null;
  }, n18.unstable_continueExecution = function() {
    v || g || (v = true, J(L));
  }, n18.unstable_forceFrameRate = function(V) {
    0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < V ? Math.floor(1e3 / V) : 5;
  }, n18.unstable_getCurrentPriorityLevel = function() {
    return p;
  }, n18.unstable_getFirstCallbackNode = function() {
    return t(u);
  }, n18.unstable_next = function(V) {
    switch (p) {
      case 1:
      case 2:
      case 3:
        var q = 3;
        break;
      default:
        q = p;
    }
    var Y = p;
    p = q;
    try {
      return V();
    } finally {
      p = Y;
    }
  }, n18.unstable_pauseExecution = function() {
  }, n18.unstable_requestPaint = function() {
  }, n18.unstable_runWithPriority = function(V, q) {
    switch (V) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        V = 3;
    }
    var Y = p;
    p = V;
    try {
      return q();
    } finally {
      p = Y;
    }
  }, n18.unstable_scheduleCallback = function(V, q, Y) {
    var $ = n18.unstable_now();
    switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? $ + Y : $) : Y = $, V) {
      case 1:
        var ae = -1;
        break;
      case 2:
        ae = 250;
        break;
      case 5:
        ae = 1073741823;
        break;
      case 4:
        ae = 1e4;
        break;
      default:
        ae = 5e3;
    }
    return ae = Y + ae, V = { id: h++, callback: q, priorityLevel: V, startTime: Y, expirationTime: ae, sortIndex: -1 }, Y > $ ? (V.sortIndex = Y, e(f, V), t(u) === null && V === t(f) && (M ? (m(U), U = -1) : M = true, ce(C, Y - $))) : (V.sortIndex = ae, e(u, V), v || g || (v = true, J(L))), V;
  }, n18.unstable_shouldYield = D, n18.unstable_wrapCallback = function(V) {
    var q = p;
    return function() {
      var Y = p;
      p = q;
      try {
        return V.apply(this, arguments);
      } finally {
        p = Y;
      }
    };
  };
})(ZA);
jA.exports = ZA;
var G3 = jA.exports;
/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var W3 = be, dr = G3;
function Se(n18) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n18, t = 1; t < arguments.length; t++) e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified React error #" + n18 + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var JA = /* @__PURE__ */ new Set(), Df = {};
function _l(n18, e) {
  Wu(n18, e), Wu(n18 + "Capture", e);
}
function Wu(n18, e) {
  for (Df[n18] = e, n18 = 0; n18 < e.length; n18++) JA.add(e[n18]);
}
var eo = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Dv = Object.prototype.hasOwnProperty, X3 = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, gw = {}, _w = {};
function Y3(n18) {
  return Dv.call(_w, n18) ? true : Dv.call(gw, n18) ? false : X3.test(n18) ? _w[n18] = true : (gw[n18] = true, false);
}
function q3(n18, e, t, i) {
  if (t !== null && t.type === 0) return false;
  switch (typeof e) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      return i ? false : t !== null ? !t.acceptsBooleans : (n18 = n18.toLowerCase().slice(0, 5), n18 !== "data-" && n18 !== "aria-");
    default:
      return false;
  }
}
function j3(n18, e, t, i) {
  if (e === null || typeof e > "u" || q3(n18, e, t, i)) return true;
  if (i) return false;
  if (t !== null) switch (t.type) {
    case 3:
      return !e;
    case 4:
      return e === false;
    case 5:
      return isNaN(e);
    case 6:
      return isNaN(e) || 1 > e;
  }
  return false;
}
function Ii(n18, e, t, i, r, s, o) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n18, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o;
}
var ti = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n18) {
  ti[n18] = new Ii(n18, 0, false, n18, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n18) {
  var e = n18[0];
  ti[e] = new Ii(e, 1, false, n18[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 2, false, n18.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 2, false, n18, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n18) {
  ti[n18] = new Ii(n18, 3, false, n18.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 3, true, n18, null, false, false);
});
["capture", "download"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 4, false, n18, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 6, false, n18, null, false, false);
});
["rowSpan", "start"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 5, false, n18.toLowerCase(), null, false, false);
});
var zx = /[\-:]([a-z])/g;
function Bx(n18) {
  return n18[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n18) {
  var e = n18.replace(zx, Bx);
  ti[e] = new Ii(e, 1, false, n18, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n18) {
  var e = n18.replace(zx, Bx);
  ti[e] = new Ii(e, 1, false, n18, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n18) {
  var e = n18.replace(zx, Bx);
  ti[e] = new Ii(e, 1, false, n18, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 1, false, n18.toLowerCase(), null, false, false);
});
ti.xlinkHref = new Ii("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(n18) {
  ti[n18] = new Ii(n18, 1, false, n18.toLowerCase(), null, true, true);
});
function Vx(n18, e, t, i) {
  var r = ti.hasOwnProperty(e) ? ti[e] : null;
  (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (j3(e, t, r, i) && (t = null), i || r === null ? Y3(e) && (t === null ? n18.removeAttribute(e) : n18.setAttribute(e, "" + t)) : r.mustUseProperty ? n18[r.propertyName] = t === null ? r.type === 3 ? false : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n18.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === true ? "" : "" + t, i ? n18.setAttributeNS(i, e, t) : n18.setAttribute(e, t))));
}
var uo = W3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, zd = Symbol.for("react.element"), du = Symbol.for("react.portal"), pu = Symbol.for("react.fragment"), Hx = Symbol.for("react.strict_mode"), Nv = Symbol.for("react.profiler"), KA = Symbol.for("react.provider"), QA = Symbol.for("react.context"), Gx = Symbol.for("react.forward_ref"), Uv = Symbol.for("react.suspense"), Ov = Symbol.for("react.suspense_list"), Wx = Symbol.for("react.memo"), bo = Symbol.for("react.lazy"), $A = Symbol.for("react.offscreen"), vw = Symbol.iterator;
function zc(n18) {
  return n18 === null || typeof n18 != "object" ? null : (n18 = vw && n18[vw] || n18["@@iterator"], typeof n18 == "function" ? n18 : null);
}
var cn = Object.assign, a_;
function uf(n18) {
  if (a_ === void 0) try {
    throw Error();
  } catch (t) {
    var e = t.stack.trim().match(/\n( *(at )?)/);
    a_ = e && e[1] || "";
  }
  return `
` + a_ + n18;
}
var l_ = false;
function u_(n18, e) {
  if (!n18 || l_) return "";
  l_ = true;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e) if (e = function() {
      throw Error();
    }, Object.defineProperty(e.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(e, []);
      } catch (f) {
        var i = f;
      }
      Reflect.construct(n18, [], e);
    } else {
      try {
        e.call();
      } catch (f) {
        i = f;
      }
      n18.call(e.prototype);
    }
    else {
      try {
        throw Error();
      } catch (f) {
        i = f;
      }
      n18();
    }
  } catch (f) {
    if (f && i && typeof f.stack == "string") {
      for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; ) a--;
      for (; 1 <= o && 0 <= a; o--, a--) if (r[o] !== s[a]) {
        if (o !== 1 || a !== 1) do
          if (o--, a--, 0 > a || r[o] !== s[a]) {
            var u = `
` + r[o].replace(" at new ", " at ");
            return n18.displayName && u.includes("<anonymous>") && (u = u.replace("<anonymous>", n18.displayName)), u;
          }
        while (1 <= o && 0 <= a);
        break;
      }
    }
  } finally {
    l_ = false, Error.prepareStackTrace = t;
  }
  return (n18 = n18 ? n18.displayName || n18.name : "") ? uf(n18) : "";
}
function Z3(n18) {
  switch (n18.tag) {
    case 5:
      return uf(n18.type);
    case 16:
      return uf("Lazy");
    case 13:
      return uf("Suspense");
    case 19:
      return uf("SuspenseList");
    case 0:
    case 2:
    case 15:
      return n18 = u_(n18.type, false), n18;
    case 11:
      return n18 = u_(n18.type.render, false), n18;
    case 1:
      return n18 = u_(n18.type, true), n18;
    default:
      return "";
  }
}
function Fv(n18) {
  if (n18 == null) return null;
  if (typeof n18 == "function") return n18.displayName || n18.name || null;
  if (typeof n18 == "string") return n18;
  switch (n18) {
    case pu:
      return "Fragment";
    case du:
      return "Portal";
    case Nv:
      return "Profiler";
    case Hx:
      return "StrictMode";
    case Uv:
      return "Suspense";
    case Ov:
      return "SuspenseList";
  }
  if (typeof n18 == "object") switch (n18.$$typeof) {
    case QA:
      return (n18.displayName || "Context") + ".Consumer";
    case KA:
      return (n18._context.displayName || "Context") + ".Provider";
    case Gx:
      var e = n18.render;
      return n18 = n18.displayName, n18 || (n18 = e.displayName || e.name || "", n18 = n18 !== "" ? "ForwardRef(" + n18 + ")" : "ForwardRef"), n18;
    case Wx:
      return e = n18.displayName || null, e !== null ? e : Fv(n18.type) || "Memo";
    case bo:
      e = n18._payload, n18 = n18._init;
      try {
        return Fv(n18(e));
      } catch {
      }
  }
  return null;
}
function J3(n18) {
  var e = n18.type;
  switch (n18.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return n18 = e.render, n18 = n18.displayName || n18.name || "", e.displayName || (n18 !== "" ? "ForwardRef(" + n18 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Fv(e);
    case 8:
      return e === Hx ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function ea(n18) {
  switch (typeof n18) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n18;
    case "object":
      return n18;
    default:
      return "";
  }
}
function eC(n18) {
  var e = n18.type;
  return (n18 = n18.nodeName) && n18.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
}
function K3(n18) {
  var e = eC(n18) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n18.constructor.prototype, e), i = "" + n18[e];
  if (!n18.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
    var r = t.get, s = t.set;
    return Object.defineProperty(n18, e, { configurable: true, get: function() {
      return r.call(this);
    }, set: function(o) {
      i = "" + o, s.call(this, o);
    } }), Object.defineProperty(n18, e, { enumerable: t.enumerable }), { getValue: function() {
      return i;
    }, setValue: function(o) {
      i = "" + o;
    }, stopTracking: function() {
      n18._valueTracker = null, delete n18[e];
    } };
  }
}
function Bd(n18) {
  n18._valueTracker || (n18._valueTracker = K3(n18));
}
function tC(n18) {
  if (!n18) return false;
  var e = n18._valueTracker;
  if (!e) return true;
  var t = e.getValue(), i = "";
  return n18 && (i = eC(n18) ? n18.checked ? "true" : "false" : n18.value), n18 = i, n18 !== t ? (e.setValue(n18), true) : false;
}
function xm(n18) {
  if (n18 = n18 || (typeof document < "u" ? document : void 0), typeof n18 > "u") return null;
  try {
    return n18.activeElement || n18.body;
  } catch {
    return n18.body;
  }
}
function kv(n18, e) {
  var t = e.checked;
  return cn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n18._wrapperState.initialChecked });
}
function yw(n18, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked;
  t = ea(e.value != null ? e.value : t), n18._wrapperState = { initialChecked: i, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null };
}
function nC(n18, e) {
  e = e.checked, e != null && Vx(n18, "checked", e, false);
}
function zv(n18, e) {
  nC(n18, e);
  var t = ea(e.value), i = e.type;
  if (t != null) i === "number" ? (t === 0 && n18.value === "" || n18.value != t) && (n18.value = "" + t) : n18.value !== "" + t && (n18.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n18.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value") ? Bv(n18, e.type, t) : e.hasOwnProperty("defaultValue") && Bv(n18, e.type, ea(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n18.defaultChecked = !!e.defaultChecked);
}
function xw(n18, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return;
    e = "" + n18._wrapperState.initialValue, t || e === n18.value || (n18.value = e), n18.defaultValue = e;
  }
  t = n18.name, t !== "" && (n18.name = ""), n18.defaultChecked = !!n18._wrapperState.initialChecked, t !== "" && (n18.name = t);
}
function Bv(n18, e, t) {
  (e !== "number" || xm(n18.ownerDocument) !== n18) && (t == null ? n18.defaultValue = "" + n18._wrapperState.initialValue : n18.defaultValue !== "" + t && (n18.defaultValue = "" + t));
}
var cf = Array.isArray;
function Du(n18, e, t, i) {
  if (n18 = n18.options, e) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = true;
    for (t = 0; t < n18.length; t++) r = e.hasOwnProperty("$" + n18[t].value), n18[t].selected !== r && (n18[t].selected = r), r && i && (n18[t].defaultSelected = true);
  } else {
    for (t = "" + ea(t), e = null, r = 0; r < n18.length; r++) {
      if (n18[r].value === t) {
        n18[r].selected = true, i && (n18[r].defaultSelected = true);
        return;
      }
      e !== null || n18[r].disabled || (e = n18[r]);
    }
    e !== null && (e.selected = true);
  }
}
function Vv(n18, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Se(91));
  return cn({}, e, { value: void 0, defaultValue: void 0, children: "" + n18._wrapperState.initialValue });
}
function Sw(n18, e) {
  var t = e.value;
  if (t == null) {
    if (t = e.children, e = e.defaultValue, t != null) {
      if (e != null) throw Error(Se(92));
      if (cf(t)) {
        if (1 < t.length) throw Error(Se(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), t = e;
  }
  n18._wrapperState = { initialValue: ea(t) };
}
function iC(n18, e) {
  var t = ea(e.value), i = ea(e.defaultValue);
  t != null && (t = "" + t, t !== n18.value && (n18.value = t), e.defaultValue == null && n18.defaultValue !== t && (n18.defaultValue = t)), i != null && (n18.defaultValue = "" + i);
}
function Mw(n18) {
  var e = n18.textContent;
  e === n18._wrapperState.initialValue && e !== "" && e !== null && (n18.value = e);
}
function rC(n18) {
  switch (n18) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function Hv(n18, e) {
  return n18 == null || n18 === "http://www.w3.org/1999/xhtml" ? rC(e) : n18 === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n18;
}
var Vd, sC = function(n18) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
    MSApp.execUnsafeLocalFunction(function() {
      return n18(e, t, i, r);
    });
  } : n18;
}(function(n18, e) {
  if (n18.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n18) n18.innerHTML = e;
  else {
    for (Vd = Vd || document.createElement("div"), Vd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Vd.firstChild; n18.firstChild; ) n18.removeChild(n18.firstChild);
    for (; e.firstChild; ) n18.appendChild(e.firstChild);
  }
});
function Nf(n18, e) {
  if (e) {
    var t = n18.firstChild;
    if (t && t === n18.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n18.textContent = e;
}
var gf = { animationIterationCount: true, aspectRatio: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true }, Q3 = ["Webkit", "ms", "Moz", "O"];
Object.keys(gf).forEach(function(n18) {
  Q3.forEach(function(e) {
    e = e + n18.charAt(0).toUpperCase() + n18.substring(1), gf[e] = gf[n18];
  });
});
function oC(n18, e, t) {
  return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || gf.hasOwnProperty(n18) && gf[n18] ? ("" + e).trim() : e + "px";
}
function aC(n18, e) {
  n18 = n18.style;
  for (var t in e) if (e.hasOwnProperty(t)) {
    var i = t.indexOf("--") === 0, r = oC(t, e[t], i);
    t === "float" && (t = "cssFloat"), i ? n18.setProperty(t, r) : n18[t] = r;
  }
}
var $3 = cn({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function Gv(n18, e) {
  if (e) {
    if ($3[n18] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Se(137, n18));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Se(60));
      if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Se(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Se(62));
  }
}
function Wv(n18, e) {
  if (n18.indexOf("-") === -1) return typeof e.is == "string";
  switch (n18) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var Xv = null;
function Xx(n18) {
  return n18 = n18.target || n18.srcElement || window, n18.correspondingUseElement && (n18 = n18.correspondingUseElement), n18.nodeType === 3 ? n18.parentNode : n18;
}
var Yv = null, Nu = null, Uu = null;
function ww(n18) {
  if (n18 = Rh(n18)) {
    if (typeof Yv != "function") throw Error(Se(280));
    var e = n18.stateNode;
    e && (e = cg(e), Yv(n18.stateNode, n18.type, e));
  }
}
function lC(n18) {
  Nu ? Uu ? Uu.push(n18) : Uu = [n18] : Nu = n18;
}
function uC() {
  if (Nu) {
    var n18 = Nu, e = Uu;
    if (Uu = Nu = null, ww(n18), e) for (n18 = 0; n18 < e.length; n18++) ww(e[n18]);
  }
}
function cC(n18, e) {
  return n18(e);
}
function fC() {
}
var c_ = false;
function hC(n18, e, t) {
  if (c_) return n18(e, t);
  c_ = true;
  try {
    return cC(n18, e, t);
  } finally {
    c_ = false, (Nu !== null || Uu !== null) && (fC(), uC());
  }
}
function Uf(n18, e) {
  var t = n18.stateNode;
  if (t === null) return null;
  var i = cg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) || (n18 = n18.type, i = !(n18 === "button" || n18 === "input" || n18 === "select" || n18 === "textarea")), n18 = !i;
      break e;
    default:
      n18 = false;
  }
  if (n18) return null;
  if (t && typeof t != "function") throw Error(Se(231, e, typeof t));
  return t;
}
var qv = false;
if (eo) try {
  var Bc = {};
  Object.defineProperty(Bc, "passive", { get: function() {
    qv = true;
  } }), window.addEventListener("test", Bc, Bc), window.removeEventListener("test", Bc, Bc);
} catch {
  qv = false;
}
function eI(n18, e, t, i, r, s, o, a, u) {
  var f = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, f);
  } catch (h) {
    this.onError(h);
  }
}
var _f = false, Sm = null, Mm = false, jv = null, tI = { onError: function(n18) {
  _f = true, Sm = n18;
} };
function nI(n18, e, t, i, r, s, o, a, u) {
  _f = false, Sm = null, eI.apply(tI, arguments);
}
function iI(n18, e, t, i, r, s, o, a, u) {
  if (nI.apply(this, arguments), _f) {
    if (_f) {
      var f = Sm;
      _f = false, Sm = null;
    } else throw Error(Se(198));
    Mm || (Mm = true, jv = f);
  }
}
function vl(n18) {
  var e = n18, t = n18;
  if (n18.alternate) for (; e.return; ) e = e.return;
  else {
    n18 = e;
    do
      e = n18, e.flags & 4098 && (t = e.return), n18 = e.return;
    while (n18);
  }
  return e.tag === 3 ? t : null;
}
function dC(n18) {
  if (n18.tag === 13) {
    var e = n18.memoizedState;
    if (e === null && (n18 = n18.alternate, n18 !== null && (e = n18.memoizedState)), e !== null) return e.dehydrated;
  }
  return null;
}
function Ew(n18) {
  if (vl(n18) !== n18) throw Error(Se(188));
}
function rI(n18) {
  var e = n18.alternate;
  if (!e) {
    if (e = vl(n18), e === null) throw Error(Se(188));
    return e !== n18 ? null : n18;
  }
  for (var t = n18, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (i = r.return, i !== null) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return Ew(r), n18;
        if (s === i) return Ew(r), e;
        s = s.sibling;
      }
      throw Error(Se(188));
    }
    if (t.return !== i.return) t = r, i = s;
    else {
      for (var o = false, a = r.child; a; ) {
        if (a === t) {
          o = true, t = r, i = s;
          break;
        }
        if (a === i) {
          o = true, i = r, t = s;
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            o = true, t = s, i = r;
            break;
          }
          if (a === i) {
            o = true, i = s, t = r;
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Se(189));
      }
    }
    if (t.alternate !== i) throw Error(Se(190));
  }
  if (t.tag !== 3) throw Error(Se(188));
  return t.stateNode.current === t ? n18 : e;
}
function pC(n18) {
  return n18 = rI(n18), n18 !== null ? mC(n18) : null;
}
function mC(n18) {
  if (n18.tag === 5 || n18.tag === 6) return n18;
  for (n18 = n18.child; n18 !== null; ) {
    var e = mC(n18);
    if (e !== null) return e;
    n18 = n18.sibling;
  }
  return null;
}
var gC = dr.unstable_scheduleCallback, Tw = dr.unstable_cancelCallback, sI = dr.unstable_shouldYield, oI = dr.unstable_requestPaint, wn = dr.unstable_now, aI = dr.unstable_getCurrentPriorityLevel, Yx = dr.unstable_ImmediatePriority, _C = dr.unstable_UserBlockingPriority, wm = dr.unstable_NormalPriority, lI = dr.unstable_LowPriority, vC = dr.unstable_IdlePriority, og = null, Ss = null;
function uI(n18) {
  if (Ss && typeof Ss.onCommitFiberRoot == "function") try {
    Ss.onCommitFiberRoot(og, n18, void 0, (n18.current.flags & 128) === 128);
  } catch {
  }
}
var Jr = Math.clz32 ? Math.clz32 : hI, cI = Math.log, fI = Math.LN2;
function hI(n18) {
  return n18 >>>= 0, n18 === 0 ? 32 : 31 - (cI(n18) / fI | 0) | 0;
}
var Hd = 64, Gd = 4194304;
function ff(n18) {
  switch (n18 & -n18) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n18 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n18 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n18;
  }
}
function Em(n18, e) {
  var t = n18.pendingLanes;
  if (t === 0) return 0;
  var i = 0, r = n18.suspendedLanes, s = n18.pingedLanes, o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? i = ff(a) : (s &= o, s !== 0 && (i = ff(s)));
  } else o = t & ~r, o !== 0 ? i = ff(o) : s !== 0 && (i = ff(s));
  if (i === 0) return 0;
  if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e;
  if (i & 4 && (i |= t & 16), e = n18.entangledLanes, e !== 0) for (n18 = n18.entanglements, e &= i; 0 < e; ) t = 31 - Jr(e), r = 1 << t, i |= n18[t], e &= ~r;
  return i;
}
function dI(n18, e) {
  switch (n18) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function pI(n18, e) {
  for (var t = n18.suspendedLanes, i = n18.pingedLanes, r = n18.expirationTimes, s = n18.pendingLanes; 0 < s; ) {
    var o = 31 - Jr(s), a = 1 << o, u = r[o];
    u === -1 ? (!(a & t) || a & i) && (r[o] = dI(a, e)) : u <= e && (n18.expiredLanes |= a), s &= ~a;
  }
}
function Zv(n18) {
  return n18 = n18.pendingLanes & -1073741825, n18 !== 0 ? n18 : n18 & 1073741824 ? 1073741824 : 0;
}
function yC() {
  var n18 = Hd;
  return Hd <<= 1, !(Hd & 4194240) && (Hd = 64), n18;
}
function f_(n18) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n18);
  return e;
}
function Ah(n18, e, t) {
  n18.pendingLanes |= e, e !== 536870912 && (n18.suspendedLanes = 0, n18.pingedLanes = 0), n18 = n18.eventTimes, e = 31 - Jr(e), n18[e] = t;
}
function mI(n18, e) {
  var t = n18.pendingLanes & ~e;
  n18.pendingLanes = e, n18.suspendedLanes = 0, n18.pingedLanes = 0, n18.expiredLanes &= e, n18.mutableReadLanes &= e, n18.entangledLanes &= e, e = n18.entanglements;
  var i = n18.eventTimes;
  for (n18 = n18.expirationTimes; 0 < t; ) {
    var r = 31 - Jr(t), s = 1 << r;
    e[r] = 0, i[r] = -1, n18[r] = -1, t &= ~s;
  }
}
function qx(n18, e) {
  var t = n18.entangledLanes |= e;
  for (n18 = n18.entanglements; t; ) {
    var i = 31 - Jr(t), r = 1 << i;
    r & e | n18[i] & e && (n18[i] |= e), t &= ~r;
  }
}
var Vt = 0;
function xC(n18) {
  return n18 &= -n18, 1 < n18 ? 4 < n18 ? n18 & 268435455 ? 16 : 536870912 : 4 : 1;
}
var SC, jx, MC, wC, EC, Jv = false, Wd = [], Vo = null, Ho = null, Go = null, Of = /* @__PURE__ */ new Map(), Ff = /* @__PURE__ */ new Map(), Do = [], gI = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Aw(n18, e) {
  switch (n18) {
    case "focusin":
    case "focusout":
      Vo = null;
      break;
    case "dragenter":
    case "dragleave":
      Ho = null;
      break;
    case "mouseover":
    case "mouseout":
      Go = null;
      break;
    case "pointerover":
    case "pointerout":
      Of.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Ff.delete(e.pointerId);
  }
}
function Vc(n18, e, t, i, r, s) {
  return n18 === null || n18.nativeEvent !== s ? (n18 = { blockedOn: e, domEventName: t, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = Rh(e), e !== null && jx(e)), n18) : (n18.eventSystemFlags |= i, e = n18.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n18);
}
function _I(n18, e, t, i, r) {
  switch (e) {
    case "focusin":
      return Vo = Vc(Vo, n18, e, t, i, r), true;
    case "dragenter":
      return Ho = Vc(Ho, n18, e, t, i, r), true;
    case "mouseover":
      return Go = Vc(Go, n18, e, t, i, r), true;
    case "pointerover":
      var s = r.pointerId;
      return Of.set(s, Vc(Of.get(s) || null, n18, e, t, i, r)), true;
    case "gotpointercapture":
      return s = r.pointerId, Ff.set(s, Vc(Ff.get(s) || null, n18, e, t, i, r)), true;
  }
  return false;
}
function TC(n18) {
  var e = Ha(n18.target);
  if (e !== null) {
    var t = vl(e);
    if (t !== null) {
      if (e = t.tag, e === 13) {
        if (e = dC(t), e !== null) {
          n18.blockedOn = e, EC(n18.priority, function() {
            MC(t);
          });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n18.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n18.blockedOn = null;
}
function Qp(n18) {
  if (n18.blockedOn !== null) return false;
  for (var e = n18.targetContainers; 0 < e.length; ) {
    var t = Kv(n18.domEventName, n18.eventSystemFlags, e[0], n18.nativeEvent);
    if (t === null) {
      t = n18.nativeEvent;
      var i = new t.constructor(t.type, t);
      Xv = i, t.target.dispatchEvent(i), Xv = null;
    } else return e = Rh(t), e !== null && jx(e), n18.blockedOn = t, false;
    e.shift();
  }
  return true;
}
function Cw(n18, e, t) {
  Qp(n18) && t.delete(e);
}
function vI() {
  Jv = false, Vo !== null && Qp(Vo) && (Vo = null), Ho !== null && Qp(Ho) && (Ho = null), Go !== null && Qp(Go) && (Go = null), Of.forEach(Cw), Ff.forEach(Cw);
}
function Hc(n18, e) {
  n18.blockedOn === e && (n18.blockedOn = null, Jv || (Jv = true, dr.unstable_scheduleCallback(dr.unstable_NormalPriority, vI)));
}
function kf(n18) {
  function e(r) {
    return Hc(r, n18);
  }
  if (0 < Wd.length) {
    Hc(Wd[0], n18);
    for (var t = 1; t < Wd.length; t++) {
      var i = Wd[t];
      i.blockedOn === n18 && (i.blockedOn = null);
    }
  }
  for (Vo !== null && Hc(Vo, n18), Ho !== null && Hc(Ho, n18), Go !== null && Hc(Go, n18), Of.forEach(e), Ff.forEach(e), t = 0; t < Do.length; t++) i = Do[t], i.blockedOn === n18 && (i.blockedOn = null);
  for (; 0 < Do.length && (t = Do[0], t.blockedOn === null); ) TC(t), t.blockedOn === null && Do.shift();
}
var Ou = uo.ReactCurrentBatchConfig, Tm = true;
function yI(n18, e, t, i) {
  var r = Vt, s = Ou.transition;
  Ou.transition = null;
  try {
    Vt = 1, Zx(n18, e, t, i);
  } finally {
    Vt = r, Ou.transition = s;
  }
}
function xI(n18, e, t, i) {
  var r = Vt, s = Ou.transition;
  Ou.transition = null;
  try {
    Vt = 4, Zx(n18, e, t, i);
  } finally {
    Vt = r, Ou.transition = s;
  }
}
function Zx(n18, e, t, i) {
  if (Tm) {
    var r = Kv(n18, e, t, i);
    if (r === null) S_(n18, e, i, Am, t), Aw(n18, i);
    else if (_I(r, n18, e, t, i)) i.stopPropagation();
    else if (Aw(n18, i), e & 4 && -1 < gI.indexOf(n18)) {
      for (; r !== null; ) {
        var s = Rh(r);
        if (s !== null && SC(s), s = Kv(n18, e, t, i), s === null && S_(n18, e, i, Am, t), s === r) break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else S_(n18, e, i, null, t);
  }
}
var Am = null;
function Kv(n18, e, t, i) {
  if (Am = null, n18 = Xx(i), n18 = Ha(n18), n18 !== null) if (e = vl(n18), e === null) n18 = null;
  else if (t = e.tag, t === 13) {
    if (n18 = dC(e), n18 !== null) return n18;
    n18 = null;
  } else if (t === 3) {
    if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
    n18 = null;
  } else e !== n18 && (n18 = null);
  return Am = n18, null;
}
function AC(n18) {
  switch (n18) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (aI()) {
        case Yx:
          return 1;
        case _C:
          return 4;
        case wm:
        case lI:
          return 16;
        case vC:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Oo = null, Jx = null, $p = null;
function CC() {
  if ($p) return $p;
  var n18, e = Jx, t = e.length, i, r = "value" in Oo ? Oo.value : Oo.textContent, s = r.length;
  for (n18 = 0; n18 < t && e[n18] === r[n18]; n18++) ;
  var o = t - n18;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++) ;
  return $p = r.slice(n18, 1 < i ? 1 - i : void 0);
}
function em(n18) {
  var e = n18.keyCode;
  return "charCode" in n18 ? (n18 = n18.charCode, n18 === 0 && e === 13 && (n18 = 13)) : n18 = e, n18 === 10 && (n18 = 13), 32 <= n18 || n18 === 13 ? n18 : 0;
}
function Xd() {
  return true;
}
function Rw() {
  return false;
}
function _r(n18) {
  function e(t, i, r, s, o) {
    this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var a in n18) n18.hasOwnProperty(a) && (t = n18[a], this[a] = t ? t(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === false) ? Xd : Rw, this.isPropagationStopped = Rw, this;
  }
  return cn(e.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var t = this.nativeEvent;
    t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = false), this.isDefaultPrevented = Xd);
  }, stopPropagation: function() {
    var t = this.nativeEvent;
    t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = true), this.isPropagationStopped = Xd);
  }, persist: function() {
  }, isPersistent: Xd }), e;
}
var cc = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(n18) {
  return n18.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, Kx = _r(cc), Ch = cn({}, cc, { view: 0, detail: 0 }), SI = _r(Ch), h_, d_, Gc, ag = cn({}, Ch, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Qx, button: 0, buttons: 0, relatedTarget: function(n18) {
  return n18.relatedTarget === void 0 ? n18.fromElement === n18.srcElement ? n18.toElement : n18.fromElement : n18.relatedTarget;
}, movementX: function(n18) {
  return "movementX" in n18 ? n18.movementX : (n18 !== Gc && (Gc && n18.type === "mousemove" ? (h_ = n18.screenX - Gc.screenX, d_ = n18.screenY - Gc.screenY) : d_ = h_ = 0, Gc = n18), h_);
}, movementY: function(n18) {
  return "movementY" in n18 ? n18.movementY : d_;
} }), Pw = _r(ag), MI = cn({}, ag, { dataTransfer: 0 }), wI = _r(MI), EI = cn({}, Ch, { relatedTarget: 0 }), p_ = _r(EI), TI = cn({}, cc, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), AI = _r(TI), CI = cn({}, cc, { clipboardData: function(n18) {
  return "clipboardData" in n18 ? n18.clipboardData : window.clipboardData;
} }), RI = _r(CI), PI = cn({}, cc, { data: 0 }), bw = _r(PI), bI = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, LI = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, II = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function DI(n18) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n18) : (n18 = II[n18]) ? !!e[n18] : false;
}
function Qx() {
  return DI;
}
var NI = cn({}, Ch, { key: function(n18) {
  if (n18.key) {
    var e = bI[n18.key] || n18.key;
    if (e !== "Unidentified") return e;
  }
  return n18.type === "keypress" ? (n18 = em(n18), n18 === 13 ? "Enter" : String.fromCharCode(n18)) : n18.type === "keydown" || n18.type === "keyup" ? LI[n18.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Qx, charCode: function(n18) {
  return n18.type === "keypress" ? em(n18) : 0;
}, keyCode: function(n18) {
  return n18.type === "keydown" || n18.type === "keyup" ? n18.keyCode : 0;
}, which: function(n18) {
  return n18.type === "keypress" ? em(n18) : n18.type === "keydown" || n18.type === "keyup" ? n18.keyCode : 0;
} }), UI = _r(NI), OI = cn({}, ag, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Lw = _r(OI), FI = cn({}, Ch, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Qx }), kI = _r(FI), zI = cn({}, cc, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), BI = _r(zI), VI = cn({}, ag, { deltaX: function(n18) {
  return "deltaX" in n18 ? n18.deltaX : "wheelDeltaX" in n18 ? -n18.wheelDeltaX : 0;
}, deltaY: function(n18) {
  return "deltaY" in n18 ? n18.deltaY : "wheelDeltaY" in n18 ? -n18.wheelDeltaY : "wheelDelta" in n18 ? -n18.wheelDelta : 0;
}, deltaZ: 0, deltaMode: 0 }), HI = _r(VI), GI = [9, 13, 27, 32], $x = eo && "CompositionEvent" in window, vf = null;
eo && "documentMode" in document && (vf = document.documentMode);
var WI = eo && "TextEvent" in window && !vf, RC = eo && (!$x || vf && 8 < vf && 11 >= vf), Iw = " ", Dw = false;
function PC(n18, e) {
  switch (n18) {
    case "keyup":
      return GI.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function bC(n18) {
  return n18 = n18.detail, typeof n18 == "object" && "data" in n18 ? n18.data : null;
}
var mu = false;
function XI(n18, e) {
  switch (n18) {
    case "compositionend":
      return bC(e);
    case "keypress":
      return e.which !== 32 ? null : (Dw = true, Iw);
    case "textInput":
      return n18 = e.data, n18 === Iw && Dw ? null : n18;
    default:
      return null;
  }
}
function YI(n18, e) {
  if (mu) return n18 === "compositionend" || !$x && PC(n18, e) ? (n18 = CC(), $p = Jx = Oo = null, mu = false, n18) : null;
  switch (n18) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return RC && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var qI = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function Nw(n18) {
  var e = n18 && n18.nodeName && n18.nodeName.toLowerCase();
  return e === "input" ? !!qI[n18.type] : e === "textarea";
}
function LC(n18, e, t, i) {
  lC(i), e = Cm(e, "onChange"), 0 < e.length && (t = new Kx("onChange", "change", null, t, i), n18.push({ event: t, listeners: e }));
}
var yf = null, zf = null;
function jI(n18) {
  HC(n18, 0);
}
function lg(n18) {
  var e = vu(n18);
  if (tC(e)) return n18;
}
function ZI(n18, e) {
  if (n18 === "change") return e;
}
var IC = false;
if (eo) {
  var m_;
  if (eo) {
    var g_ = "oninput" in document;
    if (!g_) {
      var Uw = document.createElement("div");
      Uw.setAttribute("oninput", "return;"), g_ = typeof Uw.oninput == "function";
    }
    m_ = g_;
  } else m_ = false;
  IC = m_ && (!document.documentMode || 9 < document.documentMode);
}
function Ow() {
  yf && (yf.detachEvent("onpropertychange", DC), zf = yf = null);
}
function DC(n18) {
  if (n18.propertyName === "value" && lg(zf)) {
    var e = [];
    LC(e, zf, n18, Xx(n18)), hC(jI, e);
  }
}
function JI(n18, e, t) {
  n18 === "focusin" ? (Ow(), yf = e, zf = t, yf.attachEvent("onpropertychange", DC)) : n18 === "focusout" && Ow();
}
function KI(n18) {
  if (n18 === "selectionchange" || n18 === "keyup" || n18 === "keydown") return lg(zf);
}
function QI(n18, e) {
  if (n18 === "click") return lg(e);
}
function $I(n18, e) {
  if (n18 === "input" || n18 === "change") return lg(e);
}
function eD(n18, e) {
  return n18 === e && (n18 !== 0 || 1 / n18 === 1 / e) || n18 !== n18 && e !== e;
}
var Qr = typeof Object.is == "function" ? Object.is : eD;
function Bf(n18, e) {
  if (Qr(n18, e)) return true;
  if (typeof n18 != "object" || n18 === null || typeof e != "object" || e === null) return false;
  var t = Object.keys(n18), i = Object.keys(e);
  if (t.length !== i.length) return false;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Dv.call(e, r) || !Qr(n18[r], e[r])) return false;
  }
  return true;
}
function Fw(n18) {
  for (; n18 && n18.firstChild; ) n18 = n18.firstChild;
  return n18;
}
function kw(n18, e) {
  var t = Fw(n18);
  n18 = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (i = n18 + t.textContent.length, n18 <= e && i >= e) return { node: t, offset: e - n18 };
      n18 = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = Fw(t);
  }
}
function NC(n18, e) {
  return n18 && e ? n18 === e ? true : n18 && n18.nodeType === 3 ? false : e && e.nodeType === 3 ? NC(n18, e.parentNode) : "contains" in n18 ? n18.contains(e) : n18.compareDocumentPosition ? !!(n18.compareDocumentPosition(e) & 16) : false : false;
}
function UC() {
  for (var n18 = window, e = xm(); e instanceof n18.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = false;
    }
    if (t) n18 = e.contentWindow;
    else break;
    e = xm(n18.document);
  }
  return e;
}
function eS(n18) {
  var e = n18 && n18.nodeName && n18.nodeName.toLowerCase();
  return e && (e === "input" && (n18.type === "text" || n18.type === "search" || n18.type === "tel" || n18.type === "url" || n18.type === "password") || e === "textarea" || n18.contentEditable === "true");
}
function tD(n18) {
  var e = UC(), t = n18.focusedElem, i = n18.selectionRange;
  if (e !== t && t && t.ownerDocument && NC(t.ownerDocument.documentElement, t)) {
    if (i !== null && eS(t)) {
      if (e = i.start, n18 = i.end, n18 === void 0 && (n18 = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n18, t.value.length);
      else if (n18 = (e = t.ownerDocument || document) && e.defaultView || window, n18.getSelection) {
        n18 = n18.getSelection();
        var r = t.textContent.length, s = Math.min(i.start, r);
        i = i.end === void 0 ? s : Math.min(i.end, r), !n18.extend && s > i && (r = i, i = s, s = r), r = kw(t, s);
        var o = kw(t, i);
        r && o && (n18.rangeCount !== 1 || n18.anchorNode !== r.node || n18.anchorOffset !== r.offset || n18.focusNode !== o.node || n18.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n18.removeAllRanges(), s > i ? (n18.addRange(e), n18.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n18.addRange(e)));
      }
    }
    for (e = [], n18 = t; n18 = n18.parentNode; ) n18.nodeType === 1 && e.push({ element: n18, left: n18.scrollLeft, top: n18.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++) n18 = e[t], n18.element.scrollLeft = n18.left, n18.element.scrollTop = n18.top;
  }
}
var nD = eo && "documentMode" in document && 11 >= document.documentMode, gu = null, Qv = null, xf = null, $v = false;
function zw(n18, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  $v || gu == null || gu !== xm(i) || (i = gu, "selectionStart" in i && eS(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), xf && Bf(xf, i) || (xf = i, i = Cm(Qv, "onSelect"), 0 < i.length && (e = new Kx("onSelect", "select", null, e, t), n18.push({ event: e, listeners: i }), e.target = gu)));
}
function Yd(n18, e) {
  var t = {};
  return t[n18.toLowerCase()] = e.toLowerCase(), t["Webkit" + n18] = "webkit" + e, t["Moz" + n18] = "moz" + e, t;
}
var _u = { animationend: Yd("Animation", "AnimationEnd"), animationiteration: Yd("Animation", "AnimationIteration"), animationstart: Yd("Animation", "AnimationStart"), transitionend: Yd("Transition", "TransitionEnd") }, __ = {}, OC = {};
eo && (OC = document.createElement("div").style, "AnimationEvent" in window || (delete _u.animationend.animation, delete _u.animationiteration.animation, delete _u.animationstart.animation), "TransitionEvent" in window || delete _u.transitionend.transition);
function ug(n18) {
  if (__[n18]) return __[n18];
  if (!_u[n18]) return n18;
  var e = _u[n18], t;
  for (t in e) if (e.hasOwnProperty(t) && t in OC) return __[n18] = e[t];
  return n18;
}
var FC = ug("animationend"), kC = ug("animationiteration"), zC = ug("animationstart"), BC = ug("transitionend"), VC = /* @__PURE__ */ new Map(), Bw = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function oa(n18, e) {
  VC.set(n18, e), _l(e, [n18]);
}
for (var v_ = 0; v_ < Bw.length; v_++) {
  var y_ = Bw[v_], iD = y_.toLowerCase(), rD = y_[0].toUpperCase() + y_.slice(1);
  oa(iD, "on" + rD);
}
oa(FC, "onAnimationEnd");
oa(kC, "onAnimationIteration");
oa(zC, "onAnimationStart");
oa("dblclick", "onDoubleClick");
oa("focusin", "onFocus");
oa("focusout", "onBlur");
oa(BC, "onTransitionEnd");
Wu("onMouseEnter", ["mouseout", "mouseover"]);
Wu("onMouseLeave", ["mouseout", "mouseover"]);
Wu("onPointerEnter", ["pointerout", "pointerover"]);
Wu("onPointerLeave", ["pointerout", "pointerover"]);
_l("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
_l("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
_l("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
_l("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
_l("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
_l("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var hf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), sD = new Set("cancel close invalid load scroll toggle".split(" ").concat(hf));
function Vw(n18, e, t) {
  var i = n18.type || "unknown-event";
  n18.currentTarget = t, iI(i, e, void 0, n18), n18.currentTarget = null;
}
function HC(n18, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n18.length; t++) {
    var i = n18[t], r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e) for (var o = i.length - 1; 0 <= o; o--) {
        var a = i[o], u = a.instance, f = a.currentTarget;
        if (a = a.listener, u !== s && r.isPropagationStopped()) break e;
        Vw(r, a, f), s = u;
      }
      else for (o = 0; o < i.length; o++) {
        if (a = i[o], u = a.instance, f = a.currentTarget, a = a.listener, u !== s && r.isPropagationStopped()) break e;
        Vw(r, a, f), s = u;
      }
    }
  }
  if (Mm) throw n18 = jv, Mm = false, jv = null, n18;
}
function Zt(n18, e) {
  var t = e[ry];
  t === void 0 && (t = e[ry] = /* @__PURE__ */ new Set());
  var i = n18 + "__bubble";
  t.has(i) || (GC(e, n18, 2, false), t.add(i));
}
function x_(n18, e, t) {
  var i = 0;
  e && (i |= 4), GC(t, n18, i, e);
}
var qd = "_reactListening" + Math.random().toString(36).slice(2);
function Vf(n18) {
  if (!n18[qd]) {
    n18[qd] = true, JA.forEach(function(t) {
      t !== "selectionchange" && (sD.has(t) || x_(t, false, n18), x_(t, true, n18));
    });
    var e = n18.nodeType === 9 ? n18 : n18.ownerDocument;
    e === null || e[qd] || (e[qd] = true, x_("selectionchange", false, e));
  }
}
function GC(n18, e, t, i) {
  switch (AC(e)) {
    case 1:
      var r = yI;
      break;
    case 4:
      r = xI;
      break;
    default:
      r = Zx;
  }
  t = r.bind(null, e, t, n18), r = void 0, !qv || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = true), i ? r !== void 0 ? n18.addEventListener(e, t, { capture: true, passive: r }) : n18.addEventListener(e, t, true) : r !== void 0 ? n18.addEventListener(e, t, { passive: r }) : n18.addEventListener(e, t, false);
}
function S_(n18, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null) e: for (; ; ) {
    if (i === null) return;
    var o = i.tag;
    if (o === 3 || o === 4) {
      var a = i.stateNode.containerInfo;
      if (a === r || a.nodeType === 8 && a.parentNode === r) break;
      if (o === 4) for (o = i.return; o !== null; ) {
        var u = o.tag;
        if ((u === 3 || u === 4) && (u = o.stateNode.containerInfo, u === r || u.nodeType === 8 && u.parentNode === r)) return;
        o = o.return;
      }
      for (; a !== null; ) {
        if (o = Ha(a), o === null) return;
        if (u = o.tag, u === 5 || u === 6) {
          i = s = o;
          continue e;
        }
        a = a.parentNode;
      }
    }
    i = i.return;
  }
  hC(function() {
    var f = s, h = Xx(t), d = [];
    e: {
      var p = VC.get(n18);
      if (p !== void 0) {
        var g = Kx, v = n18;
        switch (n18) {
          case "keypress":
            if (em(t) === 0) break e;
          case "keydown":
          case "keyup":
            g = UI;
            break;
          case "focusin":
            v = "focus", g = p_;
            break;
          case "focusout":
            v = "blur", g = p_;
            break;
          case "beforeblur":
          case "afterblur":
            g = p_;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            g = Pw;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            g = wI;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            g = kI;
            break;
          case FC:
          case kC:
          case zC:
            g = AI;
            break;
          case BC:
            g = BI;
            break;
          case "scroll":
            g = SI;
            break;
          case "wheel":
            g = HI;
            break;
          case "copy":
          case "cut":
          case "paste":
            g = RI;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            g = Lw;
        }
        var M = (e & 4) !== 0, S = !M && n18 === "scroll", m = M ? p !== null ? p + "Capture" : null : p;
        M = [];
        for (var E = f, T; E !== null; ) {
          T = E;
          var C = T.stateNode;
          if (T.tag === 5 && C !== null && (T = C, m !== null && (C = Uf(E, m), C != null && M.push(Hf(E, C, T)))), S) break;
          E = E.return;
        }
        0 < M.length && (p = new g(p, v, null, t, h), d.push({ event: p, listeners: M }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (p = n18 === "mouseover" || n18 === "pointerover", g = n18 === "mouseout" || n18 === "pointerout", p && t !== Xv && (v = t.relatedTarget || t.fromElement) && (Ha(v) || v[to])) break e;
        if ((g || p) && (p = h.window === h ? h : (p = h.ownerDocument) ? p.defaultView || p.parentWindow : window, g ? (v = t.relatedTarget || t.toElement, g = f, v = v ? Ha(v) : null, v !== null && (S = vl(v), v !== S || v.tag !== 5 && v.tag !== 6) && (v = null)) : (g = null, v = f), g !== v)) {
          if (M = Pw, C = "onMouseLeave", m = "onMouseEnter", E = "mouse", (n18 === "pointerout" || n18 === "pointerover") && (M = Lw, C = "onPointerLeave", m = "onPointerEnter", E = "pointer"), S = g == null ? p : vu(g), T = v == null ? p : vu(v), p = new M(C, E + "leave", g, t, h), p.target = S, p.relatedTarget = T, C = null, Ha(h) === f && (M = new M(m, E + "enter", v, t, h), M.target = T, M.relatedTarget = S, C = M), S = C, g && v) t: {
            for (M = g, m = v, E = 0, T = M; T; T = Bl(T)) E++;
            for (T = 0, C = m; C; C = Bl(C)) T++;
            for (; 0 < E - T; ) M = Bl(M), E--;
            for (; 0 < T - E; ) m = Bl(m), T--;
            for (; E--; ) {
              if (M === m || m !== null && M === m.alternate) break t;
              M = Bl(M), m = Bl(m);
            }
            M = null;
          }
          else M = null;
          g !== null && Hw(d, p, g, M, false), v !== null && S !== null && Hw(d, S, v, M, true);
        }
      }
      e: {
        if (p = f ? vu(f) : window, g = p.nodeName && p.nodeName.toLowerCase(), g === "select" || g === "input" && p.type === "file") var L = ZI;
        else if (Nw(p)) if (IC) L = $I;
        else {
          L = KI;
          var b = JI;
        }
        else (g = p.nodeName) && g.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (L = QI);
        if (L && (L = L(n18, f))) {
          LC(d, L, t, h);
          break e;
        }
        b && b(n18, p, f), n18 === "focusout" && (b = p._wrapperState) && b.controlled && p.type === "number" && Bv(p, "number", p.value);
      }
      switch (b = f ? vu(f) : window, n18) {
        case "focusin":
          (Nw(b) || b.contentEditable === "true") && (gu = b, Qv = f, xf = null);
          break;
        case "focusout":
          xf = Qv = gu = null;
          break;
        case "mousedown":
          $v = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          $v = false, zw(d, t, h);
          break;
        case "selectionchange":
          if (nD) break;
        case "keydown":
        case "keyup":
          zw(d, t, h);
      }
      var I;
      if ($x) e: {
        switch (n18) {
          case "compositionstart":
            var U = "onCompositionStart";
            break e;
          case "compositionend":
            U = "onCompositionEnd";
            break e;
          case "compositionupdate":
            U = "onCompositionUpdate";
            break e;
        }
        U = void 0;
      }
      else mu ? PC(n18, t) && (U = "onCompositionEnd") : n18 === "keydown" && t.keyCode === 229 && (U = "onCompositionStart");
      U && (RC && t.locale !== "ko" && (mu || U !== "onCompositionStart" ? U === "onCompositionEnd" && mu && (I = CC()) : (Oo = h, Jx = "value" in Oo ? Oo.value : Oo.textContent, mu = true)), b = Cm(f, U), 0 < b.length && (U = new bw(U, n18, null, t, h), d.push({ event: U, listeners: b }), I ? U.data = I : (I = bC(t), I !== null && (U.data = I)))), (I = WI ? XI(n18, t) : YI(n18, t)) && (f = Cm(f, "onBeforeInput"), 0 < f.length && (h = new bw("onBeforeInput", "beforeinput", null, t, h), d.push({ event: h, listeners: f }), h.data = I));
    }
    HC(d, e);
  });
}
function Hf(n18, e, t) {
  return { instance: n18, listener: e, currentTarget: t };
}
function Cm(n18, e) {
  for (var t = e + "Capture", i = []; n18 !== null; ) {
    var r = n18, s = r.stateNode;
    r.tag === 5 && s !== null && (r = s, s = Uf(n18, t), s != null && i.unshift(Hf(n18, s, r)), s = Uf(n18, e), s != null && i.push(Hf(n18, s, r))), n18 = n18.return;
  }
  return i;
}
function Bl(n18) {
  if (n18 === null) return null;
  do
    n18 = n18.return;
  while (n18 && n18.tag !== 5);
  return n18 || null;
}
function Hw(n18, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t, u = a.alternate, f = a.stateNode;
    if (u !== null && u === i) break;
    a.tag === 5 && f !== null && (a = f, r ? (u = Uf(t, s), u != null && o.unshift(Hf(t, u, a))) : r || (u = Uf(t, s), u != null && o.push(Hf(t, u, a)))), t = t.return;
  }
  o.length !== 0 && n18.push({ event: e, listeners: o });
}
var oD = /\r\n?/g, aD = /\u0000|\uFFFD/g;
function Gw(n18) {
  return (typeof n18 == "string" ? n18 : "" + n18).replace(oD, `
`).replace(aD, "");
}
function jd(n18, e, t) {
  if (e = Gw(e), Gw(n18) !== e && t) throw Error(Se(425));
}
function Rm() {
}
var ey = null, ty = null;
function ny(n18, e) {
  return n18 === "textarea" || n18 === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
}
var iy = typeof setTimeout == "function" ? setTimeout : void 0, lD = typeof clearTimeout == "function" ? clearTimeout : void 0, Ww = typeof Promise == "function" ? Promise : void 0, uD = typeof queueMicrotask == "function" ? queueMicrotask : typeof Ww < "u" ? function(n18) {
  return Ww.resolve(null).then(n18).catch(cD);
} : iy;
function cD(n18) {
  setTimeout(function() {
    throw n18;
  });
}
function M_(n18, e) {
  var t = e, i = 0;
  do {
    var r = t.nextSibling;
    if (n18.removeChild(t), r && r.nodeType === 8) if (t = r.data, t === "/$") {
      if (i === 0) {
        n18.removeChild(r), kf(e);
        return;
      }
      i--;
    } else t !== "$" && t !== "$?" && t !== "$!" || i++;
    t = r;
  } while (t);
  kf(e);
}
function Wo(n18) {
  for (; n18 != null; n18 = n18.nextSibling) {
    var e = n18.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (e = n18.data, e === "$" || e === "$!" || e === "$?") break;
      if (e === "/$") return null;
    }
  }
  return n18;
}
function Xw(n18) {
  n18 = n18.previousSibling;
  for (var e = 0; n18; ) {
    if (n18.nodeType === 8) {
      var t = n18.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n18;
        e--;
      } else t === "/$" && e++;
    }
    n18 = n18.previousSibling;
  }
  return null;
}
var fc = Math.random().toString(36).slice(2), ms = "__reactFiber$" + fc, Gf = "__reactProps$" + fc, to = "__reactContainer$" + fc, ry = "__reactEvents$" + fc, fD = "__reactListeners$" + fc, hD = "__reactHandles$" + fc;
function Ha(n18) {
  var e = n18[ms];
  if (e) return e;
  for (var t = n18.parentNode; t; ) {
    if (e = t[to] || t[ms]) {
      if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n18 = Xw(n18); n18 !== null; ) {
        if (t = n18[ms]) return t;
        n18 = Xw(n18);
      }
      return e;
    }
    n18 = t, t = n18.parentNode;
  }
  return null;
}
function Rh(n18) {
  return n18 = n18[ms] || n18[to], !n18 || n18.tag !== 5 && n18.tag !== 6 && n18.tag !== 13 && n18.tag !== 3 ? null : n18;
}
function vu(n18) {
  if (n18.tag === 5 || n18.tag === 6) return n18.stateNode;
  throw Error(Se(33));
}
function cg(n18) {
  return n18[Gf] || null;
}
var sy = [], yu = -1;
function aa(n18) {
  return { current: n18 };
}
function Kt(n18) {
  0 > yu || (n18.current = sy[yu], sy[yu] = null, yu--);
}
function qt(n18, e) {
  yu++, sy[yu] = n18.current, n18.current = e;
}
var ta = {}, _i = aa(ta), Bi = aa(false), ll = ta;
function Xu(n18, e) {
  var t = n18.type.contextTypes;
  if (!t) return ta;
  var i = n18.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext;
  var r = {}, s;
  for (s in t) r[s] = e[s];
  return i && (n18 = n18.stateNode, n18.__reactInternalMemoizedUnmaskedChildContext = e, n18.__reactInternalMemoizedMaskedChildContext = r), r;
}
function Vi(n18) {
  return n18 = n18.childContextTypes, n18 != null;
}
function Pm() {
  Kt(Bi), Kt(_i);
}
function Yw(n18, e, t) {
  if (_i.current !== ta) throw Error(Se(168));
  qt(_i, e), qt(Bi, t);
}
function WC(n18, e, t) {
  var i = n18.stateNode;
  if (e = e.childContextTypes, typeof i.getChildContext != "function") return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(Se(108, J3(n18) || "Unknown", r));
  return cn({}, t, i);
}
function bm(n18) {
  return n18 = (n18 = n18.stateNode) && n18.__reactInternalMemoizedMergedChildContext || ta, ll = _i.current, qt(_i, n18), qt(Bi, Bi.current), true;
}
function qw(n18, e, t) {
  var i = n18.stateNode;
  if (!i) throw Error(Se(169));
  t ? (n18 = WC(n18, e, ll), i.__reactInternalMemoizedMergedChildContext = n18, Kt(Bi), Kt(_i), qt(_i, n18)) : Kt(Bi), qt(Bi, t);
}
var Xs = null, fg = false, w_ = false;
function XC(n18) {
  Xs === null ? Xs = [n18] : Xs.push(n18);
}
function dD(n18) {
  fg = true, XC(n18);
}
function la() {
  if (!w_ && Xs !== null) {
    w_ = true;
    var n18 = 0, e = Vt;
    try {
      var t = Xs;
      for (Vt = 1; n18 < t.length; n18++) {
        var i = t[n18];
        do
          i = i(true);
        while (i !== null);
      }
      Xs = null, fg = false;
    } catch (r) {
      throw Xs !== null && (Xs = Xs.slice(n18 + 1)), gC(Yx, la), r;
    } finally {
      Vt = e, w_ = false;
    }
  }
  return null;
}
var xu = [], Su = 0, Lm = null, Im = 0, Lr = [], Ir = 0, ul = null, js = 1, Zs = "";
function Ua(n18, e) {
  xu[Su++] = Im, xu[Su++] = Lm, Lm = n18, Im = e;
}
function YC(n18, e, t) {
  Lr[Ir++] = js, Lr[Ir++] = Zs, Lr[Ir++] = ul, ul = n18;
  var i = js;
  n18 = Zs;
  var r = 32 - Jr(i) - 1;
  i &= ~(1 << r), t += 1;
  var s = 32 - Jr(e) + r;
  if (30 < s) {
    var o = r - r % 5;
    s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, js = 1 << 32 - Jr(e) + r | t << r | i, Zs = s + n18;
  } else js = 1 << s | t << r | i, Zs = n18;
}
function tS(n18) {
  n18.return !== null && (Ua(n18, 1), YC(n18, 1, 0));
}
function nS(n18) {
  for (; n18 === Lm; ) Lm = xu[--Su], xu[Su] = null, Im = xu[--Su], xu[Su] = null;
  for (; n18 === ul; ) ul = Lr[--Ir], Lr[Ir] = null, Zs = Lr[--Ir], Lr[Ir] = null, js = Lr[--Ir], Lr[Ir] = null;
}
var cr = null, lr = null, $t = false, jr = null;
function qC(n18, e) {
  var t = Nr(5, null, null, 0);
  t.elementType = "DELETED", t.stateNode = e, t.return = n18, e = n18.deletions, e === null ? (n18.deletions = [t], n18.flags |= 16) : e.push(t);
}
function jw(n18, e) {
  switch (n18.tag) {
    case 5:
      var t = n18.type;
      return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n18.stateNode = e, cr = n18, lr = Wo(e.firstChild), true) : false;
    case 6:
      return e = n18.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n18.stateNode = e, cr = n18, lr = null, true) : false;
    case 13:
      return e = e.nodeType !== 8 ? null : e, e !== null ? (t = ul !== null ? { id: js, overflow: Zs } : null, n18.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = Nr(18, null, null, 0), t.stateNode = e, t.return = n18, n18.child = t, cr = n18, lr = null, true) : false;
    default:
      return false;
  }
}
function oy(n18) {
  return (n18.mode & 1) !== 0 && (n18.flags & 128) === 0;
}
function ay(n18) {
  if ($t) {
    var e = lr;
    if (e) {
      var t = e;
      if (!jw(n18, e)) {
        if (oy(n18)) throw Error(Se(418));
        e = Wo(t.nextSibling);
        var i = cr;
        e && jw(n18, e) ? qC(i, t) : (n18.flags = n18.flags & -4097 | 2, $t = false, cr = n18);
      }
    } else {
      if (oy(n18)) throw Error(Se(418));
      n18.flags = n18.flags & -4097 | 2, $t = false, cr = n18;
    }
  }
}
function Zw(n18) {
  for (n18 = n18.return; n18 !== null && n18.tag !== 5 && n18.tag !== 3 && n18.tag !== 13; ) n18 = n18.return;
  cr = n18;
}
function Zd(n18) {
  if (n18 !== cr) return false;
  if (!$t) return Zw(n18), $t = true, false;
  var e;
  if ((e = n18.tag !== 3) && !(e = n18.tag !== 5) && (e = n18.type, e = e !== "head" && e !== "body" && !ny(n18.type, n18.memoizedProps)), e && (e = lr)) {
    if (oy(n18)) throw jC(), Error(Se(418));
    for (; e; ) qC(n18, e), e = Wo(e.nextSibling);
  }
  if (Zw(n18), n18.tag === 13) {
    if (n18 = n18.memoizedState, n18 = n18 !== null ? n18.dehydrated : null, !n18) throw Error(Se(317));
    e: {
      for (n18 = n18.nextSibling, e = 0; n18; ) {
        if (n18.nodeType === 8) {
          var t = n18.data;
          if (t === "/$") {
            if (e === 0) {
              lr = Wo(n18.nextSibling);
              break e;
            }
            e--;
          } else t !== "$" && t !== "$!" && t !== "$?" || e++;
        }
        n18 = n18.nextSibling;
      }
      lr = null;
    }
  } else lr = cr ? Wo(n18.stateNode.nextSibling) : null;
  return true;
}
function jC() {
  for (var n18 = lr; n18; ) n18 = Wo(n18.nextSibling);
}
function Yu() {
  lr = cr = null, $t = false;
}
function iS(n18) {
  jr === null ? jr = [n18] : jr.push(n18);
}
var pD = uo.ReactCurrentBatchConfig;
function Wc(n18, e, t) {
  if (n18 = t.ref, n18 !== null && typeof n18 != "function" && typeof n18 != "object") {
    if (t._owner) {
      if (t = t._owner, t) {
        if (t.tag !== 1) throw Error(Se(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(Se(147, n18));
      var r = i, s = "" + n18;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
        var a = r.refs;
        o === null ? delete a[s] : a[s] = o;
      }, e._stringRef = s, e);
    }
    if (typeof n18 != "string") throw Error(Se(284));
    if (!t._owner) throw Error(Se(290, n18));
  }
  return n18;
}
function Jd(n18, e) {
  throw n18 = Object.prototype.toString.call(e), Error(Se(31, n18 === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n18));
}
function Jw(n18) {
  var e = n18._init;
  return e(n18._payload);
}
function ZC(n18) {
  function e(m, E) {
    if (n18) {
      var T = m.deletions;
      T === null ? (m.deletions = [E], m.flags |= 16) : T.push(E);
    }
  }
  function t(m, E) {
    if (!n18) return null;
    for (; E !== null; ) e(m, E), E = E.sibling;
    return null;
  }
  function i(m, E) {
    for (m = /* @__PURE__ */ new Map(); E !== null; ) E.key !== null ? m.set(E.key, E) : m.set(E.index, E), E = E.sibling;
    return m;
  }
  function r(m, E) {
    return m = jo(m, E), m.index = 0, m.sibling = null, m;
  }
  function s(m, E, T) {
    return m.index = T, n18 ? (T = m.alternate, T !== null ? (T = T.index, T < E ? (m.flags |= 2, E) : T) : (m.flags |= 2, E)) : (m.flags |= 1048576, E);
  }
  function o(m) {
    return n18 && m.alternate === null && (m.flags |= 2), m;
  }
  function a(m, E, T, C) {
    return E === null || E.tag !== 6 ? (E = b_(T, m.mode, C), E.return = m, E) : (E = r(E, T), E.return = m, E);
  }
  function u(m, E, T, C) {
    var L = T.type;
    return L === pu ? h(m, E, T.props.children, C, T.key) : E !== null && (E.elementType === L || typeof L == "object" && L !== null && L.$$typeof === bo && Jw(L) === E.type) ? (C = r(E, T.props), C.ref = Wc(m, E, T), C.return = m, C) : (C = am(T.type, T.key, T.props, null, m.mode, C), C.ref = Wc(m, E, T), C.return = m, C);
  }
  function f(m, E, T, C) {
    return E === null || E.tag !== 4 || E.stateNode.containerInfo !== T.containerInfo || E.stateNode.implementation !== T.implementation ? (E = L_(T, m.mode, C), E.return = m, E) : (E = r(E, T.children || []), E.return = m, E);
  }
  function h(m, E, T, C, L) {
    return E === null || E.tag !== 7 ? (E = Ka(T, m.mode, C, L), E.return = m, E) : (E = r(E, T), E.return = m, E);
  }
  function d(m, E, T) {
    if (typeof E == "string" && E !== "" || typeof E == "number") return E = b_("" + E, m.mode, T), E.return = m, E;
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case zd:
          return T = am(E.type, E.key, E.props, null, m.mode, T), T.ref = Wc(m, null, E), T.return = m, T;
        case du:
          return E = L_(E, m.mode, T), E.return = m, E;
        case bo:
          var C = E._init;
          return d(m, C(E._payload), T);
      }
      if (cf(E) || zc(E)) return E = Ka(E, m.mode, T, null), E.return = m, E;
      Jd(m, E);
    }
    return null;
  }
  function p(m, E, T, C) {
    var L = E !== null ? E.key : null;
    if (typeof T == "string" && T !== "" || typeof T == "number") return L !== null ? null : a(m, E, "" + T, C);
    if (typeof T == "object" && T !== null) {
      switch (T.$$typeof) {
        case zd:
          return T.key === L ? u(m, E, T, C) : null;
        case du:
          return T.key === L ? f(m, E, T, C) : null;
        case bo:
          return L = T._init, p(m, E, L(T._payload), C);
      }
      if (cf(T) || zc(T)) return L !== null ? null : h(m, E, T, C, null);
      Jd(m, T);
    }
    return null;
  }
  function g(m, E, T, C, L) {
    if (typeof C == "string" && C !== "" || typeof C == "number") return m = m.get(T) || null, a(E, m, "" + C, L);
    if (typeof C == "object" && C !== null) {
      switch (C.$$typeof) {
        case zd:
          return m = m.get(C.key === null ? T : C.key) || null, u(E, m, C, L);
        case du:
          return m = m.get(C.key === null ? T : C.key) || null, f(E, m, C, L);
        case bo:
          var b = C._init;
          return g(m, E, T, b(C._payload), L);
      }
      if (cf(C) || zc(C)) return m = m.get(T) || null, h(E, m, C, L, null);
      Jd(E, C);
    }
    return null;
  }
  function v(m, E, T, C) {
    for (var L = null, b = null, I = E, U = E = 0, B = null; I !== null && U < T.length; U++) {
      I.index > U ? (B = I, I = null) : B = I.sibling;
      var R = p(m, I, T[U], C);
      if (R === null) {
        I === null && (I = B);
        break;
      }
      n18 && I && R.alternate === null && e(m, I), E = s(R, E, U), b === null ? L = R : b.sibling = R, b = R, I = B;
    }
    if (U === T.length) return t(m, I), $t && Ua(m, U), L;
    if (I === null) {
      for (; U < T.length; U++) I = d(m, T[U], C), I !== null && (E = s(I, E, U), b === null ? L = I : b.sibling = I, b = I);
      return $t && Ua(m, U), L;
    }
    for (I = i(m, I); U < T.length; U++) B = g(I, m, U, T[U], C), B !== null && (n18 && B.alternate !== null && I.delete(B.key === null ? U : B.key), E = s(B, E, U), b === null ? L = B : b.sibling = B, b = B);
    return n18 && I.forEach(function(D) {
      return e(m, D);
    }), $t && Ua(m, U), L;
  }
  function M(m, E, T, C) {
    var L = zc(T);
    if (typeof L != "function") throw Error(Se(150));
    if (T = L.call(T), T == null) throw Error(Se(151));
    for (var b = L = null, I = E, U = E = 0, B = null, R = T.next(); I !== null && !R.done; U++, R = T.next()) {
      I.index > U ? (B = I, I = null) : B = I.sibling;
      var D = p(m, I, R.value, C);
      if (D === null) {
        I === null && (I = B);
        break;
      }
      n18 && I && D.alternate === null && e(m, I), E = s(D, E, U), b === null ? L = D : b.sibling = D, b = D, I = B;
    }
    if (R.done) return t(m, I), $t && Ua(m, U), L;
    if (I === null) {
      for (; !R.done; U++, R = T.next()) R = d(m, R.value, C), R !== null && (E = s(R, E, U), b === null ? L = R : b.sibling = R, b = R);
      return $t && Ua(m, U), L;
    }
    for (I = i(m, I); !R.done; U++, R = T.next()) R = g(I, m, U, R.value, C), R !== null && (n18 && R.alternate !== null && I.delete(R.key === null ? U : R.key), E = s(R, E, U), b === null ? L = R : b.sibling = R, b = R);
    return n18 && I.forEach(function(j) {
      return e(m, j);
    }), $t && Ua(m, U), L;
  }
  function S(m, E, T, C) {
    if (typeof T == "object" && T !== null && T.type === pu && T.key === null && (T = T.props.children), typeof T == "object" && T !== null) {
      switch (T.$$typeof) {
        case zd:
          e: {
            for (var L = T.key, b = E; b !== null; ) {
              if (b.key === L) {
                if (L = T.type, L === pu) {
                  if (b.tag === 7) {
                    t(m, b.sibling), E = r(b, T.props.children), E.return = m, m = E;
                    break e;
                  }
                } else if (b.elementType === L || typeof L == "object" && L !== null && L.$$typeof === bo && Jw(L) === b.type) {
                  t(m, b.sibling), E = r(b, T.props), E.ref = Wc(m, b, T), E.return = m, m = E;
                  break e;
                }
                t(m, b);
                break;
              } else e(m, b);
              b = b.sibling;
            }
            T.type === pu ? (E = Ka(T.props.children, m.mode, C, T.key), E.return = m, m = E) : (C = am(T.type, T.key, T.props, null, m.mode, C), C.ref = Wc(m, E, T), C.return = m, m = C);
          }
          return o(m);
        case du:
          e: {
            for (b = T.key; E !== null; ) {
              if (E.key === b) if (E.tag === 4 && E.stateNode.containerInfo === T.containerInfo && E.stateNode.implementation === T.implementation) {
                t(m, E.sibling), E = r(E, T.children || []), E.return = m, m = E;
                break e;
              } else {
                t(m, E);
                break;
              }
              else e(m, E);
              E = E.sibling;
            }
            E = L_(T, m.mode, C), E.return = m, m = E;
          }
          return o(m);
        case bo:
          return b = T._init, S(m, E, b(T._payload), C);
      }
      if (cf(T)) return v(m, E, T, C);
      if (zc(T)) return M(m, E, T, C);
      Jd(m, T);
    }
    return typeof T == "string" && T !== "" || typeof T == "number" ? (T = "" + T, E !== null && E.tag === 6 ? (t(m, E.sibling), E = r(E, T), E.return = m, m = E) : (t(m, E), E = b_(T, m.mode, C), E.return = m, m = E), o(m)) : t(m, E);
  }
  return S;
}
var qu = ZC(true), JC = ZC(false), Dm = aa(null), Nm = null, Mu = null, rS = null;
function sS() {
  rS = Mu = Nm = null;
}
function oS(n18) {
  var e = Dm.current;
  Kt(Dm), n18._currentValue = e;
}
function ly(n18, e, t) {
  for (; n18 !== null; ) {
    var i = n18.alternate;
    if ((n18.childLanes & e) !== e ? (n18.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n18 === t) break;
    n18 = n18.return;
  }
}
function Fu(n18, e) {
  Nm = n18, rS = Mu = null, n18 = n18.dependencies, n18 !== null && n18.firstContext !== null && (n18.lanes & e && (zi = true), n18.firstContext = null);
}
function Fr(n18) {
  var e = n18._currentValue;
  if (rS !== n18) if (n18 = { context: n18, memoizedValue: e, next: null }, Mu === null) {
    if (Nm === null) throw Error(Se(308));
    Mu = n18, Nm.dependencies = { lanes: 0, firstContext: n18 };
  } else Mu = Mu.next = n18;
  return e;
}
var Ga = null;
function aS(n18) {
  Ga === null ? Ga = [n18] : Ga.push(n18);
}
function KC(n18, e, t, i) {
  var r = e.interleaved;
  return r === null ? (t.next = t, aS(e)) : (t.next = r.next, r.next = t), e.interleaved = t, no(n18, i);
}
function no(n18, e) {
  n18.lanes |= e;
  var t = n18.alternate;
  for (t !== null && (t.lanes |= e), t = n18, n18 = n18.return; n18 !== null; ) n18.childLanes |= e, t = n18.alternate, t !== null && (t.childLanes |= e), t = n18, n18 = n18.return;
  return t.tag === 3 ? t.stateNode : null;
}
var Lo = false;
function lS(n18) {
  n18.updateQueue = { baseState: n18.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function QC(n18, e) {
  n18 = n18.updateQueue, e.updateQueue === n18 && (e.updateQueue = { baseState: n18.baseState, firstBaseUpdate: n18.firstBaseUpdate, lastBaseUpdate: n18.lastBaseUpdate, shared: n18.shared, effects: n18.effects });
}
function Qs(n18, e) {
  return { eventTime: n18, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function Xo(n18, e, t) {
  var i = n18.updateQueue;
  if (i === null) return null;
  if (i = i.shared, Pt & 2) {
    var r = i.pending;
    return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, no(n18, t);
  }
  return r = i.interleaved, r === null ? (e.next = e, aS(i)) : (e.next = r.next, r.next = e), i.interleaved = e, no(n18, t);
}
function tm(n18, e, t) {
  if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) {
    var i = e.lanes;
    i &= n18.pendingLanes, t |= i, e.lanes = t, qx(n18, t);
  }
}
function Kw(n18, e) {
  var t = n18.updateQueue, i = n18.alternate;
  if (i !== null && (i = i.updateQueue, t === i)) {
    var r = null, s = null;
    if (t = t.firstBaseUpdate, t !== null) {
      do {
        var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null };
        s === null ? r = s = o : s = s.next = o, t = t.next;
      } while (t !== null);
      s === null ? r = s = e : s = s.next = e;
    } else r = s = e;
    t = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, n18.updateQueue = t;
    return;
  }
  n18 = t.lastBaseUpdate, n18 === null ? t.firstBaseUpdate = e : n18.next = e, t.lastBaseUpdate = e;
}
function Um(n18, e, t, i) {
  var r = n18.updateQueue;
  Lo = false;
  var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var u = a, f = u.next;
    u.next = null, o === null ? s = f : o.next = f, o = u;
    var h = n18.alternate;
    h !== null && (h = h.updateQueue, a = h.lastBaseUpdate, a !== o && (a === null ? h.firstBaseUpdate = f : a.next = f, h.lastBaseUpdate = u));
  }
  if (s !== null) {
    var d = r.baseState;
    o = 0, h = f = u = null, a = s;
    do {
      var p = a.lane, g = a.eventTime;
      if ((i & p) === p) {
        h !== null && (h = h.next = { eventTime: g, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null });
        e: {
          var v = n18, M = a;
          switch (p = e, g = t, M.tag) {
            case 1:
              if (v = M.payload, typeof v == "function") {
                d = v.call(g, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = v.flags & -65537 | 128;
            case 0:
              if (v = M.payload, p = typeof v == "function" ? v.call(g, d, p) : v, p == null) break e;
              d = cn({}, d, p);
              break e;
            case 2:
              Lo = true;
          }
        }
        a.callback !== null && a.lane !== 0 && (n18.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a));
      } else g = { eventTime: g, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, h === null ? (f = h = g, u = d) : h = h.next = g, o |= p;
      if (a = a.next, a === null) {
        if (a = r.shared.pending, a === null) break;
        p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null;
      }
    } while (true);
    if (h === null && (u = d), r.baseState = u, r.firstBaseUpdate = f, r.lastBaseUpdate = h, e = r.shared.interleaved, e !== null) {
      r = e;
      do
        o |= r.lane, r = r.next;
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    fl |= o, n18.lanes = o, n18.memoizedState = d;
  }
}
function Qw(n18, e, t) {
  if (n18 = e.effects, e.effects = null, n18 !== null) for (e = 0; e < n18.length; e++) {
    var i = n18[e], r = i.callback;
    if (r !== null) {
      if (i.callback = null, i = t, typeof r != "function") throw Error(Se(191, r));
      r.call(i);
    }
  }
}
var Ph = {}, Ms = aa(Ph), Wf = aa(Ph), Xf = aa(Ph);
function Wa(n18) {
  if (n18 === Ph) throw Error(Se(174));
  return n18;
}
function uS(n18, e) {
  switch (qt(Xf, e), qt(Wf, n18), qt(Ms, Ph), n18 = e.nodeType, n18) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : Hv(null, "");
      break;
    default:
      n18 = n18 === 8 ? e.parentNode : e, e = n18.namespaceURI || null, n18 = n18.tagName, e = Hv(e, n18);
  }
  Kt(Ms), qt(Ms, e);
}
function ju() {
  Kt(Ms), Kt(Wf), Kt(Xf);
}
function $C(n18) {
  Wa(Xf.current);
  var e = Wa(Ms.current), t = Hv(e, n18.type);
  e !== t && (qt(Wf, n18), qt(Ms, t));
}
function cS(n18) {
  Wf.current === n18 && (Kt(Ms), Kt(Wf));
}
var rn = aa(0);
function Om(n18) {
  for (var e = n18; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue;
    }
    if (e === n18) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n18) return null;
      e = e.return;
    }
    e.sibling.return = e.return, e = e.sibling;
  }
  return null;
}
var E_ = [];
function fS() {
  for (var n18 = 0; n18 < E_.length; n18++) E_[n18]._workInProgressVersionPrimary = null;
  E_.length = 0;
}
var nm = uo.ReactCurrentDispatcher, T_ = uo.ReactCurrentBatchConfig, cl = 0, un = null, Dn = null, Wn = null, Fm = false, Sf = false, Yf = 0, mD = 0;
function oi() {
  throw Error(Se(321));
}
function hS(n18, e) {
  if (e === null) return false;
  for (var t = 0; t < e.length && t < n18.length; t++) if (!Qr(n18[t], e[t])) return false;
  return true;
}
function dS(n18, e, t, i, r, s) {
  if (cl = s, un = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, nm.current = n18 === null || n18.memoizedState === null ? yD : xD, n18 = t(i, r), Sf) {
    s = 0;
    do {
      if (Sf = false, Yf = 0, 25 <= s) throw Error(Se(301));
      s += 1, Wn = Dn = null, e.updateQueue = null, nm.current = SD, n18 = t(i, r);
    } while (Sf);
  }
  if (nm.current = km, e = Dn !== null && Dn.next !== null, cl = 0, Wn = Dn = un = null, Fm = false, e) throw Error(Se(300));
  return n18;
}
function pS() {
  var n18 = Yf !== 0;
  return Yf = 0, n18;
}
function ds() {
  var n18 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return Wn === null ? un.memoizedState = Wn = n18 : Wn = Wn.next = n18, Wn;
}
function kr() {
  if (Dn === null) {
    var n18 = un.alternate;
    n18 = n18 !== null ? n18.memoizedState : null;
  } else n18 = Dn.next;
  var e = Wn === null ? un.memoizedState : Wn.next;
  if (e !== null) Wn = e, Dn = n18;
  else {
    if (n18 === null) throw Error(Se(310));
    Dn = n18, n18 = { memoizedState: Dn.memoizedState, baseState: Dn.baseState, baseQueue: Dn.baseQueue, queue: Dn.queue, next: null }, Wn === null ? un.memoizedState = Wn = n18 : Wn = Wn.next = n18;
  }
  return Wn;
}
function qf(n18, e) {
  return typeof e == "function" ? e(n18) : e;
}
function A_(n18) {
  var e = kr(), t = e.queue;
  if (t === null) throw Error(Se(311));
  t.lastRenderedReducer = n18;
  var i = Dn, r = i.baseQueue, s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      r.next = s.next, s.next = o;
    }
    i.baseQueue = r = s, t.pending = null;
  }
  if (r !== null) {
    s = r.next, i = i.baseState;
    var a = o = null, u = null, f = s;
    do {
      var h = f.lane;
      if ((cl & h) === h) u !== null && (u = u.next = { lane: 0, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null }), i = f.hasEagerState ? f.eagerState : n18(i, f.action);
      else {
        var d = { lane: h, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null };
        u === null ? (a = u = d, o = i) : u = u.next = d, un.lanes |= h, fl |= h;
      }
      f = f.next;
    } while (f !== null && f !== s);
    u === null ? o = i : u.next = a, Qr(i, e.memoizedState) || (zi = true), e.memoizedState = i, e.baseState = o, e.baseQueue = u, t.lastRenderedState = i;
  }
  if (n18 = t.interleaved, n18 !== null) {
    r = n18;
    do
      s = r.lane, un.lanes |= s, fl |= s, r = r.next;
    while (r !== n18);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function C_(n18) {
  var e = kr(), t = e.queue;
  if (t === null) throw Error(Se(311));
  t.lastRenderedReducer = n18;
  var i = t.dispatch, r = t.pending, s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = r = r.next;
    do
      s = n18(s, o.action), o = o.next;
    while (o !== r);
    Qr(s, e.memoizedState) || (zi = true), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s;
  }
  return [s, i];
}
function eR() {
}
function tR(n18, e) {
  var t = un, i = kr(), r = e(), s = !Qr(i.memoizedState, r);
  if (s && (i.memoizedState = r, zi = true), i = i.queue, mS(rR.bind(null, t, i, n18), [n18]), i.getSnapshot !== e || s || Wn !== null && Wn.memoizedState.tag & 1) {
    if (t.flags |= 2048, jf(9, iR.bind(null, t, i, r, e), void 0, null), Yn === null) throw Error(Se(349));
    cl & 30 || nR(t, e, r);
  }
  return r;
}
function nR(n18, e, t) {
  n18.flags |= 16384, n18 = { getSnapshot: e, value: t }, e = un.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, un.updateQueue = e, e.stores = [n18]) : (t = e.stores, t === null ? e.stores = [n18] : t.push(n18));
}
function iR(n18, e, t, i) {
  e.value = t, e.getSnapshot = i, sR(e) && oR(n18);
}
function rR(n18, e, t) {
  return t(function() {
    sR(e) && oR(n18);
  });
}
function sR(n18) {
  var e = n18.getSnapshot;
  n18 = n18.value;
  try {
    var t = e();
    return !Qr(n18, t);
  } catch {
    return true;
  }
}
function oR(n18) {
  var e = no(n18, 1);
  e !== null && Kr(e, n18, 1, -1);
}
function $w(n18) {
  var e = ds();
  return typeof n18 == "function" && (n18 = n18()), e.memoizedState = e.baseState = n18, n18 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: qf, lastRenderedState: n18 }, e.queue = n18, n18 = n18.dispatch = vD.bind(null, un, n18), [e.memoizedState, n18];
}
function jf(n18, e, t, i) {
  return n18 = { tag: n18, create: e, destroy: t, deps: i, next: null }, e = un.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, un.updateQueue = e, e.lastEffect = n18.next = n18) : (t = e.lastEffect, t === null ? e.lastEffect = n18.next = n18 : (i = t.next, t.next = n18, n18.next = i, e.lastEffect = n18)), n18;
}
function aR() {
  return kr().memoizedState;
}
function im(n18, e, t, i) {
  var r = ds();
  un.flags |= n18, r.memoizedState = jf(1 | e, t, void 0, i === void 0 ? null : i);
}
function hg(n18, e, t, i) {
  var r = kr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Dn !== null) {
    var o = Dn.memoizedState;
    if (s = o.destroy, i !== null && hS(i, o.deps)) {
      r.memoizedState = jf(e, t, s, i);
      return;
    }
  }
  un.flags |= n18, r.memoizedState = jf(1 | e, t, s, i);
}
function eE(n18, e) {
  return im(8390656, 8, n18, e);
}
function mS(n18, e) {
  return hg(2048, 8, n18, e);
}
function lR(n18, e) {
  return hg(4, 2, n18, e);
}
function uR(n18, e) {
  return hg(4, 4, n18, e);
}
function cR(n18, e) {
  if (typeof e == "function") return n18 = n18(), e(n18), function() {
    e(null);
  };
  if (e != null) return n18 = n18(), e.current = n18, function() {
    e.current = null;
  };
}
function fR(n18, e, t) {
  return t = t != null ? t.concat([n18]) : null, hg(4, 4, cR.bind(null, e, n18), t);
}
function gS() {
}
function hR(n18, e) {
  var t = kr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && hS(e, i[1]) ? i[0] : (t.memoizedState = [n18, e], n18);
}
function dR(n18, e) {
  var t = kr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && hS(e, i[1]) ? i[0] : (n18 = n18(), t.memoizedState = [n18, e], n18);
}
function pR(n18, e, t) {
  return cl & 21 ? (Qr(t, e) || (t = yC(), un.lanes |= t, fl |= t, n18.baseState = true), e) : (n18.baseState && (n18.baseState = false, zi = true), n18.memoizedState = t);
}
function gD(n18, e) {
  var t = Vt;
  Vt = t !== 0 && 4 > t ? t : 4, n18(true);
  var i = T_.transition;
  T_.transition = {};
  try {
    n18(false), e();
  } finally {
    Vt = t, T_.transition = i;
  }
}
function mR() {
  return kr().memoizedState;
}
function _D(n18, e, t) {
  var i = qo(n18);
  if (t = { lane: i, action: t, hasEagerState: false, eagerState: null, next: null }, gR(n18)) _R(e, t);
  else if (t = KC(n18, e, t, i), t !== null) {
    var r = Ri();
    Kr(t, n18, i, r), vR(t, e, i);
  }
}
function vD(n18, e, t) {
  var i = qo(n18), r = { lane: i, action: t, hasEagerState: false, eagerState: null, next: null };
  if (gR(n18)) _R(e, r);
  else {
    var s = n18.alternate;
    if (n18.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
      var o = e.lastRenderedState, a = s(o, t);
      if (r.hasEagerState = true, r.eagerState = a, Qr(a, o)) {
        var u = e.interleaved;
        u === null ? (r.next = r, aS(e)) : (r.next = u.next, u.next = r), e.interleaved = r;
        return;
      }
    } catch {
    } finally {
    }
    t = KC(n18, e, r, i), t !== null && (r = Ri(), Kr(t, n18, i, r), vR(t, e, i));
  }
}
function gR(n18) {
  var e = n18.alternate;
  return n18 === un || e !== null && e === un;
}
function _R(n18, e) {
  Sf = Fm = true;
  var t = n18.pending;
  t === null ? e.next = e : (e.next = t.next, t.next = e), n18.pending = e;
}
function vR(n18, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    i &= n18.pendingLanes, t |= i, e.lanes = t, qx(n18, t);
  }
}
var km = { readContext: Fr, useCallback: oi, useContext: oi, useEffect: oi, useImperativeHandle: oi, useInsertionEffect: oi, useLayoutEffect: oi, useMemo: oi, useReducer: oi, useRef: oi, useState: oi, useDebugValue: oi, useDeferredValue: oi, useTransition: oi, useMutableSource: oi, useSyncExternalStore: oi, useId: oi, unstable_isNewReconciler: false }, yD = { readContext: Fr, useCallback: function(n18, e) {
  return ds().memoizedState = [n18, e === void 0 ? null : e], n18;
}, useContext: Fr, useEffect: eE, useImperativeHandle: function(n18, e, t) {
  return t = t != null ? t.concat([n18]) : null, im(4194308, 4, cR.bind(null, e, n18), t);
}, useLayoutEffect: function(n18, e) {
  return im(4194308, 4, n18, e);
}, useInsertionEffect: function(n18, e) {
  return im(4, 2, n18, e);
}, useMemo: function(n18, e) {
  var t = ds();
  return e = e === void 0 ? null : e, n18 = n18(), t.memoizedState = [n18, e], n18;
}, useReducer: function(n18, e, t) {
  var i = ds();
  return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n18 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n18, lastRenderedState: e }, i.queue = n18, n18 = n18.dispatch = _D.bind(null, un, n18), [i.memoizedState, n18];
}, useRef: function(n18) {
  var e = ds();
  return n18 = { current: n18 }, e.memoizedState = n18;
}, useState: $w, useDebugValue: gS, useDeferredValue: function(n18) {
  return ds().memoizedState = n18;
}, useTransition: function() {
  var n18 = $w(false), e = n18[0];
  return n18 = gD.bind(null, n18[1]), ds().memoizedState = n18, [e, n18];
}, useMutableSource: function() {
}, useSyncExternalStore: function(n18, e, t) {
  var i = un, r = ds();
  if ($t) {
    if (t === void 0) throw Error(Se(407));
    t = t();
  } else {
    if (t = e(), Yn === null) throw Error(Se(349));
    cl & 30 || nR(i, e, t);
  }
  r.memoizedState = t;
  var s = { value: t, getSnapshot: e };
  return r.queue = s, eE(rR.bind(null, i, s, n18), [n18]), i.flags |= 2048, jf(9, iR.bind(null, i, s, t, e), void 0, null), t;
}, useId: function() {
  var n18 = ds(), e = Yn.identifierPrefix;
  if ($t) {
    var t = Zs, i = js;
    t = (i & ~(1 << 32 - Jr(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Yf++, 0 < t && (e += "H" + t.toString(32)), e += ":";
  } else t = mD++, e = ":" + e + "r" + t.toString(32) + ":";
  return n18.memoizedState = e;
}, unstable_isNewReconciler: false }, xD = { readContext: Fr, useCallback: hR, useContext: Fr, useEffect: mS, useImperativeHandle: fR, useInsertionEffect: lR, useLayoutEffect: uR, useMemo: dR, useReducer: A_, useRef: aR, useState: function() {
  return A_(qf);
}, useDebugValue: gS, useDeferredValue: function(n18) {
  var e = kr();
  return pR(e, Dn.memoizedState, n18);
}, useTransition: function() {
  var n18 = A_(qf)[0], e = kr().memoizedState;
  return [n18, e];
}, useMutableSource: eR, useSyncExternalStore: tR, useId: mR, unstable_isNewReconciler: false }, SD = { readContext: Fr, useCallback: hR, useContext: Fr, useEffect: mS, useImperativeHandle: fR, useInsertionEffect: lR, useLayoutEffect: uR, useMemo: dR, useReducer: C_, useRef: aR, useState: function() {
  return C_(qf);
}, useDebugValue: gS, useDeferredValue: function(n18) {
  var e = kr();
  return Dn === null ? e.memoizedState = n18 : pR(e, Dn.memoizedState, n18);
}, useTransition: function() {
  var n18 = C_(qf)[0], e = kr().memoizedState;
  return [n18, e];
}, useMutableSource: eR, useSyncExternalStore: tR, useId: mR, unstable_isNewReconciler: false };
function Xr(n18, e) {
  if (n18 && n18.defaultProps) {
    e = cn({}, e), n18 = n18.defaultProps;
    for (var t in n18) e[t] === void 0 && (e[t] = n18[t]);
    return e;
  }
  return e;
}
function uy(n18, e, t, i) {
  e = n18.memoizedState, t = t(i, e), t = t == null ? e : cn({}, e, t), n18.memoizedState = t, n18.lanes === 0 && (n18.updateQueue.baseState = t);
}
var dg = { isMounted: function(n18) {
  return (n18 = n18._reactInternals) ? vl(n18) === n18 : false;
}, enqueueSetState: function(n18, e, t) {
  n18 = n18._reactInternals;
  var i = Ri(), r = qo(n18), s = Qs(i, r);
  s.payload = e, t != null && (s.callback = t), e = Xo(n18, s, r), e !== null && (Kr(e, n18, r, i), tm(e, n18, r));
}, enqueueReplaceState: function(n18, e, t) {
  n18 = n18._reactInternals;
  var i = Ri(), r = qo(n18), s = Qs(i, r);
  s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Xo(n18, s, r), e !== null && (Kr(e, n18, r, i), tm(e, n18, r));
}, enqueueForceUpdate: function(n18, e) {
  n18 = n18._reactInternals;
  var t = Ri(), i = qo(n18), r = Qs(t, i);
  r.tag = 2, e != null && (r.callback = e), e = Xo(n18, r, i), e !== null && (Kr(e, n18, i, t), tm(e, n18, i));
} };
function tE(n18, e, t, i, r, s, o) {
  return n18 = n18.stateNode, typeof n18.shouldComponentUpdate == "function" ? n18.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Bf(t, i) || !Bf(r, s) : true;
}
function yR(n18, e, t) {
  var i = false, r = ta, s = e.contextType;
  return typeof s == "object" && s !== null ? s = Fr(s) : (r = Vi(e) ? ll : _i.current, i = e.contextTypes, s = (i = i != null) ? Xu(n18, r) : ta), e = new e(t, s), n18.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = dg, n18.stateNode = e, e._reactInternals = n18, i && (n18 = n18.stateNode, n18.__reactInternalMemoizedUnmaskedChildContext = r, n18.__reactInternalMemoizedMaskedChildContext = s), e;
}
function nE(n18, e, t, i) {
  n18 = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n18 && dg.enqueueReplaceState(e, e.state, null);
}
function cy(n18, e, t, i) {
  var r = n18.stateNode;
  r.props = t, r.state = n18.memoizedState, r.refs = {}, lS(n18);
  var s = e.contextType;
  typeof s == "object" && s !== null ? r.context = Fr(s) : (s = Vi(e) ? ll : _i.current, r.context = Xu(n18, s)), r.state = n18.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (uy(n18, e, s, t), r.state = n18.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && dg.enqueueReplaceState(r, r.state, null), Um(n18, t, r, i), r.state = n18.memoizedState), typeof r.componentDidMount == "function" && (n18.flags |= 4194308);
}
function Zu(n18, e) {
  try {
    var t = "", i = e;
    do
      t += Z3(i), i = i.return;
    while (i);
    var r = t;
  } catch (s) {
    r = `
Error generating stack: ` + s.message + `
` + s.stack;
  }
  return { value: n18, source: e, stack: r, digest: null };
}
function R_(n18, e, t) {
  return { value: n18, source: null, stack: t ?? null, digest: e ?? null };
}
function fy(n18, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function() {
      throw t;
    });
  }
}
var MD = typeof WeakMap == "function" ? WeakMap : Map;
function xR(n18, e, t) {
  t = Qs(-1, t), t.tag = 3, t.payload = { element: null };
  var i = e.value;
  return t.callback = function() {
    Bm || (Bm = true, Sy = i), fy(n18, e);
  }, t;
}
function SR(n18, e, t) {
  t = Qs(-1, t), t.tag = 3;
  var i = n18.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    t.payload = function() {
      return i(r);
    }, t.callback = function() {
      fy(n18, e);
    };
  }
  var s = n18.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
    fy(n18, e), typeof i != "function" && (Yo === null ? Yo = /* @__PURE__ */ new Set([this]) : Yo.add(this));
    var o = e.stack;
    this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" });
  }), t;
}
function iE(n18, e, t) {
  var i = n18.pingCache;
  if (i === null) {
    i = n18.pingCache = new MD();
    var r = /* @__PURE__ */ new Set();
    i.set(e, r);
  } else r = i.get(e), r === void 0 && (r = /* @__PURE__ */ new Set(), i.set(e, r));
  r.has(t) || (r.add(t), n18 = OD.bind(null, n18, e, t), e.then(n18, n18));
}
function rE(n18) {
  do {
    var e;
    if ((e = n18.tag === 13) && (e = n18.memoizedState, e = e !== null ? e.dehydrated !== null : true), e) return n18;
    n18 = n18.return;
  } while (n18 !== null);
  return null;
}
function sE(n18, e, t, i, r) {
  return n18.mode & 1 ? (n18.flags |= 65536, n18.lanes = r, n18) : (n18 === e ? n18.flags |= 65536 : (n18.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Qs(-1, 1), e.tag = 2, Xo(t, e, 1))), t.lanes |= 1), n18);
}
var wD = uo.ReactCurrentOwner, zi = false;
function Ei(n18, e, t, i) {
  e.child = n18 === null ? JC(e, null, t, i) : qu(e, n18.child, t, i);
}
function oE(n18, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return Fu(e, r), i = dS(n18, e, t, i, s, r), t = pS(), n18 !== null && !zi ? (e.updateQueue = n18.updateQueue, e.flags &= -2053, n18.lanes &= ~r, io(n18, e, r)) : ($t && t && tS(e), e.flags |= 1, Ei(n18, e, i, r), e.child);
}
function aE(n18, e, t, i, r) {
  if (n18 === null) {
    var s = t.type;
    return typeof s == "function" && !ES(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, MR(n18, e, s, i, r)) : (n18 = am(t.type, null, i, e, e.mode, r), n18.ref = e.ref, n18.return = e, e.child = n18);
  }
  if (s = n18.child, !(n18.lanes & r)) {
    var o = s.memoizedProps;
    if (t = t.compare, t = t !== null ? t : Bf, t(o, i) && n18.ref === e.ref) return io(n18, e, r);
  }
  return e.flags |= 1, n18 = jo(s, i), n18.ref = e.ref, n18.return = e, e.child = n18;
}
function MR(n18, e, t, i, r) {
  if (n18 !== null) {
    var s = n18.memoizedProps;
    if (Bf(s, i) && n18.ref === e.ref) if (zi = false, e.pendingProps = i = s, (n18.lanes & r) !== 0) n18.flags & 131072 && (zi = true);
    else return e.lanes = n18.lanes, io(n18, e, r);
  }
  return hy(n18, e, t, i, r);
}
function wR(n18, e, t) {
  var i = e.pendingProps, r = i.children, s = n18 !== null ? n18.memoizedState : null;
  if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, qt(Eu, ir), ir |= t;
  else {
    if (!(t & 1073741824)) return n18 = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n18, cachePool: null, transitions: null }, e.updateQueue = null, qt(Eu, ir), ir |= n18, null;
    e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : t, qt(Eu, ir), ir |= i;
  }
  else s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, qt(Eu, ir), ir |= i;
  return Ei(n18, e, r, t), e.child;
}
function ER(n18, e) {
  var t = e.ref;
  (n18 === null && t !== null || n18 !== null && n18.ref !== t) && (e.flags |= 512, e.flags |= 2097152);
}
function hy(n18, e, t, i, r) {
  var s = Vi(t) ? ll : _i.current;
  return s = Xu(e, s), Fu(e, r), t = dS(n18, e, t, i, s, r), i = pS(), n18 !== null && !zi ? (e.updateQueue = n18.updateQueue, e.flags &= -2053, n18.lanes &= ~r, io(n18, e, r)) : ($t && i && tS(e), e.flags |= 1, Ei(n18, e, t, r), e.child);
}
function lE(n18, e, t, i, r) {
  if (Vi(t)) {
    var s = true;
    bm(e);
  } else s = false;
  if (Fu(e, r), e.stateNode === null) rm(n18, e), yR(e, t, i), cy(e, t, i, r), i = true;
  else if (n18 === null) {
    var o = e.stateNode, a = e.memoizedProps;
    o.props = a;
    var u = o.context, f = t.contextType;
    typeof f == "object" && f !== null ? f = Fr(f) : (f = Vi(t) ? ll : _i.current, f = Xu(e, f));
    var h = t.getDerivedStateFromProps, d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || u !== f) && nE(e, o, i, f), Lo = false;
    var p = e.memoizedState;
    o.state = p, Um(e, i, o, r), u = e.memoizedState, a !== i || p !== u || Bi.current || Lo ? (typeof h == "function" && (uy(e, t, h, i), u = e.memoizedState), (a = Lo || tE(e, t, a, i, p, u, f)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = u), o.props = i, o.state = u, o.context = f, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = false);
  } else {
    o = e.stateNode, QC(n18, e), a = e.memoizedProps, f = e.type === e.elementType ? a : Xr(e.type, a), o.props = f, d = e.pendingProps, p = o.context, u = t.contextType, typeof u == "object" && u !== null ? u = Fr(u) : (u = Vi(t) ? ll : _i.current, u = Xu(e, u));
    var g = t.getDerivedStateFromProps;
    (h = typeof g == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== u) && nE(e, o, i, u), Lo = false, p = e.memoizedState, o.state = p, Um(e, i, o, r);
    var v = e.memoizedState;
    a !== d || p !== v || Bi.current || Lo ? (typeof g == "function" && (uy(e, t, g, i), v = e.memoizedState), (f = Lo || tE(e, t, f, i, p, v, u) || false) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, u), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, u)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n18.memoizedProps && p === n18.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n18.memoizedProps && p === n18.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = v), o.props = i, o.state = v, o.context = u, i = f) : (typeof o.componentDidUpdate != "function" || a === n18.memoizedProps && p === n18.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n18.memoizedProps && p === n18.memoizedState || (e.flags |= 1024), i = false);
  }
  return dy(n18, e, t, i, s, r);
}
function dy(n18, e, t, i, r, s) {
  ER(n18, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && qw(e, t, false), io(n18, e, s);
  i = e.stateNode, wD.current = e;
  var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return e.flags |= 1, n18 !== null && o ? (e.child = qu(e, n18.child, null, s), e.child = qu(e, null, a, s)) : Ei(n18, e, a, s), e.memoizedState = i.state, r && qw(e, t, true), e.child;
}
function TR(n18) {
  var e = n18.stateNode;
  e.pendingContext ? Yw(n18, e.pendingContext, e.pendingContext !== e.context) : e.context && Yw(n18, e.context, false), uS(n18, e.containerInfo);
}
function uE(n18, e, t, i, r) {
  return Yu(), iS(r), e.flags |= 256, Ei(n18, e, t, i), e.child;
}
var py = { dehydrated: null, treeContext: null, retryLane: 0 };
function my(n18) {
  return { baseLanes: n18, cachePool: null, transitions: null };
}
function AR(n18, e, t) {
  var i = e.pendingProps, r = rn.current, s = false, o = (e.flags & 128) !== 0, a;
  if ((a = o) || (a = n18 !== null && n18.memoizedState === null ? false : (r & 2) !== 0), a ? (s = true, e.flags &= -129) : (n18 === null || n18.memoizedState !== null) && (r |= 1), qt(rn, r & 1), n18 === null) return ay(e), n18 = e.memoizedState, n18 !== null && (n18 = n18.dehydrated, n18 !== null) ? (e.mode & 1 ? n18.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n18 = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = gg(o, i, 0, null), n18 = Ka(n18, i, t, null), s.return = e, n18.return = e, s.sibling = n18, e.child = s, e.child.memoizedState = my(t), e.memoizedState = py, n18) : _S(e, o));
  if (r = n18.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return ED(n18, e, o, i, a, r, t);
  if (s) {
    s = i.fallback, o = e.mode, r = n18.child, a = r.sibling;
    var u = { mode: "hidden", children: i.children };
    return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = u, e.deletions = null) : (i = jo(r, u), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = jo(a, s) : (s = Ka(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n18.child.memoizedState, o = o === null ? my(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n18.childLanes & ~t, e.memoizedState = py, i;
  }
  return s = n18.child, n18 = s.sibling, i = jo(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n18 !== null && (t = e.deletions, t === null ? (e.deletions = [n18], e.flags |= 16) : t.push(n18)), e.child = i, e.memoizedState = null, i;
}
function _S(n18, e) {
  return e = gg({ mode: "visible", children: e }, n18.mode, 0, null), e.return = n18, n18.child = e;
}
function Kd(n18, e, t, i) {
  return i !== null && iS(i), qu(e, n18.child, null, t), n18 = _S(e, e.pendingProps.children), n18.flags |= 2, e.memoizedState = null, n18;
}
function ED(n18, e, t, i, r, s, o) {
  if (t) return e.flags & 256 ? (e.flags &= -257, i = R_(Error(Se(422))), Kd(n18, e, o, i)) : e.memoizedState !== null ? (e.child = n18.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = gg({ mode: "visible", children: i.children }, r, 0, null), s = Ka(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && qu(e, n18.child, null, o), e.child.memoizedState = my(o), e.memoizedState = py, s);
  if (!(e.mode & 1)) return Kd(n18, e, o, null);
  if (r.data === "$!") {
    if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst;
    return i = a, s = Error(Se(419)), i = R_(s, i, void 0), Kd(n18, e, o, i);
  }
  if (a = (o & n18.childLanes) !== 0, zi || a) {
    if (i = Yn, i !== null) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, no(n18, r), Kr(i, n18, r, -1));
    }
    return wS(), i = R_(Error(Se(421))), Kd(n18, e, o, i);
  }
  return r.data === "$?" ? (e.flags |= 128, e.child = n18.child, e = FD.bind(null, n18), r._reactRetry = e, null) : (n18 = s.treeContext, lr = Wo(r.nextSibling), cr = e, $t = true, jr = null, n18 !== null && (Lr[Ir++] = js, Lr[Ir++] = Zs, Lr[Ir++] = ul, js = n18.id, Zs = n18.overflow, ul = e), e = _S(e, i.children), e.flags |= 4096, e);
}
function cE(n18, e, t) {
  n18.lanes |= e;
  var i = n18.alternate;
  i !== null && (i.lanes |= e), ly(n18.return, e, t);
}
function P_(n18, e, t, i, r) {
  var s = n18.memoizedState;
  s === null ? n18.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r);
}
function CR(n18, e, t) {
  var i = e.pendingProps, r = i.revealOrder, s = i.tail;
  if (Ei(n18, e, i.children, t), i = rn.current, i & 2) i = i & 1 | 2, e.flags |= 128;
  else {
    if (n18 !== null && n18.flags & 128) e: for (n18 = e.child; n18 !== null; ) {
      if (n18.tag === 13) n18.memoizedState !== null && cE(n18, t, e);
      else if (n18.tag === 19) cE(n18, t, e);
      else if (n18.child !== null) {
        n18.child.return = n18, n18 = n18.child;
        continue;
      }
      if (n18 === e) break e;
      for (; n18.sibling === null; ) {
        if (n18.return === null || n18.return === e) break e;
        n18 = n18.return;
      }
      n18.sibling.return = n18.return, n18 = n18.sibling;
    }
    i &= 1;
  }
  if (qt(rn, i), !(e.mode & 1)) e.memoizedState = null;
  else switch (r) {
    case "forwards":
      for (t = e.child, r = null; t !== null; ) n18 = t.alternate, n18 !== null && Om(n18) === null && (r = t), t = t.sibling;
      t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), P_(e, false, r, t, s);
      break;
    case "backwards":
      for (t = null, r = e.child, e.child = null; r !== null; ) {
        if (n18 = r.alternate, n18 !== null && Om(n18) === null) {
          e.child = r;
          break;
        }
        n18 = r.sibling, r.sibling = t, t = r, r = n18;
      }
      P_(e, true, t, null, s);
      break;
    case "together":
      P_(e, false, null, null, void 0);
      break;
    default:
      e.memoizedState = null;
  }
  return e.child;
}
function rm(n18, e) {
  !(e.mode & 1) && n18 !== null && (n18.alternate = null, e.alternate = null, e.flags |= 2);
}
function io(n18, e, t) {
  if (n18 !== null && (e.dependencies = n18.dependencies), fl |= e.lanes, !(t & e.childLanes)) return null;
  if (n18 !== null && e.child !== n18.child) throw Error(Se(153));
  if (e.child !== null) {
    for (n18 = e.child, t = jo(n18, n18.pendingProps), e.child = t, t.return = e; n18.sibling !== null; ) n18 = n18.sibling, t = t.sibling = jo(n18, n18.pendingProps), t.return = e;
    t.sibling = null;
  }
  return e.child;
}
function TD(n18, e, t) {
  switch (e.tag) {
    case 3:
      TR(e), Yu();
      break;
    case 5:
      $C(e);
      break;
    case 1:
      Vi(e.type) && bm(e);
      break;
    case 4:
      uS(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context, r = e.memoizedProps.value;
      qt(Dm, i._currentValue), i._currentValue = r;
      break;
    case 13:
      if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (qt(rn, rn.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? AR(n18, e, t) : (qt(rn, rn.current & 1), n18 = io(n18, e, t), n18 !== null ? n18.sibling : null);
      qt(rn, rn.current & 1);
      break;
    case 19:
      if (i = (t & e.childLanes) !== 0, n18.flags & 128) {
        if (i) return CR(n18, e, t);
        e.flags |= 128;
      }
      if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), qt(rn, rn.current), i) break;
      return null;
    case 22:
    case 23:
      return e.lanes = 0, wR(n18, e, t);
  }
  return io(n18, e, t);
}
var RR, gy, PR, bR;
RR = function(n18, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n18.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
};
gy = function() {
};
PR = function(n18, e, t, i) {
  var r = n18.memoizedProps;
  if (r !== i) {
    n18 = e.stateNode, Wa(Ms.current);
    var s = null;
    switch (t) {
      case "input":
        r = kv(n18, r), i = kv(n18, i), s = [];
        break;
      case "select":
        r = cn({}, r, { value: void 0 }), i = cn({}, i, { value: void 0 }), s = [];
        break;
      case "textarea":
        r = Vv(n18, r), i = Vv(n18, i), s = [];
        break;
      default:
        typeof r.onClick != "function" && typeof i.onClick == "function" && (n18.onclick = Rm);
    }
    Gv(t, i);
    var o;
    t = null;
    for (f in r) if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null) if (f === "style") {
      var a = r[f];
      for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "");
    } else f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (Df.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
    for (f in i) {
      var u = i[f];
      if (a = r == null ? void 0 : r[f], i.hasOwnProperty(f) && u !== a && (u != null || a != null)) if (f === "style") if (a) {
        for (o in a) !a.hasOwnProperty(o) || u && u.hasOwnProperty(o) || (t || (t = {}), t[o] = "");
        for (o in u) u.hasOwnProperty(o) && a[o] !== u[o] && (t || (t = {}), t[o] = u[o]);
      } else t || (s || (s = []), s.push(f, t)), t = u;
      else f === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, a = a ? a.__html : void 0, u != null && a !== u && (s = s || []).push(f, u)) : f === "children" ? typeof u != "string" && typeof u != "number" || (s = s || []).push(f, "" + u) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (Df.hasOwnProperty(f) ? (u != null && f === "onScroll" && Zt("scroll", n18), s || a === u || (s = [])) : (s = s || []).push(f, u));
    }
    t && (s = s || []).push("style", t);
    var f = s;
    (e.updateQueue = f) && (e.flags |= 4);
  }
};
bR = function(n18, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Xc(n18, e) {
  if (!$t) switch (n18.tailMode) {
    case "hidden":
      e = n18.tail;
      for (var t = null; e !== null; ) e.alternate !== null && (t = e), e = e.sibling;
      t === null ? n18.tail = null : t.sibling = null;
      break;
    case "collapsed":
      t = n18.tail;
      for (var i = null; t !== null; ) t.alternate !== null && (i = t), t = t.sibling;
      i === null ? e || n18.tail === null ? n18.tail = null : n18.tail.sibling = null : i.sibling = null;
  }
}
function ai(n18) {
  var e = n18.alternate !== null && n18.alternate.child === n18.child, t = 0, i = 0;
  if (e) for (var r = n18.child; r !== null; ) t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n18, r = r.sibling;
  else for (r = n18.child; r !== null; ) t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n18, r = r.sibling;
  return n18.subtreeFlags |= i, n18.childLanes = t, e;
}
function AD(n18, e, t) {
  var i = e.pendingProps;
  switch (nS(e), e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return ai(e), null;
    case 1:
      return Vi(e.type) && Pm(), ai(e), null;
    case 3:
      return i = e.stateNode, ju(), Kt(Bi), Kt(_i), fS(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n18 === null || n18.child === null) && (Zd(e) ? e.flags |= 4 : n18 === null || n18.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, jr !== null && (Ey(jr), jr = null))), gy(n18, e), ai(e), null;
    case 5:
      cS(e);
      var r = Wa(Xf.current);
      if (t = e.type, n18 !== null && e.stateNode != null) PR(n18, e, t, i, r), n18.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(Se(166));
          return ai(e), null;
        }
        if (n18 = Wa(Ms.current), Zd(e)) {
          i = e.stateNode, t = e.type;
          var s = e.memoizedProps;
          switch (i[ms] = e, i[Gf] = s, n18 = (e.mode & 1) !== 0, t) {
            case "dialog":
              Zt("cancel", i), Zt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              Zt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < hf.length; r++) Zt(hf[r], i);
              break;
            case "source":
              Zt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              Zt("error", i), Zt("load", i);
              break;
            case "details":
              Zt("toggle", i);
              break;
            case "input":
              yw(i, s), Zt("invalid", i);
              break;
            case "select":
              i._wrapperState = { wasMultiple: !!s.multiple }, Zt("invalid", i);
              break;
            case "textarea":
              Sw(i, s), Zt("invalid", i);
          }
          Gv(t, s), r = null;
          for (var o in s) if (s.hasOwnProperty(o)) {
            var a = s[o];
            o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== true && jd(i.textContent, a, n18), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== true && jd(i.textContent, a, n18), r = ["children", "" + a]) : Df.hasOwnProperty(o) && a != null && o === "onScroll" && Zt("scroll", i);
          }
          switch (t) {
            case "input":
              Bd(i), xw(i, s, true);
              break;
            case "textarea":
              Bd(i), Mw(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Rm);
          }
          i = r, e.updateQueue = i, i !== null && (e.flags |= 4);
        } else {
          o = r.nodeType === 9 ? r : r.ownerDocument, n18 === "http://www.w3.org/1999/xhtml" && (n18 = rC(t)), n18 === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n18 = o.createElement("div"), n18.innerHTML = "<script><\/script>", n18 = n18.removeChild(n18.firstChild)) : typeof i.is == "string" ? n18 = o.createElement(t, { is: i.is }) : (n18 = o.createElement(t), t === "select" && (o = n18, i.multiple ? o.multiple = true : i.size && (o.size = i.size))) : n18 = o.createElementNS(n18, t), n18[ms] = e, n18[Gf] = i, RR(n18, e, false, false), e.stateNode = n18;
          e: {
            switch (o = Wv(t, i), t) {
              case "dialog":
                Zt("cancel", n18), Zt("close", n18), r = i;
                break;
              case "iframe":
              case "object":
              case "embed":
                Zt("load", n18), r = i;
                break;
              case "video":
              case "audio":
                for (r = 0; r < hf.length; r++) Zt(hf[r], n18);
                r = i;
                break;
              case "source":
                Zt("error", n18), r = i;
                break;
              case "img":
              case "image":
              case "link":
                Zt("error", n18), Zt("load", n18), r = i;
                break;
              case "details":
                Zt("toggle", n18), r = i;
                break;
              case "input":
                yw(n18, i), r = kv(n18, i), Zt("invalid", n18);
                break;
              case "option":
                r = i;
                break;
              case "select":
                n18._wrapperState = { wasMultiple: !!i.multiple }, r = cn({}, i, { value: void 0 }), Zt("invalid", n18);
                break;
              case "textarea":
                Sw(n18, i), r = Vv(n18, i), Zt("invalid", n18);
                break;
              default:
                r = i;
            }
            Gv(t, r), a = r;
            for (s in a) if (a.hasOwnProperty(s)) {
              var u = a[s];
              s === "style" ? aC(n18, u) : s === "dangerouslySetInnerHTML" ? (u = u ? u.__html : void 0, u != null && sC(n18, u)) : s === "children" ? typeof u == "string" ? (t !== "textarea" || u !== "") && Nf(n18, u) : typeof u == "number" && Nf(n18, "" + u) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Df.hasOwnProperty(s) ? u != null && s === "onScroll" && Zt("scroll", n18) : u != null && Vx(n18, s, u, o));
            }
            switch (t) {
              case "input":
                Bd(n18), xw(n18, i, false);
                break;
              case "textarea":
                Bd(n18), Mw(n18);
                break;
              case "option":
                i.value != null && n18.setAttribute("value", "" + ea(i.value));
                break;
              case "select":
                n18.multiple = !!i.multiple, s = i.value, s != null ? Du(n18, !!i.multiple, s, false) : i.defaultValue != null && Du(n18, !!i.multiple, i.defaultValue, true);
                break;
              default:
                typeof r.onClick == "function" && (n18.onclick = Rm);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = true;
                break e;
              default:
                i = false;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
      }
      return ai(e), null;
    case 6:
      if (n18 && e.stateNode != null) bR(n18, e, n18.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(Se(166));
        if (t = Wa(Xf.current), Wa(Ms.current), Zd(e)) {
          if (i = e.stateNode, t = e.memoizedProps, i[ms] = e, (s = i.nodeValue !== t) && (n18 = cr, n18 !== null)) switch (n18.tag) {
            case 3:
              jd(i.nodeValue, t, (n18.mode & 1) !== 0);
              break;
            case 5:
              n18.memoizedProps.suppressHydrationWarning !== true && jd(i.nodeValue, t, (n18.mode & 1) !== 0);
          }
          s && (e.flags |= 4);
        } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[ms] = e, e.stateNode = i;
      }
      return ai(e), null;
    case 13:
      if (Kt(rn), i = e.memoizedState, n18 === null || n18.memoizedState !== null && n18.memoizedState.dehydrated !== null) {
        if ($t && lr !== null && e.mode & 1 && !(e.flags & 128)) jC(), Yu(), e.flags |= 98560, s = false;
        else if (s = Zd(e), i !== null && i.dehydrated !== null) {
          if (n18 === null) {
            if (!s) throw Error(Se(318));
            if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Se(317));
            s[ms] = e;
          } else Yu(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
          ai(e), s = false;
        } else jr !== null && (Ey(jr), jr = null), s = true;
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n18 !== null && n18.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n18 === null || rn.current & 1 ? Un === 0 && (Un = 3) : wS())), e.updateQueue !== null && (e.flags |= 4), ai(e), null);
    case 4:
      return ju(), gy(n18, e), n18 === null && Vf(e.stateNode.containerInfo), ai(e), null;
    case 10:
      return oS(e.type._context), ai(e), null;
    case 17:
      return Vi(e.type) && Pm(), ai(e), null;
    case 19:
      if (Kt(rn), s = e.memoizedState, s === null) return ai(e), null;
      if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) Xc(s, false);
      else {
        if (Un !== 0 || n18 !== null && n18.flags & 128) for (n18 = e.child; n18 !== null; ) {
          if (o = Om(n18), o !== null) {
            for (e.flags |= 128, Xc(s, false), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null; ) s = t, n18 = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n18, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n18 = o.dependencies, s.dependencies = n18 === null ? null : { lanes: n18.lanes, firstContext: n18.firstContext }), t = t.sibling;
            return qt(rn, rn.current & 1 | 2), e.child;
          }
          n18 = n18.sibling;
        }
        s.tail !== null && wn() > Ju && (e.flags |= 128, i = true, Xc(s, false), e.lanes = 4194304);
      }
      else {
        if (!i) if (n18 = Om(o), n18 !== null) {
          if (e.flags |= 128, i = true, t = n18.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Xc(s, true), s.tail === null && s.tailMode === "hidden" && !o.alternate && !$t) return ai(e), null;
        } else 2 * wn() - s.renderingStartTime > Ju && t !== 1073741824 && (e.flags |= 128, i = true, Xc(s, false), e.lanes = 4194304);
        s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o);
      }
      return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = wn(), e.sibling = null, t = rn.current, qt(rn, i ? t & 1 | 2 : t & 1), e) : (ai(e), null);
    case 22:
    case 23:
      return MS(), i = e.memoizedState !== null, n18 !== null && n18.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? ir & 1073741824 && (ai(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : ai(e), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Se(156, e.tag));
}
function CD(n18, e) {
  switch (nS(e), e.tag) {
    case 1:
      return Vi(e.type) && Pm(), n18 = e.flags, n18 & 65536 ? (e.flags = n18 & -65537 | 128, e) : null;
    case 3:
      return ju(), Kt(Bi), Kt(_i), fS(), n18 = e.flags, n18 & 65536 && !(n18 & 128) ? (e.flags = n18 & -65537 | 128, e) : null;
    case 5:
      return cS(e), null;
    case 13:
      if (Kt(rn), n18 = e.memoizedState, n18 !== null && n18.dehydrated !== null) {
        if (e.alternate === null) throw Error(Se(340));
        Yu();
      }
      return n18 = e.flags, n18 & 65536 ? (e.flags = n18 & -65537 | 128, e) : null;
    case 19:
      return Kt(rn), null;
    case 4:
      return ju(), null;
    case 10:
      return oS(e.type._context), null;
    case 22:
    case 23:
      return MS(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Qd = false, fi = false, RD = typeof WeakSet == "function" ? WeakSet : Set, ke = null;
function wu(n18, e) {
  var t = n18.ref;
  if (t !== null) if (typeof t == "function") try {
    t(null);
  } catch (i) {
    pn(n18, e, i);
  }
  else t.current = null;
}
function _y(n18, e, t) {
  try {
    t();
  } catch (i) {
    pn(n18, e, i);
  }
}
var fE = false;
function PD(n18, e) {
  if (ey = Tm, n18 = UC(), eS(n18)) {
    if ("selectionStart" in n18) var t = { start: n18.selectionStart, end: n18.selectionEnd };
    else e: {
      t = (t = n18.ownerDocument) && t.defaultView || window;
      var i = t.getSelection && t.getSelection();
      if (i && i.rangeCount !== 0) {
        t = i.anchorNode;
        var r = i.anchorOffset, s = i.focusNode;
        i = i.focusOffset;
        try {
          t.nodeType, s.nodeType;
        } catch {
          t = null;
          break e;
        }
        var o = 0, a = -1, u = -1, f = 0, h = 0, d = n18, p = null;
        t: for (; ; ) {
          for (var g; d !== t || r !== 0 && d.nodeType !== 3 || (a = o + r), d !== s || i !== 0 && d.nodeType !== 3 || (u = o + i), d.nodeType === 3 && (o += d.nodeValue.length), (g = d.firstChild) !== null; ) p = d, d = g;
          for (; ; ) {
            if (d === n18) break t;
            if (p === t && ++f === r && (a = o), p === s && ++h === i && (u = o), (g = d.nextSibling) !== null) break;
            d = p, p = d.parentNode;
          }
          d = g;
        }
        t = a === -1 || u === -1 ? null : { start: a, end: u };
      } else t = null;
    }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (ty = { focusedElem: n18, selectionRange: t }, Tm = false, ke = e; ke !== null; ) if (e = ke, n18 = e.child, (e.subtreeFlags & 1028) !== 0 && n18 !== null) n18.return = e, ke = n18;
  else for (; ke !== null; ) {
    e = ke;
    try {
      var v = e.alternate;
      if (e.flags & 1024) switch (e.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (v !== null) {
            var M = v.memoizedProps, S = v.memoizedState, m = e.stateNode, E = m.getSnapshotBeforeUpdate(e.elementType === e.type ? M : Xr(e.type, M), S);
            m.__reactInternalSnapshotBeforeUpdate = E;
          }
          break;
        case 3:
          var T = e.stateNode.containerInfo;
          T.nodeType === 1 ? T.textContent = "" : T.nodeType === 9 && T.documentElement && T.removeChild(T.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(Se(163));
      }
    } catch (C) {
      pn(e, e.return, C);
    }
    if (n18 = e.sibling, n18 !== null) {
      n18.return = e.return, ke = n18;
      break;
    }
    ke = e.return;
  }
  return v = fE, fE = false, v;
}
function Mf(n18, e, t) {
  var i = e.updateQueue;
  if (i = i !== null ? i.lastEffect : null, i !== null) {
    var r = i = i.next;
    do {
      if ((r.tag & n18) === n18) {
        var s = r.destroy;
        r.destroy = void 0, s !== void 0 && _y(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function pg(n18, e) {
  if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
    var t = e = e.next;
    do {
      if ((t.tag & n18) === n18) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function vy(n18) {
  var e = n18.ref;
  if (e !== null) {
    var t = n18.stateNode;
    switch (n18.tag) {
      case 5:
        n18 = t;
        break;
      default:
        n18 = t;
    }
    typeof e == "function" ? e(n18) : e.current = n18;
  }
}
function LR(n18) {
  var e = n18.alternate;
  e !== null && (n18.alternate = null, LR(e)), n18.child = null, n18.deletions = null, n18.sibling = null, n18.tag === 5 && (e = n18.stateNode, e !== null && (delete e[ms], delete e[Gf], delete e[ry], delete e[fD], delete e[hD])), n18.stateNode = null, n18.return = null, n18.dependencies = null, n18.memoizedProps = null, n18.memoizedState = null, n18.pendingProps = null, n18.stateNode = null, n18.updateQueue = null;
}
function IR(n18) {
  return n18.tag === 5 || n18.tag === 3 || n18.tag === 4;
}
function hE(n18) {
  e: for (; ; ) {
    for (; n18.sibling === null; ) {
      if (n18.return === null || IR(n18.return)) return null;
      n18 = n18.return;
    }
    for (n18.sibling.return = n18.return, n18 = n18.sibling; n18.tag !== 5 && n18.tag !== 6 && n18.tag !== 18; ) {
      if (n18.flags & 2 || n18.child === null || n18.tag === 4) continue e;
      n18.child.return = n18, n18 = n18.child;
    }
    if (!(n18.flags & 2)) return n18.stateNode;
  }
}
function yy(n18, e, t) {
  var i = n18.tag;
  if (i === 5 || i === 6) n18 = n18.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n18, e) : t.insertBefore(n18, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n18, t)) : (e = t, e.appendChild(n18)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Rm));
  else if (i !== 4 && (n18 = n18.child, n18 !== null)) for (yy(n18, e, t), n18 = n18.sibling; n18 !== null; ) yy(n18, e, t), n18 = n18.sibling;
}
function xy(n18, e, t) {
  var i = n18.tag;
  if (i === 5 || i === 6) n18 = n18.stateNode, e ? t.insertBefore(n18, e) : t.appendChild(n18);
  else if (i !== 4 && (n18 = n18.child, n18 !== null)) for (xy(n18, e, t), n18 = n18.sibling; n18 !== null; ) xy(n18, e, t), n18 = n18.sibling;
}
var Qn = null, qr = false;
function So(n18, e, t) {
  for (t = t.child; t !== null; ) DR(n18, e, t), t = t.sibling;
}
function DR(n18, e, t) {
  if (Ss && typeof Ss.onCommitFiberUnmount == "function") try {
    Ss.onCommitFiberUnmount(og, t);
  } catch {
  }
  switch (t.tag) {
    case 5:
      fi || wu(t, e);
    case 6:
      var i = Qn, r = qr;
      Qn = null, So(n18, e, t), Qn = i, qr = r, Qn !== null && (qr ? (n18 = Qn, t = t.stateNode, n18.nodeType === 8 ? n18.parentNode.removeChild(t) : n18.removeChild(t)) : Qn.removeChild(t.stateNode));
      break;
    case 18:
      Qn !== null && (qr ? (n18 = Qn, t = t.stateNode, n18.nodeType === 8 ? M_(n18.parentNode, t) : n18.nodeType === 1 && M_(n18, t), kf(n18)) : M_(Qn, t.stateNode));
      break;
    case 4:
      i = Qn, r = qr, Qn = t.stateNode.containerInfo, qr = true, So(n18, e, t), Qn = i, qr = r;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!fi && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) {
        r = i = i.next;
        do {
          var s = r, o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && _y(t, e, o), r = r.next;
        } while (r !== i);
      }
      So(n18, e, t);
      break;
    case 1:
      if (!fi && (wu(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function")) try {
        i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount();
      } catch (a) {
        pn(t, e, a);
      }
      So(n18, e, t);
      break;
    case 21:
      So(n18, e, t);
      break;
    case 22:
      t.mode & 1 ? (fi = (i = fi) || t.memoizedState !== null, So(n18, e, t), fi = i) : So(n18, e, t);
      break;
    default:
      So(n18, e, t);
  }
}
function dE(n18) {
  var e = n18.updateQueue;
  if (e !== null) {
    n18.updateQueue = null;
    var t = n18.stateNode;
    t === null && (t = n18.stateNode = new RD()), e.forEach(function(i) {
      var r = kD.bind(null, n18, i);
      t.has(i) || (t.add(i), i.then(r, r));
    });
  }
}
function Vr(n18, e) {
  var t = e.deletions;
  if (t !== null) for (var i = 0; i < t.length; i++) {
    var r = t[i];
    try {
      var s = n18, o = e, a = o;
      e: for (; a !== null; ) {
        switch (a.tag) {
          case 5:
            Qn = a.stateNode, qr = false;
            break e;
          case 3:
            Qn = a.stateNode.containerInfo, qr = true;
            break e;
          case 4:
            Qn = a.stateNode.containerInfo, qr = true;
            break e;
        }
        a = a.return;
      }
      if (Qn === null) throw Error(Se(160));
      DR(s, o, r), Qn = null, qr = false;
      var u = r.alternate;
      u !== null && (u.return = null), r.return = null;
    } catch (f) {
      pn(r, e, f);
    }
  }
  if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) NR(e, n18), e = e.sibling;
}
function NR(n18, e) {
  var t = n18.alternate, i = n18.flags;
  switch (n18.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (Vr(e, n18), hs(n18), i & 4) {
        try {
          Mf(3, n18, n18.return), pg(3, n18);
        } catch (M) {
          pn(n18, n18.return, M);
        }
        try {
          Mf(5, n18, n18.return);
        } catch (M) {
          pn(n18, n18.return, M);
        }
      }
      break;
    case 1:
      Vr(e, n18), hs(n18), i & 512 && t !== null && wu(t, t.return);
      break;
    case 5:
      if (Vr(e, n18), hs(n18), i & 512 && t !== null && wu(t, t.return), n18.flags & 32) {
        var r = n18.stateNode;
        try {
          Nf(r, "");
        } catch (M) {
          pn(n18, n18.return, M);
        }
      }
      if (i & 4 && (r = n18.stateNode, r != null)) {
        var s = n18.memoizedProps, o = t !== null ? t.memoizedProps : s, a = n18.type, u = n18.updateQueue;
        if (n18.updateQueue = null, u !== null) try {
          a === "input" && s.type === "radio" && s.name != null && nC(r, s), Wv(a, o);
          var f = Wv(a, s);
          for (o = 0; o < u.length; o += 2) {
            var h = u[o], d = u[o + 1];
            h === "style" ? aC(r, d) : h === "dangerouslySetInnerHTML" ? sC(r, d) : h === "children" ? Nf(r, d) : Vx(r, h, d, f);
          }
          switch (a) {
            case "input":
              zv(r, s);
              break;
            case "textarea":
              iC(r, s);
              break;
            case "select":
              var p = r._wrapperState.wasMultiple;
              r._wrapperState.wasMultiple = !!s.multiple;
              var g = s.value;
              g != null ? Du(r, !!s.multiple, g, false) : p !== !!s.multiple && (s.defaultValue != null ? Du(r, !!s.multiple, s.defaultValue, true) : Du(r, !!s.multiple, s.multiple ? [] : "", false));
          }
          r[Gf] = s;
        } catch (M) {
          pn(n18, n18.return, M);
        }
      }
      break;
    case 6:
      if (Vr(e, n18), hs(n18), i & 4) {
        if (n18.stateNode === null) throw Error(Se(162));
        r = n18.stateNode, s = n18.memoizedProps;
        try {
          r.nodeValue = s;
        } catch (M) {
          pn(n18, n18.return, M);
        }
      }
      break;
    case 3:
      if (Vr(e, n18), hs(n18), i & 4 && t !== null && t.memoizedState.isDehydrated) try {
        kf(e.containerInfo);
      } catch (M) {
        pn(n18, n18.return, M);
      }
      break;
    case 4:
      Vr(e, n18), hs(n18);
      break;
    case 13:
      Vr(e, n18), hs(n18), r = n18.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (xS = wn())), i & 4 && dE(n18);
      break;
    case 22:
      if (h = t !== null && t.memoizedState !== null, n18.mode & 1 ? (fi = (f = fi) || h, Vr(e, n18), fi = f) : Vr(e, n18), hs(n18), i & 8192) {
        if (f = n18.memoizedState !== null, (n18.stateNode.isHidden = f) && !h && n18.mode & 1) for (ke = n18, h = n18.child; h !== null; ) {
          for (d = ke = h; ke !== null; ) {
            switch (p = ke, g = p.child, p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Mf(4, p, p.return);
                break;
              case 1:
                wu(p, p.return);
                var v = p.stateNode;
                if (typeof v.componentWillUnmount == "function") {
                  i = p, t = p.return;
                  try {
                    e = i, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount();
                  } catch (M) {
                    pn(i, t, M);
                  }
                }
                break;
              case 5:
                wu(p, p.return);
                break;
              case 22:
                if (p.memoizedState !== null) {
                  mE(d);
                  continue;
                }
            }
            g !== null ? (g.return = p, ke = g) : mE(d);
          }
          h = h.sibling;
        }
        e: for (h = null, d = n18; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                r = d.stateNode, f ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, u = d.memoizedProps.style, o = u != null && u.hasOwnProperty("display") ? u.display : null, a.style.display = oC("display", o));
              } catch (M) {
                pn(n18, n18.return, M);
              }
            }
          } else if (d.tag === 6) {
            if (h === null) try {
              d.stateNode.nodeValue = f ? "" : d.memoizedProps;
            } catch (M) {
              pn(n18, n18.return, M);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n18) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === n18) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n18) break e;
            h === d && (h = null), d = d.return;
          }
          h === d && (h = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      Vr(e, n18), hs(n18), i & 4 && dE(n18);
      break;
    case 21:
      break;
    default:
      Vr(e, n18), hs(n18);
  }
}
function hs(n18) {
  var e = n18.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n18.return; t !== null; ) {
          if (IR(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Se(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Nf(r, ""), i.flags &= -33);
          var s = hE(n18);
          xy(n18, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo, a = hE(n18);
          yy(n18, a, o);
          break;
        default:
          throw Error(Se(161));
      }
    } catch (u) {
      pn(n18, n18.return, u);
    }
    n18.flags &= -3;
  }
  e & 4096 && (n18.flags &= -4097);
}
function bD(n18, e, t) {
  ke = n18, UR(n18);
}
function UR(n18, e, t) {
  for (var i = (n18.mode & 1) !== 0; ke !== null; ) {
    var r = ke, s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || Qd;
      if (!o) {
        var a = r.alternate, u = a !== null && a.memoizedState !== null || fi;
        a = Qd;
        var f = fi;
        if (Qd = o, (fi = u) && !f) for (ke = r; ke !== null; ) o = ke, u = o.child, o.tag === 22 && o.memoizedState !== null ? gE(r) : u !== null ? (u.return = o, ke = u) : gE(r);
        for (; s !== null; ) ke = s, UR(s), s = s.sibling;
        ke = r, Qd = a, fi = f;
      }
      pE(n18);
    } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, ke = s) : pE(n18);
  }
}
function pE(n18) {
  for (; ke !== null; ) {
    var e = ke;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772) switch (e.tag) {
          case 0:
          case 11:
          case 15:
            fi || pg(5, e);
            break;
          case 1:
            var i = e.stateNode;
            if (e.flags & 4 && !fi) if (t === null) i.componentDidMount();
            else {
              var r = e.elementType === e.type ? t.memoizedProps : Xr(e.type, t.memoizedProps);
              i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate);
            }
            var s = e.updateQueue;
            s !== null && Qw(e, s, i);
            break;
          case 3:
            var o = e.updateQueue;
            if (o !== null) {
              if (t = null, e.child !== null) switch (e.child.tag) {
                case 5:
                  t = e.child.stateNode;
                  break;
                case 1:
                  t = e.child.stateNode;
              }
              Qw(e, o, t);
            }
            break;
          case 5:
            var a = e.stateNode;
            if (t === null && e.flags & 4) {
              t = a;
              var u = e.memoizedProps;
              switch (e.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  u.autoFocus && t.focus();
                  break;
                case "img":
                  u.src && (t.src = u.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (e.memoizedState === null) {
              var f = e.alternate;
              if (f !== null) {
                var h = f.memoizedState;
                if (h !== null) {
                  var d = h.dehydrated;
                  d !== null && kf(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(Se(163));
        }
        fi || e.flags & 512 && vy(e);
      } catch (p) {
        pn(e, e.return, p);
      }
    }
    if (e === n18) {
      ke = null;
      break;
    }
    if (t = e.sibling, t !== null) {
      t.return = e.return, ke = t;
      break;
    }
    ke = e.return;
  }
}
function mE(n18) {
  for (; ke !== null; ) {
    var e = ke;
    if (e === n18) {
      ke = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      t.return = e.return, ke = t;
      break;
    }
    ke = e.return;
  }
}
function gE(n18) {
  for (; ke !== null; ) {
    var e = ke;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            pg(4, e);
          } catch (u) {
            pn(e, t, u);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (u) {
              pn(e, r, u);
            }
          }
          var s = e.return;
          try {
            vy(e);
          } catch (u) {
            pn(e, s, u);
          }
          break;
        case 5:
          var o = e.return;
          try {
            vy(e);
          } catch (u) {
            pn(e, o, u);
          }
      }
    } catch (u) {
      pn(e, e.return, u);
    }
    if (e === n18) {
      ke = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      a.return = e.return, ke = a;
      break;
    }
    ke = e.return;
  }
}
var LD = Math.ceil, zm = uo.ReactCurrentDispatcher, vS = uo.ReactCurrentOwner, Or = uo.ReactCurrentBatchConfig, Pt = 0, Yn = null, bn = null, $n = 0, ir = 0, Eu = aa(0), Un = 0, Zf = null, fl = 0, mg = 0, yS = 0, wf = null, ki = null, xS = 0, Ju = 1 / 0, Gs = null, Bm = false, Sy = null, Yo = null, $d = false, Fo = null, Vm = 0, Ef = 0, My = null, sm = -1, om = 0;
function Ri() {
  return Pt & 6 ? wn() : sm !== -1 ? sm : sm = wn();
}
function qo(n18) {
  return n18.mode & 1 ? Pt & 2 && $n !== 0 ? $n & -$n : pD.transition !== null ? (om === 0 && (om = yC()), om) : (n18 = Vt, n18 !== 0 || (n18 = window.event, n18 = n18 === void 0 ? 16 : AC(n18.type)), n18) : 1;
}
function Kr(n18, e, t, i) {
  if (50 < Ef) throw Ef = 0, My = null, Error(Se(185));
  Ah(n18, t, i), (!(Pt & 2) || n18 !== Yn) && (n18 === Yn && (!(Pt & 2) && (mg |= t), Un === 4 && No(n18, $n)), Hi(n18, i), t === 1 && Pt === 0 && !(e.mode & 1) && (Ju = wn() + 500, fg && la()));
}
function Hi(n18, e) {
  var t = n18.callbackNode;
  pI(n18, e);
  var i = Em(n18, n18 === Yn ? $n : 0);
  if (i === 0) t !== null && Tw(t), n18.callbackNode = null, n18.callbackPriority = 0;
  else if (e = i & -i, n18.callbackPriority !== e) {
    if (t != null && Tw(t), e === 1) n18.tag === 0 ? dD(_E.bind(null, n18)) : XC(_E.bind(null, n18)), uD(function() {
      !(Pt & 6) && la();
    }), t = null;
    else {
      switch (xC(i)) {
        case 1:
          t = Yx;
          break;
        case 4:
          t = _C;
          break;
        case 16:
          t = wm;
          break;
        case 536870912:
          t = vC;
          break;
        default:
          t = wm;
      }
      t = GR(t, OR.bind(null, n18));
    }
    n18.callbackPriority = e, n18.callbackNode = t;
  }
}
function OR(n18, e) {
  if (sm = -1, om = 0, Pt & 6) throw Error(Se(327));
  var t = n18.callbackNode;
  if (ku() && n18.callbackNode !== t) return null;
  var i = Em(n18, n18 === Yn ? $n : 0);
  if (i === 0) return null;
  if (i & 30 || i & n18.expiredLanes || e) e = Hm(n18, i);
  else {
    e = i;
    var r = Pt;
    Pt |= 2;
    var s = kR();
    (Yn !== n18 || $n !== e) && (Gs = null, Ju = wn() + 500, Ja(n18, e));
    do
      try {
        ND();
        break;
      } catch (a) {
        FR(n18, a);
      }
    while (true);
    sS(), zm.current = s, Pt = r, bn !== null ? e = 0 : (Yn = null, $n = 0, e = Un);
  }
  if (e !== 0) {
    if (e === 2 && (r = Zv(n18), r !== 0 && (i = r, e = wy(n18, r))), e === 1) throw t = Zf, Ja(n18, 0), No(n18, i), Hi(n18, wn()), t;
    if (e === 6) No(n18, i);
    else {
      if (r = n18.current.alternate, !(i & 30) && !ID(r) && (e = Hm(n18, i), e === 2 && (s = Zv(n18), s !== 0 && (i = s, e = wy(n18, s))), e === 1)) throw t = Zf, Ja(n18, 0), No(n18, i), Hi(n18, wn()), t;
      switch (n18.finishedWork = r, n18.finishedLanes = i, e) {
        case 0:
        case 1:
          throw Error(Se(345));
        case 2:
          Oa(n18, ki, Gs);
          break;
        case 3:
          if (No(n18, i), (i & 130023424) === i && (e = xS + 500 - wn(), 10 < e)) {
            if (Em(n18, 0) !== 0) break;
            if (r = n18.suspendedLanes, (r & i) !== i) {
              Ri(), n18.pingedLanes |= n18.suspendedLanes & r;
              break;
            }
            n18.timeoutHandle = iy(Oa.bind(null, n18, ki, Gs), e);
            break;
          }
          Oa(n18, ki, Gs);
          break;
        case 4:
          if (No(n18, i), (i & 4194240) === i) break;
          for (e = n18.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - Jr(i);
            s = 1 << o, o = e[o], o > r && (r = o), i &= ~s;
          }
          if (i = r, i = wn() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * LD(i / 1960)) - i, 10 < i) {
            n18.timeoutHandle = iy(Oa.bind(null, n18, ki, Gs), i);
            break;
          }
          Oa(n18, ki, Gs);
          break;
        case 5:
          Oa(n18, ki, Gs);
          break;
        default:
          throw Error(Se(329));
      }
    }
  }
  return Hi(n18, wn()), n18.callbackNode === t ? OR.bind(null, n18) : null;
}
function wy(n18, e) {
  var t = wf;
  return n18.current.memoizedState.isDehydrated && (Ja(n18, e).flags |= 256), n18 = Hm(n18, e), n18 !== 2 && (e = ki, ki = t, e !== null && Ey(e)), n18;
}
function Ey(n18) {
  ki === null ? ki = n18 : ki.push.apply(ki, n18);
}
function ID(n18) {
  for (var e = n18; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && (t = t.stores, t !== null)) for (var i = 0; i < t.length; i++) {
        var r = t[i], s = r.getSnapshot;
        r = r.value;
        try {
          if (!Qr(s(), r)) return false;
        } catch {
          return false;
        }
      }
    }
    if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t;
    else {
      if (e === n18) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n18) return true;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
  }
  return true;
}
function No(n18, e) {
  for (e &= ~yS, e &= ~mg, n18.suspendedLanes |= e, n18.pingedLanes &= ~e, n18 = n18.expirationTimes; 0 < e; ) {
    var t = 31 - Jr(e), i = 1 << t;
    n18[t] = -1, e &= ~i;
  }
}
function _E(n18) {
  if (Pt & 6) throw Error(Se(327));
  ku();
  var e = Em(n18, 0);
  if (!(e & 1)) return Hi(n18, wn()), null;
  var t = Hm(n18, e);
  if (n18.tag !== 0 && t === 2) {
    var i = Zv(n18);
    i !== 0 && (e = i, t = wy(n18, i));
  }
  if (t === 1) throw t = Zf, Ja(n18, 0), No(n18, e), Hi(n18, wn()), t;
  if (t === 6) throw Error(Se(345));
  return n18.finishedWork = n18.current.alternate, n18.finishedLanes = e, Oa(n18, ki, Gs), Hi(n18, wn()), null;
}
function SS(n18, e) {
  var t = Pt;
  Pt |= 1;
  try {
    return n18(e);
  } finally {
    Pt = t, Pt === 0 && (Ju = wn() + 500, fg && la());
  }
}
function hl(n18) {
  Fo !== null && Fo.tag === 0 && !(Pt & 6) && ku();
  var e = Pt;
  Pt |= 1;
  var t = Or.transition, i = Vt;
  try {
    if (Or.transition = null, Vt = 1, n18) return n18();
  } finally {
    Vt = i, Or.transition = t, Pt = e, !(Pt & 6) && la();
  }
}
function MS() {
  ir = Eu.current, Kt(Eu);
}
function Ja(n18, e) {
  n18.finishedWork = null, n18.finishedLanes = 0;
  var t = n18.timeoutHandle;
  if (t !== -1 && (n18.timeoutHandle = -1, lD(t)), bn !== null) for (t = bn.return; t !== null; ) {
    var i = t;
    switch (nS(i), i.tag) {
      case 1:
        i = i.type.childContextTypes, i != null && Pm();
        break;
      case 3:
        ju(), Kt(Bi), Kt(_i), fS();
        break;
      case 5:
        cS(i);
        break;
      case 4:
        ju();
        break;
      case 13:
        Kt(rn);
        break;
      case 19:
        Kt(rn);
        break;
      case 10:
        oS(i.type._context);
        break;
      case 22:
      case 23:
        MS();
    }
    t = t.return;
  }
  if (Yn = n18, bn = n18 = jo(n18.current, null), $n = ir = e, Un = 0, Zf = null, yS = mg = fl = 0, ki = wf = null, Ga !== null) {
    for (e = 0; e < Ga.length; e++) if (t = Ga[e], i = t.interleaved, i !== null) {
      t.interleaved = null;
      var r = i.next, s = t.pending;
      if (s !== null) {
        var o = s.next;
        s.next = r, i.next = o;
      }
      t.pending = i;
    }
    Ga = null;
  }
  return n18;
}
function FR(n18, e) {
  do {
    var t = bn;
    try {
      if (sS(), nm.current = km, Fm) {
        for (var i = un.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), i = i.next;
        }
        Fm = false;
      }
      if (cl = 0, Wn = Dn = un = null, Sf = false, Yf = 0, vS.current = null, t === null || t.return === null) {
        Un = 1, Zf = e, bn = null;
        break;
      }
      e: {
        var s = n18, o = t.return, a = t, u = e;
        if (e = $n, a.flags |= 32768, u !== null && typeof u == "object" && typeof u.then == "function") {
          var f = u, h = a, d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p ? (h.updateQueue = p.updateQueue, h.memoizedState = p.memoizedState, h.lanes = p.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var g = rE(o);
          if (g !== null) {
            g.flags &= -257, sE(g, o, a, s, e), g.mode & 1 && iE(s, f, e), e = g, u = f;
            var v = e.updateQueue;
            if (v === null) {
              var M = /* @__PURE__ */ new Set();
              M.add(u), e.updateQueue = M;
            } else v.add(u);
            break e;
          } else {
            if (!(e & 1)) {
              iE(s, f, e), wS();
              break e;
            }
            u = Error(Se(426));
          }
        } else if ($t && a.mode & 1) {
          var S = rE(o);
          if (S !== null) {
            !(S.flags & 65536) && (S.flags |= 256), sE(S, o, a, s, e), iS(Zu(u, a));
            break e;
          }
        }
        s = u = Zu(u, a), Un !== 4 && (Un = 2), wf === null ? wf = [s] : wf.push(s), s = o;
        do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, e &= -e, s.lanes |= e;
              var m = xR(s, u, e);
              Kw(s, m);
              break e;
            case 1:
              a = u;
              var E = s.type, T = s.stateNode;
              if (!(s.flags & 128) && (typeof E.getDerivedStateFromError == "function" || T !== null && typeof T.componentDidCatch == "function" && (Yo === null || !Yo.has(T)))) {
                s.flags |= 65536, e &= -e, s.lanes |= e;
                var C = SR(s, a, e);
                Kw(s, C);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      BR(t);
    } catch (L) {
      e = L, bn === t && t !== null && (bn = t = t.return);
      continue;
    }
    break;
  } while (true);
}
function kR() {
  var n18 = zm.current;
  return zm.current = km, n18 === null ? km : n18;
}
function wS() {
  (Un === 0 || Un === 3 || Un === 2) && (Un = 4), Yn === null || !(fl & 268435455) && !(mg & 268435455) || No(Yn, $n);
}
function Hm(n18, e) {
  var t = Pt;
  Pt |= 2;
  var i = kR();
  (Yn !== n18 || $n !== e) && (Gs = null, Ja(n18, e));
  do
    try {
      DD();
      break;
    } catch (r) {
      FR(n18, r);
    }
  while (true);
  if (sS(), Pt = t, zm.current = i, bn !== null) throw Error(Se(261));
  return Yn = null, $n = 0, Un;
}
function DD() {
  for (; bn !== null; ) zR(bn);
}
function ND() {
  for (; bn !== null && !sI(); ) zR(bn);
}
function zR(n18) {
  var e = HR(n18.alternate, n18, ir);
  n18.memoizedProps = n18.pendingProps, e === null ? BR(n18) : bn = e, vS.current = null;
}
function BR(n18) {
  var e = n18;
  do {
    var t = e.alternate;
    if (n18 = e.return, e.flags & 32768) {
      if (t = CD(t, e), t !== null) {
        t.flags &= 32767, bn = t;
        return;
      }
      if (n18 !== null) n18.flags |= 32768, n18.subtreeFlags = 0, n18.deletions = null;
      else {
        Un = 6, bn = null;
        return;
      }
    } else if (t = AD(t, e, ir), t !== null) {
      bn = t;
      return;
    }
    if (e = e.sibling, e !== null) {
      bn = e;
      return;
    }
    bn = e = n18;
  } while (e !== null);
  Un === 0 && (Un = 5);
}
function Oa(n18, e, t) {
  var i = Vt, r = Or.transition;
  try {
    Or.transition = null, Vt = 1, UD(n18, e, t, i);
  } finally {
    Or.transition = r, Vt = i;
  }
  return null;
}
function UD(n18, e, t, i) {
  do
    ku();
  while (Fo !== null);
  if (Pt & 6) throw Error(Se(327));
  t = n18.finishedWork;
  var r = n18.finishedLanes;
  if (t === null) return null;
  if (n18.finishedWork = null, n18.finishedLanes = 0, t === n18.current) throw Error(Se(177));
  n18.callbackNode = null, n18.callbackPriority = 0;
  var s = t.lanes | t.childLanes;
  if (mI(n18, s), n18 === Yn && (bn = Yn = null, $n = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || $d || ($d = true, GR(wm, function() {
    return ku(), null;
  })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) {
    s = Or.transition, Or.transition = null;
    var o = Vt;
    Vt = 1;
    var a = Pt;
    Pt |= 4, vS.current = null, PD(n18, t), NR(t, n18), tD(ty), Tm = !!ey, ty = ey = null, n18.current = t, bD(t), oI(), Pt = a, Vt = o, Or.transition = s;
  } else n18.current = t;
  if ($d && ($d = false, Fo = n18, Vm = r), s = n18.pendingLanes, s === 0 && (Yo = null), uI(t.stateNode), Hi(n18, wn()), e !== null) for (i = n18.onRecoverableError, t = 0; t < e.length; t++) r = e[t], i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Bm) throw Bm = false, n18 = Sy, Sy = null, n18;
  return Vm & 1 && n18.tag !== 0 && ku(), s = n18.pendingLanes, s & 1 ? n18 === My ? Ef++ : (Ef = 0, My = n18) : Ef = 0, la(), null;
}
function ku() {
  if (Fo !== null) {
    var n18 = xC(Vm), e = Or.transition, t = Vt;
    try {
      if (Or.transition = null, Vt = 16 > n18 ? 16 : n18, Fo === null) var i = false;
      else {
        if (n18 = Fo, Fo = null, Vm = 0, Pt & 6) throw Error(Se(331));
        var r = Pt;
        for (Pt |= 4, ke = n18.current; ke !== null; ) {
          var s = ke, o = s.child;
          if (ke.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var u = 0; u < a.length; u++) {
                var f = a[u];
                for (ke = f; ke !== null; ) {
                  var h = ke;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Mf(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) d.return = h, ke = d;
                  else for (; ke !== null; ) {
                    h = ke;
                    var p = h.sibling, g = h.return;
                    if (LR(h), h === f) {
                      ke = null;
                      break;
                    }
                    if (p !== null) {
                      p.return = g, ke = p;
                      break;
                    }
                    ke = g;
                  }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var M = v.child;
                if (M !== null) {
                  v.child = null;
                  do {
                    var S = M.sibling;
                    M.sibling = null, M = S;
                  } while (M !== null);
                }
              }
              ke = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) o.return = s, ke = o;
          else e: for (; ke !== null; ) {
            if (s = ke, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                Mf(9, s, s.return);
            }
            var m = s.sibling;
            if (m !== null) {
              m.return = s.return, ke = m;
              break e;
            }
            ke = s.return;
          }
        }
        var E = n18.current;
        for (ke = E; ke !== null; ) {
          o = ke;
          var T = o.child;
          if (o.subtreeFlags & 2064 && T !== null) T.return = o, ke = T;
          else e: for (o = E; ke !== null; ) {
            if (a = ke, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  pg(9, a);
              }
            } catch (L) {
              pn(a, a.return, L);
            }
            if (a === o) {
              ke = null;
              break e;
            }
            var C = a.sibling;
            if (C !== null) {
              C.return = a.return, ke = C;
              break e;
            }
            ke = a.return;
          }
        }
        if (Pt = r, la(), Ss && typeof Ss.onPostCommitFiberRoot == "function") try {
          Ss.onPostCommitFiberRoot(og, n18);
        } catch {
        }
        i = true;
      }
      return i;
    } finally {
      Vt = t, Or.transition = e;
    }
  }
  return false;
}
function vE(n18, e, t) {
  e = Zu(t, e), e = xR(n18, e, 1), n18 = Xo(n18, e, 1), e = Ri(), n18 !== null && (Ah(n18, 1, e), Hi(n18, e));
}
function pn(n18, e, t) {
  if (n18.tag === 3) vE(n18, n18, t);
  else for (; e !== null; ) {
    if (e.tag === 3) {
      vE(e, n18, t);
      break;
    } else if (e.tag === 1) {
      var i = e.stateNode;
      if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Yo === null || !Yo.has(i))) {
        n18 = Zu(t, n18), n18 = SR(e, n18, 1), e = Xo(e, n18, 1), n18 = Ri(), e !== null && (Ah(e, 1, n18), Hi(e, n18));
        break;
      }
    }
    e = e.return;
  }
}
function OD(n18, e, t) {
  var i = n18.pingCache;
  i !== null && i.delete(e), e = Ri(), n18.pingedLanes |= n18.suspendedLanes & t, Yn === n18 && ($n & t) === t && (Un === 4 || Un === 3 && ($n & 130023424) === $n && 500 > wn() - xS ? Ja(n18, 0) : yS |= t), Hi(n18, e);
}
function VR(n18, e) {
  e === 0 && (n18.mode & 1 ? (e = Gd, Gd <<= 1, !(Gd & 130023424) && (Gd = 4194304)) : e = 1);
  var t = Ri();
  n18 = no(n18, e), n18 !== null && (Ah(n18, e, t), Hi(n18, t));
}
function FD(n18) {
  var e = n18.memoizedState, t = 0;
  e !== null && (t = e.retryLane), VR(n18, t);
}
function kD(n18, e) {
  var t = 0;
  switch (n18.tag) {
    case 13:
      var i = n18.stateNode, r = n18.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n18.stateNode;
      break;
    default:
      throw Error(Se(314));
  }
  i !== null && i.delete(e), VR(n18, t);
}
var HR;
HR = function(n18, e, t) {
  if (n18 !== null) if (n18.memoizedProps !== e.pendingProps || Bi.current) zi = true;
  else {
    if (!(n18.lanes & t) && !(e.flags & 128)) return zi = false, TD(n18, e, t);
    zi = !!(n18.flags & 131072);
  }
  else zi = false, $t && e.flags & 1048576 && YC(e, Im, e.index);
  switch (e.lanes = 0, e.tag) {
    case 2:
      var i = e.type;
      rm(n18, e), n18 = e.pendingProps;
      var r = Xu(e, _i.current);
      Fu(e, t), r = dS(null, e, i, n18, r, t);
      var s = pS();
      return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Vi(i) ? (s = true, bm(e)) : s = false, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, lS(e), r.updater = dg, e.stateNode = r, r._reactInternals = e, cy(e, i, n18, t), e = dy(null, e, i, true, s, t)) : (e.tag = 0, $t && s && tS(e), Ei(null, e, r, t), e = e.child), e;
    case 16:
      i = e.elementType;
      e: {
        switch (rm(n18, e), n18 = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = BD(i), n18 = Xr(i, n18), r) {
          case 0:
            e = hy(null, e, i, n18, t);
            break e;
          case 1:
            e = lE(null, e, i, n18, t);
            break e;
          case 11:
            e = oE(null, e, i, n18, t);
            break e;
          case 14:
            e = aE(null, e, i, Xr(i.type, n18), t);
            break e;
        }
        throw Error(Se(306, i, ""));
      }
      return e;
    case 0:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Xr(i, r), hy(n18, e, i, r, t);
    case 1:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Xr(i, r), lE(n18, e, i, r, t);
    case 3:
      e: {
        if (TR(e), n18 === null) throw Error(Se(387));
        i = e.pendingProps, s = e.memoizedState, r = s.element, QC(n18, e), Um(e, i, null, t);
        var o = e.memoizedState;
        if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: false, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
          r = Zu(Error(Se(423)), e), e = uE(n18, e, i, t, r);
          break e;
        } else if (i !== r) {
          r = Zu(Error(Se(424)), e), e = uE(n18, e, i, t, r);
          break e;
        } else for (lr = Wo(e.stateNode.containerInfo.firstChild), cr = e, $t = true, jr = null, t = JC(e, null, i, t), e.child = t; t; ) t.flags = t.flags & -3 | 4096, t = t.sibling;
        else {
          if (Yu(), i === r) {
            e = io(n18, e, t);
            break e;
          }
          Ei(n18, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return $C(e), n18 === null && ay(e), i = e.type, r = e.pendingProps, s = n18 !== null ? n18.memoizedProps : null, o = r.children, ny(i, r) ? o = null : s !== null && ny(i, s) && (e.flags |= 32), ER(n18, e), Ei(n18, e, o, t), e.child;
    case 6:
      return n18 === null && ay(e), null;
    case 13:
      return AR(n18, e, t);
    case 4:
      return uS(e, e.stateNode.containerInfo), i = e.pendingProps, n18 === null ? e.child = qu(e, null, i, t) : Ei(n18, e, i, t), e.child;
    case 11:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Xr(i, r), oE(n18, e, i, r, t);
    case 7:
      return Ei(n18, e, e.pendingProps, t), e.child;
    case 8:
      return Ei(n18, e, e.pendingProps.children, t), e.child;
    case 12:
      return Ei(n18, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, qt(Dm, i._currentValue), i._currentValue = o, s !== null) if (Qr(s.value, o)) {
          if (s.children === r.children && !Bi.current) {
            e = io(n18, e, t);
            break e;
          }
        } else for (s = e.child, s !== null && (s.return = e); s !== null; ) {
          var a = s.dependencies;
          if (a !== null) {
            o = s.child;
            for (var u = a.firstContext; u !== null; ) {
              if (u.context === i) {
                if (s.tag === 1) {
                  u = Qs(-1, t & -t), u.tag = 2;
                  var f = s.updateQueue;
                  if (f !== null) {
                    f = f.shared;
                    var h = f.pending;
                    h === null ? u.next = u : (u.next = h.next, h.next = u), f.pending = u;
                  }
                }
                s.lanes |= t, u = s.alternate, u !== null && (u.lanes |= t), ly(s.return, t, e), a.lanes |= t;
                break;
              }
              u = u.next;
            }
          } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
          else if (s.tag === 18) {
            if (o = s.return, o === null) throw Error(Se(341));
            o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), ly(o, t, e), o = s.sibling;
          } else o = s.child;
          if (o !== null) o.return = s;
          else for (o = s; o !== null; ) {
            if (o === e) {
              o = null;
              break;
            }
            if (s = o.sibling, s !== null) {
              s.return = o.return, o = s;
              break;
            }
            o = o.return;
          }
          s = o;
        }
        Ei(n18, e, r.children, t), e = e.child;
      }
      return e;
    case 9:
      return r = e.type, i = e.pendingProps.children, Fu(e, t), r = Fr(r), i = i(r), e.flags |= 1, Ei(n18, e, i, t), e.child;
    case 14:
      return i = e.type, r = Xr(i, e.pendingProps), r = Xr(i.type, r), aE(n18, e, i, r, t);
    case 15:
      return MR(n18, e, e.type, e.pendingProps, t);
    case 17:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : Xr(i, r), rm(n18, e), e.tag = 1, Vi(i) ? (n18 = true, bm(e)) : n18 = false, Fu(e, t), yR(e, i, r), cy(e, i, r, t), dy(null, e, i, true, n18, t);
    case 19:
      return CR(n18, e, t);
    case 22:
      return wR(n18, e, t);
  }
  throw Error(Se(156, e.tag));
};
function GR(n18, e) {
  return gC(n18, e);
}
function zD(n18, e, t, i) {
  this.tag = n18, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function Nr(n18, e, t, i) {
  return new zD(n18, e, t, i);
}
function ES(n18) {
  return n18 = n18.prototype, !(!n18 || !n18.isReactComponent);
}
function BD(n18) {
  if (typeof n18 == "function") return ES(n18) ? 1 : 0;
  if (n18 != null) {
    if (n18 = n18.$$typeof, n18 === Gx) return 11;
    if (n18 === Wx) return 14;
  }
  return 2;
}
function jo(n18, e) {
  var t = n18.alternate;
  return t === null ? (t = Nr(n18.tag, e, n18.key, n18.mode), t.elementType = n18.elementType, t.type = n18.type, t.stateNode = n18.stateNode, t.alternate = n18, n18.alternate = t) : (t.pendingProps = e, t.type = n18.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n18.flags & 14680064, t.childLanes = n18.childLanes, t.lanes = n18.lanes, t.child = n18.child, t.memoizedProps = n18.memoizedProps, t.memoizedState = n18.memoizedState, t.updateQueue = n18.updateQueue, e = n18.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n18.sibling, t.index = n18.index, t.ref = n18.ref, t;
}
function am(n18, e, t, i, r, s) {
  var o = 2;
  if (i = n18, typeof n18 == "function") ES(n18) && (o = 1);
  else if (typeof n18 == "string") o = 5;
  else e: switch (n18) {
    case pu:
      return Ka(t.children, r, s, e);
    case Hx:
      o = 8, r |= 8;
      break;
    case Nv:
      return n18 = Nr(12, t, e, r | 2), n18.elementType = Nv, n18.lanes = s, n18;
    case Uv:
      return n18 = Nr(13, t, e, r), n18.elementType = Uv, n18.lanes = s, n18;
    case Ov:
      return n18 = Nr(19, t, e, r), n18.elementType = Ov, n18.lanes = s, n18;
    case $A:
      return gg(t, r, s, e);
    default:
      if (typeof n18 == "object" && n18 !== null) switch (n18.$$typeof) {
        case KA:
          o = 10;
          break e;
        case QA:
          o = 9;
          break e;
        case Gx:
          o = 11;
          break e;
        case Wx:
          o = 14;
          break e;
        case bo:
          o = 16, i = null;
          break e;
      }
      throw Error(Se(130, n18 == null ? n18 : typeof n18, ""));
  }
  return e = Nr(o, t, e, r), e.elementType = n18, e.type = i, e.lanes = s, e;
}
function Ka(n18, e, t, i) {
  return n18 = Nr(7, n18, i, e), n18.lanes = t, n18;
}
function gg(n18, e, t, i) {
  return n18 = Nr(22, n18, i, e), n18.elementType = $A, n18.lanes = t, n18.stateNode = { isHidden: false }, n18;
}
function b_(n18, e, t) {
  return n18 = Nr(6, n18, null, e), n18.lanes = t, n18;
}
function L_(n18, e, t) {
  return e = Nr(4, n18.children !== null ? n18.children : [], n18.key, e), e.lanes = t, e.stateNode = { containerInfo: n18.containerInfo, pendingChildren: null, implementation: n18.implementation }, e;
}
function VD(n18, e, t, i, r) {
  this.tag = e, this.containerInfo = n18, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = f_(0), this.expirationTimes = f_(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = f_(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null;
}
function TS(n18, e, t, i, r, s, o, a, u) {
  return n18 = new VD(n18, e, t, a, u), e === 1 ? (e = 1, s === true && (e |= 8)) : e = 0, s = Nr(3, null, null, e), n18.current = s, s.stateNode = n18, s.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, lS(s), n18;
}
function HD(n18, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: du, key: i == null ? null : "" + i, children: n18, containerInfo: e, implementation: t };
}
function WR(n18) {
  if (!n18) return ta;
  n18 = n18._reactInternals;
  e: {
    if (vl(n18) !== n18 || n18.tag !== 1) throw Error(Se(170));
    var e = n18;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Vi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Se(171));
  }
  if (n18.tag === 1) {
    var t = n18.type;
    if (Vi(t)) return WC(n18, t, e);
  }
  return e;
}
function XR(n18, e, t, i, r, s, o, a, u) {
  return n18 = TS(t, i, true, n18, r, s, o, a, u), n18.context = WR(null), t = n18.current, i = Ri(), r = qo(t), s = Qs(i, r), s.callback = e ?? null, Xo(t, s, r), n18.current.lanes = r, Ah(n18, r, i), Hi(n18, i), n18;
}
function _g(n18, e, t, i) {
  var r = e.current, s = Ri(), o = qo(r);
  return t = WR(t), e.context === null ? e.context = t : e.pendingContext = t, e = Qs(s, o), e.payload = { element: n18 }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n18 = Xo(r, e, o), n18 !== null && (Kr(n18, r, o, s), tm(n18, r, o)), o;
}
function Gm(n18) {
  if (n18 = n18.current, !n18.child) return null;
  switch (n18.child.tag) {
    case 5:
      return n18.child.stateNode;
    default:
      return n18.child.stateNode;
  }
}
function yE(n18, e) {
  if (n18 = n18.memoizedState, n18 !== null && n18.dehydrated !== null) {
    var t = n18.retryLane;
    n18.retryLane = t !== 0 && t < e ? t : e;
  }
}
function AS(n18, e) {
  yE(n18, e), (n18 = n18.alternate) && yE(n18, e);
}
function GD() {
  return null;
}
var YR = typeof reportError == "function" ? reportError : function(n18) {
  console.error(n18);
};
function CS(n18) {
  this._internalRoot = n18;
}
vg.prototype.render = CS.prototype.render = function(n18) {
  var e = this._internalRoot;
  if (e === null) throw Error(Se(409));
  _g(n18, e, null, null);
};
vg.prototype.unmount = CS.prototype.unmount = function() {
  var n18 = this._internalRoot;
  if (n18 !== null) {
    this._internalRoot = null;
    var e = n18.containerInfo;
    hl(function() {
      _g(null, n18, null, null);
    }), e[to] = null;
  }
};
function vg(n18) {
  this._internalRoot = n18;
}
vg.prototype.unstable_scheduleHydration = function(n18) {
  if (n18) {
    var e = wC();
    n18 = { blockedOn: null, target: n18, priority: e };
    for (var t = 0; t < Do.length && e !== 0 && e < Do[t].priority; t++) ;
    Do.splice(t, 0, n18), t === 0 && TC(n18);
  }
};
function RS(n18) {
  return !(!n18 || n18.nodeType !== 1 && n18.nodeType !== 9 && n18.nodeType !== 11);
}
function yg(n18) {
  return !(!n18 || n18.nodeType !== 1 && n18.nodeType !== 9 && n18.nodeType !== 11 && (n18.nodeType !== 8 || n18.nodeValue !== " react-mount-point-unstable "));
}
function xE() {
}
function WD(n18, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function() {
        var f = Gm(o);
        s.call(f);
      };
    }
    var o = XR(e, i, n18, 0, null, false, false, "", xE);
    return n18._reactRootContainer = o, n18[to] = o.current, Vf(n18.nodeType === 8 ? n18.parentNode : n18), hl(), o;
  }
  for (; r = n18.lastChild; ) n18.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function() {
      var f = Gm(u);
      a.call(f);
    };
  }
  var u = TS(n18, 0, false, null, null, false, false, "", xE);
  return n18._reactRootContainer = u, n18[to] = u.current, Vf(n18.nodeType === 8 ? n18.parentNode : n18), hl(function() {
    _g(e, u, t, i);
  }), u;
}
function xg(n18, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var u = Gm(o);
        a.call(u);
      };
    }
    _g(e, o, n18, r);
  } else o = WD(t, e, n18, r, i);
  return Gm(o);
}
SC = function(n18) {
  switch (n18.tag) {
    case 3:
      var e = n18.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = ff(e.pendingLanes);
        t !== 0 && (qx(e, t | 1), Hi(e, wn()), !(Pt & 6) && (Ju = wn() + 500, la()));
      }
      break;
    case 13:
      hl(function() {
        var i = no(n18, 1);
        if (i !== null) {
          var r = Ri();
          Kr(i, n18, 1, r);
        }
      }), AS(n18, 1);
  }
};
jx = function(n18) {
  if (n18.tag === 13) {
    var e = no(n18, 134217728);
    if (e !== null) {
      var t = Ri();
      Kr(e, n18, 134217728, t);
    }
    AS(n18, 134217728);
  }
};
MC = function(n18) {
  if (n18.tag === 13) {
    var e = qo(n18), t = no(n18, e);
    if (t !== null) {
      var i = Ri();
      Kr(t, n18, e, i);
    }
    AS(n18, e);
  }
};
wC = function() {
  return Vt;
};
EC = function(n18, e) {
  var t = Vt;
  try {
    return Vt = n18, e();
  } finally {
    Vt = t;
  }
};
Yv = function(n18, e, t) {
  switch (e) {
    case "input":
      if (zv(n18, t), e = t.name, t.type === "radio" && e != null) {
        for (t = n18; t.parentNode; ) t = t.parentNode;
        for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) {
          var i = t[e];
          if (i !== n18 && i.form === n18.form) {
            var r = cg(i);
            if (!r) throw Error(Se(90));
            tC(i), zv(i, r);
          }
        }
      }
      break;
    case "textarea":
      iC(n18, t);
      break;
    case "select":
      e = t.value, e != null && Du(n18, !!t.multiple, e, false);
  }
};
cC = SS;
fC = hl;
var XD = { usingClientEntryPoint: false, Events: [Rh, vu, cg, lC, uC, SS] }, Yc = { findFiberByHostInstance: Ha, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, YD = { bundleType: Yc.bundleType, version: Yc.version, rendererPackageName: Yc.rendererPackageName, rendererConfig: Yc.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: uo.ReactCurrentDispatcher, findHostInstanceByFiber: function(n18) {
  return n18 = pC(n18), n18 === null ? null : n18.stateNode;
}, findFiberByHostInstance: Yc.findFiberByHostInstance || GD, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var ep = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!ep.isDisabled && ep.supportsFiber) try {
    og = ep.inject(YD), Ss = ep;
  } catch {
  }
}
gr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = XD;
gr.createPortal = function(n18, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!RS(e)) throw Error(Se(200));
  return HD(n18, e, null, t);
};
gr.createRoot = function(n18, e) {
  if (!RS(n18)) throw Error(Se(299));
  var t = false, i = "", r = YR;
  return e != null && (e.unstable_strictMode === true && (t = true), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = TS(n18, 1, false, null, null, t, false, i, r), n18[to] = e.current, Vf(n18.nodeType === 8 ? n18.parentNode : n18), new CS(e);
};
gr.findDOMNode = function(n18) {
  if (n18 == null) return null;
  if (n18.nodeType === 1) return n18;
  var e = n18._reactInternals;
  if (e === void 0) throw typeof n18.render == "function" ? Error(Se(188)) : (n18 = Object.keys(n18).join(","), Error(Se(268, n18)));
  return n18 = pC(e), n18 = n18 === null ? null : n18.stateNode, n18;
};
gr.flushSync = function(n18) {
  return hl(n18);
};
gr.hydrate = function(n18, e, t) {
  if (!yg(e)) throw Error(Se(200));
  return xg(null, n18, e, true, t);
};
gr.hydrateRoot = function(n18, e, t) {
  if (!RS(n18)) throw Error(Se(405));
  var i = t != null && t.hydratedSources || null, r = false, s = "", o = YR;
  if (t != null && (t.unstable_strictMode === true && (r = true), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = XR(e, null, n18, 1, t ?? null, r, false, s, o), n18[to] = e.current, Vf(n18), i) for (n18 = 0; n18 < i.length; n18++) t = i[n18], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
  return new vg(e);
};
gr.render = function(n18, e, t) {
  if (!yg(e)) throw Error(Se(200));
  return xg(null, n18, e, false, t);
};
gr.unmountComponentAtNode = function(n18) {
  if (!yg(n18)) throw Error(Se(40));
  return n18._reactRootContainer ? (hl(function() {
    xg(null, null, n18, false, function() {
      n18._reactRootContainer = null, n18[to] = null;
    });
  }), true) : false;
};
gr.unstable_batchedUpdates = SS;
gr.unstable_renderSubtreeIntoContainer = function(n18, e, t, i) {
  if (!yg(t)) throw Error(Se(200));
  if (n18 == null || n18._reactInternals === void 0) throw Error(Se(38));
  return xg(n18, e, t, false, i);
};
gr.version = "18.3.1-next-f1338f8080-20240426";
function qR() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(qR);
  } catch (n18) {
    console.error(n18);
  }
}
qR(), qA.exports = gr;
var qD = qA.exports, SE = qD;
Iv.createRoot = SE.createRoot, Iv.hydrateRoot = SE.hydrateRoot;
/**
* @license
* Copyright 2010-2023 Three.js Authors
* SPDX-License-Identifier: MIT
*/
const Sg = "161", jD = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, ZD = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, jR = 0, Ty = 1, ZR = 2, JD = 3, JR = 0, Mg = 1, Tf = 2, Yr = 3, ro = 0, Pi = 1, gs = 2, $s = 0, Qa = 1, Ay = 2, Cy = 3, Ry = 4, KR = 5, Uo = 100, QR = 101, $R = 102, Py = 103, by = 104, e2 = 200, t2 = 201, n2 = 202, i2 = 203, Wm = 204, Xm = 205, r2 = 206, s2 = 207, o2 = 208, a2 = 209, l2 = 210, u2 = 211, c2 = 212, f2 = 213, h2 = 214, d2 = 0, p2 = 1, m2 = 2, Jf = 3, g2 = 4, _2 = 5, v2 = 6, y2 = 7, bh = 0, x2 = 1, S2 = 2, ws = 0, M2 = 1, w2 = 2, E2 = 3, PS = 4, T2 = 5, A2 = 6, Ly = "attached", C2 = "detached", wg = 300, so = 301, na = 302, Kf = 303, Qf = 304, hc = 306, $f = 1e3, hi = 1001, eh = 1002, Mn = 1003, Ym = 1004, KD = 1004, Ba = 1005, QD = 1005, sn = 1006, Af = 1007, $D = 1007, vs = 1008, eN = 1008, Es = 1009, R2 = 1010, P2 = 1011, Eg = 1012, bS = 1013, Js = 1014, Dr = 1015, Ku = 1016, LS = 1017, IS = 1018, Zo = 1020, b2 = 1021, Ti = 1023, L2 = 1024, I2 = 1025, Jo = 1026, dl = 1027, D2 = 1028, DS = 1029, N2 = 1030, NS = 1031, US = 1033, lm = 33776, um = 33777, cm = 33778, fm = 33779, Iy = 35840, Dy = 35841, Ny = 35842, Uy = 35843, OS = 36196, Oy = 37492, Fy = 37496, ky = 37808, zy = 37809, By = 37810, Vy = 37811, Hy = 37812, Gy = 37813, Wy = 37814, Xy = 37815, Yy = 37816, qy = 37817, jy = 37818, Zy = 37819, Jy = 37820, Ky = 37821, hm = 36492, Qy = 36494, $y = 36495, U2 = 36283, ex = 36284, tx = 36285, nx = 36286, O2 = 2200, F2 = 2201, k2 = 2202, th = 2300, nh = 2301, dm = 2302, Xa = 2400, Ya = 2401, ih = 2402, Tg = 2500, FS = 2501, tN = 0, nN = 1, iN = 2, kS = 3e3, Ko = 3001, z2 = 3200, B2 = 3201, ua = 0, V2 = 1, sr = "", Nn = "srgb", Rs = "srgb-linear", Ag = "display-p3", Lh = "display-p3-linear", rh = "linear", Yt = "srgb", sh = "rec709", oh = "p3", rN = 0, Fa = 7680, sN = 7681, oN = 7682, aN = 7683, lN = 34055, uN = 34056, cN = 5386, fN = 512, hN = 513, dN = 514, pN = 515, mN = 516, gN = 517, _N = 518, ix = 519, H2 = 512, G2 = 513, W2 = 514, zS = 515, X2 = 516, Y2 = 517, q2 = 518, j2 = 519, ah = 35044, vN = 35048, yN = 35040, xN = 35045, SN = 35049, MN = 35041, wN = 35046, EN = 35050, TN = 35042, AN = "100", rx = "300 es", qm = 1035, ys = 2e3, lh = 2001;
class co {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return false;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const li = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let ME = 1234567;
const $a = Math.PI / 180, Qu = 180 / Math.PI;
function fr() {
  const n18 = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (li[n18 & 255] + li[n18 >> 8 & 255] + li[n18 >> 16 & 255] + li[n18 >> 24 & 255] + "-" + li[e & 255] + li[e >> 8 & 255] + "-" + li[e >> 16 & 15 | 64] + li[e >> 24 & 255] + "-" + li[t & 63 | 128] + li[t >> 8 & 255] + "-" + li[t >> 16 & 255] + li[t >> 24 & 255] + li[i & 255] + li[i >> 8 & 255] + li[i >> 16 & 255] + li[i >> 24 & 255]).toLowerCase();
}
function mn(n18, e, t) {
  return Math.max(e, Math.min(t, n18));
}
function BS(n18, e) {
  return (n18 % e + e) % e;
}
function CN(n18, e, t, i, r) {
  return i + (n18 - e) * (r - i) / (t - e);
}
function RN(n18, e, t) {
  return n18 !== e ? (t - n18) / (e - n18) : 0;
}
function Cf(n18, e, t) {
  return (1 - t) * n18 + t * e;
}
function PN(n18, e, t, i) {
  return Cf(n18, e, 1 - Math.exp(-t * i));
}
function bN(n18, e = 1) {
  return e - Math.abs(BS(n18, e * 2) - e);
}
function LN(n18, e, t) {
  return n18 <= e ? 0 : n18 >= t ? 1 : (n18 = (n18 - e) / (t - e), n18 * n18 * (3 - 2 * n18));
}
function IN(n18, e, t) {
  return n18 <= e ? 0 : n18 >= t ? 1 : (n18 = (n18 - e) / (t - e), n18 * n18 * n18 * (n18 * (n18 * 6 - 15) + 10));
}
function DN(n18, e) {
  return n18 + Math.floor(Math.random() * (e - n18 + 1));
}
function NN(n18, e) {
  return n18 + Math.random() * (e - n18);
}
function UN(n18) {
  return n18 * (0.5 - Math.random());
}
function ON(n18) {
  n18 !== void 0 && (ME = n18);
  let e = ME += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function FN(n18) {
  return n18 * $a;
}
function kN(n18) {
  return n18 * Qu;
}
function sx(n18) {
  return (n18 & n18 - 1) === 0 && n18 !== 0;
}
function zN(n18) {
  return Math.pow(2, Math.ceil(Math.log(n18) / Math.LN2));
}
function jm(n18) {
  return Math.pow(2, Math.floor(Math.log(n18) / Math.LN2));
}
function BN(n18, e, t, i, r) {
  const s = Math.cos, o = Math.sin, a = s(t / 2), u = o(t / 2), f = s((e + i) / 2), h = o((e + i) / 2), d = s((e - i) / 2), p = o((e - i) / 2), g = s((i - e) / 2), v = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n18.set(a * h, u * d, u * p, a * f);
      break;
    case "YZY":
      n18.set(u * p, a * h, u * d, a * f);
      break;
    case "ZXZ":
      n18.set(u * d, u * p, a * h, a * f);
      break;
    case "XZX":
      n18.set(a * h, u * v, u * g, a * f);
      break;
    case "YXY":
      n18.set(u * g, a * h, u * v, a * f);
      break;
    case "ZYZ":
      n18.set(u * v, u * g, a * h, a * f);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Ai(n18, e) {
  switch (e.constructor) {
    case Float32Array:
      return n18;
    case Uint32Array:
      return n18 / 4294967295;
    case Uint16Array:
      return n18 / 65535;
    case Uint8Array:
      return n18 / 255;
    case Int32Array:
      return Math.max(n18 / 2147483647, -1);
    case Int16Array:
      return Math.max(n18 / 32767, -1);
    case Int8Array:
      return Math.max(n18 / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function mt(n18, e) {
  switch (e.constructor) {
    case Float32Array:
      return n18;
    case Uint32Array:
      return Math.round(n18 * 4294967295);
    case Uint16Array:
      return Math.round(n18 * 65535);
    case Uint8Array:
      return Math.round(n18 * 255);
    case Int32Array:
      return Math.round(n18 * 2147483647);
    case Int16Array:
      return Math.round(n18 * 32767);
    case Int8Array:
      return Math.round(n18 * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const ox = { DEG2RAD: $a, RAD2DEG: Qu, generateUUID: fr, clamp: mn, euclideanModulo: BS, mapLinear: CN, inverseLerp: RN, lerp: Cf, damp: PN, pingpong: bN, smoothstep: LN, smootherstep: IN, randInt: DN, randFloat: NN, randFloatSpread: UN, seededRandom: ON, degToRad: FN, radToDeg: kN, isPowerOfTwo: sx, ceilPowerOfTwo: zN, floorPowerOfTwo: jm, setQuaternionFromProperEuler: BN, normalize: mt, denormalize: Ai };
class me {
  constructor(e = 0, t = 0) {
    me.prototype.isVector2 = true, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(mn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class yt {
  constructor(e, t, i, r, s, o, a, u, f) {
    yt.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, u, f);
  }
  set(e, t, i, r, s, o, a, u, f) {
    const h = this.elements;
    return h[0] = e, h[1] = r, h[2] = a, h[3] = t, h[4] = s, h[5] = u, h[6] = i, h[7] = o, h[8] = f, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], u = i[6], f = i[1], h = i[4], d = i[7], p = i[2], g = i[5], v = i[8], M = r[0], S = r[3], m = r[6], E = r[1], T = r[4], C = r[7], L = r[2], b = r[5], I = r[8];
    return s[0] = o * M + a * E + u * L, s[3] = o * S + a * T + u * b, s[6] = o * m + a * C + u * I, s[1] = f * M + h * E + d * L, s[4] = f * S + h * T + d * b, s[7] = f * m + h * C + d * I, s[2] = p * M + g * E + v * L, s[5] = p * S + g * T + v * b, s[8] = p * m + g * C + v * I, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], u = e[6], f = e[7], h = e[8];
    return t * o * h - t * a * f - i * s * h + i * a * u + r * s * f - r * o * u;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], u = e[6], f = e[7], h = e[8], d = h * o - a * f, p = a * u - h * s, g = f * s - o * u, v = t * d + i * p + r * g;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / v;
    return e[0] = d * M, e[1] = (r * f - h * i) * M, e[2] = (a * i - r * o) * M, e[3] = p * M, e[4] = (h * t - r * u) * M, e[5] = (r * s - a * t) * M, e[6] = g * M, e[7] = (i * u - f * t) * M, e[8] = (o * t - i * s) * M, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const u = Math.cos(s), f = Math.sin(s);
    return this.set(i * u, i * f, -i * (u * o + f * a) + o + e, -r * f, r * u, -r * (-f * o + u * a) + a + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(I_.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(I_.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(I_.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const I_ = new yt();
function Z2(n18) {
  for (let e = n18.length - 1; e >= 0; --e) if (n18[e] >= 65535) return true;
  return false;
}
const VN = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function Tu(n18, e) {
  return new VN[n18](e);
}
function uh(n18) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n18);
}
function J2() {
  const n18 = uh("canvas");
  return n18.style.display = "block", n18;
}
const wE = {};
function el(n18) {
  n18 in wE || (wE[n18] = true, console.warn(n18));
}
const EE = new yt().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), TE = new yt().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), tp = { [Rs]: { transfer: rh, primaries: sh, toReference: (n18) => n18, fromReference: (n18) => n18 }, [Nn]: { transfer: Yt, primaries: sh, toReference: (n18) => n18.convertSRGBToLinear(), fromReference: (n18) => n18.convertLinearToSRGB() }, [Lh]: { transfer: rh, primaries: oh, toReference: (n18) => n18.applyMatrix3(TE), fromReference: (n18) => n18.applyMatrix3(EE) }, [Ag]: { transfer: Yt, primaries: oh, toReference: (n18) => n18.convertSRGBToLinear().applyMatrix3(TE), fromReference: (n18) => n18.applyMatrix3(EE).convertLinearToSRGB() } }, HN = /* @__PURE__ */ new Set([Rs, Lh]), zt = { enabled: true, _workingColorSpace: Rs, get workingColorSpace() {
  return this._workingColorSpace;
}, set workingColorSpace(n18) {
  if (!HN.has(n18)) throw new Error(`Unsupported working color space, "${n18}".`);
  this._workingColorSpace = n18;
}, convert: function(n18, e, t) {
  if (this.enabled === false || e === t || !e || !t) return n18;
  const i = tp[e].toReference, r = tp[t].fromReference;
  return r(i(n18));
}, fromWorkingColorSpace: function(n18, e) {
  return this.convert(n18, this._workingColorSpace, e);
}, toWorkingColorSpace: function(n18, e) {
  return this.convert(n18, e, this._workingColorSpace);
}, getPrimaries: function(n18) {
  return tp[n18].primaries;
}, getTransfer: function(n18) {
  return n18 === sr ? rh : tp[n18].transfer;
} };
function zu(n18) {
  return n18 < 0.04045 ? n18 * 0.0773993808 : Math.pow(n18 * 0.9478672986 + 0.0521327014, 2.4);
}
function D_(n18) {
  return n18 < 31308e-7 ? n18 * 12.92 : 1.055 * Math.pow(n18, 0.41666) - 0.055;
}
let Vl;
class VS {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Vl === void 0 && (Vl = uh("canvas")), Vl.width = e.width, Vl.height = e.height;
      const i = Vl.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Vl;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = uh("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = zu(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(zu(t[i] / 255) * 255) : t[i] = zu(t[i]);
      return { data: t, width: e.width, height: e.height };
    } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let GN = 0;
class qa {
  constructor(e = null) {
    this.isSource = true, Object.defineProperty(this, "id", { value: GN++ }), this.uuid = fr(), this.data = e, this.dataReady = true, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++) r[o].isDataTexture ? s.push(N_(r[o].image)) : s.push(N_(r[o]));
      } else s = N_(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function N_(n18) {
  return typeof HTMLImageElement < "u" && n18 instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n18 instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n18 instanceof ImageBitmap ? VS.getDataURL(n18) : n18.data ? { data: Array.from(n18.data), width: n18.width, height: n18.height, type: n18.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let WN = 0;
class _n extends co {
  constructor(e = _n.DEFAULT_IMAGE, t = _n.DEFAULT_MAPPING, i = hi, r = hi, s = sn, o = vs, a = Ti, u = Es, f = _n.DEFAULT_ANISOTROPY, h = sr) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: WN++ }), this.uuid = fr(), this.name = "", this.source = new qa(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = f, this.format = a, this.internalFormat = null, this.type = u, this.offset = new me(0, 0), this.repeat = new me(1, 1), this.center = new me(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new yt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (el("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === Ko ? Nn : sr), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== wg) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
      case $f:
        e.x = e.x - Math.floor(e.x);
        break;
      case hi:
        e.x = e.x < 0 ? 0 : 1;
        break;
      case eh:
        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
        break;
    }
    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
      case $f:
        e.y = e.y - Math.floor(e.y);
        break;
      case hi:
        e.y = e.y < 0 ? 0 : 1;
        break;
      case eh:
        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
        break;
    }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === true && (this.version++, this.source.needsUpdate = true);
  }
  get encoding() {
    return el("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Nn ? Ko : kS;
  }
  set encoding(e) {
    el("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Ko ? Nn : sr;
  }
}
_n.DEFAULT_IMAGE = null;
_n.DEFAULT_MAPPING = wg;
_n.DEFAULT_ANISOTROPY = 1;
class Bt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    Bt.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return this.x = e, this.y = t, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const u = e.elements, f = u[0], h = u[4], d = u[8], p = u[1], g = u[5], v = u[9], M = u[2], S = u[6], m = u[10];
    if (Math.abs(h - p) < 0.01 && Math.abs(d - M) < 0.01 && Math.abs(v - S) < 0.01) {
      if (Math.abs(h + p) < 0.1 && Math.abs(d + M) < 0.1 && Math.abs(v + S) < 0.1 && Math.abs(f + g + m - 3) < 0.1) return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const T = (f + 1) / 2, C = (g + 1) / 2, L = (m + 1) / 2, b = (h + p) / 4, I = (d + M) / 4, U = (v + S) / 4;
      return T > C && T > L ? T < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(T), r = b / i, s = I / i) : C > L ? C < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(C), i = b / r, s = U / r) : L < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(L), i = I / s, r = U / s), this.set(i, r, s, t), this;
    }
    let E = Math.sqrt((S - v) * (S - v) + (d - M) * (d - M) + (p - h) * (p - h));
    return Math.abs(E) < 1e-3 && (E = 1), this.x = (S - v) / E, this.y = (d - M) / E, this.z = (p - h) / E, this.w = Math.acos((f + g + m - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class K2 extends co {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new Bt(0, 0, e, t), this.scissorTest = false, this.viewport = new Bt(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 && (el("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === Ko ? Nn : sr), i = Object.assign({ generateMipmaps: false, internalFormat: null, minFilter: sn, depthBuffer: true, stencilBuffer: false, depthTexture: null, samples: 0 }, i), this.texture = new _n(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = i.generateMipmaps, this.texture.internalFormat = i.internalFormat, this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = true;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new qa(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class $r extends K2 {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = true;
  }
}
class Cg extends _n {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Mn, this.minFilter = Mn, this.wrapR = hi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class XN extends $r {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGLArrayRenderTarget = true, this.depth = i, this.texture = new Cg(null, e, t, i), this.texture.isRenderTargetTexture = true;
  }
}
class HS extends _n {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Mn, this.minFilter = Mn, this.wrapR = hi, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class YN extends $r {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGL3DRenderTarget = true, this.depth = i, this.texture = new HS(null, e, t, i), this.texture.isRenderTargetTexture = true;
  }
}
class qN extends $r {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = true;
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++) this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = true;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let r = 0, s = this.texture.length; r < s; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = true;
    return this;
  }
}
class Gi {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = r;
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let u = i[r + 0], f = i[r + 1], h = i[r + 2], d = i[r + 3];
    const p = s[o + 0], g = s[o + 1], v = s[o + 2], M = s[o + 3];
    if (a === 0) {
      e[t + 0] = u, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
      return;
    }
    if (a === 1) {
      e[t + 0] = p, e[t + 1] = g, e[t + 2] = v, e[t + 3] = M;
      return;
    }
    if (d !== M || u !== p || f !== g || h !== v) {
      let S = 1 - a;
      const m = u * p + f * g + h * v + d * M, E = m >= 0 ? 1 : -1, T = 1 - m * m;
      if (T > Number.EPSILON) {
        const L = Math.sqrt(T), b = Math.atan2(L, m * E);
        S = Math.sin(S * b) / L, a = Math.sin(a * b) / L;
      }
      const C = a * E;
      if (u = u * S + p * C, f = f * S + g * C, h = h * S + v * C, d = d * S + M * C, S === 1 - a) {
        const L = 1 / Math.sqrt(u * u + f * f + h * h + d * d);
        u *= L, f *= L, h *= L, d *= L;
      }
    }
    e[t] = u, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r], u = i[r + 1], f = i[r + 2], h = i[r + 3], d = s[o], p = s[o + 1], g = s[o + 2], v = s[o + 3];
    return e[t] = a * v + h * d + u * g - f * p, e[t + 1] = u * v + h * p + f * d - a * g, e[t + 2] = f * v + h * g + a * p - u * d, e[t + 3] = h * v - a * d - u * p - f * g, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, r) {
    return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = true) {
    const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, u = Math.sin, f = a(i / 2), h = a(r / 2), d = a(s / 2), p = u(i / 2), g = u(r / 2), v = u(s / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "YXZ":
        this._x = p * h * d + f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d + p * g * v;
        break;
      case "ZXY":
        this._x = p * h * d - f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "ZYX":
        this._x = p * h * d - f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d + p * g * v;
        break;
      case "YZX":
        this._x = p * h * d + f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "XZY":
        this._x = p * h * d - f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d + p * g * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === true && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], u = t[9], f = t[2], h = t[6], d = t[10], p = i + a + d;
    if (p > 0) {
      const g = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / g, this._x = (h - u) * g, this._y = (s - f) * g, this._z = (o - r) * g;
    } else if (i > a && i > d) {
      const g = 2 * Math.sqrt(1 + i - a - d);
      this._w = (h - u) / g, this._x = 0.25 * g, this._y = (r + o) / g, this._z = (s + f) / g;
    } else if (a > d) {
      const g = 2 * Math.sqrt(1 + a - i - d);
      this._w = (s - f) / g, this._x = (r + o) / g, this._y = 0.25 * g, this._z = (u + h) / g;
    } else {
      const g = 2 * Math.sqrt(1 + d - i - a);
      this._w = (o - r) / g, this._x = (s + f) / g, this._y = (u + h) / g, this._z = 0.25 * g;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(mn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, u = t._y, f = t._z, h = t._w;
    return this._x = i * h + o * a + r * f - s * u, this._y = r * h + o * u + s * a - i * f, this._z = s * h + o * f + i * u - r * a, this._w = o * h - i * a - r * u - s * f, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, r = this._y, s = this._z, o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this;
    const u = 1 - a * a;
    if (u <= Number.EPSILON) {
      const g = 1 - t;
      return this._w = g * o + t * this._w, this._x = g * i + t * this._x, this._y = g * r + t * this._y, this._z = g * s + t * this._z, this.normalize(), this;
    }
    const f = Math.sqrt(u), h = Math.atan2(f, a), d = Math.sin((1 - t) * h) / f, p = Math.sin(t * h) / f;
    return this._w = o * d + this._w * p, this._x = i * d + this._x * p, this._y = r * d + this._y * p, this._z = s * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class k {
  constructor(e = 0, t = 0, i = 0) {
    k.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(AE.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(AE.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, u = e.w, f = 2 * (o * r - a * i), h = 2 * (a * t - s * r), d = 2 * (s * i - o * t);
    return this.x = t + u * f + o * d - a * h, this.y = i + u * h + a * f - s * d, this.z = r + u * d + s * h - o * f, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, u = t.z;
    return this.x = r * u - s * a, this.y = s * o - i * u, this.z = i * a - r * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return U_.copy(this).projectOnVector(e), this.sub(U_);
  }
  reflect(e) {
    return this.sub(U_.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(mn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const U_ = new k(), AE = new Gi();
class bi {
  constructor(e = new k(1 / 0, 1 / 0, 1 / 0), t = new k(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Hr.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Hr.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Hr.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = false) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = false) {
    e.updateWorldMatrix(false, false);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === true && s !== void 0 && e.isInstancedMesh !== true) for (let o = 0, a = s.count; o < a; o++) e.isMesh === true ? e.getVertexPosition(o, Hr) : Hr.fromBufferAttribute(s, o), Hr.applyMatrix4(e.matrixWorld), this.expandByPoint(Hr);
      else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), np.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), np.copy(i.boundingBox)), np.applyMatrix4(e.matrixWorld), this.union(np);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, Hr), Hr.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return false;
    this.getCenter(qc), ip.subVectors(this.max, qc), Hl.subVectors(e.a, qc), Gl.subVectors(e.b, qc), Wl.subVectors(e.c, qc), Mo.subVectors(Gl, Hl), wo.subVectors(Wl, Gl), wa.subVectors(Hl, Wl);
    let t = [0, -Mo.z, Mo.y, 0, -wo.z, wo.y, 0, -wa.z, wa.y, Mo.z, 0, -Mo.x, wo.z, 0, -wo.x, wa.z, 0, -wa.x, -Mo.y, Mo.x, 0, -wo.y, wo.x, 0, -wa.y, wa.x, 0];
    return !O_(t, Hl, Gl, Wl, ip) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !O_(t, Hl, Gl, Wl, ip)) ? false : (rp.crossVectors(Mo, wo), t = [rp.x, rp.y, rp.z], O_(t, Hl, Gl, Wl, ip));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Hr).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Hr).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (Fs[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Fs[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Fs[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Fs[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Fs[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Fs[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Fs[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Fs[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Fs), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Fs = [new k(), new k(), new k(), new k(), new k(), new k(), new k(), new k()], Hr = new k(), np = new bi(), Hl = new k(), Gl = new k(), Wl = new k(), Mo = new k(), wo = new k(), wa = new k(), qc = new k(), ip = new k(), rp = new k(), Ea = new k();
function O_(n18, e, t, i, r) {
  for (let s = 0, o = n18.length - 3; s <= o; s += 3) {
    Ea.fromArray(n18, s);
    const a = r.x * Math.abs(Ea.x) + r.y * Math.abs(Ea.y) + r.z * Math.abs(Ea.z), u = e.dot(Ea), f = t.dot(Ea), h = i.dot(Ea);
    if (Math.max(-Math.max(u, f, h), Math.min(u, f, h)) > a) return false;
  }
  return true;
}
const jN = new bi(), jc = new k(), F_ = new k();
class mi {
  constructor(e = new k(), t = -1) {
    this.isSphere = true, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : jN.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
    jc.subVectors(e, this.center);
    const t = jc.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(jc, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (F_.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(jc.copy(e.center).add(F_)), this.expandByPoint(jc.copy(e.center).sub(F_))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ks = new k(), k_ = new k(), sp = new k(), Eo = new k(), z_ = new k(), op = new k(), B_ = new k();
class dc {
  constructor(e = new k(), t = new k(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, ks)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = ks.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (ks.copy(this.origin).addScaledVector(this.direction, t), ks.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    k_.copy(e).add(t).multiplyScalar(0.5), sp.copy(t).sub(e).normalize(), Eo.copy(this.origin).sub(k_);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(sp), a = Eo.dot(this.direction), u = -Eo.dot(sp), f = Eo.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, g, v;
    if (h > 0) if (d = o * u - a, p = o * a - u, v = s * h, d >= 0) if (p >= -v) if (p <= v) {
      const M = 1 / h;
      d *= M, p *= M, g = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * u) + f;
    } else p = s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * u) + f;
    else p = -s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * u) + f;
    else p <= -v ? (d = Math.max(0, -(-o * s + a)), p = d > 0 ? -s : Math.min(Math.max(-s, -u), s), g = -d * d + p * (p + 2 * u) + f) : p <= v ? (d = 0, p = Math.min(Math.max(-s, -u), s), g = p * (p + 2 * u) + f) : (d = Math.max(0, -(o * s + a)), p = d > 0 ? s : Math.min(Math.max(-s, -u), s), g = -d * d + p * (p + 2 * u) + f);
    else p = o > 0 ? -s : s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * u) + f;
    return i && i.copy(this.origin).addScaledVector(this.direction, d), r && r.copy(k_).addScaledVector(sp, p), g;
  }
  intersectSphere(e, t) {
    ks.subVectors(e.center, this.origin);
    const i = ks.dot(this.direction), r = ks.dot(ks) - i * i, s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r), a = i - o, u = i + o;
    return u < 0 ? null : a < 0 ? this.at(u, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, u;
    const f = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return f >= 0 ? (i = (e.min.x - p.x) * f, r = (e.max.x - p.x) * f) : (i = (e.max.x - p.x) * f, r = (e.min.x - p.x) * f), h >= 0 ? (s = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (s = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), d >= 0 ? (a = (e.min.z - p.z) * d, u = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, u = (e.min.z - p.z) * d), i > u || a > r) || ((a > i || i !== i) && (i = a), (u < r || r !== r) && (r = u), r < 0) ? null : this.at(i >= 0 ? i : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, ks) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    z_.subVectors(t, e), op.subVectors(i, e), B_.crossVectors(z_, op);
    let o = this.direction.dot(B_), a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) a = -1, o = -o;
    else return null;
    Eo.subVectors(this.origin, e);
    const u = a * this.direction.dot(op.crossVectors(Eo, op));
    if (u < 0) return null;
    const f = a * this.direction.dot(z_.cross(Eo));
    if (f < 0 || u + f > o) return null;
    const h = -a * Eo.dot(B_);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class st {
  constructor(e, t, i, r, s, o, a, u, f, h, d, p, g, v, M, S) {
    st.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, u, f, h, d, p, g, v, M, S);
  }
  set(e, t, i, r, s, o, a, u, f, h, d, p, g, v, M, S) {
    const m = this.elements;
    return m[0] = e, m[4] = t, m[8] = i, m[12] = r, m[1] = s, m[5] = o, m[9] = a, m[13] = u, m[2] = f, m[6] = h, m[10] = d, m[14] = p, m[3] = g, m[7] = v, m[11] = M, m[15] = S, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new st().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / Xl.setFromMatrixColumn(e, 0).length(), s = 1 / Xl.setFromMatrixColumn(e, 1).length(), o = 1 / Xl.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), u = Math.cos(r), f = Math.sin(r), h = Math.cos(s), d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h, g = o * d, v = a * h, M = a * d;
      t[0] = u * h, t[4] = -u * d, t[8] = f, t[1] = g + v * f, t[5] = p - M * f, t[9] = -a * u, t[2] = M - p * f, t[6] = v + g * f, t[10] = o * u;
    } else if (e.order === "YXZ") {
      const p = u * h, g = u * d, v = f * h, M = f * d;
      t[0] = p + M * a, t[4] = v * a - g, t[8] = o * f, t[1] = o * d, t[5] = o * h, t[9] = -a, t[2] = g * a - v, t[6] = M + p * a, t[10] = o * u;
    } else if (e.order === "ZXY") {
      const p = u * h, g = u * d, v = f * h, M = f * d;
      t[0] = p - M * a, t[4] = -o * d, t[8] = v + g * a, t[1] = g + v * a, t[5] = o * h, t[9] = M - p * a, t[2] = -o * f, t[6] = a, t[10] = o * u;
    } else if (e.order === "ZYX") {
      const p = o * h, g = o * d, v = a * h, M = a * d;
      t[0] = u * h, t[4] = v * f - g, t[8] = p * f + M, t[1] = u * d, t[5] = M * f + p, t[9] = g * f - v, t[2] = -f, t[6] = a * u, t[10] = o * u;
    } else if (e.order === "YZX") {
      const p = o * u, g = o * f, v = a * u, M = a * f;
      t[0] = u * h, t[4] = M - p * d, t[8] = v * d + g, t[1] = d, t[5] = o * h, t[9] = -a * h, t[2] = -f * h, t[6] = g * d + v, t[10] = p - M * d;
    } else if (e.order === "XZY") {
      const p = o * u, g = o * f, v = a * u, M = a * f;
      t[0] = u * h, t[4] = -d, t[8] = f * h, t[1] = p * d + M, t[5] = o * h, t[9] = g * d - v, t[2] = v * d - g, t[6] = a * h, t[10] = M * d + p;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(ZN, e, JN);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return tr.subVectors(e, t), tr.lengthSq() === 0 && (tr.z = 1), tr.normalize(), To.crossVectors(i, tr), To.lengthSq() === 0 && (Math.abs(i.z) === 1 ? tr.x += 1e-4 : tr.z += 1e-4, tr.normalize(), To.crossVectors(i, tr)), To.normalize(), ap.crossVectors(tr, To), r[0] = To.x, r[4] = ap.x, r[8] = tr.x, r[1] = To.y, r[5] = ap.y, r[9] = tr.y, r[2] = To.z, r[6] = ap.z, r[10] = tr.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], u = i[8], f = i[12], h = i[1], d = i[5], p = i[9], g = i[13], v = i[2], M = i[6], S = i[10], m = i[14], E = i[3], T = i[7], C = i[11], L = i[15], b = r[0], I = r[4], U = r[8], B = r[12], R = r[1], D = r[5], j = r[9], te = r[13], X = r[2], Q = r[6], J = r[10], ce = r[14], V = r[3], q = r[7], Y = r[11], $ = r[15];
    return s[0] = o * b + a * R + u * X + f * V, s[4] = o * I + a * D + u * Q + f * q, s[8] = o * U + a * j + u * J + f * Y, s[12] = o * B + a * te + u * ce + f * $, s[1] = h * b + d * R + p * X + g * V, s[5] = h * I + d * D + p * Q + g * q, s[9] = h * U + d * j + p * J + g * Y, s[13] = h * B + d * te + p * ce + g * $, s[2] = v * b + M * R + S * X + m * V, s[6] = v * I + M * D + S * Q + m * q, s[10] = v * U + M * j + S * J + m * Y, s[14] = v * B + M * te + S * ce + m * $, s[3] = E * b + T * R + C * X + L * V, s[7] = E * I + T * D + C * Q + L * q, s[11] = E * U + T * j + C * J + L * Y, s[15] = E * B + T * te + C * ce + L * $, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], u = e[9], f = e[13], h = e[2], d = e[6], p = e[10], g = e[14], v = e[3], M = e[7], S = e[11], m = e[15];
    return v * (+s * u * d - r * f * d - s * a * p + i * f * p + r * a * g - i * u * g) + M * (+t * u * g - t * f * p + s * o * p - r * o * g + r * f * h - s * u * h) + S * (+t * f * d - t * a * g - s * o * d + i * o * g + s * a * h - i * f * h) + m * (-r * a * h - t * u * d + t * a * p + r * o * d - i * o * p + i * u * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], u = e[6], f = e[7], h = e[8], d = e[9], p = e[10], g = e[11], v = e[12], M = e[13], S = e[14], m = e[15], E = d * S * f - M * p * f + M * u * g - a * S * g - d * u * m + a * p * m, T = v * p * f - h * S * f - v * u * g + o * S * g + h * u * m - o * p * m, C = h * M * f - v * d * f + v * a * g - o * M * g - h * a * m + o * d * m, L = v * d * u - h * M * u - v * a * p + o * M * p + h * a * S - o * d * S, b = t * E + i * T + r * C + s * L;
    if (b === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const I = 1 / b;
    return e[0] = E * I, e[1] = (M * p * s - d * S * s - M * r * g + i * S * g + d * r * m - i * p * m) * I, e[2] = (a * S * s - M * u * s + M * r * f - i * S * f - a * r * m + i * u * m) * I, e[3] = (d * u * s - a * p * s - d * r * f + i * p * f + a * r * g - i * u * g) * I, e[4] = T * I, e[5] = (h * S * s - v * p * s + v * r * g - t * S * g - h * r * m + t * p * m) * I, e[6] = (v * u * s - o * S * s - v * r * f + t * S * f + o * r * m - t * u * m) * I, e[7] = (o * p * s - h * u * s + h * r * f - t * p * f - o * r * g + t * u * g) * I, e[8] = C * I, e[9] = (v * d * s - h * M * s - v * i * g + t * M * g + h * i * m - t * d * m) * I, e[10] = (o * M * s - v * a * s + v * i * f - t * M * f - o * i * m + t * a * m) * I, e[11] = (h * a * s - o * d * s - h * i * f + t * d * f + o * i * g - t * a * g) * I, e[12] = L * I, e[13] = (h * M * r - v * d * r + v * i * p - t * M * p - h * i * S + t * d * S) * I, e[14] = (v * a * r - o * M * r - v * i * u + t * M * u + o * i * S - t * a * S) * I, e[15] = (o * d * r - h * a * r + h * i * u - t * d * u - o * i * p + t * a * p) * I, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, u = e.z, f = s * o, h = s * a;
    return this.set(f * o + i, f * a - r * u, f * u + r * a, 0, f * a + r * u, h * a + i, h * u - r * o, 0, f * u - r * a, h * u + r * o, s * u * u + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t._x, o = t._y, a = t._z, u = t._w, f = s + s, h = o + o, d = a + a, p = s * f, g = s * h, v = s * d, M = o * h, S = o * d, m = a * d, E = u * f, T = u * h, C = u * d, L = i.x, b = i.y, I = i.z;
    return r[0] = (1 - (M + m)) * L, r[1] = (g + C) * L, r[2] = (v - T) * L, r[3] = 0, r[4] = (g - C) * b, r[5] = (1 - (p + m)) * b, r[6] = (S + E) * b, r[7] = 0, r[8] = (v + T) * I, r[9] = (S - E) * I, r[10] = (1 - (p + M)) * I, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Xl.set(r[0], r[1], r[2]).length();
    const o = Xl.set(r[4], r[5], r[6]).length(), a = Xl.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Gr.copy(this);
    const f = 1 / s, h = 1 / o, d = 1 / a;
    return Gr.elements[0] *= f, Gr.elements[1] *= f, Gr.elements[2] *= f, Gr.elements[4] *= h, Gr.elements[5] *= h, Gr.elements[6] *= h, Gr.elements[8] *= d, Gr.elements[9] *= d, Gr.elements[10] *= d, t.setFromRotationMatrix(Gr), i.x = s, i.y = o, i.z = a, this;
  }
  makePerspective(e, t, i, r, s, o, a = ys) {
    const u = this.elements, f = 2 * s / (t - e), h = 2 * s / (i - r), d = (t + e) / (t - e), p = (i + r) / (i - r);
    let g, v;
    if (a === ys) g = -(o + s) / (o - s), v = -2 * o * s / (o - s);
    else if (a === lh) g = -o / (o - s), v = -o * s / (o - s);
    else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return u[0] = f, u[4] = 0, u[8] = d, u[12] = 0, u[1] = 0, u[5] = h, u[9] = p, u[13] = 0, u[2] = 0, u[6] = 0, u[10] = g, u[14] = v, u[3] = 0, u[7] = 0, u[11] = -1, u[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, o, a = ys) {
    const u = this.elements, f = 1 / (t - e), h = 1 / (i - r), d = 1 / (o - s), p = (t + e) * f, g = (i + r) * h;
    let v, M;
    if (a === ys) v = (o + s) * d, M = -2 * d;
    else if (a === lh) v = s * d, M = -1 * d;
    else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return u[0] = 2 * f, u[4] = 0, u[8] = 0, u[12] = -p, u[1] = 0, u[5] = 2 * h, u[9] = 0, u[13] = -g, u[2] = 0, u[6] = 0, u[10] = M, u[14] = -v, u[3] = 0, u[7] = 0, u[11] = 0, u[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Xl = new k(), Gr = new st(), ZN = new k(0, 0, 0), JN = new k(1, 1, 1), To = new k(), ap = new k(), tr = new k(), CE = new st(), RE = new Gi();
class Ih {
  constructor(e = 0, t = 0, i = 0, r = Ih.DEFAULT_ORDER) {
    this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = true) {
    const r = e.elements, s = r[0], o = r[4], a = r[8], u = r[1], f = r[5], h = r[9], d = r[2], p = r[6], g = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(mn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, g), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, f), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-mn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, g), this._z = Math.atan2(u, f)) : (this._y = Math.atan2(-d, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(mn(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, g), this._z = Math.atan2(-o, f)) : (this._y = 0, this._z = Math.atan2(u, s));
        break;
      case "ZYX":
        this._y = Math.asin(-mn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, g), this._z = Math.atan2(u, s)) : (this._x = 0, this._z = Math.atan2(-o, f));
        break;
      case "YZX":
        this._z = Math.asin(mn(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, g));
        break;
      case "XZY":
        this._z = Math.asin(-mn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, f), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, g), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return CE.makeRotationFromQuaternion(e), this.setFromRotationMatrix(CE, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return RE.setFromEuler(this), this.setFromQuaternion(RE, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Ih.DEFAULT_ORDER = "XYZ";
class tl {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let KN = 0;
const PE = new k(), Yl = new Gi(), zs = new st(), lp = new k(), Zc = new k(), QN = new k(), $N = new Gi(), bE = new k(1, 0, 0), LE = new k(0, 1, 0), IE = new k(0, 0, 1), eU = { type: "added" }, tU = { type: "removed" };
class Nt extends co {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: KN++ }), this.uuid = fr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Nt.DEFAULT_UP.clone();
    const e = new k(), t = new Ih(), i = new Gi(), r = new k(1, 1, 1);
    function s() {
      i.setFromEuler(t, false);
    }
    function o() {
      t.setFromQuaternion(i, void 0, false);
    }
    t._onChange(s), i._onChange(o), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e }, rotation: { configurable: true, enumerable: true, value: t }, quaternion: { configurable: true, enumerable: true, value: i }, scale: { configurable: true, enumerable: true, value: r }, modelViewMatrix: { value: new st() }, normalMatrix: { value: new yt() } }), this.matrix = new st(), this.matrixWorld = new st(), this.matrixAutoUpdate = Nt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Nt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new tl(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, true);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Yl.setFromAxisAngle(e, t), this.quaternion.multiply(Yl), this;
  }
  rotateOnWorldAxis(e, t) {
    return Yl.setFromAxisAngle(e, t), this.quaternion.premultiply(Yl), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(bE, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(LE, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(IE, e);
  }
  translateOnAxis(e, t) {
    return PE.copy(e).applyQuaternion(this.quaternion), this.position.add(PE.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(bE, e);
  }
  translateY(e) {
    return this.translateOnAxis(LE, e);
  }
  translateZ(e) {
    return this.translateOnAxis(IE, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(zs.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? lp.copy(e) : lp.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(true, false), Zc.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? zs.lookAt(Zc, lp, this.up) : zs.lookAt(lp, Zc, this.up), this.quaternion.setFromRotationMatrix(zs), r && (zs.extractRotation(r.matrixWorld), Yl.setFromRotationMatrix(zs), this.quaternion.premultiply(Yl.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(eU)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(tU)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(true, false), zs.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), zs.multiply(e.parent.matrixWorld)), e.applyMatrix4(zs), this.add(e), e.updateWorldMatrix(false, true), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Zc, e, QN), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(Zc, $N, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === false) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === true || e === true) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === true && i !== null && i.matrixWorldAutoUpdate === true && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === true) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === true && a.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === true && (r.castShadow = true), this.receiveShadow === true && (r.receiveShadow = true), this.visible === false && (r.visible = false), this.frustumCulled === false && (r.frustumCulled = false), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === false && (r.matrixAutoUpdate = false), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((a) => ({ boxInitialized: a.boxInitialized, boxMin: a.box.min.toArray(), boxMax: a.box.max.toArray(), sphereInitialized: a.sphereInitialized, sphereRadius: a.sphere.radius, sphereCenter: a.sphere.center.toArray() })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), this.boundingBox !== null && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() }));
    function s(a, u) {
      return a[u.uuid] === void 0 && (a[u.uuid] = u.toJSON(e)), u.uuid;
    }
    if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const u = a.shapes;
        if (Array.isArray(u)) for (let f = 0, h = u.length; f < h; f++) {
          const d = u[f];
          s(e.shapes, d);
        }
        else s(e.shapes, u);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
      const a = [];
      for (let u = 0, f = this.material.length; u < f; u++) a.push(s(e.materials, this.material[u]));
      r.material = a;
    } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const u = this.animations[a];
        r.animations.push(s(e.animations, u));
      }
    }
    if (t) {
      const a = o(e.geometries), u = o(e.materials), f = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), g = o(e.animations), v = o(e.nodes);
      a.length > 0 && (i.geometries = a), u.length > 0 && (i.materials = u), f.length > 0 && (i.textures = f), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), p.length > 0 && (i.skeletons = p), g.length > 0 && (i.animations = g), v.length > 0 && (i.nodes = v);
    }
    return i.object = r, i;
    function o(a) {
      const u = [];
      for (const f in a) {
        const h = a[f];
        delete h.metadata, u.push(h);
      }
      return u;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = true) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
      const r = e.children[i];
      this.add(r.clone());
    }
    return this;
  }
}
Nt.DEFAULT_UP = new k(0, 1, 0);
Nt.DEFAULT_MATRIX_AUTO_UPDATE = true;
Nt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const Wr = new k(), Bs = new k(), V_ = new k(), Vs = new k(), ql = new k(), jl = new k(), DE = new k(), H_ = new k(), G_ = new k(), W_ = new k();
class or {
  constructor(e = new k(), t = new k(), i = new k()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), Wr.subVectors(e, t), r.cross(Wr);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    Wr.subVectors(r, t), Bs.subVectors(i, t), V_.subVectors(e, t);
    const o = Wr.dot(Wr), a = Wr.dot(Bs), u = Wr.dot(V_), f = Bs.dot(Bs), h = Bs.dot(V_), d = o * f - a * a;
    if (d === 0) return s.set(0, 0, 0), null;
    const p = 1 / d, g = (f * u - a * h) * p, v = (o * h - a * u) * p;
    return s.set(1 - g - v, v, g);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, Vs) === null ? false : Vs.x >= 0 && Vs.y >= 0 && Vs.x + Vs.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, o, a, u) {
    return this.getBarycoord(e, t, i, r, Vs) === null ? (u.x = 0, u.y = 0, "z" in u && (u.z = 0), "w" in u && (u.w = 0), null) : (u.setScalar(0), u.addScaledVector(s, Vs.x), u.addScaledVector(o, Vs.y), u.addScaledVector(a, Vs.z), u);
  }
  static isFrontFacing(e, t, i, r) {
    return Wr.subVectors(i, t), Bs.subVectors(e, t), Wr.cross(Bs).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return Wr.subVectors(this.c, this.b), Bs.subVectors(this.a, this.b), Wr.cross(Bs).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return or.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return or.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return or.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return or.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return or.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, r = this.b, s = this.c;
    let o, a;
    ql.subVectors(r, i), jl.subVectors(s, i), H_.subVectors(e, i);
    const u = ql.dot(H_), f = jl.dot(H_);
    if (u <= 0 && f <= 0) return t.copy(i);
    G_.subVectors(e, r);
    const h = ql.dot(G_), d = jl.dot(G_);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = u * d - h * f;
    if (p <= 0 && u >= 0 && h <= 0) return o = u / (u - h), t.copy(i).addScaledVector(ql, o);
    W_.subVectors(e, s);
    const g = ql.dot(W_), v = jl.dot(W_);
    if (v >= 0 && g <= v) return t.copy(s);
    const M = g * f - u * v;
    if (M <= 0 && f >= 0 && v <= 0) return a = f / (f - v), t.copy(i).addScaledVector(jl, a);
    const S = h * v - g * d;
    if (S <= 0 && d - h >= 0 && g - v >= 0) return DE.subVectors(s, r), a = (d - h) / (d - h + (g - v)), t.copy(r).addScaledVector(DE, a);
    const m = 1 / (S + M + p);
    return o = M * m, a = p * m, t.copy(i).addScaledVector(ql, o).addScaledVector(jl, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const Q2 = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Ao = { h: 0, s: 0, l: 0 }, up = { h: 0, s: 0, l: 0 };
function X_(n18, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n18 + (e - n18) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n18 + (e - n18) * 6 * (2 / 3 - t) : n18;
}
class Oe {
  constructor(e, t, i) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Nn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, zt.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, r = zt.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, zt.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, i, r = zt.workingColorSpace) {
    if (e = BS(e, 1), t = mn(t, 0, 1), i = mn(i, 0, 1), t === 0) this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s;
      this.r = X_(o, s, e + 1 / 3), this.g = X_(o, s, e), this.b = X_(o, s, e - 1 / 3);
    }
    return zt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Nn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Nn) {
    const i = Q2[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = zu(e.r), this.g = zu(e.g), this.b = zu(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = D_(e.r), this.g = D_(e.g), this.b = D_(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Nn) {
    return zt.fromWorkingColorSpace(ui.copy(this), e), Math.round(mn(ui.r * 255, 0, 255)) * 65536 + Math.round(mn(ui.g * 255, 0, 255)) * 256 + Math.round(mn(ui.b * 255, 0, 255));
  }
  getHexString(e = Nn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = zt.workingColorSpace) {
    zt.fromWorkingColorSpace(ui.copy(this), t);
    const i = ui.r, r = ui.g, s = ui.b, o = Math.max(i, r, s), a = Math.min(i, r, s);
    let u, f;
    const h = (a + o) / 2;
    if (a === o) u = 0, f = 0;
    else {
      const d = o - a;
      switch (f = h <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case i:
          u = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          u = (s - i) / d + 2;
          break;
        case s:
          u = (i - r) / d + 4;
          break;
      }
      u /= 6;
    }
    return e.h = u, e.s = f, e.l = h, e;
  }
  getRGB(e, t = zt.workingColorSpace) {
    return zt.fromWorkingColorSpace(ui.copy(this), t), e.r = ui.r, e.g = ui.g, e.b = ui.b, e;
  }
  getStyle(e = Nn) {
    zt.fromWorkingColorSpace(ui.copy(this), e);
    const t = ui.r, i = ui.g, r = ui.b;
    return e !== Nn ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(Ao), this.setHSL(Ao.h + e, Ao.s + t, Ao.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(Ao), e.getHSL(up);
    const i = Cf(Ao.h, up.h, t), r = Cf(Ao.s, up.s, t), s = Cf(Ao.l, up.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, i = this.g, r = this.b, s = e.elements;
    return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ui = new Oe();
Oe.NAMES = Q2;
let nU = 0;
class vi extends co {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: nU++ }), this.uuid = fr(), this.name = "", this.type = "Material", this.blending = Qa, this.side = ro, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Wm, this.blendDst = Xm, this.blendEquation = Uo, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Oe(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Jf, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = ix, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Fa, this.stencilZFail = Fa, this.stencilZPass = Fa, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0) for (const t in e) {
      const i = e[t];
      if (i === void 0) {
        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
        continue;
      }
      const r = this[t];
      if (r === void 0) {
        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
        continue;
      }
      r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i;
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Qa && (i.blending = this.blending), this.side !== ro && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== Wm && (i.blendSrc = this.blendSrc), this.blendDst !== Xm && (i.blendDst = this.blendDst), this.blendEquation !== Uo && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Jf && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ix && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Fa && (i.stencilFail = this.stencilFail), this.stencilZFail !== Fa && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Fa && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const u = s[a];
        delete u.metadata, o.push(u);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
}
class ca extends vi {
  constructor(e) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const qs = iU();
function iU() {
  const n18 = new ArrayBuffer(4), e = new Float32Array(n18), t = new Uint32Array(n18), i = new Uint32Array(512), r = new Uint32Array(512);
  for (let u = 0; u < 256; ++u) {
    const f = u - 127;
    f < -27 ? (i[u] = 0, i[u | 256] = 32768, r[u] = 24, r[u | 256] = 24) : f < -14 ? (i[u] = 1024 >> -f - 14, i[u | 256] = 1024 >> -f - 14 | 32768, r[u] = -f - 1, r[u | 256] = -f - 1) : f <= 15 ? (i[u] = f + 15 << 10, i[u | 256] = f + 15 << 10 | 32768, r[u] = 13, r[u | 256] = 13) : f < 128 ? (i[u] = 31744, i[u | 256] = 64512, r[u] = 24, r[u | 256] = 24) : (i[u] = 31744, i[u | 256] = 64512, r[u] = 13, r[u | 256] = 13);
  }
  const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let u = 1; u < 1024; ++u) {
    let f = u << 13, h = 0;
    for (; !(f & 8388608); ) f <<= 1, h -= 8388608;
    f &= -8388609, h += 947912704, s[u] = f | h;
  }
  for (let u = 1024; u < 2048; ++u) s[u] = 939524096 + (u - 1024 << 13);
  for (let u = 1; u < 31; ++u) o[u] = u << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let u = 33; u < 63; ++u) o[u] = 2147483648 + (u - 32 << 23);
  o[63] = 3347054592;
  for (let u = 1; u < 64; ++u) u !== 32 && (a[u] = 1024);
  return { floatView: e, uint32View: t, baseTable: i, shiftTable: r, mantissaTable: s, exponentTable: o, offsetTable: a };
}
function Fi(n18) {
  Math.abs(n18) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n18 = mn(n18, -65504, 65504), qs.floatView[0] = n18;
  const e = qs.uint32View[0], t = e >> 23 & 511;
  return qs.baseTable[t] + ((e & 8388607) >> qs.shiftTable[t]);
}
function df(n18) {
  const e = n18 >> 10;
  return qs.uint32View[0] = qs.mantissaTable[qs.offsetTable[e] + (n18 & 1023)] + qs.exponentTable[e], qs.floatView[0];
}
const rU = { toHalfFloat: Fi, fromHalfFloat: df }, Cn = new k(), cp = new me();
class Ot {
  constructor(e, t, i = false) {
    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = ah, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = Dr, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  get updateRange() {
    return el("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) cp.fromBufferAttribute(this, t), cp.applyMatrix3(e), this.setXY(t, cp.x, cp.y);
    else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) Cn.fromBufferAttribute(this, t), Cn.applyMatrix3(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++) Cn.fromBufferAttribute(this, t), Cn.applyMatrix4(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) Cn.fromBufferAttribute(this, t), Cn.applyNormalMatrix(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) Cn.fromBufferAttribute(this, t), Cn.transformDirection(e), this.setXYZ(t, Cn.x, Cn.y, Cn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Ai(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = mt(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array), s = mt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== ah && (e.usage = this.usage), e;
  }
}
class sU extends Ot {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class oU extends Ot {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class aU extends Ot {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class lU extends Ot {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class GS extends Ot {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class uU extends Ot {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class WS extends Ot {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class cU extends Ot {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = true;
  }
  getX(e) {
    let t = df(this.array[e * this.itemSize]);
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize] = Fi(t), this;
  }
  getY(e) {
    let t = df(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 1] = Fi(t), this;
  }
  getZ(e) {
    let t = df(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 2] = Fi(t), this;
  }
  getW(e) {
    let t = df(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.array[e * this.itemSize + 3] = Fi(t), this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array)), this.array[e + 0] = Fi(t), this.array[e + 1] = Fi(i), this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array)), this.array[e + 0] = Fi(t), this.array[e + 1] = Fi(i), this.array[e + 2] = Fi(r), this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array), s = mt(s, this.array)), this.array[e + 0] = Fi(t), this.array[e + 1] = Fi(i), this.array[e + 2] = Fi(r), this.array[e + 3] = Fi(s), this;
  }
}
class Ye extends Ot {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class fU extends Ot {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let hU = 0;
const Pr = new st(), Y_ = new Nt(), Zl = new k(), nr = new bi(), Jc = new bi(), Gn = new k();
class _t extends co {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: hU++ }), this.uuid = fr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Z2(e) ? WS : GS)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new yt().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = true;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Pr.makeRotationFromQuaternion(e), this.applyMatrix4(Pr), this;
  }
  rotateX(e) {
    return Pr.makeRotationX(e), this.applyMatrix4(Pr), this;
  }
  rotateY(e) {
    return Pr.makeRotationY(e), this.applyMatrix4(Pr), this;
  }
  rotateZ(e) {
    return Pr.makeRotationZ(e), this.applyMatrix4(Pr), this;
  }
  translate(e, t, i) {
    return Pr.makeTranslation(e, t, i), this.applyMatrix4(Pr), this;
  }
  scale(e, t, i) {
    return Pr.makeScale(e, t, i), this.applyMatrix4(Pr), this;
  }
  lookAt(e) {
    return Y_.lookAt(e), Y_.updateMatrix(), this.applyMatrix4(Y_.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Zl).negate(), this.translate(Zl.x, Zl.y, Zl.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new k(-1 / 0, -1 / 0, -1 / 0), new k(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, r = t.length; i < r; i++) {
        const s = t[i];
        nr.setFromBufferAttribute(s), this.morphTargetsRelative ? (Gn.addVectors(this.boundingBox.min, nr.min), this.boundingBox.expandByPoint(Gn), Gn.addVectors(this.boundingBox.max, nr.max), this.boundingBox.expandByPoint(Gn)) : (this.boundingBox.expandByPoint(nr.min), this.boundingBox.expandByPoint(nr.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new k(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (nr.setFromBufferAttribute(e), t) for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s];
        Jc.setFromBufferAttribute(a), this.morphTargetsRelative ? (Gn.addVectors(nr.min, Jc.min), nr.expandByPoint(Gn), Gn.addVectors(nr.max, Jc.max), nr.expandByPoint(Gn)) : (nr.expandByPoint(Jc.min), nr.expandByPoint(Jc.max));
      }
      nr.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++) Gn.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(Gn));
      if (t) for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s], u = this.morphTargetsRelative;
        for (let f = 0, h = a.count; f < h; f++) Gn.fromBufferAttribute(a, f), u && (Zl.fromBufferAttribute(e, f), Gn.add(Zl)), r = Math.max(r, i.distanceToSquared(Gn));
      }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3;
    this.hasAttribute("tangent") === false && this.setAttribute("tangent", new Ot(new Float32Array(4 * a), 4));
    const u = this.getAttribute("tangent").array, f = [], h = [];
    for (let R = 0; R < a; R++) f[R] = new k(), h[R] = new k();
    const d = new k(), p = new k(), g = new k(), v = new me(), M = new me(), S = new me(), m = new k(), E = new k();
    function T(R, D, j) {
      d.fromArray(r, R * 3), p.fromArray(r, D * 3), g.fromArray(r, j * 3), v.fromArray(o, R * 2), M.fromArray(o, D * 2), S.fromArray(o, j * 2), p.sub(d), g.sub(d), M.sub(v), S.sub(v);
      const te = 1 / (M.x * S.y - S.x * M.y);
      isFinite(te) && (m.copy(p).multiplyScalar(S.y).addScaledVector(g, -M.y).multiplyScalar(te), E.copy(g).multiplyScalar(M.x).addScaledVector(p, -S.x).multiplyScalar(te), f[R].add(m), f[D].add(m), f[j].add(m), h[R].add(E), h[D].add(E), h[j].add(E));
    }
    let C = this.groups;
    C.length === 0 && (C = [{ start: 0, count: i.length }]);
    for (let R = 0, D = C.length; R < D; ++R) {
      const j = C[R], te = j.start, X = j.count;
      for (let Q = te, J = te + X; Q < J; Q += 3) T(i[Q + 0], i[Q + 1], i[Q + 2]);
    }
    const L = new k(), b = new k(), I = new k(), U = new k();
    function B(R) {
      I.fromArray(s, R * 3), U.copy(I);
      const D = f[R];
      L.copy(D), L.sub(I.multiplyScalar(I.dot(D))).normalize(), b.crossVectors(U, D);
      const te = b.dot(h[R]) < 0 ? -1 : 1;
      u[R * 4] = L.x, u[R * 4 + 1] = L.y, u[R * 4 + 2] = L.z, u[R * 4 + 3] = te;
    }
    for (let R = 0, D = C.length; R < D; ++R) {
      const j = C[R], te = j.start, X = j.count;
      for (let Q = te, J = te + X; Q < J; Q += 3) B(i[Q + 0]), B(i[Q + 1]), B(i[Q + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0) i = new Ot(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else for (let p = 0, g = i.count; p < g; p++) i.setXYZ(p, 0, 0, 0);
      const r = new k(), s = new k(), o = new k(), a = new k(), u = new k(), f = new k(), h = new k(), d = new k();
      if (e) for (let p = 0, g = e.count; p < g; p += 3) {
        const v = e.getX(p + 0), M = e.getX(p + 1), S = e.getX(p + 2);
        r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, M), o.fromBufferAttribute(t, S), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), a.fromBufferAttribute(i, v), u.fromBufferAttribute(i, M), f.fromBufferAttribute(i, S), a.add(h), u.add(h), f.add(h), i.setXYZ(v, a.x, a.y, a.z), i.setXYZ(M, u.x, u.y, u.z), i.setXYZ(S, f.x, f.y, f.z);
      }
      else for (let p = 0, g = t.count; p < g; p += 3) r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), i.setXYZ(p + 0, h.x, h.y, h.z), i.setXYZ(p + 1, h.x, h.y, h.z), i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++) Gn.fromBufferAttribute(e, t), Gn.normalize(), e.setXYZ(t, Gn.x, Gn.y, Gn.z);
  }
  toNonIndexed() {
    function e(a, u) {
      const f = a.array, h = a.itemSize, d = a.normalized, p = new f.constructor(u.length * h);
      let g = 0, v = 0;
      for (let M = 0, S = u.length; M < S; M++) {
        a.isInterleavedBufferAttribute ? g = u[M] * a.data.stride + a.offset : g = u[M] * h;
        for (let m = 0; m < h; m++) p[v++] = f[g++];
      }
      return new Ot(p, h, d);
    }
    if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new _t(), i = this.index.array, r = this.attributes;
    for (const a in r) {
      const u = r[a], f = e(u, i);
      t.setAttribute(a, f);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const u = [], f = s[a];
      for (let h = 0, d = f.length; h < d; h++) {
        const p = f[h], g = e(p, i);
        u.push(g);
      }
      t.morphAttributes[a] = u;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, u = o.length; a < u; a++) {
      const f = o[a];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const u = this.parameters;
      for (const f in u) u[f] !== void 0 && (e[f] = u[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
    const i = this.attributes;
    for (const u in i) {
      const f = i[u];
      e.data.attributes[u] = f.toJSON(e.data);
    }
    const r = {};
    let s = false;
    for (const u in this.morphAttributes) {
      const f = this.morphAttributes[u], h = [];
      for (let d = 0, p = f.length; d < p; d++) {
        const g = f[d];
        h.push(g.toJSON(e.data));
      }
      h.length > 0 && (r[u] = h, s = true);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const f in r) {
      const h = r[f];
      this.setAttribute(f, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const f in s) {
      const h = [], d = s[f];
      for (let p = 0, g = d.length; p < g; p++) h.push(d[p].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let f = 0, h = o.length; f < h; f++) {
      const d = o[f];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const u = e.boundingSphere;
    return u !== null && (this.boundingSphere = u.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const NE = new st(), Ta = new dc(), fp = new mi(), UE = new k(), Jl = new k(), Kl = new k(), Ql = new k(), q_ = new k(), hp = new k(), dp = new me(), pp = new me(), mp = new me(), OE = new k(), FE = new k(), kE = new k(), gp = new k(), _p = new k();
class Ln extends Nt {
  constructor(e = new _t(), t = new ca()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      hp.set(0, 0, 0);
      for (let u = 0, f = s.length; u < f; u++) {
        const h = a[u], d = s[u];
        h !== 0 && (q_.fromBufferAttribute(d, e), o ? hp.addScaledVector(q_, h) : hp.addScaledVector(q_.sub(t), h));
      }
      t.add(hp);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), fp.copy(i.boundingSphere), fp.applyMatrix4(s), Ta.copy(e.ray).recast(e.near), !(fp.containsPoint(Ta.origin) === false && (Ta.intersectSphere(fp, UE) === null || Ta.origin.distanceToSquared(UE) > (e.far - e.near) ** 2)) && (NE.copy(s).invert(), Ta.copy(e.ray).applyMatrix4(NE), !(i.boundingBox !== null && Ta.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, Ta)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry, o = this.material, a = s.index, u = s.attributes.position, f = s.attributes.uv, h = s.attributes.uv1, d = s.attributes.normal, p = s.groups, g = s.drawRange;
    if (a !== null) if (Array.isArray(o)) for (let v = 0, M = p.length; v < M; v++) {
      const S = p[v], m = o[S.materialIndex], E = Math.max(S.start, g.start), T = Math.min(a.count, Math.min(S.start + S.count, g.start + g.count));
      for (let C = E, L = T; C < L; C += 3) {
        const b = a.getX(C), I = a.getX(C + 1), U = a.getX(C + 2);
        r = vp(this, m, e, i, f, h, d, b, I, U), r && (r.faceIndex = Math.floor(C / 3), r.face.materialIndex = S.materialIndex, t.push(r));
      }
    }
    else {
      const v = Math.max(0, g.start), M = Math.min(a.count, g.start + g.count);
      for (let S = v, m = M; S < m; S += 3) {
        const E = a.getX(S), T = a.getX(S + 1), C = a.getX(S + 2);
        r = vp(this, o, e, i, f, h, d, E, T, C), r && (r.faceIndex = Math.floor(S / 3), t.push(r));
      }
    }
    else if (u !== void 0) if (Array.isArray(o)) for (let v = 0, M = p.length; v < M; v++) {
      const S = p[v], m = o[S.materialIndex], E = Math.max(S.start, g.start), T = Math.min(u.count, Math.min(S.start + S.count, g.start + g.count));
      for (let C = E, L = T; C < L; C += 3) {
        const b = C, I = C + 1, U = C + 2;
        r = vp(this, m, e, i, f, h, d, b, I, U), r && (r.faceIndex = Math.floor(C / 3), r.face.materialIndex = S.materialIndex, t.push(r));
      }
    }
    else {
      const v = Math.max(0, g.start), M = Math.min(u.count, g.start + g.count);
      for (let S = v, m = M; S < m; S += 3) {
        const E = S, T = S + 1, C = S + 2;
        r = vp(this, o, e, i, f, h, d, E, T, C), r && (r.faceIndex = Math.floor(S / 3), t.push(r));
      }
    }
  }
}
function dU(n18, e, t, i, r, s, o, a) {
  let u;
  if (e.side === Pi ? u = i.intersectTriangle(o, s, r, true, a) : u = i.intersectTriangle(r, s, o, e.side === ro, a), u === null) return null;
  _p.copy(a), _p.applyMatrix4(n18.matrixWorld);
  const f = t.ray.origin.distanceTo(_p);
  return f < t.near || f > t.far ? null : { distance: f, point: _p.clone(), object: n18 };
}
function vp(n18, e, t, i, r, s, o, a, u, f) {
  n18.getVertexPosition(a, Jl), n18.getVertexPosition(u, Kl), n18.getVertexPosition(f, Ql);
  const h = dU(n18, e, t, i, Jl, Kl, Ql, gp);
  if (h) {
    r && (dp.fromBufferAttribute(r, a), pp.fromBufferAttribute(r, u), mp.fromBufferAttribute(r, f), h.uv = or.getInterpolation(gp, Jl, Kl, Ql, dp, pp, mp, new me())), s && (dp.fromBufferAttribute(s, a), pp.fromBufferAttribute(s, u), mp.fromBufferAttribute(s, f), h.uv1 = or.getInterpolation(gp, Jl, Kl, Ql, dp, pp, mp, new me()), h.uv2 = h.uv1), o && (OE.fromBufferAttribute(o, a), FE.fromBufferAttribute(o, u), kE.fromBufferAttribute(o, f), h.normal = or.getInterpolation(gp, Jl, Kl, Ql, OE, FE, kE, new k()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: u, c: f, normal: new k(), materialIndex: 0 };
    or.getNormal(Jl, Kl, Ql, d.normal), h.face = d;
  }
  return h;
}
class yl extends _t {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: o };
    const a = this;
    r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
    const u = [], f = [], h = [], d = [];
    let p = 0, g = 0;
    v("z", "y", "x", -1, -1, i, t, e, o, s, 0), v("z", "y", "x", 1, -1, i, t, -e, o, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, o, 2), v("x", "z", "y", 1, -1, e, i, -t, r, o, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(u), this.setAttribute("position", new Ye(f, 3)), this.setAttribute("normal", new Ye(h, 3)), this.setAttribute("uv", new Ye(d, 2));
    function v(M, S, m, E, T, C, L, b, I, U, B) {
      const R = C / I, D = L / U, j = C / 2, te = L / 2, X = b / 2, Q = I + 1, J = U + 1;
      let ce = 0, V = 0;
      const q = new k();
      for (let Y = 0; Y < J; Y++) {
        const $ = Y * D - te;
        for (let ae = 0; ae < Q; ae++) {
          const Ee = ae * R - j;
          q[M] = Ee * E, q[S] = $ * T, q[m] = X, f.push(q.x, q.y, q.z), q[M] = 0, q[S] = 0, q[m] = b > 0 ? 1 : -1, h.push(q.x, q.y, q.z), d.push(ae / I), d.push(1 - Y / U), ce += 1;
        }
      }
      for (let Y = 0; Y < U; Y++) for (let $ = 0; $ < I; $++) {
        const ae = p + $ + Q * Y, Ee = p + $ + Q * (Y + 1), ne = p + ($ + 1) + Q * (Y + 1), he = p + ($ + 1) + Q * Y;
        u.push(ae, Ee, he), u.push(Ee, ne, he), V += 6;
      }
      a.addGroup(g, V, B), g += V, p += ce;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new yl(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function $u(n18) {
  const e = {};
  for (const t in n18) {
    e[t] = {};
    for (const i in n18[t]) {
      const r = n18[t][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
    }
  }
  return e;
}
function wi(n18) {
  const e = {};
  for (let t = 0; t < n18.length; t++) {
    const i = $u(n18[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function pU(n18) {
  const e = [];
  for (let t = 0; t < n18.length; t++) e.push(n18[t].clone());
  return e;
}
function $2(n18) {
  return n18.getRenderTarget() === null ? n18.outputColorSpace : zt.workingColorSpace;
}
const eP = { clone: $u, merge: wi };
var mU = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, gU = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class es extends vi {
  constructor(e) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = mU, this.fragmentShader = gU, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false, clipCullDistance: false, multiDraw: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = $u(e.uniforms), this.uniformsGroups = pU(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture ? t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[r] = { type: "m4", value: o.toArray() } : t.uniforms[r] = { value: o };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions) this.extensions[r] === true && (i[r] = true);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Dh extends Nt {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new st(), this.projectionMatrix = new st(), this.projectionMatrixInverse = new st(), this.coordinateSystem = ys;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Co = new k(), zE = new me(), BE = new me();
class Xn extends Dh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Qu * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan($a * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Qu * 2 * Math.atan(Math.tan($a * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    Co.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Co.x, Co.y).multiplyScalar(-e / Co.z), Co.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Co.x, Co.y).multiplyScalar(-e / Co.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, zE, BE), t.subVectors(BE, zE);
  }
  setViewOffset(e, t, i, r, s, o) {
    this.aspect = e / t, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan($a * 0.5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const u = o.fullWidth, f = o.fullHeight;
      s += o.offsetX * r / u, t -= o.offsetY * i / f, r *= o.width / u, i *= o.height / f;
    }
    const a = this.filmOffset;
    a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const $l = -90, eu = 1;
class tP extends Nt {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new Xn($l, eu, e, t);
    r.layers = this.layers, this.add(r);
    const s = new Xn($l, eu, e, t);
    s.layers = this.layers, this.add(s);
    const o = new Xn($l, eu, e, t);
    o.layers = this.layers, this.add(o);
    const a = new Xn($l, eu, e, t);
    a.layers = this.layers, this.add(a);
    const u = new Xn($l, eu, e, t);
    u.layers = this.layers, this.add(u);
    const f = new Xn($l, eu, e, t);
    f.layers = this.layers, this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, r, s, o, a, u] = t;
    for (const f of t) this.remove(f);
    if (e === ys) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), u.up.set(0, 1, 0), u.lookAt(0, 0, -1);
    else if (e === lh) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), u.up.set(0, -1, 0), u.lookAt(0, 0, -1);
    else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const f of t) this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [s, o, a, u, f, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), g = e.getActiveMipmapLevel(), v = e.xr.enabled;
    e.xr.enabled = false;
    const M = i.texture.generateMipmaps;
    i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, o), e.setRenderTarget(i, 2, r), e.render(t, a), e.setRenderTarget(i, 3, r), e.render(t, u), e.setRenderTarget(i, 4, r), e.render(t, f), i.texture.generateMipmaps = M, e.setRenderTarget(i, 5, r), e.render(t, h), e.setRenderTarget(d, p, g), e.xr.enabled = v, i.texture.needsPMREMUpdate = true;
  }
}
class Nh extends _n {
  constructor(e, t, i, r, s, o, a, u, f, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : so, super(e, t, i, r, s, o, a, u, f, h), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class nP extends $r {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = true;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    t.encoding !== void 0 && (el("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Ko ? Nn : sr), this.texture = new Nh(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : sn;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new yl(5, 5, 5), s = new es({ name: "CubemapFromEquirect", uniforms: $u(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Pi, blending: $s });
    s.uniforms.tEquirect.value = t;
    const o = new Ln(r, s), a = t.minFilter;
    return t.minFilter === vs && (t.minFilter = sn), new tP(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const j_ = new k(), _U = new k(), vU = new yt();
class Io {
  constructor(e = new k(1, 0, 0), t = 0) {
    this.isPlane = true, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = j_.subVectors(i, t).cross(_U.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(j_), r = this.normal.dot(i);
    if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || vU.getNormalMatrix(e), r = this.coplanarPoint(j_).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Aa = new mi(), yp = new k();
class Uh {
  constructor(e = new Io(), t = new Io(), i = new Io(), r = new Io(), s = new Io(), o = new Io()) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = ys) {
    const i = this.planes, r = e.elements, s = r[0], o = r[1], a = r[2], u = r[3], f = r[4], h = r[5], d = r[6], p = r[7], g = r[8], v = r[9], M = r[10], S = r[11], m = r[12], E = r[13], T = r[14], C = r[15];
    if (i[0].setComponents(u - s, p - f, S - g, C - m).normalize(), i[1].setComponents(u + s, p + f, S + g, C + m).normalize(), i[2].setComponents(u + o, p + h, S + v, C + E).normalize(), i[3].setComponents(u - o, p - h, S - v, C - E).normalize(), i[4].setComponents(u - a, p - d, S - M, C - T).normalize(), t === ys) i[5].setComponents(u + a, p + d, S + M, C + T).normalize();
    else if (t === lh) i[5].setComponents(a, d, M, T).normalize();
    else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), Aa.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), Aa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Aa);
  }
  intersectsSprite(e) {
    return Aa.center.set(0, 0, 0), Aa.radius = 0.7071067811865476, Aa.applyMatrix4(e.matrixWorld), this.intersectsSphere(Aa);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return false;
    return true;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (yp.x = r.normal.x > 0 ? e.max.x : e.min.x, yp.y = r.normal.y > 0 ? e.max.y : e.min.y, yp.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(yp) < 0) return false;
    }
    return true;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function iP() {
  let n18 = null, e = false, t = null, i = null;
  function r(s, o) {
    t(s, o), i = n18.requestAnimationFrame(r);
  }
  return { start: function() {
    e !== true && t !== null && (i = n18.requestAnimationFrame(r), e = true);
  }, stop: function() {
    n18.cancelAnimationFrame(i), e = false;
  }, setAnimationLoop: function(s) {
    t = s;
  }, setContext: function(s) {
    n18 = s;
  } };
}
function yU(n18, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function r(f, h) {
    const d = f.array, p = f.usage, g = d.byteLength, v = n18.createBuffer();
    n18.bindBuffer(h, v), n18.bufferData(h, d, p), f.onUploadCallback();
    let M;
    if (d instanceof Float32Array) M = n18.FLOAT;
    else if (d instanceof Uint16Array) if (f.isFloat16BufferAttribute) if (t) M = n18.HALF_FLOAT;
    else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
    else M = n18.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) M = n18.SHORT;
    else if (d instanceof Uint32Array) M = n18.UNSIGNED_INT;
    else if (d instanceof Int32Array) M = n18.INT;
    else if (d instanceof Int8Array) M = n18.BYTE;
    else if (d instanceof Uint8Array) M = n18.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) M = n18.UNSIGNED_BYTE;
    else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return { buffer: v, type: M, bytesPerElement: d.BYTES_PER_ELEMENT, version: f.version, size: g };
  }
  function s(f, h, d) {
    const p = h.array, g = h._updateRange, v = h.updateRanges;
    if (n18.bindBuffer(d, f), g.count === -1 && v.length === 0 && n18.bufferSubData(d, 0, p), v.length !== 0) {
      for (let M = 0, S = v.length; M < S; M++) {
        const m = v[M];
        t ? n18.bufferSubData(d, m.start * p.BYTES_PER_ELEMENT, p, m.start, m.count) : n18.bufferSubData(d, m.start * p.BYTES_PER_ELEMENT, p.subarray(m.start, m.start + m.count));
      }
      h.clearUpdateRanges();
    }
    g.count !== -1 && (t ? n18.bufferSubData(d, g.offset * p.BYTES_PER_ELEMENT, p, g.offset, g.count) : n18.bufferSubData(d, g.offset * p.BYTES_PER_ELEMENT, p.subarray(g.offset, g.offset + g.count)), g.count = -1), h.onUploadCallback();
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), i.get(f);
  }
  function a(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    const h = i.get(f);
    h && (n18.deleteBuffer(h.buffer), i.delete(f));
  }
  function u(f, h) {
    if (f.isGLBufferAttribute) {
      const p = i.get(f);
      (!p || p.version < f.version) && i.set(f, { buffer: f.buffer, type: f.type, bytesPerElement: f.elementSize, version: f.version });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    const d = i.get(f);
    if (d === void 0) i.set(f, r(f, h));
    else if (d.version < f.version) {
      if (d.size !== f.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      s(d.buffer, f, h), d.version = f.version;
    }
  }
  return { get: o, remove: a, update: u };
}
class pc extends _t {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r };
    const s = e / 2, o = t / 2, a = Math.floor(i), u = Math.floor(r), f = a + 1, h = u + 1, d = e / a, p = t / u, g = [], v = [], M = [], S = [];
    for (let m = 0; m < h; m++) {
      const E = m * p - o;
      for (let T = 0; T < f; T++) {
        const C = T * d - s;
        v.push(C, -E, 0), M.push(0, 0, 1), S.push(T / a), S.push(1 - m / u);
      }
    }
    for (let m = 0; m < u; m++) for (let E = 0; E < a; E++) {
      const T = E + f * m, C = E + f * (m + 1), L = E + 1 + f * (m + 1), b = E + 1 + f * m;
      g.push(T, C, b), g.push(C, L, b);
    }
    this.setIndex(g), this.setAttribute("position", new Ye(v, 3)), this.setAttribute("normal", new Ye(M, 3)), this.setAttribute("uv", new Ye(S, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new pc(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var xU = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, SU = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, MU = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, wU = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, EU = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, TU = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, AU = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, CU = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, RU = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, PU = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, bU = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, LU = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, IU = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, DU = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, NU = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, UU = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, OU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, FU = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, kU = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, zU = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, BU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, VU = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, HU = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, GU = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, WU = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, XU = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, YU = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, qU = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, jU = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, ZU = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, JU = "gl_FragColor = linearToOutputTexel( gl_FragColor );", KU = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, QU = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, $U = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, eO = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, tO = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, nO = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, iO = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, rO = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, sO = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, oO = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, aO = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, lO = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, uO = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, cO = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, fO = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, hO = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, dO = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, pO = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, mO = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, gO = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, _O = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, vO = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, yO = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, xO = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, SO = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, MO = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, wO = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, EO = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, TO = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, AO = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, CO = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, RO = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, PO = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, bO = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, LO = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, IO = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, DO = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, NO = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, UO = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, OO = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, FO = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, kO = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, zO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, BO = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, VO = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, HO = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, GO = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, WO = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, XO = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, YO = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, qO = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, jO = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, ZO = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, JO = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, KO = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, QO = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, $O = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, eF = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, tF = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, nF = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, iF = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, rF = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, sF = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, oF = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, aF = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, lF = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, uF = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, cF = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, fF = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, hF = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, dF = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, pF = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, mF = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, gF = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, _F = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, vF = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const yF = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, xF = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, SF = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, MF = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, wF = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, EF = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, TF = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, AF = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, CF = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, RF = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, PF = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, bF = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, LF = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, IF = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, DF = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, NF = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, UF = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, OF = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, FF = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, kF = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, zF = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, BF = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, VF = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, HF = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, GF = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, WF = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, XF = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, YF = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, qF = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, jF = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, ZF = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JF = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, KF = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, QF = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, gt = { alphahash_fragment: xU, alphahash_pars_fragment: SU, alphamap_fragment: MU, alphamap_pars_fragment: wU, alphatest_fragment: EU, alphatest_pars_fragment: TU, aomap_fragment: AU, aomap_pars_fragment: CU, batching_pars_vertex: RU, batching_vertex: PU, begin_vertex: bU, beginnormal_vertex: LU, bsdfs: IU, iridescence_fragment: DU, bumpmap_pars_fragment: NU, clipping_planes_fragment: UU, clipping_planes_pars_fragment: OU, clipping_planes_pars_vertex: FU, clipping_planes_vertex: kU, color_fragment: zU, color_pars_fragment: BU, color_pars_vertex: VU, color_vertex: HU, common: GU, cube_uv_reflection_fragment: WU, defaultnormal_vertex: XU, displacementmap_pars_vertex: YU, displacementmap_vertex: qU, emissivemap_fragment: jU, emissivemap_pars_fragment: ZU, colorspace_fragment: JU, colorspace_pars_fragment: KU, envmap_fragment: QU, envmap_common_pars_fragment: $U, envmap_pars_fragment: eO, envmap_pars_vertex: tO, envmap_physical_pars_fragment: dO, envmap_vertex: nO, fog_vertex: iO, fog_pars_vertex: rO, fog_fragment: sO, fog_pars_fragment: oO, gradientmap_pars_fragment: aO, lightmap_fragment: lO, lightmap_pars_fragment: uO, lights_lambert_fragment: cO, lights_lambert_pars_fragment: fO, lights_pars_begin: hO, lights_toon_fragment: pO, lights_toon_pars_fragment: mO, lights_phong_fragment: gO, lights_phong_pars_fragment: _O, lights_physical_fragment: vO, lights_physical_pars_fragment: yO, lights_fragment_begin: xO, lights_fragment_maps: SO, lights_fragment_end: MO, logdepthbuf_fragment: wO, logdepthbuf_pars_fragment: EO, logdepthbuf_pars_vertex: TO, logdepthbuf_vertex: AO, map_fragment: CO, map_pars_fragment: RO, map_particle_fragment: PO, map_particle_pars_fragment: bO, metalnessmap_fragment: LO, metalnessmap_pars_fragment: IO, morphcolor_vertex: DO, morphnormal_vertex: NO, morphtarget_pars_vertex: UO, morphtarget_vertex: OO, normal_fragment_begin: FO, normal_fragment_maps: kO, normal_pars_fragment: zO, normal_pars_vertex: BO, normal_vertex: VO, normalmap_pars_fragment: HO, clearcoat_normal_fragment_begin: GO, clearcoat_normal_fragment_maps: WO, clearcoat_pars_fragment: XO, iridescence_pars_fragment: YO, opaque_fragment: qO, packing: jO, premultiplied_alpha_fragment: ZO, project_vertex: JO, dithering_fragment: KO, dithering_pars_fragment: QO, roughnessmap_fragment: $O, roughnessmap_pars_fragment: eF, shadowmap_pars_fragment: tF, shadowmap_pars_vertex: nF, shadowmap_vertex: iF, shadowmask_pars_fragment: rF, skinbase_vertex: sF, skinning_pars_vertex: oF, skinning_vertex: aF, skinnormal_vertex: lF, specularmap_fragment: uF, specularmap_pars_fragment: cF, tonemapping_fragment: fF, tonemapping_pars_fragment: hF, transmission_fragment: dF, transmission_pars_fragment: pF, uv_pars_fragment: mF, uv_pars_vertex: gF, uv_vertex: _F, worldpos_vertex: vF, background_vert: yF, background_frag: xF, backgroundCube_vert: SF, backgroundCube_frag: MF, cube_vert: wF, cube_frag: EF, depth_vert: TF, depth_frag: AF, distanceRGBA_vert: CF, distanceRGBA_frag: RF, equirect_vert: PF, equirect_frag: bF, linedashed_vert: LF, linedashed_frag: IF, meshbasic_vert: DF, meshbasic_frag: NF, meshlambert_vert: UF, meshlambert_frag: OF, meshmatcap_vert: FF, meshmatcap_frag: kF, meshnormal_vert: zF, meshnormal_frag: BF, meshphong_vert: VF, meshphong_frag: HF, meshphysical_vert: GF, meshphysical_frag: WF, meshtoon_vert: XF, meshtoon_frag: YF, points_vert: qF, points_frag: jF, shadow_vert: ZF, shadow_frag: JF, sprite_vert: KF, sprite_frag: QF }, Re = { common: { diffuse: { value: new Oe(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new yt() }, alphaMap: { value: null }, alphaMapTransform: { value: new yt() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new yt() } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new yt() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new yt() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new yt() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new yt() }, normalScale: { value: new me(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new yt() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new yt() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new yt() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new yt() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Oe(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Oe(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new yt() }, alphaTest: { value: 0 }, uvTransform: { value: new yt() } }, sprite: { diffuse: { value: new Oe(16777215) }, opacity: { value: 1 }, center: { value: new me(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new yt() }, alphaMap: { value: null }, alphaMapTransform: { value: new yt() }, alphaTest: { value: 0 } } }, Zr = { basic: { uniforms: wi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.fog]), vertexShader: gt.meshbasic_vert, fragmentShader: gt.meshbasic_frag }, lambert: { uniforms: wi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, { emissive: { value: new Oe(0) } }]), vertexShader: gt.meshlambert_vert, fragmentShader: gt.meshlambert_frag }, phong: { uniforms: wi([Re.common, Re.specularmap, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, Re.lights, { emissive: { value: new Oe(0) }, specular: { value: new Oe(1118481) }, shininess: { value: 30 } }]), vertexShader: gt.meshphong_vert, fragmentShader: gt.meshphong_frag }, standard: { uniforms: wi([Re.common, Re.envmap, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.roughnessmap, Re.metalnessmap, Re.fog, Re.lights, { emissive: { value: new Oe(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: gt.meshphysical_vert, fragmentShader: gt.meshphysical_frag }, toon: { uniforms: wi([Re.common, Re.aomap, Re.lightmap, Re.emissivemap, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.gradientmap, Re.fog, Re.lights, { emissive: { value: new Oe(0) } }]), vertexShader: gt.meshtoon_vert, fragmentShader: gt.meshtoon_frag }, matcap: { uniforms: wi([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, Re.fog, { matcap: { value: null } }]), vertexShader: gt.meshmatcap_vert, fragmentShader: gt.meshmatcap_frag }, points: { uniforms: wi([Re.points, Re.fog]), vertexShader: gt.points_vert, fragmentShader: gt.points_frag }, dashed: { uniforms: wi([Re.common, Re.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: gt.linedashed_vert, fragmentShader: gt.linedashed_frag }, depth: { uniforms: wi([Re.common, Re.displacementmap]), vertexShader: gt.depth_vert, fragmentShader: gt.depth_frag }, normal: { uniforms: wi([Re.common, Re.bumpmap, Re.normalmap, Re.displacementmap, { opacity: { value: 1 } }]), vertexShader: gt.meshnormal_vert, fragmentShader: gt.meshnormal_frag }, sprite: { uniforms: wi([Re.sprite, Re.fog]), vertexShader: gt.sprite_vert, fragmentShader: gt.sprite_frag }, background: { uniforms: { uvTransform: { value: new yt() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: gt.background_vert, fragmentShader: gt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: gt.backgroundCube_vert, fragmentShader: gt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: gt.cube_vert, fragmentShader: gt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: gt.equirect_vert, fragmentShader: gt.equirect_frag }, distanceRGBA: { uniforms: wi([Re.common, Re.displacementmap, { referencePosition: { value: new k() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: gt.distanceRGBA_vert, fragmentShader: gt.distanceRGBA_frag }, shadow: { uniforms: wi([Re.lights, Re.fog, { color: { value: new Oe(0) }, opacity: { value: 1 } }]), vertexShader: gt.shadow_vert, fragmentShader: gt.shadow_frag } };
Zr.physical = { uniforms: wi([Zr.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new yt() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new yt() }, clearcoatNormalScale: { value: new me(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new yt() }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new yt() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new yt() }, sheen: { value: 0 }, sheenColor: { value: new Oe(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new yt() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new yt() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new yt() }, transmissionSamplerSize: { value: new me() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new yt() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Oe(0) }, specularColor: { value: new Oe(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new yt() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new yt() }, anisotropyVector: { value: new me() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new yt() } }]), vertexShader: gt.meshphysical_vert, fragmentShader: gt.meshphysical_frag };
const xp = { r: 0, b: 0, g: 0 };
function $F(n18, e, t, i, r, s, o) {
  const a = new Oe(0);
  let u = s === true ? 0 : 1, f, h, d = null, p = 0, g = null;
  function v(S, m) {
    let E = false, T = m.isScene === true ? m.background : null;
    T && T.isTexture && (T = (m.backgroundBlurriness > 0 ? t : e).get(T)), T === null ? M(a, u) : T && T.isColor && (M(T, 1), E = true);
    const C = n18.xr.getEnvironmentBlendMode();
    C === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : C === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n18.autoClear || E) && n18.clear(n18.autoClearColor, n18.autoClearDepth, n18.autoClearStencil), T && (T.isCubeTexture || T.mapping === hc) ? (h === void 0 && (h = new Ln(new yl(1, 1, 1), new es({ name: "BackgroundCubeMaterial", uniforms: $u(Zr.backgroundCube.uniforms), vertexShader: Zr.backgroundCube.vertexShader, fragmentShader: Zr.backgroundCube.fragmentShader, side: Pi, depthTest: false, depthWrite: false, fog: false })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(L, b, I) {
      this.matrixWorld.copyPosition(I.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(h)), h.material.uniforms.envMap.value = T, h.material.uniforms.flipEnvMap.value = T.isCubeTexture && T.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, h.material.toneMapped = zt.getTransfer(T.colorSpace) !== Yt, (d !== T || p !== T.version || g !== n18.toneMapping) && (h.material.needsUpdate = true, d = T, p = T.version, g = n18.toneMapping), h.layers.enableAll(), S.unshift(h, h.geometry, h.material, 0, 0, null)) : T && T.isTexture && (f === void 0 && (f = new Ln(new pc(2, 2), new es({ name: "BackgroundMaterial", uniforms: $u(Zr.background.uniforms), vertexShader: Zr.background.vertexShader, fragmentShader: Zr.background.fragmentShader, side: ro, depthTest: false, depthWrite: false, fog: false })), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(f)), f.material.uniforms.t2D.value = T, f.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, f.material.toneMapped = zt.getTransfer(T.colorSpace) !== Yt, T.matrixAutoUpdate === true && T.updateMatrix(), f.material.uniforms.uvTransform.value.copy(T.matrix), (d !== T || p !== T.version || g !== n18.toneMapping) && (f.material.needsUpdate = true, d = T, p = T.version, g = n18.toneMapping), f.layers.enableAll(), S.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function M(S, m) {
    S.getRGB(xp, $2(n18)), i.buffers.color.setClear(xp.r, xp.g, xp.b, m, o);
  }
  return { getClearColor: function() {
    return a;
  }, setClearColor: function(S, m = 1) {
    a.set(S), u = m, M(a, u);
  }, getClearAlpha: function() {
    return u;
  }, setClearAlpha: function(S) {
    u = S, M(a, u);
  }, render: v };
}
function ek(n18, e, t, i) {
  const r = n18.getParameter(n18.MAX_VERTEX_ATTRIBS), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, a = {}, u = S(null);
  let f = u, h = false;
  function d(X, Q, J, ce, V) {
    let q = false;
    if (o) {
      const Y = M(ce, J, Q);
      f !== Y && (f = Y, g(f.object)), q = m(X, ce, J, V), q && E(X, ce, J, V);
    } else {
      const Y = Q.wireframe === true;
      (f.geometry !== ce.id || f.program !== J.id || f.wireframe !== Y) && (f.geometry = ce.id, f.program = J.id, f.wireframe = Y, q = true);
    }
    V !== null && t.update(V, n18.ELEMENT_ARRAY_BUFFER), (q || h) && (h = false, U(X, Q, J, ce), V !== null && n18.bindBuffer(n18.ELEMENT_ARRAY_BUFFER, t.get(V).buffer));
  }
  function p() {
    return i.isWebGL2 ? n18.createVertexArray() : s.createVertexArrayOES();
  }
  function g(X) {
    return i.isWebGL2 ? n18.bindVertexArray(X) : s.bindVertexArrayOES(X);
  }
  function v(X) {
    return i.isWebGL2 ? n18.deleteVertexArray(X) : s.deleteVertexArrayOES(X);
  }
  function M(X, Q, J) {
    const ce = J.wireframe === true;
    let V = a[X.id];
    V === void 0 && (V = {}, a[X.id] = V);
    let q = V[Q.id];
    q === void 0 && (q = {}, V[Q.id] = q);
    let Y = q[ce];
    return Y === void 0 && (Y = S(p()), q[ce] = Y), Y;
  }
  function S(X) {
    const Q = [], J = [], ce = [];
    for (let V = 0; V < r; V++) Q[V] = 0, J[V] = 0, ce[V] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: Q, enabledAttributes: J, attributeDivisors: ce, object: X, attributes: {}, index: null };
  }
  function m(X, Q, J, ce) {
    const V = f.attributes, q = Q.attributes;
    let Y = 0;
    const $ = J.getAttributes();
    for (const ae in $) if ($[ae].location >= 0) {
      const ne = V[ae];
      let he = q[ae];
      if (he === void 0 && (ae === "instanceMatrix" && X.instanceMatrix && (he = X.instanceMatrix), ae === "instanceColor" && X.instanceColor && (he = X.instanceColor)), ne === void 0 || ne.attribute !== he || he && ne.data !== he.data) return true;
      Y++;
    }
    return f.attributesNum !== Y || f.index !== ce;
  }
  function E(X, Q, J, ce) {
    const V = {}, q = Q.attributes;
    let Y = 0;
    const $ = J.getAttributes();
    for (const ae in $) if ($[ae].location >= 0) {
      let ne = q[ae];
      ne === void 0 && (ae === "instanceMatrix" && X.instanceMatrix && (ne = X.instanceMatrix), ae === "instanceColor" && X.instanceColor && (ne = X.instanceColor));
      const he = {};
      he.attribute = ne, ne && ne.data && (he.data = ne.data), V[ae] = he, Y++;
    }
    f.attributes = V, f.attributesNum = Y, f.index = ce;
  }
  function T() {
    const X = f.newAttributes;
    for (let Q = 0, J = X.length; Q < J; Q++) X[Q] = 0;
  }
  function C(X) {
    L(X, 0);
  }
  function L(X, Q) {
    const J = f.newAttributes, ce = f.enabledAttributes, V = f.attributeDivisors;
    J[X] = 1, ce[X] === 0 && (n18.enableVertexAttribArray(X), ce[X] = 1), V[X] !== Q && ((i.isWebGL2 ? n18 : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](X, Q), V[X] = Q);
  }
  function b() {
    const X = f.newAttributes, Q = f.enabledAttributes;
    for (let J = 0, ce = Q.length; J < ce; J++) Q[J] !== X[J] && (n18.disableVertexAttribArray(J), Q[J] = 0);
  }
  function I(X, Q, J, ce, V, q, Y) {
    Y === true ? n18.vertexAttribIPointer(X, Q, J, V, q) : n18.vertexAttribPointer(X, Q, J, ce, V, q);
  }
  function U(X, Q, J, ce) {
    if (i.isWebGL2 === false && (X.isInstancedMesh || ce.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
    T();
    const V = ce.attributes, q = J.getAttributes(), Y = Q.defaultAttributeValues;
    for (const $ in q) {
      const ae = q[$];
      if (ae.location >= 0) {
        let Ee = V[$];
        if (Ee === void 0 && ($ === "instanceMatrix" && X.instanceMatrix && (Ee = X.instanceMatrix), $ === "instanceColor" && X.instanceColor && (Ee = X.instanceColor)), Ee !== void 0) {
          const ne = Ee.normalized, he = Ee.itemSize, Ce = t.get(Ee);
          if (Ce === void 0) continue;
          const Ie = Ce.buffer, Ke = Ce.type, Ve = Ce.bytesPerElement, ot = i.isWebGL2 === true && (Ke === n18.INT || Ke === n18.UNSIGNED_INT || Ee.gpuType === bS);
          if (Ee.isInterleavedBufferAttribute) {
            const He = Ee.data, W = He.stride, xe = Ee.offset;
            if (He.isInstancedInterleavedBuffer) {
              for (let de = 0; de < ae.locationSize; de++) L(ae.location + de, He.meshPerAttribute);
              X.isInstancedMesh !== true && ce._maxInstanceCount === void 0 && (ce._maxInstanceCount = He.meshPerAttribute * He.count);
            } else for (let de = 0; de < ae.locationSize; de++) C(ae.location + de);
            n18.bindBuffer(n18.ARRAY_BUFFER, Ie);
            for (let de = 0; de < ae.locationSize; de++) I(ae.location + de, he / ae.locationSize, Ke, ne, W * Ve, (xe + he / ae.locationSize * de) * Ve, ot);
          } else {
            if (Ee.isInstancedBufferAttribute) {
              for (let He = 0; He < ae.locationSize; He++) L(ae.location + He, Ee.meshPerAttribute);
              X.isInstancedMesh !== true && ce._maxInstanceCount === void 0 && (ce._maxInstanceCount = Ee.meshPerAttribute * Ee.count);
            } else for (let He = 0; He < ae.locationSize; He++) C(ae.location + He);
            n18.bindBuffer(n18.ARRAY_BUFFER, Ie);
            for (let He = 0; He < ae.locationSize; He++) I(ae.location + He, he / ae.locationSize, Ke, ne, he * Ve, he / ae.locationSize * He * Ve, ot);
          }
        } else if (Y !== void 0) {
          const ne = Y[$];
          if (ne !== void 0) switch (ne.length) {
            case 2:
              n18.vertexAttrib2fv(ae.location, ne);
              break;
            case 3:
              n18.vertexAttrib3fv(ae.location, ne);
              break;
            case 4:
              n18.vertexAttrib4fv(ae.location, ne);
              break;
            default:
              n18.vertexAttrib1fv(ae.location, ne);
          }
        }
      }
    }
    b();
  }
  function B() {
    j();
    for (const X in a) {
      const Q = a[X];
      for (const J in Q) {
        const ce = Q[J];
        for (const V in ce) v(ce[V].object), delete ce[V];
        delete Q[J];
      }
      delete a[X];
    }
  }
  function R(X) {
    if (a[X.id] === void 0) return;
    const Q = a[X.id];
    for (const J in Q) {
      const ce = Q[J];
      for (const V in ce) v(ce[V].object), delete ce[V];
      delete Q[J];
    }
    delete a[X.id];
  }
  function D(X) {
    for (const Q in a) {
      const J = a[Q];
      if (J[X.id] === void 0) continue;
      const ce = J[X.id];
      for (const V in ce) v(ce[V].object), delete ce[V];
      delete J[X.id];
    }
  }
  function j() {
    te(), h = true, f !== u && (f = u, g(f.object));
  }
  function te() {
    u.geometry = null, u.program = null, u.wireframe = false;
  }
  return { setup: d, reset: j, resetDefaultState: te, dispose: B, releaseStatesOfGeometry: R, releaseStatesOfProgram: D, initAttributes: T, enableAttribute: C, disableUnusedAttributes: b };
}
function tk(n18, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(h) {
    s = h;
  }
  function a(h, d) {
    n18.drawArrays(s, h, d), t.update(d, s, 1);
  }
  function u(h, d, p) {
    if (p === 0) return;
    let g, v;
    if (r) g = n18, v = "drawArraysInstanced";
    else if (g = e.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", g === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    g[v](s, h, d, p), t.update(d, s, p);
  }
  function f(h, d, p) {
    if (p === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null) for (let v = 0; v < p; v++) this.render(h[v], d[v]);
    else {
      g.multiDrawArraysWEBGL(s, h, 0, d, 0, p);
      let v = 0;
      for (let M = 0; M < p; M++) v += d[M];
      t.update(v, s, 1);
    }
  }
  this.setMode = o, this.render = a, this.renderInstances = u, this.renderMultiDraw = f;
}
function nk(n18, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === true) {
      const I = e.get("EXT_texture_filter_anisotropic");
      i = n18.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(I) {
    if (I === "highp") {
      if (n18.getShaderPrecisionFormat(n18.VERTEX_SHADER, n18.HIGH_FLOAT).precision > 0 && n18.getShaderPrecisionFormat(n18.FRAGMENT_SHADER, n18.HIGH_FLOAT).precision > 0) return "highp";
      I = "mediump";
    }
    return I === "mediump" && n18.getShaderPrecisionFormat(n18.VERTEX_SHADER, n18.MEDIUM_FLOAT).precision > 0 && n18.getShaderPrecisionFormat(n18.FRAGMENT_SHADER, n18.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && n18.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const u = s(a);
  u !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", u, "instead."), a = u);
  const f = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === true, d = n18.getParameter(n18.MAX_TEXTURE_IMAGE_UNITS), p = n18.getParameter(n18.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = n18.getParameter(n18.MAX_TEXTURE_SIZE), v = n18.getParameter(n18.MAX_CUBE_MAP_TEXTURE_SIZE), M = n18.getParameter(n18.MAX_VERTEX_ATTRIBS), S = n18.getParameter(n18.MAX_VERTEX_UNIFORM_VECTORS), m = n18.getParameter(n18.MAX_VARYING_VECTORS), E = n18.getParameter(n18.MAX_FRAGMENT_UNIFORM_VECTORS), T = p > 0, C = o || e.has("OES_texture_float"), L = T && C, b = o ? n18.getParameter(n18.MAX_SAMPLES) : 0;
  return { isWebGL2: o, drawBuffers: f, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: h, maxTextures: d, maxVertexTextures: p, maxTextureSize: g, maxCubemapSize: v, maxAttributes: M, maxVertexUniforms: S, maxVaryings: m, maxFragmentUniforms: E, vertexTextures: T, floatFragmentTextures: C, floatVertexTextures: L, maxSamples: b };
}
function ik(n18) {
  const e = this;
  let t = null, i = 0, r = false, s = false;
  const o = new Io(), a = new yt(), u = { value: null, needsUpdate: false };
  this.uniform = u, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const g = d.length !== 0 || p || i !== 0 || r;
    return r = p, i = d.length, g;
  }, this.beginShadows = function() {
    s = true, h(null);
  }, this.endShadows = function() {
    s = false;
  }, this.setGlobalState = function(d, p) {
    t = h(d, p, 0);
  }, this.setState = function(d, p, g) {
    const v = d.clippingPlanes, M = d.clipIntersection, S = d.clipShadows, m = n18.get(d);
    if (!r || v === null || v.length === 0 || s && !S) s ? h(null) : f();
    else {
      const E = s ? 0 : i, T = E * 4;
      let C = m.clippingState || null;
      u.value = C, C = h(v, p, T, g);
      for (let L = 0; L !== T; ++L) C[L] = t[L];
      m.clippingState = C, this.numIntersection = M ? this.numPlanes : 0, this.numPlanes += E;
    }
  };
  function f() {
    u.value !== t && (u.value = t, u.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(d, p, g, v) {
    const M = d !== null ? d.length : 0;
    let S = null;
    if (M !== 0) {
      if (S = u.value, v !== true || S === null) {
        const m = g + M * 4, E = p.matrixWorldInverse;
        a.getNormalMatrix(E), (S === null || S.length < m) && (S = new Float32Array(m));
        for (let T = 0, C = g; T !== M; ++T, C += 4) o.copy(d[T]).applyMatrix4(E, a), o.normal.toArray(S, C), S[C + 3] = o.constant;
      }
      u.value = S, u.needsUpdate = true;
    }
    return e.numPlanes = M, e.numIntersection = 0, S;
  }
}
function rk(n18) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === Kf ? o.mapping = so : a === Qf && (o.mapping = na), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Kf || a === Qf) if (e.has(o)) {
        const u = e.get(o).texture;
        return t(u, o.mapping);
      } else {
        const u = o.image;
        if (u && u.height > 0) {
          const f = new nP(u.height);
          return f.fromEquirectangularTexture(n18, o), e.set(o, f), o.addEventListener("dispose", r), t(f.texture, o.mapping);
        } else return null;
      }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const u = e.get(a);
    u !== void 0 && (e.delete(a), u.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: s };
}
class Oh extends Dh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - e, o = i + e, a = r + t, u = r - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += f * this.view.offsetX, o = s + f * this.view.width, a -= h * this.view.offsetY, u = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, u, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const Au = 4, VE = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Va = 20, Z_ = new Oh(), HE = new Oe();
let J_ = null, K_ = 0, Q_ = 0;
const ka = (1 + Math.sqrt(5)) / 2, tu = 1 / ka, GE = [new k(1, 1, 1), new k(-1, 1, 1), new k(1, 1, -1), new k(-1, 1, -1), new k(0, ka, tu), new k(0, ka, -tu), new k(tu, 0, ka), new k(-tu, 0, ka), new k(ka, tu, 0), new k(-ka, tu, 0)];
class ax {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    J_ = this._renderer.getRenderTarget(), K_ = this._renderer.getActiveCubeFace(), Q_ = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = true, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = YE(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = XE(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(J_, K_, Q_), e.scissorTest = false, Sp(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === so || e.mapping === na ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), J_ = this._renderer.getRenderTarget(), K_ = this._renderer.getActiveCubeFace(), Q_ = this._renderer.getActiveMipmapLevel();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: sn, minFilter: sn, generateMipmaps: false, type: Ku, format: Ti, colorSpace: Rs, depthBuffer: false }, r = WE(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = WE(e, t, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = sk(s)), this._blurMaterial = ok(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Ln(this._lodPlanes[0], e);
    this._renderer.compile(t, Z_);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new Xn(90, 1, t, i), u = [1, -1, 1, 1, 1, 1], f = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, p = h.toneMapping;
    h.getClearColor(HE), h.toneMapping = ws, h.autoClear = false;
    const g = new ca({ name: "PMREM.Background", side: Pi, depthWrite: false, depthTest: false }), v = new Ln(new yl(), g);
    let M = false;
    const S = e.background;
    S ? S.isColor && (g.color.copy(S), e.background = null, M = true) : (g.color.copy(HE), M = true);
    for (let m = 0; m < 6; m++) {
      const E = m % 3;
      E === 0 ? (a.up.set(0, u[m], 0), a.lookAt(f[m], 0, 0)) : E === 1 ? (a.up.set(0, 0, u[m]), a.lookAt(0, f[m], 0)) : (a.up.set(0, u[m], 0), a.lookAt(0, 0, f[m]));
      const T = this._cubeSize;
      Sp(r, E * T, m > 2 ? T : 0, T, T), h.setRenderTarget(r), M && h.render(v, a), h.render(e, a);
    }
    v.geometry.dispose(), v.material.dispose(), h.toneMapping = p, h.autoClear = d, e.background = S;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, r = e.mapping === so || e.mapping === na;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = YE()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = XE());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Ln(this._lodPlanes[0], s), a = s.uniforms;
    a.envMap.value = e;
    const u = this._cubeSize;
    Sp(t, 0, 0, 3 * u, 2 * u), i.setRenderTarget(t), i.render(o, Z_);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = false;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = GE[(r - 1) % GE.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const u = this._renderer, f = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = new Ln(this._lodPlanes[r], f), p = f.uniforms, g = this._sizeLods[i] - 1, v = isFinite(s) ? Math.PI / (2 * g) : 2 * Math.PI / (2 * Va - 1), M = s / v, S = isFinite(s) ? 1 + Math.floor(h * M) : Va;
    S > Va && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${S} samples when the maximum is set to ${Va}`);
    const m = [];
    let E = 0;
    for (let I = 0; I < Va; ++I) {
      const U = I / M, B = Math.exp(-U * U / 2);
      m.push(B), I === 0 ? E += B : I < S && (E += 2 * B);
    }
    for (let I = 0; I < m.length; I++) m[I] = m[I] / E;
    p.envMap.value = e.texture, p.samples.value = S, p.weights.value = m, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a);
    const { _lodMax: T } = this;
    p.dTheta.value = v, p.mipInt.value = T - i;
    const C = this._sizeLods[r], L = 3 * C * (r > T - Au ? r - T + Au : 0), b = 4 * (this._cubeSize - C);
    Sp(t, L, b, 3 * C, 2 * C), u.setRenderTarget(t), u.render(d, Z_);
  }
}
function sk(n18) {
  const e = [], t = [], i = [];
  let r = n18;
  const s = n18 - Au + 1 + VE.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let u = 1 / a;
    o > n18 - Au ? u = VE[o - n18 + Au - 1] : o === 0 && (u = 0), i.push(u);
    const f = 1 / (a - 2), h = -f, d = 1 + f, p = [h, h, d, h, d, d, h, h, d, d, h, d], g = 6, v = 6, M = 3, S = 2, m = 1, E = new Float32Array(M * v * g), T = new Float32Array(S * v * g), C = new Float32Array(m * v * g);
    for (let b = 0; b < g; b++) {
      const I = b % 3 * 2 / 3 - 1, U = b > 2 ? 0 : -1, B = [I, U, 0, I + 2 / 3, U, 0, I + 2 / 3, U + 1, 0, I, U, 0, I + 2 / 3, U + 1, 0, I, U + 1, 0];
      E.set(B, M * v * b), T.set(p, S * v * b);
      const R = [b, b, b, b, b, b];
      C.set(R, m * v * b);
    }
    const L = new _t();
    L.setAttribute("position", new Ot(E, M)), L.setAttribute("uv", new Ot(T, S)), L.setAttribute("faceIndex", new Ot(C, m)), e.push(L), r > Au && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function WE(n18, e, t) {
  const i = new $r(n18, e, t);
  return i.texture.mapping = hc, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
}
function Sp(n18, e, t, i, r) {
  n18.viewport.set(e, t, i, r), n18.scissor.set(e, t, i, r);
}
function ok(n18, e, t) {
  const i = new Float32Array(Va), r = new k(0, 1, 0);
  return new es({ name: "SphericalGaussianBlur", defines: { n: Va, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n18}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: XS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: $s, depthTest: false, depthWrite: false });
}
function XE() {
  return new es({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: XS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: $s, depthTest: false, depthWrite: false });
}
function YE() {
  return new es({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: XS(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: $s, depthTest: false, depthWrite: false });
}
function XS() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function ak(n18) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const u = a.mapping, f = u === Kf || u === Qf, h = u === so || u === na;
      if (f || h) if (a.isRenderTargetTexture && a.needsPMREMUpdate === true) {
        a.needsPMREMUpdate = false;
        let d = e.get(a);
        return t === null && (t = new ax(n18)), d = f ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture;
      } else {
        if (e.has(a)) return e.get(a).texture;
        {
          const d = a.image;
          if (f && d && d.height > 0 || h && d && r(d)) {
            t === null && (t = new ax(n18));
            const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
            return e.set(a, p), a.addEventListener("dispose", s), p.texture;
          } else return null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let u = 0;
    const f = 6;
    for (let h = 0; h < f; h++) a[h] !== void 0 && u++;
    return u === f;
  }
  function s(a) {
    const u = a.target;
    u.removeEventListener("dispose", s);
    const f = e.get(u);
    f !== void 0 && (e.delete(u), f.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return { get: i, dispose: o };
}
function lk(n18) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n18.getExtension("WEBGL_depth_texture") || n18.getExtension("MOZ_WEBGL_depth_texture") || n18.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n18.getExtension("EXT_texture_filter_anisotropic") || n18.getExtension("MOZ_EXT_texture_filter_anisotropic") || n18.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n18.getExtension("WEBGL_compressed_texture_s3tc") || n18.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n18.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n18.getExtension("WEBGL_compressed_texture_pvrtc") || n18.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n18.getExtension(i);
    }
    return e[i] = r, r;
  }
  return { has: function(i) {
    return t(i) !== null;
  }, init: function(i) {
    i.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
  }, get: function(i) {
    const r = t(i);
    return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r;
  } };
}
function uk(n18, e, t, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    for (const v in p.morphAttributes) {
      const M = p.morphAttributes[v];
      for (let S = 0, m = M.length; S < m; S++) e.remove(M[S]);
    }
    p.removeEventListener("dispose", o), delete r[p.id];
    const g = s.get(p);
    g && (e.remove(g), s.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === true && delete p._maxInstanceCount, t.memory.geometries--;
  }
  function a(d, p) {
    return r[p.id] === true || (p.addEventListener("dispose", o), r[p.id] = true, t.memory.geometries++), p;
  }
  function u(d) {
    const p = d.attributes;
    for (const v in p) e.update(p[v], n18.ARRAY_BUFFER);
    const g = d.morphAttributes;
    for (const v in g) {
      const M = g[v];
      for (let S = 0, m = M.length; S < m; S++) e.update(M[S], n18.ARRAY_BUFFER);
    }
  }
  function f(d) {
    const p = [], g = d.index, v = d.attributes.position;
    let M = 0;
    if (g !== null) {
      const E = g.array;
      M = g.version;
      for (let T = 0, C = E.length; T < C; T += 3) {
        const L = E[T + 0], b = E[T + 1], I = E[T + 2];
        p.push(L, b, b, I, I, L);
      }
    } else if (v !== void 0) {
      const E = v.array;
      M = v.version;
      for (let T = 0, C = E.length / 3 - 1; T < C; T += 3) {
        const L = T + 0, b = T + 1, I = T + 2;
        p.push(L, b, b, I, I, L);
      }
    } else return;
    const S = new (Z2(p) ? WS : GS)(p, 1);
    S.version = M;
    const m = s.get(d);
    m && e.remove(m), s.set(d, S);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const g = d.index;
      g !== null && p.version < g.version && f(d);
    } else f(d);
    return s.get(d);
  }
  return { get: a, update: u, getWireframeAttribute: h };
}
function ck(n18, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(g) {
    s = g;
  }
  let a, u;
  function f(g) {
    a = g.type, u = g.bytesPerElement;
  }
  function h(g, v) {
    n18.drawElements(s, v, a, g * u), t.update(v, s, 1);
  }
  function d(g, v, M) {
    if (M === 0) return;
    let S, m;
    if (r) S = n18, m = "drawElementsInstanced";
    else if (S = e.get("ANGLE_instanced_arrays"), m = "drawElementsInstancedANGLE", S === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    S[m](s, v, a, g * u, M), t.update(v, s, M);
  }
  function p(g, v, M) {
    if (M === 0) return;
    const S = e.get("WEBGL_multi_draw");
    if (S === null) for (let m = 0; m < M; m++) this.render(g[m] / u, v[m]);
    else {
      S.multiDrawElementsWEBGL(s, v, 0, a, g, 0, M);
      let m = 0;
      for (let E = 0; E < M; E++) m += v[E];
      t.update(m, s, 1);
    }
  }
  this.setMode = o, this.setIndex = f, this.render = h, this.renderInstances = d, this.renderMultiDraw = p;
}
function fk(n18) {
  const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch (t.calls++, o) {
      case n18.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n18.LINES:
        t.lines += a * (s / 2);
        break;
      case n18.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n18.LINE_LOOP:
        t.lines += a * s;
        break;
      case n18.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return { memory: e, render: t, programs: null, autoReset: true, reset: r, update: i };
}
function hk(n18, e) {
  return n18[0] - e[0];
}
function dk(n18, e) {
  return Math.abs(e[1]) - Math.abs(n18[1]);
}
function pk(n18, e, t) {
  const i = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), o = new Bt(), a = [];
  for (let f = 0; f < 8; f++) a[f] = [f, 0];
  function u(f, h, d) {
    const p = f.morphTargetInfluences;
    if (e.isWebGL2 === true) {
      const v = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, M = v !== void 0 ? v.length : 0;
      let S = s.get(h);
      if (S === void 0 || S.count !== M) {
        let Q = function() {
          te.dispose(), s.delete(h), h.removeEventListener("dispose", Q);
        };
        var g = Q;
        S !== void 0 && S.texture.dispose();
        const T = h.morphAttributes.position !== void 0, C = h.morphAttributes.normal !== void 0, L = h.morphAttributes.color !== void 0, b = h.morphAttributes.position || [], I = h.morphAttributes.normal || [], U = h.morphAttributes.color || [];
        let B = 0;
        T === true && (B = 1), C === true && (B = 2), L === true && (B = 3);
        let R = h.attributes.position.count * B, D = 1;
        R > e.maxTextureSize && (D = Math.ceil(R / e.maxTextureSize), R = e.maxTextureSize);
        const j = new Float32Array(R * D * 4 * M), te = new Cg(j, R, D, M);
        te.type = Dr, te.needsUpdate = true;
        const X = B * 4;
        for (let J = 0; J < M; J++) {
          const ce = b[J], V = I[J], q = U[J], Y = R * D * 4 * J;
          for (let $ = 0; $ < ce.count; $++) {
            const ae = $ * X;
            T === true && (o.fromBufferAttribute(ce, $), j[Y + ae + 0] = o.x, j[Y + ae + 1] = o.y, j[Y + ae + 2] = o.z, j[Y + ae + 3] = 0), C === true && (o.fromBufferAttribute(V, $), j[Y + ae + 4] = o.x, j[Y + ae + 5] = o.y, j[Y + ae + 6] = o.z, j[Y + ae + 7] = 0), L === true && (o.fromBufferAttribute(q, $), j[Y + ae + 8] = o.x, j[Y + ae + 9] = o.y, j[Y + ae + 10] = o.z, j[Y + ae + 11] = q.itemSize === 4 ? o.w : 1);
          }
        }
        S = { count: M, texture: te, size: new me(R, D) }, s.set(h, S), h.addEventListener("dispose", Q);
      }
      let m = 0;
      for (let T = 0; T < p.length; T++) m += p[T];
      const E = h.morphTargetsRelative ? 1 : 1 - m;
      d.getUniforms().setValue(n18, "morphTargetBaseInfluence", E), d.getUniforms().setValue(n18, "morphTargetInfluences", p), d.getUniforms().setValue(n18, "morphTargetsTexture", S.texture, t), d.getUniforms().setValue(n18, "morphTargetsTextureSize", S.size);
    } else {
      const v = p === void 0 ? 0 : p.length;
      let M = i[h.id];
      if (M === void 0 || M.length !== v) {
        M = [];
        for (let C = 0; C < v; C++) M[C] = [C, 0];
        i[h.id] = M;
      }
      for (let C = 0; C < v; C++) {
        const L = M[C];
        L[0] = C, L[1] = p[C];
      }
      M.sort(dk);
      for (let C = 0; C < 8; C++) C < v && M[C][1] ? (a[C][0] = M[C][0], a[C][1] = M[C][1]) : (a[C][0] = Number.MAX_SAFE_INTEGER, a[C][1] = 0);
      a.sort(hk);
      const S = h.morphAttributes.position, m = h.morphAttributes.normal;
      let E = 0;
      for (let C = 0; C < 8; C++) {
        const L = a[C], b = L[0], I = L[1];
        b !== Number.MAX_SAFE_INTEGER && I ? (S && h.getAttribute("morphTarget" + C) !== S[b] && h.setAttribute("morphTarget" + C, S[b]), m && h.getAttribute("morphNormal" + C) !== m[b] && h.setAttribute("morphNormal" + C, m[b]), r[C] = I, E += I) : (S && h.hasAttribute("morphTarget" + C) === true && h.deleteAttribute("morphTarget" + C), m && h.hasAttribute("morphNormal" + C) === true && h.deleteAttribute("morphNormal" + C), r[C] = 0);
      }
      const T = h.morphTargetsRelative ? 1 : 1 - E;
      d.getUniforms().setValue(n18, "morphTargetBaseInfluence", T), d.getUniforms().setValue(n18, "morphTargetInfluences", r);
    }
  }
  return { update: u };
}
function mk(n18, e, t, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(u) {
    const f = i.render.frame, h = u.geometry, d = e.get(u, h);
    if (r.get(d) !== f && (e.update(d), r.set(d, f)), u.isInstancedMesh && (u.hasEventListener("dispose", a) === false && u.addEventListener("dispose", a), r.get(u) !== f && (t.update(u.instanceMatrix, n18.ARRAY_BUFFER), u.instanceColor !== null && t.update(u.instanceColor, n18.ARRAY_BUFFER), r.set(u, f))), u.isSkinnedMesh) {
      const p = u.skeleton;
      r.get(p) !== f && (p.update(), r.set(p, f));
    }
    return d;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function a(u) {
    const f = u.target;
    f.removeEventListener("dispose", a), t.remove(f.instanceMatrix), f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: s, dispose: o };
}
class YS extends _n {
  constructor(e, t, i, r, s, o, a, u, f, h) {
    if (h = h !== void 0 ? h : Jo, h !== Jo && h !== dl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === Jo && (i = Js), i === void 0 && h === dl && (i = Zo), super(null, r, s, o, a, u, h, i, f), this.isDepthTexture = true, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Mn, this.minFilter = u !== void 0 ? u : Mn, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const rP = new _n(), sP = new YS(1, 1);
sP.compareFunction = zS;
const oP = new Cg(), aP = new HS(), lP = new Nh(), qE = [], jE = [], ZE = new Float32Array(16), JE = new Float32Array(9), KE = new Float32Array(4);
function mc(n18, e, t) {
  const i = n18[0];
  if (i <= 0 || i > 0) return n18;
  const r = e * t;
  let s = qE[r];
  if (s === void 0 && (s = new Float32Array(r), qE[r] = s), e !== 0) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) a += t, n18[o].toArray(s, a);
  }
  return s;
}
function On(n18, e) {
  if (n18.length !== e.length) return false;
  for (let t = 0, i = n18.length; t < i; t++) if (n18[t] !== e[t]) return false;
  return true;
}
function Fn(n18, e) {
  for (let t = 0, i = e.length; t < i; t++) n18[t] = e[t];
}
function Rg(n18, e) {
  let t = jE[e];
  t === void 0 && (t = new Int32Array(e), jE[e] = t);
  for (let i = 0; i !== e; ++i) t[i] = n18.allocateTextureUnit();
  return t;
}
function gk(n18, e) {
  const t = this.cache;
  t[0] !== e && (n18.uniform1f(this.addr, e), t[0] = e);
}
function _k(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n18.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (On(t, e)) return;
    n18.uniform2fv(this.addr, e), Fn(t, e);
  }
}
function vk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n18.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n18.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if (On(t, e)) return;
    n18.uniform3fv(this.addr, e), Fn(t, e);
  }
}
function yk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n18.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (On(t, e)) return;
    n18.uniform4fv(this.addr, e), Fn(t, e);
  }
}
function xk(n18, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (On(t, e)) return;
    n18.uniformMatrix2fv(this.addr, false, e), Fn(t, e);
  } else {
    if (On(t, i)) return;
    KE.set(i), n18.uniformMatrix2fv(this.addr, false, KE), Fn(t, i);
  }
}
function Sk(n18, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (On(t, e)) return;
    n18.uniformMatrix3fv(this.addr, false, e), Fn(t, e);
  } else {
    if (On(t, i)) return;
    JE.set(i), n18.uniformMatrix3fv(this.addr, false, JE), Fn(t, i);
  }
}
function Mk(n18, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if (On(t, e)) return;
    n18.uniformMatrix4fv(this.addr, false, e), Fn(t, e);
  } else {
    if (On(t, i)) return;
    ZE.set(i), n18.uniformMatrix4fv(this.addr, false, ZE), Fn(t, i);
  }
}
function wk(n18, e) {
  const t = this.cache;
  t[0] !== e && (n18.uniform1i(this.addr, e), t[0] = e);
}
function Ek(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n18.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (On(t, e)) return;
    n18.uniform2iv(this.addr, e), Fn(t, e);
  }
}
function Tk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n18.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (On(t, e)) return;
    n18.uniform3iv(this.addr, e), Fn(t, e);
  }
}
function Ak(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n18.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (On(t, e)) return;
    n18.uniform4iv(this.addr, e), Fn(t, e);
  }
}
function Ck(n18, e) {
  const t = this.cache;
  t[0] !== e && (n18.uniform1ui(this.addr, e), t[0] = e);
}
function Rk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n18.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if (On(t, e)) return;
    n18.uniform2uiv(this.addr, e), Fn(t, e);
  }
}
function Pk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n18.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if (On(t, e)) return;
    n18.uniform3uiv(this.addr, e), Fn(t, e);
  }
}
function bk(n18, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n18.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if (On(t, e)) return;
    n18.uniform4uiv(this.addr, e), Fn(t, e);
  }
}
function Lk(n18, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n18.uniform1i(this.addr, r), i[0] = r);
  const s = this.type === n18.SAMPLER_2D_SHADOW ? sP : rP;
  t.setTexture2D(e || s, r);
}
function Ik(n18, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n18.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || aP, r);
}
function Dk(n18, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n18.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || lP, r);
}
function Nk(n18, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n18.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || oP, r);
}
function Uk(n18) {
  switch (n18) {
    case 5126:
      return gk;
    case 35664:
      return _k;
    case 35665:
      return vk;
    case 35666:
      return yk;
    case 35674:
      return xk;
    case 35675:
      return Sk;
    case 35676:
      return Mk;
    case 5124:
    case 35670:
      return wk;
    case 35667:
    case 35671:
      return Ek;
    case 35668:
    case 35672:
      return Tk;
    case 35669:
    case 35673:
      return Ak;
    case 5125:
      return Ck;
    case 36294:
      return Rk;
    case 36295:
      return Pk;
    case 36296:
      return bk;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Lk;
    case 35679:
    case 36299:
    case 36307:
      return Ik;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Dk;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return Nk;
  }
}
function Ok(n18, e) {
  n18.uniform1fv(this.addr, e);
}
function Fk(n18, e) {
  const t = mc(e, this.size, 2);
  n18.uniform2fv(this.addr, t);
}
function kk(n18, e) {
  const t = mc(e, this.size, 3);
  n18.uniform3fv(this.addr, t);
}
function zk(n18, e) {
  const t = mc(e, this.size, 4);
  n18.uniform4fv(this.addr, t);
}
function Bk(n18, e) {
  const t = mc(e, this.size, 4);
  n18.uniformMatrix2fv(this.addr, false, t);
}
function Vk(n18, e) {
  const t = mc(e, this.size, 9);
  n18.uniformMatrix3fv(this.addr, false, t);
}
function Hk(n18, e) {
  const t = mc(e, this.size, 16);
  n18.uniformMatrix4fv(this.addr, false, t);
}
function Gk(n18, e) {
  n18.uniform1iv(this.addr, e);
}
function Wk(n18, e) {
  n18.uniform2iv(this.addr, e);
}
function Xk(n18, e) {
  n18.uniform3iv(this.addr, e);
}
function Yk(n18, e) {
  n18.uniform4iv(this.addr, e);
}
function qk(n18, e) {
  n18.uniform1uiv(this.addr, e);
}
function jk(n18, e) {
  n18.uniform2uiv(this.addr, e);
}
function Zk(n18, e) {
  n18.uniform3uiv(this.addr, e);
}
function Jk(n18, e) {
  n18.uniform4uiv(this.addr, e);
}
function Kk(n18, e, t) {
  const i = this.cache, r = e.length, s = Rg(t, r);
  On(i, s) || (n18.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || rP, s[o]);
}
function Qk(n18, e, t) {
  const i = this.cache, r = e.length, s = Rg(t, r);
  On(i, s) || (n18.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || aP, s[o]);
}
function $k(n18, e, t) {
  const i = this.cache, r = e.length, s = Rg(t, r);
  On(i, s) || (n18.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || lP, s[o]);
}
function ez(n18, e, t) {
  const i = this.cache, r = e.length, s = Rg(t, r);
  On(i, s) || (n18.uniform1iv(this.addr, s), Fn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || oP, s[o]);
}
function tz(n18) {
  switch (n18) {
    case 5126:
      return Ok;
    case 35664:
      return Fk;
    case 35665:
      return kk;
    case 35666:
      return zk;
    case 35674:
      return Bk;
    case 35675:
      return Vk;
    case 35676:
      return Hk;
    case 5124:
    case 35670:
      return Gk;
    case 35667:
    case 35671:
      return Wk;
    case 35668:
    case 35672:
      return Xk;
    case 35669:
    case 35673:
      return Yk;
    case 5125:
      return qk;
    case 36294:
      return jk;
    case 36295:
      return Zk;
    case 36296:
      return Jk;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Kk;
    case 35679:
    case 36299:
    case 36307:
      return Qk;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return $k;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return ez;
  }
}
class nz {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = Uk(t.type);
  }
}
class iz {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = tz(t.type);
  }
}
class rz {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const $_ = /(\w+)(\])?(\[|\.)?/g;
function QE(n18, e) {
  n18.seq.push(e), n18.map[e.id] = e;
}
function sz(n18, e, t) {
  const i = n18.name, r = i.length;
  for ($_.lastIndex = 0; ; ) {
    const s = $_.exec(i), o = $_.lastIndex;
    let a = s[1];
    const u = s[2] === "]", f = s[3];
    if (u && (a = a | 0), f === void 0 || f === "[" && o + 2 === r) {
      QE(t, f === void 0 ? new nz(a, n18, e) : new iz(a, n18, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && (d = new rz(a), QE(t, d)), t = d;
    }
  }
}
class pm {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name);
      sz(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s], u = i[a.id];
      u.needsUpdate !== false && a.setValue(e, u.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function $E(n18, e, t) {
  const i = n18.createShader(e);
  return n18.shaderSource(i, t), n18.compileShader(i), i;
}
const oz = 37297;
let az = 0;
function lz(n18, e) {
  const t = n18.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function uz(n18) {
  const e = zt.getPrimaries(zt.workingColorSpace), t = zt.getPrimaries(n18);
  let i;
  switch (e === t ? i = "" : e === oh && t === sh ? i = "LinearDisplayP3ToLinearSRGB" : e === sh && t === oh && (i = "LinearSRGBToLinearDisplayP3"), n18) {
    case Rs:
    case Lh:
      return [i, "LinearTransferOETF"];
    case Nn:
    case Ag:
      return [i, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n18), [i, "LinearTransferOETF"];
  }
}
function eT(n18, e, t) {
  const i = n18.getShaderParameter(e, n18.COMPILE_STATUS), r = n18.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + lz(n18.getShaderSource(e), o);
  } else return r;
}
function cz(n18, e) {
  const t = uz(e);
  return `vec4 ${n18}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function fz(n18, e) {
  let t;
  switch (e) {
    case M2:
      t = "Linear";
      break;
    case w2:
      t = "Reinhard";
      break;
    case E2:
      t = "OptimizedCineon";
      break;
    case PS:
      t = "ACESFilmic";
      break;
    case A2:
      t = "AgX";
      break;
    case T2:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n18 + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function hz(n18) {
  return [n18.extensionDerivatives || n18.envMapCubeUVHeight || n18.bumpMap || n18.normalMapTangentSpace || n18.clearcoatNormalMap || n18.flatShading || n18.alphaToCoverage || n18.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n18.extensionFragDepth || n18.logarithmicDepthBuffer) && n18.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n18.extensionDrawBuffers && n18.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n18.extensionShaderTextureLOD || n18.envMap || n18.transmission) && n18.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Cu).join(`
`);
}
function dz(n18) {
  return [n18.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n18.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Cu).join(`
`);
}
function pz(n18) {
  const e = [];
  for (const t in n18) {
    const i = n18[t];
    i !== false && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function mz(n18, e) {
  const t = {}, i = n18.getProgramParameter(e, n18.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n18.getActiveAttrib(e, r), o = s.name;
    let a = 1;
    s.type === n18.FLOAT_MAT2 && (a = 2), s.type === n18.FLOAT_MAT3 && (a = 3), s.type === n18.FLOAT_MAT4 && (a = 4), t[o] = { type: s.type, location: n18.getAttribLocation(e, o), locationSize: a };
  }
  return t;
}
function Cu(n18) {
  return n18 !== "";
}
function tT(n18, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n18.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function nT(n18, e) {
  return n18.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const gz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function lx(n18) {
  return n18.replace(gz, vz);
}
const _z = /* @__PURE__ */ new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function vz(n18, e) {
  let t = gt[e];
  if (t === void 0) {
    const i = _z.get(e);
    if (i !== void 0) t = gt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return lx(t);
}
const yz = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function iT(n18) {
  return n18.replace(yz, xz);
}
function xz(n18, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function rT(n18) {
  let e = `precision ${n18.precision} float;
	precision ${n18.precision} int;
	precision ${n18.precision} sampler2D;
	precision ${n18.precision} samplerCube;
	`;
  return n18.isWebGL2 && (e += `precision ${n18.precision} sampler3D;
		precision ${n18.precision} sampler2DArray;
		precision ${n18.precision} sampler2DShadow;
		precision ${n18.precision} samplerCubeShadow;
		precision ${n18.precision} sampler2DArrayShadow;
		precision ${n18.precision} isampler2D;
		precision ${n18.precision} isampler3D;
		precision ${n18.precision} isamplerCube;
		precision ${n18.precision} isampler2DArray;
		precision ${n18.precision} usampler2D;
		precision ${n18.precision} usampler3D;
		precision ${n18.precision} usamplerCube;
		precision ${n18.precision} usampler2DArray;
		`), n18.precision === "highp" ? e += `
#define HIGH_PRECISION` : n18.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n18.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function Sz(n18) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n18.shadowMapType === Mg ? e = "SHADOWMAP_TYPE_PCF" : n18.shadowMapType === Tf ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n18.shadowMapType === Yr && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function Mz(n18) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n18.envMap) switch (n18.envMapMode) {
    case so:
    case na:
      e = "ENVMAP_TYPE_CUBE";
      break;
    case hc:
      e = "ENVMAP_TYPE_CUBE_UV";
      break;
  }
  return e;
}
function wz(n18) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n18.envMap) switch (n18.envMapMode) {
    case na:
      e = "ENVMAP_MODE_REFRACTION";
      break;
  }
  return e;
}
function Ez(n18) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n18.envMap) switch (n18.combine) {
    case bh:
      e = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case x2:
      e = "ENVMAP_BLENDING_MIX";
      break;
    case S2:
      e = "ENVMAP_BLENDING_ADD";
      break;
  }
  return e;
}
function Tz(n18) {
  const e = n18.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function Az(n18, e, t, i) {
  const r = n18.getContext(), s = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const u = Sz(t), f = Mz(t), h = wz(t), d = Ez(t), p = Tz(t), g = t.isWebGL2 ? "" : hz(t), v = dz(t), M = pz(s), S = r.createProgram();
  let m, E, T = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, M].filter(Cu).join(`
`), m.length > 0 && (m += `
`), E = [g, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, M].filter(Cu).join(`
`), E.length > 0 && (E += `
`)) : (m = [rT(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, M, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Cu).join(`
`), E = [g, rT(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, M, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + u : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== ws ? "#define TONE_MAPPING" : "", t.toneMapping !== ws ? gt.tonemapping_pars_fragment : "", t.toneMapping !== ws ? fz("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", gt.colorspace_pars_fragment, cz("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Cu).join(`
`)), o = lx(o), o = tT(o, t), o = nT(o, t), a = lx(a), a = tT(a, t), a = nT(a, t), o = iT(o), a = iT(a), t.isWebGL2 && t.isRawShaderMaterial !== true && (T = `#version 300 es
`, m = [v, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, E = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === rx ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === rx ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + E);
  const C = T + m + o, L = T + E + a, b = $E(r, r.VERTEX_SHADER, C), I = $E(r, r.FRAGMENT_SHADER, L);
  r.attachShader(S, b), r.attachShader(S, I), t.index0AttributeName !== void 0 ? r.bindAttribLocation(S, 0, t.index0AttributeName) : t.morphTargets === true && r.bindAttribLocation(S, 0, "position"), r.linkProgram(S);
  function U(j) {
    if (n18.debug.checkShaderErrors) {
      const te = r.getProgramInfoLog(S).trim(), X = r.getShaderInfoLog(b).trim(), Q = r.getShaderInfoLog(I).trim();
      let J = true, ce = true;
      if (r.getProgramParameter(S, r.LINK_STATUS) === false) if (J = false, typeof n18.debug.onShaderError == "function") n18.debug.onShaderError(r, S, b, I);
      else {
        const V = eT(r, b, "vertex"), q = eT(r, I, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(S, r.VALIDATE_STATUS) + `

Material Name: ` + j.name + `
Material Type: ` + j.type + `

Program Info Log: ` + te + `
` + V + `
` + q);
      }
      else te !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", te) : (X === "" || Q === "") && (ce = false);
      ce && (j.diagnostics = { runnable: J, programLog: te, vertexShader: { log: X, prefix: m }, fragmentShader: { log: Q, prefix: E } });
    }
    r.deleteShader(b), r.deleteShader(I), B = new pm(r, S), R = mz(r, S);
  }
  let B;
  this.getUniforms = function() {
    return B === void 0 && U(this), B;
  };
  let R;
  this.getAttributes = function() {
    return R === void 0 && U(this), R;
  };
  let D = t.rendererExtensionParallelShaderCompile === false;
  return this.isReady = function() {
    return D === false && (D = r.getProgramParameter(S, oz)), D;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(S), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = az++, this.cacheKey = e, this.usedTimes = 1, this.program = S, this.vertexShader = b, this.fragmentShader = I, this;
}
let Cz = 0;
class Rz {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(r) === false && (o.add(r), r.usedTimes++), o.has(s) === false && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new Pz(e), t.set(e, i)), i;
  }
}
class Pz {
  constructor(e) {
    this.id = Cz++, this.code = e, this.usedTimes = 0;
  }
}
function bz(n18, e, t, i, r, s, o) {
  const a = new tl(), u = new Rz(), f = /* @__PURE__ */ new Set(), h = [], d = r.isWebGL2, p = r.logarithmicDepthBuffer, g = r.vertexTextures;
  let v = r.precision;
  const M = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function S(R) {
    return f.add(R), R === 0 ? "uv" : `uv${R}`;
  }
  function m(R, D, j, te, X) {
    const Q = te.fog, J = X.geometry, ce = R.isMeshStandardMaterial ? te.environment : null, V = (R.isMeshStandardMaterial ? t : e).get(R.envMap || ce), q = V && V.mapping === hc ? V.image.height : null, Y = M[R.type];
    R.precision !== null && (v = r.getMaxPrecision(R.precision), v !== R.precision && console.warn("THREE.WebGLProgram.getParameters:", R.precision, "not supported, using", v, "instead."));
    const $ = J.morphAttributes.position || J.morphAttributes.normal || J.morphAttributes.color, ae = $ !== void 0 ? $.length : 0;
    let Ee = 0;
    J.morphAttributes.position !== void 0 && (Ee = 1), J.morphAttributes.normal !== void 0 && (Ee = 2), J.morphAttributes.color !== void 0 && (Ee = 3);
    let ne, he, Ce, Ie;
    if (Y) {
      const kt = Zr[Y];
      ne = kt.vertexShader, he = kt.fragmentShader;
    } else ne = R.vertexShader, he = R.fragmentShader, u.update(R), Ce = u.getVertexShaderID(R), Ie = u.getFragmentShaderID(R);
    const Ke = n18.getRenderTarget(), Ve = X.isInstancedMesh === true, ot = X.isBatchedMesh === true, He = !!R.map, W = !!R.matcap, xe = !!V, de = !!R.aoMap, Me = !!R.lightMap, pe = !!R.bumpMap, Je = !!R.normalMap, De = !!R.displacementMap, O = !!R.emissiveMap, N = !!R.metalnessMap, ie = !!R.roughnessMap, ye = R.anisotropy > 0, _e = R.clearcoat > 0, ge = R.iridescence > 0, We = R.sheen > 0, Pe = R.transmission > 0, Fe = ye && !!R.anisotropyMap, tt = _e && !!R.clearcoatMap, ft = _e && !!R.clearcoatNormalMap, ve = _e && !!R.clearcoatRoughnessMap, Ct = ge && !!R.iridescenceMap, xt = ge && !!R.iridescenceThicknessMap, lt = We && !!R.sheenColorMap, Qe = We && !!R.sheenRoughnessMap, Ge = !!R.specularMap, pt = !!R.specularColorMap, bt = !!R.specularIntensityMap, Gt = Pe && !!R.transmissionMap, wt = Pe && !!R.thicknessMap, Ft = !!R.gradientMap, G = !!R.alphaMap, Te = R.alphaTest > 0, Ae = !!R.alphaHash, Xe = !!R.extensions;
    let $e = ws;
    R.toneMapped && (Ke === null || Ke.isXRRenderTarget === true) && ($e = n18.toneMapping);
    const Ut = { isWebGL2: d, shaderID: Y, shaderType: R.type, shaderName: R.name, vertexShader: ne, fragmentShader: he, defines: R.defines, customVertexShaderID: Ce, customFragmentShaderID: Ie, isRawShaderMaterial: R.isRawShaderMaterial === true, glslVersion: R.glslVersion, precision: v, batching: ot, instancing: Ve, instancingColor: Ve && X.instanceColor !== null, supportsVertexTextures: g, outputColorSpace: Ke === null ? n18.outputColorSpace : Ke.isXRRenderTarget === true ? Ke.texture.colorSpace : Rs, alphaToCoverage: !!R.alphaToCoverage, map: He, matcap: W, envMap: xe, envMapMode: xe && V.mapping, envMapCubeUVHeight: q, aoMap: de, lightMap: Me, bumpMap: pe, normalMap: Je, displacementMap: g && De, emissiveMap: O, normalMapObjectSpace: Je && R.normalMapType === V2, normalMapTangentSpace: Je && R.normalMapType === ua, metalnessMap: N, roughnessMap: ie, anisotropy: ye, anisotropyMap: Fe, clearcoat: _e, clearcoatMap: tt, clearcoatNormalMap: ft, clearcoatRoughnessMap: ve, iridescence: ge, iridescenceMap: Ct, iridescenceThicknessMap: xt, sheen: We, sheenColorMap: lt, sheenRoughnessMap: Qe, specularMap: Ge, specularColorMap: pt, specularIntensityMap: bt, transmission: Pe, transmissionMap: Gt, thicknessMap: wt, gradientMap: Ft, opaque: R.transparent === false && R.blending === Qa && R.alphaToCoverage === false, alphaMap: G, alphaTest: Te, alphaHash: Ae, combine: R.combine, mapUv: He && S(R.map.channel), aoMapUv: de && S(R.aoMap.channel), lightMapUv: Me && S(R.lightMap.channel), bumpMapUv: pe && S(R.bumpMap.channel), normalMapUv: Je && S(R.normalMap.channel), displacementMapUv: De && S(R.displacementMap.channel), emissiveMapUv: O && S(R.emissiveMap.channel), metalnessMapUv: N && S(R.metalnessMap.channel), roughnessMapUv: ie && S(R.roughnessMap.channel), anisotropyMapUv: Fe && S(R.anisotropyMap.channel), clearcoatMapUv: tt && S(R.clearcoatMap.channel), clearcoatNormalMapUv: ft && S(R.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ve && S(R.clearcoatRoughnessMap.channel), iridescenceMapUv: Ct && S(R.iridescenceMap.channel), iridescenceThicknessMapUv: xt && S(R.iridescenceThicknessMap.channel), sheenColorMapUv: lt && S(R.sheenColorMap.channel), sheenRoughnessMapUv: Qe && S(R.sheenRoughnessMap.channel), specularMapUv: Ge && S(R.specularMap.channel), specularColorMapUv: pt && S(R.specularColorMap.channel), specularIntensityMapUv: bt && S(R.specularIntensityMap.channel), transmissionMapUv: Gt && S(R.transmissionMap.channel), thicknessMapUv: wt && S(R.thicknessMap.channel), alphaMapUv: G && S(R.alphaMap.channel), vertexTangents: !!J.attributes.tangent && (Je || ye), vertexColors: R.vertexColors, vertexAlphas: R.vertexColors === true && !!J.attributes.color && J.attributes.color.itemSize === 4, pointsUvs: X.isPoints === true && !!J.attributes.uv && (He || G), fog: !!Q, useFog: R.fog === true, fogExp2: !!Q && Q.isFogExp2, flatShading: R.flatShading === true, sizeAttenuation: R.sizeAttenuation === true, logarithmicDepthBuffer: p, skinning: X.isSkinnedMesh === true, morphTargets: J.morphAttributes.position !== void 0, morphNormals: J.morphAttributes.normal !== void 0, morphColors: J.morphAttributes.color !== void 0, morphTargetsCount: ae, morphTextureStride: Ee, numDirLights: D.directional.length, numPointLights: D.point.length, numSpotLights: D.spot.length, numSpotLightMaps: D.spotLightMap.length, numRectAreaLights: D.rectArea.length, numHemiLights: D.hemi.length, numDirLightShadows: D.directionalShadowMap.length, numPointLightShadows: D.pointShadowMap.length, numSpotLightShadows: D.spotShadowMap.length, numSpotLightShadowsWithMaps: D.numSpotLightShadowsWithMaps, numLightProbes: D.numLightProbes, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: R.dithering, shadowMapEnabled: n18.shadowMap.enabled && j.length > 0, shadowMapType: n18.shadowMap.type, toneMapping: $e, useLegacyLights: n18._useLegacyLights, decodeVideoTexture: He && R.map.isVideoTexture === true && zt.getTransfer(R.map.colorSpace) === Yt, premultipliedAlpha: R.premultipliedAlpha, doubleSided: R.side === gs, flipSided: R.side === Pi, useDepthPacking: R.depthPacking >= 0, depthPacking: R.depthPacking || 0, index0AttributeName: R.index0AttributeName, extensionDerivatives: Xe && R.extensions.derivatives === true, extensionFragDepth: Xe && R.extensions.fragDepth === true, extensionDrawBuffers: Xe && R.extensions.drawBuffers === true, extensionShaderTextureLOD: Xe && R.extensions.shaderTextureLOD === true, extensionClipCullDistance: Xe && R.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"), extensionMultiDraw: Xe && R.extensions.multiDraw === true && i.has("WEBGL_multi_draw"), rendererExtensionFragDepth: d || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"), rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"), customProgramCacheKey: R.customProgramCacheKey() };
    return Ut.vertexUv1s = f.has(1), Ut.vertexUv2s = f.has(2), Ut.vertexUv3s = f.has(3), f.clear(), Ut;
  }
  function E(R) {
    const D = [];
    if (R.shaderID ? D.push(R.shaderID) : (D.push(R.customVertexShaderID), D.push(R.customFragmentShaderID)), R.defines !== void 0) for (const j in R.defines) D.push(j), D.push(R.defines[j]);
    return R.isRawShaderMaterial === false && (T(D, R), C(D, R), D.push(n18.outputColorSpace)), D.push(R.customProgramCacheKey), D.join();
  }
  function T(R, D) {
    R.push(D.precision), R.push(D.outputColorSpace), R.push(D.envMapMode), R.push(D.envMapCubeUVHeight), R.push(D.mapUv), R.push(D.alphaMapUv), R.push(D.lightMapUv), R.push(D.aoMapUv), R.push(D.bumpMapUv), R.push(D.normalMapUv), R.push(D.displacementMapUv), R.push(D.emissiveMapUv), R.push(D.metalnessMapUv), R.push(D.roughnessMapUv), R.push(D.anisotropyMapUv), R.push(D.clearcoatMapUv), R.push(D.clearcoatNormalMapUv), R.push(D.clearcoatRoughnessMapUv), R.push(D.iridescenceMapUv), R.push(D.iridescenceThicknessMapUv), R.push(D.sheenColorMapUv), R.push(D.sheenRoughnessMapUv), R.push(D.specularMapUv), R.push(D.specularColorMapUv), R.push(D.specularIntensityMapUv), R.push(D.transmissionMapUv), R.push(D.thicknessMapUv), R.push(D.combine), R.push(D.fogExp2), R.push(D.sizeAttenuation), R.push(D.morphTargetsCount), R.push(D.morphAttributeCount), R.push(D.numDirLights), R.push(D.numPointLights), R.push(D.numSpotLights), R.push(D.numSpotLightMaps), R.push(D.numHemiLights), R.push(D.numRectAreaLights), R.push(D.numDirLightShadows), R.push(D.numPointLightShadows), R.push(D.numSpotLightShadows), R.push(D.numSpotLightShadowsWithMaps), R.push(D.numLightProbes), R.push(D.shadowMapType), R.push(D.toneMapping), R.push(D.numClippingPlanes), R.push(D.numClipIntersection), R.push(D.depthPacking);
  }
  function C(R, D) {
    a.disableAll(), D.isWebGL2 && a.enable(0), D.supportsVertexTextures && a.enable(1), D.instancing && a.enable(2), D.instancingColor && a.enable(3), D.matcap && a.enable(4), D.envMap && a.enable(5), D.normalMapObjectSpace && a.enable(6), D.normalMapTangentSpace && a.enable(7), D.clearcoat && a.enable(8), D.iridescence && a.enable(9), D.alphaTest && a.enable(10), D.vertexColors && a.enable(11), D.vertexAlphas && a.enable(12), D.vertexUv1s && a.enable(13), D.vertexUv2s && a.enable(14), D.vertexUv3s && a.enable(15), D.vertexTangents && a.enable(16), D.anisotropy && a.enable(17), D.alphaHash && a.enable(18), D.batching && a.enable(19), R.push(a.mask), a.disableAll(), D.fog && a.enable(0), D.useFog && a.enable(1), D.flatShading && a.enable(2), D.logarithmicDepthBuffer && a.enable(3), D.skinning && a.enable(4), D.morphTargets && a.enable(5), D.morphNormals && a.enable(6), D.morphColors && a.enable(7), D.premultipliedAlpha && a.enable(8), D.shadowMapEnabled && a.enable(9), D.useLegacyLights && a.enable(10), D.doubleSided && a.enable(11), D.flipSided && a.enable(12), D.useDepthPacking && a.enable(13), D.dithering && a.enable(14), D.transmission && a.enable(15), D.sheen && a.enable(16), D.opaque && a.enable(17), D.pointsUvs && a.enable(18), D.decodeVideoTexture && a.enable(19), D.alphaToCoverage && a.enable(20), R.push(a.mask);
  }
  function L(R) {
    const D = M[R.type];
    let j;
    if (D) {
      const te = Zr[D];
      j = eP.clone(te.uniforms);
    } else j = R.uniforms;
    return j;
  }
  function b(R, D) {
    let j;
    for (let te = 0, X = h.length; te < X; te++) {
      const Q = h[te];
      if (Q.cacheKey === D) {
        j = Q, ++j.usedTimes;
        break;
      }
    }
    return j === void 0 && (j = new Az(n18, D, R, s), h.push(j)), j;
  }
  function I(R) {
    if (--R.usedTimes === 0) {
      const D = h.indexOf(R);
      h[D] = h[h.length - 1], h.pop(), R.destroy();
    }
  }
  function U(R) {
    u.remove(R);
  }
  function B() {
    u.dispose();
  }
  return { getParameters: m, getProgramCacheKey: E, getUniforms: L, acquireProgram: b, releaseProgram: I, releaseShaderCache: U, programs: h, dispose: B };
}
function Lz() {
  let n18 = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let o = n18.get(s);
    return o === void 0 && (o = {}, n18.set(s, o)), o;
  }
  function t(s) {
    n18.delete(s);
  }
  function i(s, o, a) {
    n18.get(s)[o] = a;
  }
  function r() {
    n18 = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function Iz(n18, e) {
  return n18.groupOrder !== e.groupOrder ? n18.groupOrder - e.groupOrder : n18.renderOrder !== e.renderOrder ? n18.renderOrder - e.renderOrder : n18.material.id !== e.material.id ? n18.material.id - e.material.id : n18.z !== e.z ? n18.z - e.z : n18.id - e.id;
}
function sT(n18, e) {
  return n18.groupOrder !== e.groupOrder ? n18.groupOrder - e.groupOrder : n18.renderOrder !== e.renderOrder ? n18.renderOrder - e.renderOrder : n18.z !== e.z ? e.z - n18.z : n18.id - e.id;
}
function oT() {
  const n18 = [];
  let e = 0;
  const t = [], i = [], r = [];
  function s() {
    e = 0, t.length = 0, i.length = 0, r.length = 0;
  }
  function o(d, p, g, v, M, S) {
    let m = n18[e];
    return m === void 0 ? (m = { id: d.id, object: d, geometry: p, material: g, groupOrder: v, renderOrder: d.renderOrder, z: M, group: S }, n18[e] = m) : (m.id = d.id, m.object = d, m.geometry = p, m.material = g, m.groupOrder = v, m.renderOrder = d.renderOrder, m.z = M, m.group = S), e++, m;
  }
  function a(d, p, g, v, M, S) {
    const m = o(d, p, g, v, M, S);
    g.transmission > 0 ? i.push(m) : g.transparent === true ? r.push(m) : t.push(m);
  }
  function u(d, p, g, v, M, S) {
    const m = o(d, p, g, v, M, S);
    g.transmission > 0 ? i.unshift(m) : g.transparent === true ? r.unshift(m) : t.unshift(m);
  }
  function f(d, p) {
    t.length > 1 && t.sort(d || Iz), i.length > 1 && i.sort(p || sT), r.length > 1 && r.sort(p || sT);
  }
  function h() {
    for (let d = e, p = n18.length; d < p; d++) {
      const g = n18[d];
      if (g.id === null) break;
      g.id = null, g.object = null, g.geometry = null, g.material = null, g.group = null;
    }
  }
  return { opaque: t, transmissive: i, transparent: r, init: s, push: a, unshift: u, finish: h, sort: f };
}
function Dz() {
  let n18 = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const s = n18.get(i);
    let o;
    return s === void 0 ? (o = new oT(), n18.set(i, [o])) : r >= s.length ? (o = new oT(), s.push(o)) : o = s[r], o;
  }
  function t() {
    n18 = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, dispose: t };
}
function Nz() {
  const n18 = {};
  return { get: function(e) {
    if (n18[e.id] !== void 0) return n18[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { direction: new k(), color: new Oe() };
        break;
      case "SpotLight":
        t = { position: new k(), direction: new k(), color: new Oe(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        t = { position: new k(), color: new Oe(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        t = { direction: new k(), skyColor: new Oe(), groundColor: new Oe() };
        break;
      case "RectAreaLight":
        t = { color: new Oe(), position: new k(), halfWidth: new k(), halfHeight: new k() };
        break;
    }
    return n18[e.id] = t, t;
  } };
}
function Uz() {
  const n18 = {};
  return { get: function(e) {
    if (n18[e.id] !== void 0) return n18[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me() };
        break;
      case "SpotLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me() };
        break;
      case "PointLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new me(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return n18[e.id] = t, t;
  } };
}
let Oz = 0;
function Fz(n18, e) {
  return (e.castShadow ? 2 : 0) - (n18.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n18.map ? 1 : 0);
}
function kz(n18, e) {
  const t = new Nz(), i = Uz(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let h = 0; h < 9; h++) r.probe.push(new k());
  const s = new k(), o = new st(), a = new st();
  function u(h, d) {
    let p = 0, g = 0, v = 0;
    for (let j = 0; j < 9; j++) r.probe[j].set(0, 0, 0);
    let M = 0, S = 0, m = 0, E = 0, T = 0, C = 0, L = 0, b = 0, I = 0, U = 0, B = 0;
    h.sort(Fz);
    const R = d === true ? Math.PI : 1;
    for (let j = 0, te = h.length; j < te; j++) {
      const X = h[j], Q = X.color, J = X.intensity, ce = X.distance, V = X.shadow && X.shadow.map ? X.shadow.map.texture : null;
      if (X.isAmbientLight) p += Q.r * J * R, g += Q.g * J * R, v += Q.b * J * R;
      else if (X.isLightProbe) {
        for (let q = 0; q < 9; q++) r.probe[q].addScaledVector(X.sh.coefficients[q], J);
        B++;
      } else if (X.isDirectionalLight) {
        const q = t.get(X);
        if (q.color.copy(X.color).multiplyScalar(X.intensity * R), X.castShadow) {
          const Y = X.shadow, $ = i.get(X);
          $.shadowBias = Y.bias, $.shadowNormalBias = Y.normalBias, $.shadowRadius = Y.radius, $.shadowMapSize = Y.mapSize, r.directionalShadow[M] = $, r.directionalShadowMap[M] = V, r.directionalShadowMatrix[M] = X.shadow.matrix, C++;
        }
        r.directional[M] = q, M++;
      } else if (X.isSpotLight) {
        const q = t.get(X);
        q.position.setFromMatrixPosition(X.matrixWorld), q.color.copy(Q).multiplyScalar(J * R), q.distance = ce, q.coneCos = Math.cos(X.angle), q.penumbraCos = Math.cos(X.angle * (1 - X.penumbra)), q.decay = X.decay, r.spot[m] = q;
        const Y = X.shadow;
        if (X.map && (r.spotLightMap[I] = X.map, I++, Y.updateMatrices(X), X.castShadow && U++), r.spotLightMatrix[m] = Y.matrix, X.castShadow) {
          const $ = i.get(X);
          $.shadowBias = Y.bias, $.shadowNormalBias = Y.normalBias, $.shadowRadius = Y.radius, $.shadowMapSize = Y.mapSize, r.spotShadow[m] = $, r.spotShadowMap[m] = V, b++;
        }
        m++;
      } else if (X.isRectAreaLight) {
        const q = t.get(X);
        q.color.copy(Q).multiplyScalar(J), q.halfWidth.set(X.width * 0.5, 0, 0), q.halfHeight.set(0, X.height * 0.5, 0), r.rectArea[E] = q, E++;
      } else if (X.isPointLight) {
        const q = t.get(X);
        if (q.color.copy(X.color).multiplyScalar(X.intensity * R), q.distance = X.distance, q.decay = X.decay, X.castShadow) {
          const Y = X.shadow, $ = i.get(X);
          $.shadowBias = Y.bias, $.shadowNormalBias = Y.normalBias, $.shadowRadius = Y.radius, $.shadowMapSize = Y.mapSize, $.shadowCameraNear = Y.camera.near, $.shadowCameraFar = Y.camera.far, r.pointShadow[S] = $, r.pointShadowMap[S] = V, r.pointShadowMatrix[S] = X.shadow.matrix, L++;
        }
        r.point[S] = q, S++;
      } else if (X.isHemisphereLight) {
        const q = t.get(X);
        q.skyColor.copy(X.color).multiplyScalar(J * R), q.groundColor.copy(X.groundColor).multiplyScalar(J * R), r.hemi[T] = q, T++;
      }
    }
    E > 0 && (e.isWebGL2 ? n18.has("OES_texture_float_linear") === true ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1, r.rectAreaLTC2 = Re.LTC_FLOAT_2) : (r.rectAreaLTC1 = Re.LTC_HALF_1, r.rectAreaLTC2 = Re.LTC_HALF_2) : n18.has("OES_texture_float_linear") === true ? (r.rectAreaLTC1 = Re.LTC_FLOAT_1, r.rectAreaLTC2 = Re.LTC_FLOAT_2) : n18.has("OES_texture_half_float_linear") === true ? (r.rectAreaLTC1 = Re.LTC_HALF_1, r.rectAreaLTC2 = Re.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = g, r.ambient[2] = v;
    const D = r.hash;
    (D.directionalLength !== M || D.pointLength !== S || D.spotLength !== m || D.rectAreaLength !== E || D.hemiLength !== T || D.numDirectionalShadows !== C || D.numPointShadows !== L || D.numSpotShadows !== b || D.numSpotMaps !== I || D.numLightProbes !== B) && (r.directional.length = M, r.spot.length = m, r.rectArea.length = E, r.point.length = S, r.hemi.length = T, r.directionalShadow.length = C, r.directionalShadowMap.length = C, r.pointShadow.length = L, r.pointShadowMap.length = L, r.spotShadow.length = b, r.spotShadowMap.length = b, r.directionalShadowMatrix.length = C, r.pointShadowMatrix.length = L, r.spotLightMatrix.length = b + I - U, r.spotLightMap.length = I, r.numSpotLightShadowsWithMaps = U, r.numLightProbes = B, D.directionalLength = M, D.pointLength = S, D.spotLength = m, D.rectAreaLength = E, D.hemiLength = T, D.numDirectionalShadows = C, D.numPointShadows = L, D.numSpotShadows = b, D.numSpotMaps = I, D.numLightProbes = B, r.version = Oz++);
  }
  function f(h, d) {
    let p = 0, g = 0, v = 0, M = 0, S = 0;
    const m = d.matrixWorldInverse;
    for (let E = 0, T = h.length; E < T; E++) {
      const C = h[E];
      if (C.isDirectionalLight) {
        const L = r.directional[p];
        L.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), L.direction.sub(s), L.direction.transformDirection(m), p++;
      } else if (C.isSpotLight) {
        const L = r.spot[v];
        L.position.setFromMatrixPosition(C.matrixWorld), L.position.applyMatrix4(m), L.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), L.direction.sub(s), L.direction.transformDirection(m), v++;
      } else if (C.isRectAreaLight) {
        const L = r.rectArea[M];
        L.position.setFromMatrixPosition(C.matrixWorld), L.position.applyMatrix4(m), a.identity(), o.copy(C.matrixWorld), o.premultiply(m), a.extractRotation(o), L.halfWidth.set(C.width * 0.5, 0, 0), L.halfHeight.set(0, C.height * 0.5, 0), L.halfWidth.applyMatrix4(a), L.halfHeight.applyMatrix4(a), M++;
      } else if (C.isPointLight) {
        const L = r.point[g];
        L.position.setFromMatrixPosition(C.matrixWorld), L.position.applyMatrix4(m), g++;
      } else if (C.isHemisphereLight) {
        const L = r.hemi[S];
        L.direction.setFromMatrixPosition(C.matrixWorld), L.direction.transformDirection(m), S++;
      }
    }
  }
  return { setup: u, setupView: f, state: r };
}
function aT(n18, e) {
  const t = new kz(n18, e), i = [], r = [];
  function s() {
    i.length = 0, r.length = 0;
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function u(d) {
    t.setup(i, d);
  }
  function f(d) {
    t.setupView(i, d);
  }
  return { init: s, state: { lightsArray: i, shadowsArray: r, lights: t }, setupLights: u, setupLightsView: f, pushLight: o, pushShadow: a };
}
function zz(n18, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let u;
    return a === void 0 ? (u = new aT(n18, e), t.set(s, [u])) : o >= a.length ? (u = new aT(n18, e), a.push(u)) : u = a[o], u;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: r };
}
class qS extends vi {
  constructor(e) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = z2, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class jS extends vi {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const Bz = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, Vz = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Hz(n18, e, t) {
  let i = new Uh();
  const r = new me(), s = new me(), o = new Bt(), a = new qS({ depthPacking: B2 }), u = new jS(), f = {}, h = t.maxTextureSize, d = { [ro]: Pi, [Pi]: ro, [gs]: gs }, p = new es({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new me() }, radius: { value: 4 } }, vertexShader: Bz, fragmentShader: Vz }), g = p.clone();
  g.defines.HORIZONTAL_PASS = 1;
  const v = new _t();
  v.setAttribute("position", new Ot(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const M = new Ln(v, p), S = this;
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = Mg;
  let m = this.type;
  this.render = function(b, I, U) {
    if (S.enabled === false || S.autoUpdate === false && S.needsUpdate === false || b.length === 0) return;
    const B = n18.getRenderTarget(), R = n18.getActiveCubeFace(), D = n18.getActiveMipmapLevel(), j = n18.state;
    j.setBlending($s), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(true), j.setScissorTest(false);
    const te = m !== Yr && this.type === Yr, X = m === Yr && this.type !== Yr;
    for (let Q = 0, J = b.length; Q < J; Q++) {
      const ce = b[Q], V = ce.shadow;
      if (V === void 0) {
        console.warn("THREE.WebGLShadowMap:", ce, "has no shadow.");
        continue;
      }
      if (V.autoUpdate === false && V.needsUpdate === false) continue;
      r.copy(V.mapSize);
      const q = V.getFrameExtents();
      if (r.multiply(q), s.copy(V.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / q.x), r.x = s.x * q.x, V.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / q.y), r.y = s.y * q.y, V.mapSize.y = s.y)), V.map === null || te === true || X === true) {
        const $ = this.type !== Yr ? { minFilter: Mn, magFilter: Mn } : {};
        V.map !== null && V.map.dispose(), V.map = new $r(r.x, r.y, $), V.map.texture.name = ce.name + ".shadowMap", V.camera.updateProjectionMatrix();
      }
      n18.setRenderTarget(V.map), n18.clear();
      const Y = V.getViewportCount();
      for (let $ = 0; $ < Y; $++) {
        const ae = V.getViewport($);
        o.set(s.x * ae.x, s.y * ae.y, s.x * ae.z, s.y * ae.w), j.viewport(o), V.updateMatrices(ce, $), i = V.getFrustum(), C(I, U, V.camera, ce, this.type);
      }
      V.isPointLightShadow !== true && this.type === Yr && E(V, U), V.needsUpdate = false;
    }
    m = this.type, S.needsUpdate = false, n18.setRenderTarget(B, R, D);
  };
  function E(b, I) {
    const U = e.update(M);
    p.defines.VSM_SAMPLES !== b.blurSamples && (p.defines.VSM_SAMPLES = b.blurSamples, g.defines.VSM_SAMPLES = b.blurSamples, p.needsUpdate = true, g.needsUpdate = true), b.mapPass === null && (b.mapPass = new $r(r.x, r.y)), p.uniforms.shadow_pass.value = b.map.texture, p.uniforms.resolution.value = b.mapSize, p.uniforms.radius.value = b.radius, n18.setRenderTarget(b.mapPass), n18.clear(), n18.renderBufferDirect(I, null, U, p, M, null), g.uniforms.shadow_pass.value = b.mapPass.texture, g.uniforms.resolution.value = b.mapSize, g.uniforms.radius.value = b.radius, n18.setRenderTarget(b.map), n18.clear(), n18.renderBufferDirect(I, null, U, g, M, null);
  }
  function T(b, I, U, B) {
    let R = null;
    const D = U.isPointLight === true ? b.customDistanceMaterial : b.customDepthMaterial;
    if (D !== void 0) R = D;
    else if (R = U.isPointLight === true ? u : a, n18.localClippingEnabled && I.clipShadows === true && Array.isArray(I.clippingPlanes) && I.clippingPlanes.length !== 0 || I.displacementMap && I.displacementScale !== 0 || I.alphaMap && I.alphaTest > 0 || I.map && I.alphaTest > 0) {
      const j = R.uuid, te = I.uuid;
      let X = f[j];
      X === void 0 && (X = {}, f[j] = X);
      let Q = X[te];
      Q === void 0 && (Q = R.clone(), X[te] = Q, I.addEventListener("dispose", L)), R = Q;
    }
    if (R.visible = I.visible, R.wireframe = I.wireframe, B === Yr ? R.side = I.shadowSide !== null ? I.shadowSide : I.side : R.side = I.shadowSide !== null ? I.shadowSide : d[I.side], R.alphaMap = I.alphaMap, R.alphaTest = I.alphaTest, R.map = I.map, R.clipShadows = I.clipShadows, R.clippingPlanes = I.clippingPlanes, R.clipIntersection = I.clipIntersection, R.displacementMap = I.displacementMap, R.displacementScale = I.displacementScale, R.displacementBias = I.displacementBias, R.wireframeLinewidth = I.wireframeLinewidth, R.linewidth = I.linewidth, U.isPointLight === true && R.isMeshDistanceMaterial === true) {
      const j = n18.properties.get(R);
      j.light = U;
    }
    return R;
  }
  function C(b, I, U, B, R) {
    if (b.visible === false) return;
    if (b.layers.test(I.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && R === Yr) && (!b.frustumCulled || i.intersectsObject(b))) {
      b.modelViewMatrix.multiplyMatrices(U.matrixWorldInverse, b.matrixWorld);
      const te = e.update(b), X = b.material;
      if (Array.isArray(X)) {
        const Q = te.groups;
        for (let J = 0, ce = Q.length; J < ce; J++) {
          const V = Q[J], q = X[V.materialIndex];
          if (q && q.visible) {
            const Y = T(b, q, B, R);
            b.onBeforeShadow(n18, b, I, U, te, Y, V), n18.renderBufferDirect(U, null, te, Y, b, V), b.onAfterShadow(n18, b, I, U, te, Y, V);
          }
        }
      } else if (X.visible) {
        const Q = T(b, X, B, R);
        b.onBeforeShadow(n18, b, I, U, te, Q, null), n18.renderBufferDirect(U, null, te, Q, b, null), b.onAfterShadow(n18, b, I, U, te, Q, null);
      }
    }
    const j = b.children;
    for (let te = 0, X = j.length; te < X; te++) C(j[te], I, U, B, R);
  }
  function L(b) {
    b.target.removeEventListener("dispose", L);
    for (const U in f) {
      const B = f[U], R = b.target.uuid;
      R in B && (B[R].dispose(), delete B[R]);
    }
  }
}
function Gz(n18, e, t) {
  const i = t.isWebGL2;
  function r() {
    let G = false;
    const Te = new Bt();
    let Ae = null;
    const Xe = new Bt(0, 0, 0, 0);
    return { setMask: function($e) {
      Ae !== $e && !G && (n18.colorMask($e, $e, $e, $e), Ae = $e);
    }, setLocked: function($e) {
      G = $e;
    }, setClear: function($e, Ut, kt, En, yi) {
      yi === true && ($e *= En, Ut *= En, kt *= En), Te.set($e, Ut, kt, En), Xe.equals(Te) === false && (n18.clearColor($e, Ut, kt, En), Xe.copy(Te));
    }, reset: function() {
      G = false, Ae = null, Xe.set(-1, 0, 0, 0);
    } };
  }
  function s() {
    let G = false, Te = null, Ae = null, Xe = null;
    return { setTest: function($e) {
      $e ? Ve(n18.DEPTH_TEST) : ot(n18.DEPTH_TEST);
    }, setMask: function($e) {
      Te !== $e && !G && (n18.depthMask($e), Te = $e);
    }, setFunc: function($e) {
      if (Ae !== $e) {
        switch ($e) {
          case d2:
            n18.depthFunc(n18.NEVER);
            break;
          case p2:
            n18.depthFunc(n18.ALWAYS);
            break;
          case m2:
            n18.depthFunc(n18.LESS);
            break;
          case Jf:
            n18.depthFunc(n18.LEQUAL);
            break;
          case g2:
            n18.depthFunc(n18.EQUAL);
            break;
          case _2:
            n18.depthFunc(n18.GEQUAL);
            break;
          case v2:
            n18.depthFunc(n18.GREATER);
            break;
          case y2:
            n18.depthFunc(n18.NOTEQUAL);
            break;
          default:
            n18.depthFunc(n18.LEQUAL);
        }
        Ae = $e;
      }
    }, setLocked: function($e) {
      G = $e;
    }, setClear: function($e) {
      Xe !== $e && (n18.clearDepth($e), Xe = $e);
    }, reset: function() {
      G = false, Te = null, Ae = null, Xe = null;
    } };
  }
  function o() {
    let G = false, Te = null, Ae = null, Xe = null, $e = null, Ut = null, kt = null, En = null, yi = null;
    return { setTest: function(Ht) {
      G || (Ht ? Ve(n18.STENCIL_TEST) : ot(n18.STENCIL_TEST));
    }, setMask: function(Ht) {
      Te !== Ht && !G && (n18.stencilMask(Ht), Te = Ht);
    }, setFunc: function(Ht, jn, vr) {
      (Ae !== Ht || Xe !== jn || $e !== vr) && (n18.stencilFunc(Ht, jn, vr), Ae = Ht, Xe = jn, $e = vr);
    }, setOp: function(Ht, jn, vr) {
      (Ut !== Ht || kt !== jn || En !== vr) && (n18.stencilOp(Ht, jn, vr), Ut = Ht, kt = jn, En = vr);
    }, setLocked: function(Ht) {
      G = Ht;
    }, setClear: function(Ht) {
      yi !== Ht && (n18.clearStencil(Ht), yi = Ht);
    }, reset: function() {
      G = false, Te = null, Ae = null, Xe = null, $e = null, Ut = null, kt = null, En = null, yi = null;
    } };
  }
  const a = new r(), u = new s(), f = new o(), h = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
  let p = {}, g = {}, v = /* @__PURE__ */ new WeakMap(), M = [], S = null, m = false, E = null, T = null, C = null, L = null, b = null, I = null, U = null, B = new Oe(0, 0, 0), R = 0, D = false, j = null, te = null, X = null, Q = null, J = null;
  const ce = n18.getParameter(n18.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let V = false, q = 0;
  const Y = n18.getParameter(n18.VERSION);
  Y.indexOf("WebGL") !== -1 ? (q = parseFloat(/^WebGL (\d)/.exec(Y)[1]), V = q >= 1) : Y.indexOf("OpenGL ES") !== -1 && (q = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]), V = q >= 2);
  let $ = null, ae = {};
  const Ee = n18.getParameter(n18.SCISSOR_BOX), ne = n18.getParameter(n18.VIEWPORT), he = new Bt().fromArray(Ee), Ce = new Bt().fromArray(ne);
  function Ie(G, Te, Ae, Xe) {
    const $e = new Uint8Array(4), Ut = n18.createTexture();
    n18.bindTexture(G, Ut), n18.texParameteri(G, n18.TEXTURE_MIN_FILTER, n18.NEAREST), n18.texParameteri(G, n18.TEXTURE_MAG_FILTER, n18.NEAREST);
    for (let kt = 0; kt < Ae; kt++) i && (G === n18.TEXTURE_3D || G === n18.TEXTURE_2D_ARRAY) ? n18.texImage3D(Te, 0, n18.RGBA, 1, 1, Xe, 0, n18.RGBA, n18.UNSIGNED_BYTE, $e) : n18.texImage2D(Te + kt, 0, n18.RGBA, 1, 1, 0, n18.RGBA, n18.UNSIGNED_BYTE, $e);
    return Ut;
  }
  const Ke = {};
  Ke[n18.TEXTURE_2D] = Ie(n18.TEXTURE_2D, n18.TEXTURE_2D, 1), Ke[n18.TEXTURE_CUBE_MAP] = Ie(n18.TEXTURE_CUBE_MAP, n18.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (Ke[n18.TEXTURE_2D_ARRAY] = Ie(n18.TEXTURE_2D_ARRAY, n18.TEXTURE_2D_ARRAY, 1, 1), Ke[n18.TEXTURE_3D] = Ie(n18.TEXTURE_3D, n18.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), u.setClear(1), f.setClear(0), Ve(n18.DEPTH_TEST), u.setFunc(Jf), De(false), O(Ty), Ve(n18.CULL_FACE), pe($s);
  function Ve(G) {
    p[G] !== true && (n18.enable(G), p[G] = true);
  }
  function ot(G) {
    p[G] !== false && (n18.disable(G), p[G] = false);
  }
  function He(G, Te) {
    return g[G] !== Te ? (n18.bindFramebuffer(G, Te), g[G] = Te, i && (G === n18.DRAW_FRAMEBUFFER && (g[n18.FRAMEBUFFER] = Te), G === n18.FRAMEBUFFER && (g[n18.DRAW_FRAMEBUFFER] = Te)), true) : false;
  }
  function W(G, Te) {
    let Ae = M, Xe = false;
    if (G) if (Ae = v.get(Te), Ae === void 0 && (Ae = [], v.set(Te, Ae)), G.isWebGLMultipleRenderTargets) {
      const $e = G.texture;
      if (Ae.length !== $e.length || Ae[0] !== n18.COLOR_ATTACHMENT0) {
        for (let Ut = 0, kt = $e.length; Ut < kt; Ut++) Ae[Ut] = n18.COLOR_ATTACHMENT0 + Ut;
        Ae.length = $e.length, Xe = true;
      }
    } else Ae[0] !== n18.COLOR_ATTACHMENT0 && (Ae[0] = n18.COLOR_ATTACHMENT0, Xe = true);
    else Ae[0] !== n18.BACK && (Ae[0] = n18.BACK, Xe = true);
    Xe && (t.isWebGL2 ? n18.drawBuffers(Ae) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ae));
  }
  function xe(G) {
    return S !== G ? (n18.useProgram(G), S = G, true) : false;
  }
  const de = { [Uo]: n18.FUNC_ADD, [QR]: n18.FUNC_SUBTRACT, [$R]: n18.FUNC_REVERSE_SUBTRACT };
  if (i) de[Py] = n18.MIN, de[by] = n18.MAX;
  else {
    const G = e.get("EXT_blend_minmax");
    G !== null && (de[Py] = G.MIN_EXT, de[by] = G.MAX_EXT);
  }
  const Me = { [e2]: n18.ZERO, [t2]: n18.ONE, [n2]: n18.SRC_COLOR, [Wm]: n18.SRC_ALPHA, [l2]: n18.SRC_ALPHA_SATURATE, [o2]: n18.DST_COLOR, [r2]: n18.DST_ALPHA, [i2]: n18.ONE_MINUS_SRC_COLOR, [Xm]: n18.ONE_MINUS_SRC_ALPHA, [a2]: n18.ONE_MINUS_DST_COLOR, [s2]: n18.ONE_MINUS_DST_ALPHA, [u2]: n18.CONSTANT_COLOR, [c2]: n18.ONE_MINUS_CONSTANT_COLOR, [f2]: n18.CONSTANT_ALPHA, [h2]: n18.ONE_MINUS_CONSTANT_ALPHA };
  function pe(G, Te, Ae, Xe, $e, Ut, kt, En, yi, Ht) {
    if (G === $s) {
      m === true && (ot(n18.BLEND), m = false);
      return;
    }
    if (m === false && (Ve(n18.BLEND), m = true), G !== KR) {
      if (G !== E || Ht !== D) {
        if ((T !== Uo || b !== Uo) && (n18.blendEquation(n18.FUNC_ADD), T = Uo, b = Uo), Ht) switch (G) {
          case Qa:
            n18.blendFuncSeparate(n18.ONE, n18.ONE_MINUS_SRC_ALPHA, n18.ONE, n18.ONE_MINUS_SRC_ALPHA);
            break;
          case Ay:
            n18.blendFunc(n18.ONE, n18.ONE);
            break;
          case Cy:
            n18.blendFuncSeparate(n18.ZERO, n18.ONE_MINUS_SRC_COLOR, n18.ZERO, n18.ONE);
            break;
          case Ry:
            n18.blendFuncSeparate(n18.ZERO, n18.SRC_COLOR, n18.ZERO, n18.SRC_ALPHA);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", G);
            break;
        }
        else switch (G) {
          case Qa:
            n18.blendFuncSeparate(n18.SRC_ALPHA, n18.ONE_MINUS_SRC_ALPHA, n18.ONE, n18.ONE_MINUS_SRC_ALPHA);
            break;
          case Ay:
            n18.blendFunc(n18.SRC_ALPHA, n18.ONE);
            break;
          case Cy:
            n18.blendFuncSeparate(n18.ZERO, n18.ONE_MINUS_SRC_COLOR, n18.ZERO, n18.ONE);
            break;
          case Ry:
            n18.blendFunc(n18.ZERO, n18.SRC_COLOR);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", G);
            break;
        }
        C = null, L = null, I = null, U = null, B.set(0, 0, 0), R = 0, E = G, D = Ht;
      }
      return;
    }
    $e = $e || Te, Ut = Ut || Ae, kt = kt || Xe, (Te !== T || $e !== b) && (n18.blendEquationSeparate(de[Te], de[$e]), T = Te, b = $e), (Ae !== C || Xe !== L || Ut !== I || kt !== U) && (n18.blendFuncSeparate(Me[Ae], Me[Xe], Me[Ut], Me[kt]), C = Ae, L = Xe, I = Ut, U = kt), (En.equals(B) === false || yi !== R) && (n18.blendColor(En.r, En.g, En.b, yi), B.copy(En), R = yi), E = G, D = false;
  }
  function Je(G, Te) {
    G.side === gs ? ot(n18.CULL_FACE) : Ve(n18.CULL_FACE);
    let Ae = G.side === Pi;
    Te && (Ae = !Ae), De(Ae), G.blending === Qa && G.transparent === false ? pe($s) : pe(G.blending, G.blendEquation, G.blendSrc, G.blendDst, G.blendEquationAlpha, G.blendSrcAlpha, G.blendDstAlpha, G.blendColor, G.blendAlpha, G.premultipliedAlpha), u.setFunc(G.depthFunc), u.setTest(G.depthTest), u.setMask(G.depthWrite), a.setMask(G.colorWrite);
    const Xe = G.stencilWrite;
    f.setTest(Xe), Xe && (f.setMask(G.stencilWriteMask), f.setFunc(G.stencilFunc, G.stencilRef, G.stencilFuncMask), f.setOp(G.stencilFail, G.stencilZFail, G.stencilZPass)), ie(G.polygonOffset, G.polygonOffsetFactor, G.polygonOffsetUnits), G.alphaToCoverage === true ? Ve(n18.SAMPLE_ALPHA_TO_COVERAGE) : ot(n18.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function De(G) {
    j !== G && (G ? n18.frontFace(n18.CW) : n18.frontFace(n18.CCW), j = G);
  }
  function O(G) {
    G !== jR ? (Ve(n18.CULL_FACE), G !== te && (G === Ty ? n18.cullFace(n18.BACK) : G === ZR ? n18.cullFace(n18.FRONT) : n18.cullFace(n18.FRONT_AND_BACK))) : ot(n18.CULL_FACE), te = G;
  }
  function N(G) {
    G !== X && (V && n18.lineWidth(G), X = G);
  }
  function ie(G, Te, Ae) {
    G ? (Ve(n18.POLYGON_OFFSET_FILL), (Q !== Te || J !== Ae) && (n18.polygonOffset(Te, Ae), Q = Te, J = Ae)) : ot(n18.POLYGON_OFFSET_FILL);
  }
  function ye(G) {
    G ? Ve(n18.SCISSOR_TEST) : ot(n18.SCISSOR_TEST);
  }
  function _e(G) {
    G === void 0 && (G = n18.TEXTURE0 + ce - 1), $ !== G && (n18.activeTexture(G), $ = G);
  }
  function ge(G, Te, Ae) {
    Ae === void 0 && ($ === null ? Ae = n18.TEXTURE0 + ce - 1 : Ae = $);
    let Xe = ae[Ae];
    Xe === void 0 && (Xe = { type: void 0, texture: void 0 }, ae[Ae] = Xe), (Xe.type !== G || Xe.texture !== Te) && ($ !== Ae && (n18.activeTexture(Ae), $ = Ae), n18.bindTexture(G, Te || Ke[G]), Xe.type = G, Xe.texture = Te);
  }
  function We() {
    const G = ae[$];
    G !== void 0 && G.type !== void 0 && (n18.bindTexture(G.type, null), G.type = void 0, G.texture = void 0);
  }
  function Pe() {
    try {
      n18.compressedTexImage2D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function Fe() {
    try {
      n18.compressedTexImage3D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function tt() {
    try {
      n18.texSubImage2D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function ft() {
    try {
      n18.texSubImage3D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function ve() {
    try {
      n18.compressedTexSubImage2D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function Ct() {
    try {
      n18.compressedTexSubImage3D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function xt() {
    try {
      n18.texStorage2D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function lt() {
    try {
      n18.texStorage3D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function Qe() {
    try {
      n18.texImage2D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function Ge() {
    try {
      n18.texImage3D.apply(n18, arguments);
    } catch (G) {
      console.error("THREE.WebGLState:", G);
    }
  }
  function pt(G) {
    he.equals(G) === false && (n18.scissor(G.x, G.y, G.z, G.w), he.copy(G));
  }
  function bt(G) {
    Ce.equals(G) === false && (n18.viewport(G.x, G.y, G.z, G.w), Ce.copy(G));
  }
  function Gt(G, Te) {
    let Ae = d.get(Te);
    Ae === void 0 && (Ae = /* @__PURE__ */ new WeakMap(), d.set(Te, Ae));
    let Xe = Ae.get(G);
    Xe === void 0 && (Xe = n18.getUniformBlockIndex(Te, G.name), Ae.set(G, Xe));
  }
  function wt(G, Te) {
    const Xe = d.get(Te).get(G);
    h.get(Te) !== Xe && (n18.uniformBlockBinding(Te, Xe, G.__bindingPointIndex), h.set(Te, Xe));
  }
  function Ft() {
    n18.disable(n18.BLEND), n18.disable(n18.CULL_FACE), n18.disable(n18.DEPTH_TEST), n18.disable(n18.POLYGON_OFFSET_FILL), n18.disable(n18.SCISSOR_TEST), n18.disable(n18.STENCIL_TEST), n18.disable(n18.SAMPLE_ALPHA_TO_COVERAGE), n18.blendEquation(n18.FUNC_ADD), n18.blendFunc(n18.ONE, n18.ZERO), n18.blendFuncSeparate(n18.ONE, n18.ZERO, n18.ONE, n18.ZERO), n18.blendColor(0, 0, 0, 0), n18.colorMask(true, true, true, true), n18.clearColor(0, 0, 0, 0), n18.depthMask(true), n18.depthFunc(n18.LESS), n18.clearDepth(1), n18.stencilMask(4294967295), n18.stencilFunc(n18.ALWAYS, 0, 4294967295), n18.stencilOp(n18.KEEP, n18.KEEP, n18.KEEP), n18.clearStencil(0), n18.cullFace(n18.BACK), n18.frontFace(n18.CCW), n18.polygonOffset(0, 0), n18.activeTexture(n18.TEXTURE0), n18.bindFramebuffer(n18.FRAMEBUFFER, null), i === true && (n18.bindFramebuffer(n18.DRAW_FRAMEBUFFER, null), n18.bindFramebuffer(n18.READ_FRAMEBUFFER, null)), n18.useProgram(null), n18.lineWidth(1), n18.scissor(0, 0, n18.canvas.width, n18.canvas.height), n18.viewport(0, 0, n18.canvas.width, n18.canvas.height), p = {}, $ = null, ae = {}, g = {}, v = /* @__PURE__ */ new WeakMap(), M = [], S = null, m = false, E = null, T = null, C = null, L = null, b = null, I = null, U = null, B = new Oe(0, 0, 0), R = 0, D = false, j = null, te = null, X = null, Q = null, J = null, he.set(0, 0, n18.canvas.width, n18.canvas.height), Ce.set(0, 0, n18.canvas.width, n18.canvas.height), a.reset(), u.reset(), f.reset();
  }
  return { buffers: { color: a, depth: u, stencil: f }, enable: Ve, disable: ot, bindFramebuffer: He, drawBuffers: W, useProgram: xe, setBlending: pe, setMaterial: Je, setFlipSided: De, setCullFace: O, setLineWidth: N, setPolygonOffset: ie, setScissorTest: ye, activeTexture: _e, bindTexture: ge, unbindTexture: We, compressedTexImage2D: Pe, compressedTexImage3D: Fe, texImage2D: Qe, texImage3D: Ge, updateUBOMapping: Gt, uniformBlockBinding: wt, texStorage2D: xt, texStorage3D: lt, texSubImage2D: tt, texSubImage3D: ft, compressedTexSubImage2D: ve, compressedTexSubImage3D: Ct, scissor: pt, viewport: bt, reset: Ft };
}
function Wz(n18, e, t, i, r, s, o) {
  const a = r.isWebGL2, u = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let g = false;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(O, N) {
    return g ? new OffscreenCanvas(O, N) : uh("canvas");
  }
  function M(O, N, ie, ye) {
    let _e = 1;
    if ((O.width > ye || O.height > ye) && (_e = ye / Math.max(O.width, O.height)), _e < 1 || N === true) if (typeof HTMLImageElement < "u" && O instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && O instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && O instanceof ImageBitmap) {
      const ge = N ? jm : Math.floor, We = ge(_e * O.width), Pe = ge(_e * O.height);
      d === void 0 && (d = v(We, Pe));
      const Fe = ie ? v(We, Pe) : d;
      return Fe.width = We, Fe.height = Pe, Fe.getContext("2d").drawImage(O, 0, 0, We, Pe), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + O.width + "x" + O.height + ") to (" + We + "x" + Pe + ")."), Fe;
    } else return "data" in O && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + O.width + "x" + O.height + ")."), O;
    return O;
  }
  function S(O) {
    return sx(O.width) && sx(O.height);
  }
  function m(O) {
    return a ? false : O.wrapS !== hi || O.wrapT !== hi || O.minFilter !== Mn && O.minFilter !== sn;
  }
  function E(O, N) {
    return O.generateMipmaps && N && O.minFilter !== Mn && O.minFilter !== sn;
  }
  function T(O) {
    n18.generateMipmap(O);
  }
  function C(O, N, ie, ye, _e = false) {
    if (a === false) return N;
    if (O !== null) {
      if (n18[O] !== void 0) return n18[O];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + O + "'");
    }
    let ge = N;
    if (N === n18.RED && (ie === n18.FLOAT && (ge = n18.R32F), ie === n18.HALF_FLOAT && (ge = n18.R16F), ie === n18.UNSIGNED_BYTE && (ge = n18.R8)), N === n18.RED_INTEGER && (ie === n18.UNSIGNED_BYTE && (ge = n18.R8UI), ie === n18.UNSIGNED_SHORT && (ge = n18.R16UI), ie === n18.UNSIGNED_INT && (ge = n18.R32UI), ie === n18.BYTE && (ge = n18.R8I), ie === n18.SHORT && (ge = n18.R16I), ie === n18.INT && (ge = n18.R32I)), N === n18.RG && (ie === n18.FLOAT && (ge = n18.RG32F), ie === n18.HALF_FLOAT && (ge = n18.RG16F), ie === n18.UNSIGNED_BYTE && (ge = n18.RG8)), N === n18.RGBA) {
      const We = _e ? rh : zt.getTransfer(ye);
      ie === n18.FLOAT && (ge = n18.RGBA32F), ie === n18.HALF_FLOAT && (ge = n18.RGBA16F), ie === n18.UNSIGNED_BYTE && (ge = We === Yt ? n18.SRGB8_ALPHA8 : n18.RGBA8), ie === n18.UNSIGNED_SHORT_4_4_4_4 && (ge = n18.RGBA4), ie === n18.UNSIGNED_SHORT_5_5_5_1 && (ge = n18.RGB5_A1);
    }
    return (ge === n18.R16F || ge === n18.R32F || ge === n18.RG16F || ge === n18.RG32F || ge === n18.RGBA16F || ge === n18.RGBA32F) && e.get("EXT_color_buffer_float"), ge;
  }
  function L(O, N, ie) {
    return E(O, ie) === true || O.isFramebufferTexture && O.minFilter !== Mn && O.minFilter !== sn ? Math.log2(Math.max(N.width, N.height)) + 1 : O.mipmaps !== void 0 && O.mipmaps.length > 0 ? O.mipmaps.length : O.isCompressedTexture && Array.isArray(O.image) ? N.mipmaps.length : 1;
  }
  function b(O) {
    return O === Mn || O === Ym || O === Ba ? n18.NEAREST : n18.LINEAR;
  }
  function I(O) {
    const N = O.target;
    N.removeEventListener("dispose", I), B(N), N.isVideoTexture && h.delete(N);
  }
  function U(O) {
    const N = O.target;
    N.removeEventListener("dispose", U), D(N);
  }
  function B(O) {
    const N = i.get(O);
    if (N.__webglInit === void 0) return;
    const ie = O.source, ye = p.get(ie);
    if (ye) {
      const _e = ye[N.__cacheKey];
      _e.usedTimes--, _e.usedTimes === 0 && R(O), Object.keys(ye).length === 0 && p.delete(ie);
    }
    i.remove(O);
  }
  function R(O) {
    const N = i.get(O);
    n18.deleteTexture(N.__webglTexture);
    const ie = O.source, ye = p.get(ie);
    delete ye[N.__cacheKey], o.memory.textures--;
  }
  function D(O) {
    const N = O.texture, ie = i.get(O), ye = i.get(N);
    if (ye.__webglTexture !== void 0 && (n18.deleteTexture(ye.__webglTexture), o.memory.textures--), O.depthTexture && O.depthTexture.dispose(), O.isWebGLCubeRenderTarget) for (let _e = 0; _e < 6; _e++) {
      if (Array.isArray(ie.__webglFramebuffer[_e])) for (let ge = 0; ge < ie.__webglFramebuffer[_e].length; ge++) n18.deleteFramebuffer(ie.__webglFramebuffer[_e][ge]);
      else n18.deleteFramebuffer(ie.__webglFramebuffer[_e]);
      ie.__webglDepthbuffer && n18.deleteRenderbuffer(ie.__webglDepthbuffer[_e]);
    }
    else {
      if (Array.isArray(ie.__webglFramebuffer)) for (let _e = 0; _e < ie.__webglFramebuffer.length; _e++) n18.deleteFramebuffer(ie.__webglFramebuffer[_e]);
      else n18.deleteFramebuffer(ie.__webglFramebuffer);
      if (ie.__webglDepthbuffer && n18.deleteRenderbuffer(ie.__webglDepthbuffer), ie.__webglMultisampledFramebuffer && n18.deleteFramebuffer(ie.__webglMultisampledFramebuffer), ie.__webglColorRenderbuffer) for (let _e = 0; _e < ie.__webglColorRenderbuffer.length; _e++) ie.__webglColorRenderbuffer[_e] && n18.deleteRenderbuffer(ie.__webglColorRenderbuffer[_e]);
      ie.__webglDepthRenderbuffer && n18.deleteRenderbuffer(ie.__webglDepthRenderbuffer);
    }
    if (O.isWebGLMultipleRenderTargets) for (let _e = 0, ge = N.length; _e < ge; _e++) {
      const We = i.get(N[_e]);
      We.__webglTexture && (n18.deleteTexture(We.__webglTexture), o.memory.textures--), i.remove(N[_e]);
    }
    i.remove(N), i.remove(O);
  }
  let j = 0;
  function te() {
    j = 0;
  }
  function X() {
    const O = j;
    return O >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + O + " texture units while this GPU supports only " + r.maxTextures), j += 1, O;
  }
  function Q(O) {
    const N = [];
    return N.push(O.wrapS), N.push(O.wrapT), N.push(O.wrapR || 0), N.push(O.magFilter), N.push(O.minFilter), N.push(O.anisotropy), N.push(O.internalFormat), N.push(O.format), N.push(O.type), N.push(O.generateMipmaps), N.push(O.premultiplyAlpha), N.push(O.flipY), N.push(O.unpackAlignment), N.push(O.colorSpace), N.join();
  }
  function J(O, N) {
    const ie = i.get(O);
    if (O.isVideoTexture && Je(O), O.isRenderTargetTexture === false && O.version > 0 && ie.__version !== O.version) {
      const ye = O.image;
      if (ye === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (ye.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        he(ie, O, N);
        return;
      }
    }
    t.bindTexture(n18.TEXTURE_2D, ie.__webglTexture, n18.TEXTURE0 + N);
  }
  function ce(O, N) {
    const ie = i.get(O);
    if (O.version > 0 && ie.__version !== O.version) {
      he(ie, O, N);
      return;
    }
    t.bindTexture(n18.TEXTURE_2D_ARRAY, ie.__webglTexture, n18.TEXTURE0 + N);
  }
  function V(O, N) {
    const ie = i.get(O);
    if (O.version > 0 && ie.__version !== O.version) {
      he(ie, O, N);
      return;
    }
    t.bindTexture(n18.TEXTURE_3D, ie.__webglTexture, n18.TEXTURE0 + N);
  }
  function q(O, N) {
    const ie = i.get(O);
    if (O.version > 0 && ie.__version !== O.version) {
      Ce(ie, O, N);
      return;
    }
    t.bindTexture(n18.TEXTURE_CUBE_MAP, ie.__webglTexture, n18.TEXTURE0 + N);
  }
  const Y = { [$f]: n18.REPEAT, [hi]: n18.CLAMP_TO_EDGE, [eh]: n18.MIRRORED_REPEAT }, $ = { [Mn]: n18.NEAREST, [Ym]: n18.NEAREST_MIPMAP_NEAREST, [Ba]: n18.NEAREST_MIPMAP_LINEAR, [sn]: n18.LINEAR, [Af]: n18.LINEAR_MIPMAP_NEAREST, [vs]: n18.LINEAR_MIPMAP_LINEAR }, ae = { [H2]: n18.NEVER, [j2]: n18.ALWAYS, [G2]: n18.LESS, [zS]: n18.LEQUAL, [W2]: n18.EQUAL, [q2]: n18.GEQUAL, [X2]: n18.GREATER, [Y2]: n18.NOTEQUAL };
  function Ee(O, N, ie) {
    if (N.type === Dr && e.has("OES_texture_float_linear") === false && (N.magFilter === sn || N.magFilter === Af || N.magFilter === Ba || N.magFilter === vs || N.minFilter === sn || N.minFilter === Af || N.minFilter === Ba || N.minFilter === vs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), ie ? (n18.texParameteri(O, n18.TEXTURE_WRAP_S, Y[N.wrapS]), n18.texParameteri(O, n18.TEXTURE_WRAP_T, Y[N.wrapT]), (O === n18.TEXTURE_3D || O === n18.TEXTURE_2D_ARRAY) && n18.texParameteri(O, n18.TEXTURE_WRAP_R, Y[N.wrapR]), n18.texParameteri(O, n18.TEXTURE_MAG_FILTER, $[N.magFilter]), n18.texParameteri(O, n18.TEXTURE_MIN_FILTER, $[N.minFilter])) : (n18.texParameteri(O, n18.TEXTURE_WRAP_S, n18.CLAMP_TO_EDGE), n18.texParameteri(O, n18.TEXTURE_WRAP_T, n18.CLAMP_TO_EDGE), (O === n18.TEXTURE_3D || O === n18.TEXTURE_2D_ARRAY) && n18.texParameteri(O, n18.TEXTURE_WRAP_R, n18.CLAMP_TO_EDGE), (N.wrapS !== hi || N.wrapT !== hi) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n18.texParameteri(O, n18.TEXTURE_MAG_FILTER, b(N.magFilter)), n18.texParameteri(O, n18.TEXTURE_MIN_FILTER, b(N.minFilter)), N.minFilter !== Mn && N.minFilter !== sn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), N.compareFunction && (n18.texParameteri(O, n18.TEXTURE_COMPARE_MODE, n18.COMPARE_REF_TO_TEXTURE), n18.texParameteri(O, n18.TEXTURE_COMPARE_FUNC, ae[N.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
      const ye = e.get("EXT_texture_filter_anisotropic");
      if (N.magFilter === Mn || N.minFilter !== Ba && N.minFilter !== vs || N.type === Dr && e.has("OES_texture_float_linear") === false || a === false && N.type === Ku && e.has("OES_texture_half_float_linear") === false) return;
      (N.anisotropy > 1 || i.get(N).__currentAnisotropy) && (n18.texParameterf(O, ye.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(N.anisotropy, r.getMaxAnisotropy())), i.get(N).__currentAnisotropy = N.anisotropy);
    }
  }
  function ne(O, N) {
    let ie = false;
    O.__webglInit === void 0 && (O.__webglInit = true, N.addEventListener("dispose", I));
    const ye = N.source;
    let _e = p.get(ye);
    _e === void 0 && (_e = {}, p.set(ye, _e));
    const ge = Q(N);
    if (ge !== O.__cacheKey) {
      _e[ge] === void 0 && (_e[ge] = { texture: n18.createTexture(), usedTimes: 0 }, o.memory.textures++, ie = true), _e[ge].usedTimes++;
      const We = _e[O.__cacheKey];
      We !== void 0 && (_e[O.__cacheKey].usedTimes--, We.usedTimes === 0 && R(N)), O.__cacheKey = ge, O.__webglTexture = _e[ge].texture;
    }
    return ie;
  }
  function he(O, N, ie) {
    let ye = n18.TEXTURE_2D;
    (N.isDataArrayTexture || N.isCompressedArrayTexture) && (ye = n18.TEXTURE_2D_ARRAY), N.isData3DTexture && (ye = n18.TEXTURE_3D);
    const _e = ne(O, N), ge = N.source;
    t.bindTexture(ye, O.__webglTexture, n18.TEXTURE0 + ie);
    const We = i.get(ge);
    if (ge.version !== We.__version || _e === true) {
      t.activeTexture(n18.TEXTURE0 + ie);
      const Pe = zt.getPrimaries(zt.workingColorSpace), Fe = N.colorSpace === sr ? null : zt.getPrimaries(N.colorSpace), tt = N.colorSpace === sr || Pe === Fe ? n18.NONE : n18.BROWSER_DEFAULT_WEBGL;
      n18.pixelStorei(n18.UNPACK_FLIP_Y_WEBGL, N.flipY), n18.pixelStorei(n18.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), n18.pixelStorei(n18.UNPACK_ALIGNMENT, N.unpackAlignment), n18.pixelStorei(n18.UNPACK_COLORSPACE_CONVERSION_WEBGL, tt);
      const ft = m(N) && S(N.image) === false;
      let ve = M(N.image, ft, false, r.maxTextureSize);
      ve = De(N, ve);
      const Ct = S(ve) || a, xt = s.convert(N.format, N.colorSpace);
      let lt = s.convert(N.type), Qe = C(N.internalFormat, xt, lt, N.colorSpace, N.isVideoTexture);
      Ee(ye, N, Ct);
      let Ge;
      const pt = N.mipmaps, bt = a && N.isVideoTexture !== true && Qe !== OS, Gt = We.__version === void 0 || _e === true, wt = ge.dataReady, Ft = L(N, ve, Ct);
      if (N.isDepthTexture) Qe = n18.DEPTH_COMPONENT, a ? N.type === Dr ? Qe = n18.DEPTH_COMPONENT32F : N.type === Js ? Qe = n18.DEPTH_COMPONENT24 : N.type === Zo ? Qe = n18.DEPTH24_STENCIL8 : Qe = n18.DEPTH_COMPONENT16 : N.type === Dr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), N.format === Jo && Qe === n18.DEPTH_COMPONENT && N.type !== Eg && N.type !== Js && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), N.type = Js, lt = s.convert(N.type)), N.format === dl && Qe === n18.DEPTH_COMPONENT && (Qe = n18.DEPTH_STENCIL, N.type !== Zo && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), N.type = Zo, lt = s.convert(N.type))), Gt && (bt ? t.texStorage2D(n18.TEXTURE_2D, 1, Qe, ve.width, ve.height) : t.texImage2D(n18.TEXTURE_2D, 0, Qe, ve.width, ve.height, 0, xt, lt, null));
      else if (N.isDataTexture) if (pt.length > 0 && Ct) {
        bt && Gt && t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, pt[0].width, pt[0].height);
        for (let G = 0, Te = pt.length; G < Te; G++) Ge = pt[G], bt ? wt && t.texSubImage2D(n18.TEXTURE_2D, G, 0, 0, Ge.width, Ge.height, xt, lt, Ge.data) : t.texImage2D(n18.TEXTURE_2D, G, Qe, Ge.width, Ge.height, 0, xt, lt, Ge.data);
        N.generateMipmaps = false;
      } else bt ? (Gt && t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, ve.width, ve.height), wt && t.texSubImage2D(n18.TEXTURE_2D, 0, 0, 0, ve.width, ve.height, xt, lt, ve.data)) : t.texImage2D(n18.TEXTURE_2D, 0, Qe, ve.width, ve.height, 0, xt, lt, ve.data);
      else if (N.isCompressedTexture) if (N.isCompressedArrayTexture) {
        bt && Gt && t.texStorage3D(n18.TEXTURE_2D_ARRAY, Ft, Qe, pt[0].width, pt[0].height, ve.depth);
        for (let G = 0, Te = pt.length; G < Te; G++) Ge = pt[G], N.format !== Ti ? xt !== null ? bt ? wt && t.compressedTexSubImage3D(n18.TEXTURE_2D_ARRAY, G, 0, 0, 0, Ge.width, Ge.height, ve.depth, xt, Ge.data, 0, 0) : t.compressedTexImage3D(n18.TEXTURE_2D_ARRAY, G, Qe, Ge.width, Ge.height, ve.depth, 0, Ge.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : bt ? wt && t.texSubImage3D(n18.TEXTURE_2D_ARRAY, G, 0, 0, 0, Ge.width, Ge.height, ve.depth, xt, lt, Ge.data) : t.texImage3D(n18.TEXTURE_2D_ARRAY, G, Qe, Ge.width, Ge.height, ve.depth, 0, xt, lt, Ge.data);
      } else {
        bt && Gt && t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, pt[0].width, pt[0].height);
        for (let G = 0, Te = pt.length; G < Te; G++) Ge = pt[G], N.format !== Ti ? xt !== null ? bt ? wt && t.compressedTexSubImage2D(n18.TEXTURE_2D, G, 0, 0, Ge.width, Ge.height, xt, Ge.data) : t.compressedTexImage2D(n18.TEXTURE_2D, G, Qe, Ge.width, Ge.height, 0, Ge.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : bt ? wt && t.texSubImage2D(n18.TEXTURE_2D, G, 0, 0, Ge.width, Ge.height, xt, lt, Ge.data) : t.texImage2D(n18.TEXTURE_2D, G, Qe, Ge.width, Ge.height, 0, xt, lt, Ge.data);
      }
      else if (N.isDataArrayTexture) bt ? (Gt && t.texStorage3D(n18.TEXTURE_2D_ARRAY, Ft, Qe, ve.width, ve.height, ve.depth), wt && t.texSubImage3D(n18.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ve.width, ve.height, ve.depth, xt, lt, ve.data)) : t.texImage3D(n18.TEXTURE_2D_ARRAY, 0, Qe, ve.width, ve.height, ve.depth, 0, xt, lt, ve.data);
      else if (N.isData3DTexture) bt ? (Gt && t.texStorage3D(n18.TEXTURE_3D, Ft, Qe, ve.width, ve.height, ve.depth), wt && t.texSubImage3D(n18.TEXTURE_3D, 0, 0, 0, 0, ve.width, ve.height, ve.depth, xt, lt, ve.data)) : t.texImage3D(n18.TEXTURE_3D, 0, Qe, ve.width, ve.height, ve.depth, 0, xt, lt, ve.data);
      else if (N.isFramebufferTexture) {
        if (Gt) if (bt) t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, ve.width, ve.height);
        else {
          let G = ve.width, Te = ve.height;
          for (let Ae = 0; Ae < Ft; Ae++) t.texImage2D(n18.TEXTURE_2D, Ae, Qe, G, Te, 0, xt, lt, null), G >>= 1, Te >>= 1;
        }
      } else if (pt.length > 0 && Ct) {
        bt && Gt && t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, pt[0].width, pt[0].height);
        for (let G = 0, Te = pt.length; G < Te; G++) Ge = pt[G], bt ? wt && t.texSubImage2D(n18.TEXTURE_2D, G, 0, 0, xt, lt, Ge) : t.texImage2D(n18.TEXTURE_2D, G, Qe, xt, lt, Ge);
        N.generateMipmaps = false;
      } else bt ? (Gt && t.texStorage2D(n18.TEXTURE_2D, Ft, Qe, ve.width, ve.height), wt && t.texSubImage2D(n18.TEXTURE_2D, 0, 0, 0, xt, lt, ve)) : t.texImage2D(n18.TEXTURE_2D, 0, Qe, xt, lt, ve);
      E(N, Ct) && T(ye), We.__version = ge.version, N.onUpdate && N.onUpdate(N);
    }
    O.__version = N.version;
  }
  function Ce(O, N, ie) {
    if (N.image.length !== 6) return;
    const ye = ne(O, N), _e = N.source;
    t.bindTexture(n18.TEXTURE_CUBE_MAP, O.__webglTexture, n18.TEXTURE0 + ie);
    const ge = i.get(_e);
    if (_e.version !== ge.__version || ye === true) {
      t.activeTexture(n18.TEXTURE0 + ie);
      const We = zt.getPrimaries(zt.workingColorSpace), Pe = N.colorSpace === sr ? null : zt.getPrimaries(N.colorSpace), Fe = N.colorSpace === sr || We === Pe ? n18.NONE : n18.BROWSER_DEFAULT_WEBGL;
      n18.pixelStorei(n18.UNPACK_FLIP_Y_WEBGL, N.flipY), n18.pixelStorei(n18.UNPACK_PREMULTIPLY_ALPHA_WEBGL, N.premultiplyAlpha), n18.pixelStorei(n18.UNPACK_ALIGNMENT, N.unpackAlignment), n18.pixelStorei(n18.UNPACK_COLORSPACE_CONVERSION_WEBGL, Fe);
      const tt = N.isCompressedTexture || N.image[0].isCompressedTexture, ft = N.image[0] && N.image[0].isDataTexture, ve = [];
      for (let G = 0; G < 6; G++) !tt && !ft ? ve[G] = M(N.image[G], false, true, r.maxCubemapSize) : ve[G] = ft ? N.image[G].image : N.image[G], ve[G] = De(N, ve[G]);
      const Ct = ve[0], xt = S(Ct) || a, lt = s.convert(N.format, N.colorSpace), Qe = s.convert(N.type), Ge = C(N.internalFormat, lt, Qe, N.colorSpace), pt = a && N.isVideoTexture !== true, bt = ge.__version === void 0 || ye === true, Gt = _e.dataReady;
      let wt = L(N, Ct, xt);
      Ee(n18.TEXTURE_CUBE_MAP, N, xt);
      let Ft;
      if (tt) {
        pt && bt && t.texStorage2D(n18.TEXTURE_CUBE_MAP, wt, Ge, Ct.width, Ct.height);
        for (let G = 0; G < 6; G++) {
          Ft = ve[G].mipmaps;
          for (let Te = 0; Te < Ft.length; Te++) {
            const Ae = Ft[Te];
            N.format !== Ti ? lt !== null ? pt ? Gt && t.compressedTexSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te, 0, 0, Ae.width, Ae.height, lt, Ae.data) : t.compressedTexImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te, Ge, Ae.width, Ae.height, 0, Ae.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : pt ? Gt && t.texSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te, 0, 0, Ae.width, Ae.height, lt, Qe, Ae.data) : t.texImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te, Ge, Ae.width, Ae.height, 0, lt, Qe, Ae.data);
          }
        }
      } else {
        Ft = N.mipmaps, pt && bt && (Ft.length > 0 && wt++, t.texStorage2D(n18.TEXTURE_CUBE_MAP, wt, Ge, ve[0].width, ve[0].height));
        for (let G = 0; G < 6; G++) if (ft) {
          pt ? Gt && t.texSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, 0, 0, 0, ve[G].width, ve[G].height, lt, Qe, ve[G].data) : t.texImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, 0, Ge, ve[G].width, ve[G].height, 0, lt, Qe, ve[G].data);
          for (let Te = 0; Te < Ft.length; Te++) {
            const Xe = Ft[Te].image[G].image;
            pt ? Gt && t.texSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te + 1, 0, 0, Xe.width, Xe.height, lt, Qe, Xe.data) : t.texImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te + 1, Ge, Xe.width, Xe.height, 0, lt, Qe, Xe.data);
          }
        } else {
          pt ? Gt && t.texSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, 0, 0, 0, lt, Qe, ve[G]) : t.texImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, 0, Ge, lt, Qe, ve[G]);
          for (let Te = 0; Te < Ft.length; Te++) {
            const Ae = Ft[Te];
            pt ? Gt && t.texSubImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te + 1, 0, 0, lt, Qe, Ae.image[G]) : t.texImage2D(n18.TEXTURE_CUBE_MAP_POSITIVE_X + G, Te + 1, Ge, lt, Qe, Ae.image[G]);
          }
        }
      }
      E(N, xt) && T(n18.TEXTURE_CUBE_MAP), ge.__version = _e.version, N.onUpdate && N.onUpdate(N);
    }
    O.__version = N.version;
  }
  function Ie(O, N, ie, ye, _e, ge) {
    const We = s.convert(ie.format, ie.colorSpace), Pe = s.convert(ie.type), Fe = C(ie.internalFormat, We, Pe, ie.colorSpace);
    if (!i.get(N).__hasExternalTextures) {
      const ft = Math.max(1, N.width >> ge), ve = Math.max(1, N.height >> ge);
      _e === n18.TEXTURE_3D || _e === n18.TEXTURE_2D_ARRAY ? t.texImage3D(_e, ge, Fe, ft, ve, N.depth, 0, We, Pe, null) : t.texImage2D(_e, ge, Fe, ft, ve, 0, We, Pe, null);
    }
    t.bindFramebuffer(n18.FRAMEBUFFER, O), pe(N) ? u.framebufferTexture2DMultisampleEXT(n18.FRAMEBUFFER, ye, _e, i.get(ie).__webglTexture, 0, Me(N)) : (_e === n18.TEXTURE_2D || _e >= n18.TEXTURE_CUBE_MAP_POSITIVE_X && _e <= n18.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n18.framebufferTexture2D(n18.FRAMEBUFFER, ye, _e, i.get(ie).__webglTexture, ge), t.bindFramebuffer(n18.FRAMEBUFFER, null);
  }
  function Ke(O, N, ie) {
    if (n18.bindRenderbuffer(n18.RENDERBUFFER, O), N.depthBuffer && !N.stencilBuffer) {
      let ye = a === true ? n18.DEPTH_COMPONENT24 : n18.DEPTH_COMPONENT16;
      if (ie || pe(N)) {
        const _e = N.depthTexture;
        _e && _e.isDepthTexture && (_e.type === Dr ? ye = n18.DEPTH_COMPONENT32F : _e.type === Js && (ye = n18.DEPTH_COMPONENT24));
        const ge = Me(N);
        pe(N) ? u.renderbufferStorageMultisampleEXT(n18.RENDERBUFFER, ge, ye, N.width, N.height) : n18.renderbufferStorageMultisample(n18.RENDERBUFFER, ge, ye, N.width, N.height);
      } else n18.renderbufferStorage(n18.RENDERBUFFER, ye, N.width, N.height);
      n18.framebufferRenderbuffer(n18.FRAMEBUFFER, n18.DEPTH_ATTACHMENT, n18.RENDERBUFFER, O);
    } else if (N.depthBuffer && N.stencilBuffer) {
      const ye = Me(N);
      ie && pe(N) === false ? n18.renderbufferStorageMultisample(n18.RENDERBUFFER, ye, n18.DEPTH24_STENCIL8, N.width, N.height) : pe(N) ? u.renderbufferStorageMultisampleEXT(n18.RENDERBUFFER, ye, n18.DEPTH24_STENCIL8, N.width, N.height) : n18.renderbufferStorage(n18.RENDERBUFFER, n18.DEPTH_STENCIL, N.width, N.height), n18.framebufferRenderbuffer(n18.FRAMEBUFFER, n18.DEPTH_STENCIL_ATTACHMENT, n18.RENDERBUFFER, O);
    } else {
      const ye = N.isWebGLMultipleRenderTargets === true ? N.texture : [N.texture];
      for (let _e = 0; _e < ye.length; _e++) {
        const ge = ye[_e], We = s.convert(ge.format, ge.colorSpace), Pe = s.convert(ge.type), Fe = C(ge.internalFormat, We, Pe, ge.colorSpace), tt = Me(N);
        ie && pe(N) === false ? n18.renderbufferStorageMultisample(n18.RENDERBUFFER, tt, Fe, N.width, N.height) : pe(N) ? u.renderbufferStorageMultisampleEXT(n18.RENDERBUFFER, tt, Fe, N.width, N.height) : n18.renderbufferStorage(n18.RENDERBUFFER, Fe, N.width, N.height);
      }
    }
    n18.bindRenderbuffer(n18.RENDERBUFFER, null);
  }
  function Ve(O, N) {
    if (N && N.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n18.FRAMEBUFFER, O), !(N.depthTexture && N.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(N.depthTexture).__webglTexture || N.depthTexture.image.width !== N.width || N.depthTexture.image.height !== N.height) && (N.depthTexture.image.width = N.width, N.depthTexture.image.height = N.height, N.depthTexture.needsUpdate = true), J(N.depthTexture, 0);
    const ye = i.get(N.depthTexture).__webglTexture, _e = Me(N);
    if (N.depthTexture.format === Jo) pe(N) ? u.framebufferTexture2DMultisampleEXT(n18.FRAMEBUFFER, n18.DEPTH_ATTACHMENT, n18.TEXTURE_2D, ye, 0, _e) : n18.framebufferTexture2D(n18.FRAMEBUFFER, n18.DEPTH_ATTACHMENT, n18.TEXTURE_2D, ye, 0);
    else if (N.depthTexture.format === dl) pe(N) ? u.framebufferTexture2DMultisampleEXT(n18.FRAMEBUFFER, n18.DEPTH_STENCIL_ATTACHMENT, n18.TEXTURE_2D, ye, 0, _e) : n18.framebufferTexture2D(n18.FRAMEBUFFER, n18.DEPTH_STENCIL_ATTACHMENT, n18.TEXTURE_2D, ye, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function ot(O) {
    const N = i.get(O), ie = O.isWebGLCubeRenderTarget === true;
    if (O.depthTexture && !N.__autoAllocateDepthBuffer) {
      if (ie) throw new Error("target.depthTexture not supported in Cube render targets");
      Ve(N.__webglFramebuffer, O);
    } else if (ie) {
      N.__webglDepthbuffer = [];
      for (let ye = 0; ye < 6; ye++) t.bindFramebuffer(n18.FRAMEBUFFER, N.__webglFramebuffer[ye]), N.__webglDepthbuffer[ye] = n18.createRenderbuffer(), Ke(N.__webglDepthbuffer[ye], O, false);
    } else t.bindFramebuffer(n18.FRAMEBUFFER, N.__webglFramebuffer), N.__webglDepthbuffer = n18.createRenderbuffer(), Ke(N.__webglDepthbuffer, O, false);
    t.bindFramebuffer(n18.FRAMEBUFFER, null);
  }
  function He(O, N, ie) {
    const ye = i.get(O);
    N !== void 0 && Ie(ye.__webglFramebuffer, O, O.texture, n18.COLOR_ATTACHMENT0, n18.TEXTURE_2D, 0), ie !== void 0 && ot(O);
  }
  function W(O) {
    const N = O.texture, ie = i.get(O), ye = i.get(N);
    O.addEventListener("dispose", U), O.isWebGLMultipleRenderTargets !== true && (ye.__webglTexture === void 0 && (ye.__webglTexture = n18.createTexture()), ye.__version = N.version, o.memory.textures++);
    const _e = O.isWebGLCubeRenderTarget === true, ge = O.isWebGLMultipleRenderTargets === true, We = S(O) || a;
    if (_e) {
      ie.__webglFramebuffer = [];
      for (let Pe = 0; Pe < 6; Pe++) if (a && N.mipmaps && N.mipmaps.length > 0) {
        ie.__webglFramebuffer[Pe] = [];
        for (let Fe = 0; Fe < N.mipmaps.length; Fe++) ie.__webglFramebuffer[Pe][Fe] = n18.createFramebuffer();
      } else ie.__webglFramebuffer[Pe] = n18.createFramebuffer();
    } else {
      if (a && N.mipmaps && N.mipmaps.length > 0) {
        ie.__webglFramebuffer = [];
        for (let Pe = 0; Pe < N.mipmaps.length; Pe++) ie.__webglFramebuffer[Pe] = n18.createFramebuffer();
      } else ie.__webglFramebuffer = n18.createFramebuffer();
      if (ge) if (r.drawBuffers) {
        const Pe = O.texture;
        for (let Fe = 0, tt = Pe.length; Fe < tt; Fe++) {
          const ft = i.get(Pe[Fe]);
          ft.__webglTexture === void 0 && (ft.__webglTexture = n18.createTexture(), o.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a && O.samples > 0 && pe(O) === false) {
        const Pe = ge ? N : [N];
        ie.__webglMultisampledFramebuffer = n18.createFramebuffer(), ie.__webglColorRenderbuffer = [], t.bindFramebuffer(n18.FRAMEBUFFER, ie.__webglMultisampledFramebuffer);
        for (let Fe = 0; Fe < Pe.length; Fe++) {
          const tt = Pe[Fe];
          ie.__webglColorRenderbuffer[Fe] = n18.createRenderbuffer(), n18.bindRenderbuffer(n18.RENDERBUFFER, ie.__webglColorRenderbuffer[Fe]);
          const ft = s.convert(tt.format, tt.colorSpace), ve = s.convert(tt.type), Ct = C(tt.internalFormat, ft, ve, tt.colorSpace, O.isXRRenderTarget === true), xt = Me(O);
          n18.renderbufferStorageMultisample(n18.RENDERBUFFER, xt, Ct, O.width, O.height), n18.framebufferRenderbuffer(n18.FRAMEBUFFER, n18.COLOR_ATTACHMENT0 + Fe, n18.RENDERBUFFER, ie.__webglColorRenderbuffer[Fe]);
        }
        n18.bindRenderbuffer(n18.RENDERBUFFER, null), O.depthBuffer && (ie.__webglDepthRenderbuffer = n18.createRenderbuffer(), Ke(ie.__webglDepthRenderbuffer, O, true)), t.bindFramebuffer(n18.FRAMEBUFFER, null);
      }
    }
    if (_e) {
      t.bindTexture(n18.TEXTURE_CUBE_MAP, ye.__webglTexture), Ee(n18.TEXTURE_CUBE_MAP, N, We);
      for (let Pe = 0; Pe < 6; Pe++) if (a && N.mipmaps && N.mipmaps.length > 0) for (let Fe = 0; Fe < N.mipmaps.length; Fe++) Ie(ie.__webglFramebuffer[Pe][Fe], O, N, n18.COLOR_ATTACHMENT0, n18.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, Fe);
      else Ie(ie.__webglFramebuffer[Pe], O, N, n18.COLOR_ATTACHMENT0, n18.TEXTURE_CUBE_MAP_POSITIVE_X + Pe, 0);
      E(N, We) && T(n18.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ge) {
      const Pe = O.texture;
      for (let Fe = 0, tt = Pe.length; Fe < tt; Fe++) {
        const ft = Pe[Fe], ve = i.get(ft);
        t.bindTexture(n18.TEXTURE_2D, ve.__webglTexture), Ee(n18.TEXTURE_2D, ft, We), Ie(ie.__webglFramebuffer, O, ft, n18.COLOR_ATTACHMENT0 + Fe, n18.TEXTURE_2D, 0), E(ft, We) && T(n18.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Pe = n18.TEXTURE_2D;
      if ((O.isWebGL3DRenderTarget || O.isWebGLArrayRenderTarget) && (a ? Pe = O.isWebGL3DRenderTarget ? n18.TEXTURE_3D : n18.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Pe, ye.__webglTexture), Ee(Pe, N, We), a && N.mipmaps && N.mipmaps.length > 0) for (let Fe = 0; Fe < N.mipmaps.length; Fe++) Ie(ie.__webglFramebuffer[Fe], O, N, n18.COLOR_ATTACHMENT0, Pe, Fe);
      else Ie(ie.__webglFramebuffer, O, N, n18.COLOR_ATTACHMENT0, Pe, 0);
      E(N, We) && T(Pe), t.unbindTexture();
    }
    O.depthBuffer && ot(O);
  }
  function xe(O) {
    const N = S(O) || a, ie = O.isWebGLMultipleRenderTargets === true ? O.texture : [O.texture];
    for (let ye = 0, _e = ie.length; ye < _e; ye++) {
      const ge = ie[ye];
      if (E(ge, N)) {
        const We = O.isWebGLCubeRenderTarget ? n18.TEXTURE_CUBE_MAP : n18.TEXTURE_2D, Pe = i.get(ge).__webglTexture;
        t.bindTexture(We, Pe), T(We), t.unbindTexture();
      }
    }
  }
  function de(O) {
    if (a && O.samples > 0 && pe(O) === false) {
      const N = O.isWebGLMultipleRenderTargets ? O.texture : [O.texture], ie = O.width, ye = O.height;
      let _e = n18.COLOR_BUFFER_BIT;
      const ge = [], We = O.stencilBuffer ? n18.DEPTH_STENCIL_ATTACHMENT : n18.DEPTH_ATTACHMENT, Pe = i.get(O), Fe = O.isWebGLMultipleRenderTargets === true;
      if (Fe) for (let tt = 0; tt < N.length; tt++) t.bindFramebuffer(n18.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), n18.framebufferRenderbuffer(n18.FRAMEBUFFER, n18.COLOR_ATTACHMENT0 + tt, n18.RENDERBUFFER, null), t.bindFramebuffer(n18.FRAMEBUFFER, Pe.__webglFramebuffer), n18.framebufferTexture2D(n18.DRAW_FRAMEBUFFER, n18.COLOR_ATTACHMENT0 + tt, n18.TEXTURE_2D, null, 0);
      t.bindFramebuffer(n18.READ_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), t.bindFramebuffer(n18.DRAW_FRAMEBUFFER, Pe.__webglFramebuffer);
      for (let tt = 0; tt < N.length; tt++) {
        ge.push(n18.COLOR_ATTACHMENT0 + tt), O.depthBuffer && ge.push(We);
        const ft = Pe.__ignoreDepthValues !== void 0 ? Pe.__ignoreDepthValues : false;
        if (ft === false && (O.depthBuffer && (_e |= n18.DEPTH_BUFFER_BIT), O.stencilBuffer && (_e |= n18.STENCIL_BUFFER_BIT)), Fe && n18.framebufferRenderbuffer(n18.READ_FRAMEBUFFER, n18.COLOR_ATTACHMENT0, n18.RENDERBUFFER, Pe.__webglColorRenderbuffer[tt]), ft === true && (n18.invalidateFramebuffer(n18.READ_FRAMEBUFFER, [We]), n18.invalidateFramebuffer(n18.DRAW_FRAMEBUFFER, [We])), Fe) {
          const ve = i.get(N[tt]).__webglTexture;
          n18.framebufferTexture2D(n18.DRAW_FRAMEBUFFER, n18.COLOR_ATTACHMENT0, n18.TEXTURE_2D, ve, 0);
        }
        n18.blitFramebuffer(0, 0, ie, ye, 0, 0, ie, ye, _e, n18.NEAREST), f && n18.invalidateFramebuffer(n18.READ_FRAMEBUFFER, ge);
      }
      if (t.bindFramebuffer(n18.READ_FRAMEBUFFER, null), t.bindFramebuffer(n18.DRAW_FRAMEBUFFER, null), Fe) for (let tt = 0; tt < N.length; tt++) {
        t.bindFramebuffer(n18.FRAMEBUFFER, Pe.__webglMultisampledFramebuffer), n18.framebufferRenderbuffer(n18.FRAMEBUFFER, n18.COLOR_ATTACHMENT0 + tt, n18.RENDERBUFFER, Pe.__webglColorRenderbuffer[tt]);
        const ft = i.get(N[tt]).__webglTexture;
        t.bindFramebuffer(n18.FRAMEBUFFER, Pe.__webglFramebuffer), n18.framebufferTexture2D(n18.DRAW_FRAMEBUFFER, n18.COLOR_ATTACHMENT0 + tt, n18.TEXTURE_2D, ft, 0);
      }
      t.bindFramebuffer(n18.DRAW_FRAMEBUFFER, Pe.__webglMultisampledFramebuffer);
    }
  }
  function Me(O) {
    return Math.min(r.maxSamples, O.samples);
  }
  function pe(O) {
    const N = i.get(O);
    return a && O.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && N.__useRenderToTexture !== false;
  }
  function Je(O) {
    const N = o.render.frame;
    h.get(O) !== N && (h.set(O, N), O.update());
  }
  function De(O, N) {
    const ie = O.colorSpace, ye = O.format, _e = O.type;
    return O.isCompressedTexture === true || O.isVideoTexture === true || O.format === qm || ie !== Rs && ie !== sr && (zt.getTransfer(ie) === Yt ? a === false ? e.has("EXT_sRGB") === true && ye === Ti ? (O.format = qm, O.minFilter = sn, O.generateMipmaps = false) : N = VS.sRGBToLinear(N) : (ye !== Ti || _e !== Es) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ie)), N;
  }
  this.allocateTextureUnit = X, this.resetTextureUnits = te, this.setTexture2D = J, this.setTexture2DArray = ce, this.setTexture3D = V, this.setTextureCube = q, this.rebindTextures = He, this.setupRenderTarget = W, this.updateRenderTargetMipmap = xe, this.updateMultisampleRenderTarget = de, this.setupDepthRenderbuffer = ot, this.setupFrameBufferTexture = Ie, this.useMultisampledRTT = pe;
}
function uP(n18, e, t) {
  const i = t.isWebGL2;
  function r(s, o = sr) {
    let a;
    const u = zt.getTransfer(o);
    if (s === Es) return n18.UNSIGNED_BYTE;
    if (s === LS) return n18.UNSIGNED_SHORT_4_4_4_4;
    if (s === IS) return n18.UNSIGNED_SHORT_5_5_5_1;
    if (s === R2) return n18.BYTE;
    if (s === P2) return n18.SHORT;
    if (s === Eg) return n18.UNSIGNED_SHORT;
    if (s === bS) return n18.INT;
    if (s === Js) return n18.UNSIGNED_INT;
    if (s === Dr) return n18.FLOAT;
    if (s === Ku) return i ? n18.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (s === b2) return n18.ALPHA;
    if (s === Ti) return n18.RGBA;
    if (s === L2) return n18.LUMINANCE;
    if (s === I2) return n18.LUMINANCE_ALPHA;
    if (s === Jo) return n18.DEPTH_COMPONENT;
    if (s === dl) return n18.DEPTH_STENCIL;
    if (s === qm) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === D2) return n18.RED;
    if (s === DS) return n18.RED_INTEGER;
    if (s === N2) return n18.RG;
    if (s === NS) return n18.RG_INTEGER;
    if (s === US) return n18.RGBA_INTEGER;
    if (s === lm || s === um || s === cm || s === fm) if (u === Yt) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
      if (s === lm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (s === um) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (s === cm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (s === fm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else return null;
    else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
      if (s === lm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (s === um) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (s === cm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (s === fm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else return null;
    if (s === Iy || s === Dy || s === Ny || s === Uy) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
      if (s === Iy) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (s === Dy) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (s === Ny) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (s === Uy) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else return null;
    if (s === OS) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === Oy || s === Fy) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
      if (s === Oy) return u === Yt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
      if (s === Fy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
    } else return null;
    if (s === ky || s === zy || s === By || s === Vy || s === Hy || s === Gy || s === Wy || s === Xy || s === Yy || s === qy || s === jy || s === Zy || s === Jy || s === Ky) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
      if (s === ky) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (s === zy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (s === By) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (s === Vy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (s === Hy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (s === Gy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (s === Wy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (s === Xy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (s === Yy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (s === qy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (s === jy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (s === Zy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (s === Jy) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (s === Ky) return u === Yt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else return null;
    if (s === hm || s === Qy || s === $y) if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
      if (s === hm) return u === Yt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (s === Qy) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (s === $y) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    } else return null;
    if (s === U2 || s === ex || s === tx || s === nx) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
      if (s === hm) return a.COMPRESSED_RED_RGTC1_EXT;
      if (s === ex) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (s === tx) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (s === nx) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    } else return null;
    return s === Zo ? i ? n18.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n18[s] !== void 0 ? n18[s] : null;
  }
  return { convert: r };
}
class cP extends Xn {
  constructor(e = []) {
    super(), this.isArrayCamera = true, this.cameras = e;
  }
}
class Ru extends Nt {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
}
const Xz = { type: "move" };
class ev {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new Ru(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new Ru(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new k(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new k()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new Ru(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new k(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new k()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(e, t, i) {
    let r = null, s = null, o = null;
    const a = this._targetRay, u = this._grip, f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        o = true;
        for (const M of e.hand.values()) {
          const S = t.getJointPose(M, i), m = this._getHandJoint(f, M);
          S !== null && (m.matrix.fromArray(S.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = true, m.jointRadius = S.radius), m.visible = S !== null;
        }
        const h = f.joints["index-finger-tip"], d = f.joints["thumb-tip"], p = h.position.distanceTo(d.position), g = 0.02, v = 5e-3;
        f.inputState.pinching && p > g + v ? (f.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !f.inputState.pinching && p <= g - v && (f.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else u !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (u.matrix.fromArray(s.transform.matrix), u.matrix.decompose(u.position, u.rotation, u.scale), u.matrixWorldNeedsUpdate = true, s.linearVelocity ? (u.hasLinearVelocity = true, u.linearVelocity.copy(s.linearVelocity)) : u.hasLinearVelocity = false, s.angularVelocity ? (u.hasAngularVelocity = true, u.angularVelocity.copy(s.angularVelocity)) : u.hasAngularVelocity = false));
      a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, r.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = false, r.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(Xz)));
    }
    return a !== null && (a.visible = r !== null), u !== null && (u.visible = s !== null), f !== null && (f.visible = o !== null), this;
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Ru();
      i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const Yz = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, qz = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class jz {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new _n(), s = e.properties.get(r);
      s.__webglTexture = t.texture, (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
    }
  }
  render(e, t) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const i = t.cameras[0].viewport, r = new es({ extensions: { fragDepth: true }, vertexShader: Yz, fragmentShader: qz, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: i.z }, depthHeight: { value: i.w } } });
        this.mesh = new Ln(new pc(20, 20), r);
      }
      e.render(this.mesh, t);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class Zz extends co {
  constructor(e, t) {
    super();
    const i = this;
    let r = null, s = 1, o = null, a = "local-floor", u = 1, f = null, h = null, d = null, p = null, g = null, v = null;
    const M = new jz(), S = t.getContextAttributes();
    let m = null, E = null;
    const T = [], C = [], L = new me();
    let b = null;
    const I = new Xn();
    I.layers.enable(1), I.viewport = new Bt();
    const U = new Xn();
    U.layers.enable(2), U.viewport = new Bt();
    const B = [I, U], R = new cP();
    R.layers.enable(1), R.layers.enable(2);
    let D = null, j = null;
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(ne) {
      let he = T[ne];
      return he === void 0 && (he = new ev(), T[ne] = he), he.getTargetRaySpace();
    }, this.getControllerGrip = function(ne) {
      let he = T[ne];
      return he === void 0 && (he = new ev(), T[ne] = he), he.getGripSpace();
    }, this.getHand = function(ne) {
      let he = T[ne];
      return he === void 0 && (he = new ev(), T[ne] = he), he.getHandSpace();
    };
    function te(ne) {
      const he = C.indexOf(ne.inputSource);
      if (he === -1) return;
      const Ce = T[he];
      Ce !== void 0 && (Ce.update(ne.inputSource, ne.frame, f || o), Ce.dispatchEvent({ type: ne.type, data: ne.inputSource }));
    }
    function X() {
      r.removeEventListener("select", te), r.removeEventListener("selectstart", te), r.removeEventListener("selectend", te), r.removeEventListener("squeeze", te), r.removeEventListener("squeezestart", te), r.removeEventListener("squeezeend", te), r.removeEventListener("end", X), r.removeEventListener("inputsourceschange", Q);
      for (let ne = 0; ne < T.length; ne++) {
        const he = C[ne];
        he !== null && (C[ne] = null, T[ne].disconnect(he));
      }
      D = null, j = null, M.reset(), e.setRenderTarget(m), g = null, p = null, d = null, r = null, E = null, Ee.stop(), i.isPresenting = false, e.setPixelRatio(b), e.setSize(L.width, L.height, false), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(ne) {
      s = ne, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(ne) {
      a = ne, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return f || o;
    }, this.setReferenceSpace = function(ne) {
      f = ne;
    }, this.getBaseLayer = function() {
      return p !== null ? p : g;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(ne) {
      if (r = ne, r !== null) {
        if (m = e.getRenderTarget(), r.addEventListener("select", te), r.addEventListener("selectstart", te), r.addEventListener("selectend", te), r.addEventListener("squeeze", te), r.addEventListener("squeezestart", te), r.addEventListener("squeezeend", te), r.addEventListener("end", X), r.addEventListener("inputsourceschange", Q), S.xrCompatible !== true && await t.makeXRCompatible(), b = e.getPixelRatio(), e.getSize(L), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === false) {
          const he = { antialias: r.renderState.layers === void 0 ? S.antialias : true, alpha: true, depth: S.depth, stencil: S.stencil, framebufferScaleFactor: s };
          g = new XRWebGLLayer(r, t, he), r.updateRenderState({ baseLayer: g }), e.setPixelRatio(1), e.setSize(g.framebufferWidth, g.framebufferHeight, false), E = new $r(g.framebufferWidth, g.framebufferHeight, { format: Ti, type: Es, colorSpace: e.outputColorSpace, stencilBuffer: S.stencil });
        } else {
          let he = null, Ce = null, Ie = null;
          S.depth && (Ie = S.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, he = S.stencil ? dl : Jo, Ce = S.stencil ? Zo : Js);
          const Ke = { colorFormat: t.RGBA8, depthFormat: Ie, scaleFactor: s };
          d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(Ke), r.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, false), E = new $r(p.textureWidth, p.textureHeight, { format: Ti, type: Es, depthTexture: new YS(p.textureWidth, p.textureHeight, Ce, void 0, void 0, void 0, void 0, void 0, void 0, he), stencilBuffer: S.stencil, colorSpace: e.outputColorSpace, samples: S.antialias ? 4 : 0 });
          const Ve = e.properties.get(E);
          Ve.__ignoreDepthValues = p.ignoreDepthValues;
        }
        E.isXRRenderTarget = true, this.setFoveation(u), f = null, o = await r.requestReferenceSpace(a), Ee.setContext(r), Ee.start(), i.isPresenting = true, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null) return r.environmentBlendMode;
    };
    function Q(ne) {
      for (let he = 0; he < ne.removed.length; he++) {
        const Ce = ne.removed[he], Ie = C.indexOf(Ce);
        Ie >= 0 && (C[Ie] = null, T[Ie].disconnect(Ce));
      }
      for (let he = 0; he < ne.added.length; he++) {
        const Ce = ne.added[he];
        let Ie = C.indexOf(Ce);
        if (Ie === -1) {
          for (let Ve = 0; Ve < T.length; Ve++) if (Ve >= C.length) {
            C.push(Ce), Ie = Ve;
            break;
          } else if (C[Ve] === null) {
            C[Ve] = Ce, Ie = Ve;
            break;
          }
          if (Ie === -1) break;
        }
        const Ke = T[Ie];
        Ke && Ke.connect(Ce);
      }
    }
    const J = new k(), ce = new k();
    function V(ne, he, Ce) {
      J.setFromMatrixPosition(he.matrixWorld), ce.setFromMatrixPosition(Ce.matrixWorld);
      const Ie = J.distanceTo(ce), Ke = he.projectionMatrix.elements, Ve = Ce.projectionMatrix.elements, ot = Ke[14] / (Ke[10] - 1), He = Ke[14] / (Ke[10] + 1), W = (Ke[9] + 1) / Ke[5], xe = (Ke[9] - 1) / Ke[5], de = (Ke[8] - 1) / Ke[0], Me = (Ve[8] + 1) / Ve[0], pe = ot * de, Je = ot * Me, De = Ie / (-de + Me), O = De * -de;
      he.matrixWorld.decompose(ne.position, ne.quaternion, ne.scale), ne.translateX(O), ne.translateZ(De), ne.matrixWorld.compose(ne.position, ne.quaternion, ne.scale), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
      const N = ot + De, ie = He + De, ye = pe - O, _e = Je + (Ie - O), ge = W * He / ie * N, We = xe * He / ie * N;
      ne.projectionMatrix.makePerspective(ye, _e, ge, We, N, ie), ne.projectionMatrixInverse.copy(ne.projectionMatrix).invert();
    }
    function q(ne, he) {
      he === null ? ne.matrixWorld.copy(ne.matrix) : ne.matrixWorld.multiplyMatrices(he.matrixWorld, ne.matrix), ne.matrixWorldInverse.copy(ne.matrixWorld).invert();
    }
    this.updateCamera = function(ne) {
      if (r === null) return;
      M.texture !== null && (ne.near = M.depthNear, ne.far = M.depthFar), R.near = U.near = I.near = ne.near, R.far = U.far = I.far = ne.far, (D !== R.near || j !== R.far) && (r.updateRenderState({ depthNear: R.near, depthFar: R.far }), D = R.near, j = R.far, I.near = D, I.far = j, U.near = D, U.far = j, I.updateProjectionMatrix(), U.updateProjectionMatrix(), ne.updateProjectionMatrix());
      const he = ne.parent, Ce = R.cameras;
      q(R, he);
      for (let Ie = 0; Ie < Ce.length; Ie++) q(Ce[Ie], he);
      Ce.length === 2 ? V(R, I, U) : R.projectionMatrix.copy(I.projectionMatrix), Y(ne, R, he);
    };
    function Y(ne, he, Ce) {
      Ce === null ? ne.matrix.copy(he.matrixWorld) : (ne.matrix.copy(Ce.matrixWorld), ne.matrix.invert(), ne.matrix.multiply(he.matrixWorld)), ne.matrix.decompose(ne.position, ne.quaternion, ne.scale), ne.updateMatrixWorld(true), ne.projectionMatrix.copy(he.projectionMatrix), ne.projectionMatrixInverse.copy(he.projectionMatrixInverse), ne.isPerspectiveCamera && (ne.fov = Qu * 2 * Math.atan(1 / ne.projectionMatrix.elements[5]), ne.zoom = 1);
    }
    this.getCamera = function() {
      return R;
    }, this.getFoveation = function() {
      if (!(p === null && g === null)) return u;
    }, this.setFoveation = function(ne) {
      u = ne, p !== null && (p.fixedFoveation = ne), g !== null && g.fixedFoveation !== void 0 && (g.fixedFoveation = ne);
    }, this.hasDepthSensing = function() {
      return M.texture !== null;
    };
    let $ = null;
    function ae(ne, he) {
      if (h = he.getViewerPose(f || o), v = he, h !== null) {
        const Ce = h.views;
        g !== null && (e.setRenderTargetFramebuffer(E, g.framebuffer), e.setRenderTarget(E));
        let Ie = false;
        Ce.length !== R.cameras.length && (R.cameras.length = 0, Ie = true);
        for (let Ve = 0; Ve < Ce.length; Ve++) {
          const ot = Ce[Ve];
          let He = null;
          if (g !== null) He = g.getViewport(ot);
          else {
            const xe = d.getViewSubImage(p, ot);
            He = xe.viewport, Ve === 0 && (e.setRenderTargetTextures(E, xe.colorTexture, p.ignoreDepthValues ? void 0 : xe.depthStencilTexture), e.setRenderTarget(E));
          }
          let W = B[Ve];
          W === void 0 && (W = new Xn(), W.layers.enable(Ve), W.viewport = new Bt(), B[Ve] = W), W.matrix.fromArray(ot.transform.matrix), W.matrix.decompose(W.position, W.quaternion, W.scale), W.projectionMatrix.fromArray(ot.projectionMatrix), W.projectionMatrixInverse.copy(W.projectionMatrix).invert(), W.viewport.set(He.x, He.y, He.width, He.height), Ve === 0 && (R.matrix.copy(W.matrix), R.matrix.decompose(R.position, R.quaternion, R.scale)), Ie === true && R.cameras.push(W);
        }
        const Ke = r.enabledFeatures;
        if (Ke && Ke.includes("depth-sensing")) {
          const Ve = d.getDepthInformation(Ce[0]);
          Ve && Ve.isValid && Ve.texture && M.init(e, Ve, r.renderState);
        }
      }
      for (let Ce = 0; Ce < T.length; Ce++) {
        const Ie = C[Ce], Ke = T[Ce];
        Ie !== null && Ke !== void 0 && Ke.update(Ie, he, f || o);
      }
      M.render(e, R), $ && $(ne, he), he.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: he }), v = null;
    }
    const Ee = new iP();
    Ee.setAnimationLoop(ae), this.setAnimationLoop = function(ne) {
      $ = ne;
    }, this.dispose = function() {
    };
  }
}
function Jz(n18, e) {
  function t(S, m) {
    S.matrixAutoUpdate === true && S.updateMatrix(), m.value.copy(S.matrix);
  }
  function i(S, m) {
    m.color.getRGB(S.fogColor.value, $2(n18)), m.isFog ? (S.fogNear.value = m.near, S.fogFar.value = m.far) : m.isFogExp2 && (S.fogDensity.value = m.density);
  }
  function r(S, m, E, T, C) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(S, m) : m.isMeshToonMaterial ? (s(S, m), d(S, m)) : m.isMeshPhongMaterial ? (s(S, m), h(S, m)) : m.isMeshStandardMaterial ? (s(S, m), p(S, m), m.isMeshPhysicalMaterial && g(S, m, C)) : m.isMeshMatcapMaterial ? (s(S, m), v(S, m)) : m.isMeshDepthMaterial ? s(S, m) : m.isMeshDistanceMaterial ? (s(S, m), M(S, m)) : m.isMeshNormalMaterial ? s(S, m) : m.isLineBasicMaterial ? (o(S, m), m.isLineDashedMaterial && a(S, m)) : m.isPointsMaterial ? u(S, m, E, T) : m.isSpriteMaterial ? f(S, m) : m.isShadowMaterial ? (S.color.value.copy(m.color), S.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = false);
  }
  function s(S, m) {
    S.opacity.value = m.opacity, m.color && S.diffuse.value.copy(m.color), m.emissive && S.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (S.map.value = m.map, t(m.map, S.mapTransform)), m.alphaMap && (S.alphaMap.value = m.alphaMap, t(m.alphaMap, S.alphaMapTransform)), m.bumpMap && (S.bumpMap.value = m.bumpMap, t(m.bumpMap, S.bumpMapTransform), S.bumpScale.value = m.bumpScale, m.side === Pi && (S.bumpScale.value *= -1)), m.normalMap && (S.normalMap.value = m.normalMap, t(m.normalMap, S.normalMapTransform), S.normalScale.value.copy(m.normalScale), m.side === Pi && S.normalScale.value.negate()), m.displacementMap && (S.displacementMap.value = m.displacementMap, t(m.displacementMap, S.displacementMapTransform), S.displacementScale.value = m.displacementScale, S.displacementBias.value = m.displacementBias), m.emissiveMap && (S.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, S.emissiveMapTransform)), m.specularMap && (S.specularMap.value = m.specularMap, t(m.specularMap, S.specularMapTransform)), m.alphaTest > 0 && (S.alphaTest.value = m.alphaTest);
    const E = e.get(m).envMap;
    if (E && (S.envMap.value = E, S.flipEnvMap.value = E.isCubeTexture && E.isRenderTargetTexture === false ? -1 : 1, S.reflectivity.value = m.reflectivity, S.ior.value = m.ior, S.refractionRatio.value = m.refractionRatio), m.lightMap) {
      S.lightMap.value = m.lightMap;
      const T = n18._useLegacyLights === true ? Math.PI : 1;
      S.lightMapIntensity.value = m.lightMapIntensity * T, t(m.lightMap, S.lightMapTransform);
    }
    m.aoMap && (S.aoMap.value = m.aoMap, S.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, S.aoMapTransform));
  }
  function o(S, m) {
    S.diffuse.value.copy(m.color), S.opacity.value = m.opacity, m.map && (S.map.value = m.map, t(m.map, S.mapTransform));
  }
  function a(S, m) {
    S.dashSize.value = m.dashSize, S.totalSize.value = m.dashSize + m.gapSize, S.scale.value = m.scale;
  }
  function u(S, m, E, T) {
    S.diffuse.value.copy(m.color), S.opacity.value = m.opacity, S.size.value = m.size * E, S.scale.value = T * 0.5, m.map && (S.map.value = m.map, t(m.map, S.uvTransform)), m.alphaMap && (S.alphaMap.value = m.alphaMap, t(m.alphaMap, S.alphaMapTransform)), m.alphaTest > 0 && (S.alphaTest.value = m.alphaTest);
  }
  function f(S, m) {
    S.diffuse.value.copy(m.color), S.opacity.value = m.opacity, S.rotation.value = m.rotation, m.map && (S.map.value = m.map, t(m.map, S.mapTransform)), m.alphaMap && (S.alphaMap.value = m.alphaMap, t(m.alphaMap, S.alphaMapTransform)), m.alphaTest > 0 && (S.alphaTest.value = m.alphaTest);
  }
  function h(S, m) {
    S.specular.value.copy(m.specular), S.shininess.value = Math.max(m.shininess, 1e-4);
  }
  function d(S, m) {
    m.gradientMap && (S.gradientMap.value = m.gradientMap);
  }
  function p(S, m) {
    S.metalness.value = m.metalness, m.metalnessMap && (S.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, S.metalnessMapTransform)), S.roughness.value = m.roughness, m.roughnessMap && (S.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, S.roughnessMapTransform)), e.get(m).envMap && (S.envMapIntensity.value = m.envMapIntensity);
  }
  function g(S, m, E) {
    S.ior.value = m.ior, m.sheen > 0 && (S.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), S.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (S.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, S.sheenColorMapTransform)), m.sheenRoughnessMap && (S.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, S.sheenRoughnessMapTransform))), m.clearcoat > 0 && (S.clearcoat.value = m.clearcoat, S.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (S.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, S.clearcoatMapTransform)), m.clearcoatRoughnessMap && (S.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, S.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (S.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, S.clearcoatNormalMapTransform), S.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Pi && S.clearcoatNormalScale.value.negate())), m.iridescence > 0 && (S.iridescence.value = m.iridescence, S.iridescenceIOR.value = m.iridescenceIOR, S.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], S.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (S.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, S.iridescenceMapTransform)), m.iridescenceThicknessMap && (S.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, S.iridescenceThicknessMapTransform))), m.transmission > 0 && (S.transmission.value = m.transmission, S.transmissionSamplerMap.value = E.texture, S.transmissionSamplerSize.value.set(E.width, E.height), m.transmissionMap && (S.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, S.transmissionMapTransform)), S.thickness.value = m.thickness, m.thicknessMap && (S.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, S.thicknessMapTransform)), S.attenuationDistance.value = m.attenuationDistance, S.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (S.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (S.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, S.anisotropyMapTransform))), S.specularIntensity.value = m.specularIntensity, S.specularColor.value.copy(m.specularColor), m.specularColorMap && (S.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, S.specularColorMapTransform)), m.specularIntensityMap && (S.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, S.specularIntensityMapTransform));
  }
  function v(S, m) {
    m.matcap && (S.matcap.value = m.matcap);
  }
  function M(S, m) {
    const E = e.get(m).light;
    S.referencePosition.value.setFromMatrixPosition(E.matrixWorld), S.nearDistance.value = E.shadow.camera.near, S.farDistance.value = E.shadow.camera.far;
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function Kz(n18, e, t, i) {
  let r = {}, s = {}, o = [];
  const a = t.isWebGL2 ? n18.getParameter(n18.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function u(E, T) {
    const C = T.program;
    i.uniformBlockBinding(E, C);
  }
  function f(E, T) {
    let C = r[E.id];
    C === void 0 && (v(E), C = h(E), r[E.id] = C, E.addEventListener("dispose", S));
    const L = T.program;
    i.updateUBOMapping(E, L);
    const b = e.render.frame;
    s[E.id] !== b && (p(E), s[E.id] = b);
  }
  function h(E) {
    const T = d();
    E.__bindingPointIndex = T;
    const C = n18.createBuffer(), L = E.__size, b = E.usage;
    return n18.bindBuffer(n18.UNIFORM_BUFFER, C), n18.bufferData(n18.UNIFORM_BUFFER, L, b), n18.bindBuffer(n18.UNIFORM_BUFFER, null), n18.bindBufferBase(n18.UNIFORM_BUFFER, T, C), C;
  }
  function d() {
    for (let E = 0; E < a; E++) if (o.indexOf(E) === -1) return o.push(E), E;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(E) {
    const T = r[E.id], C = E.uniforms, L = E.__cache;
    n18.bindBuffer(n18.UNIFORM_BUFFER, T);
    for (let b = 0, I = C.length; b < I; b++) {
      const U = Array.isArray(C[b]) ? C[b] : [C[b]];
      for (let B = 0, R = U.length; B < R; B++) {
        const D = U[B];
        if (g(D, b, B, L) === true) {
          const j = D.__offset, te = Array.isArray(D.value) ? D.value : [D.value];
          let X = 0;
          for (let Q = 0; Q < te.length; Q++) {
            const J = te[Q], ce = M(J);
            typeof J == "number" || typeof J == "boolean" ? (D.__data[0] = J, n18.bufferSubData(n18.UNIFORM_BUFFER, j + X, D.__data)) : J.isMatrix3 ? (D.__data[0] = J.elements[0], D.__data[1] = J.elements[1], D.__data[2] = J.elements[2], D.__data[3] = 0, D.__data[4] = J.elements[3], D.__data[5] = J.elements[4], D.__data[6] = J.elements[5], D.__data[7] = 0, D.__data[8] = J.elements[6], D.__data[9] = J.elements[7], D.__data[10] = J.elements[8], D.__data[11] = 0) : (J.toArray(D.__data, X), X += ce.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          n18.bufferSubData(n18.UNIFORM_BUFFER, j, D.__data);
        }
      }
    }
    n18.bindBuffer(n18.UNIFORM_BUFFER, null);
  }
  function g(E, T, C, L) {
    const b = E.value, I = T + "_" + C;
    if (L[I] === void 0) return typeof b == "number" || typeof b == "boolean" ? L[I] = b : L[I] = b.clone(), true;
    {
      const U = L[I];
      if (typeof b == "number" || typeof b == "boolean") {
        if (U !== b) return L[I] = b, true;
      } else if (U.equals(b) === false) return U.copy(b), true;
    }
    return false;
  }
  function v(E) {
    const T = E.uniforms;
    let C = 0;
    const L = 16;
    for (let I = 0, U = T.length; I < U; I++) {
      const B = Array.isArray(T[I]) ? T[I] : [T[I]];
      for (let R = 0, D = B.length; R < D; R++) {
        const j = B[R], te = Array.isArray(j.value) ? j.value : [j.value];
        for (let X = 0, Q = te.length; X < Q; X++) {
          const J = te[X], ce = M(J), V = C % L;
          V !== 0 && L - V < ce.boundary && (C += L - V), j.__data = new Float32Array(ce.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = C, C += ce.storage;
        }
      }
    }
    const b = C % L;
    return b > 0 && (C += L - b), E.__size = C, E.__cache = {}, this;
  }
  function M(E) {
    const T = { boundary: 0, storage: 0 };
    return typeof E == "number" || typeof E == "boolean" ? (T.boundary = 4, T.storage = 4) : E.isVector2 ? (T.boundary = 8, T.storage = 8) : E.isVector3 || E.isColor ? (T.boundary = 16, T.storage = 12) : E.isVector4 ? (T.boundary = 16, T.storage = 16) : E.isMatrix3 ? (T.boundary = 48, T.storage = 48) : E.isMatrix4 ? (T.boundary = 64, T.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E), T;
  }
  function S(E) {
    const T = E.target;
    T.removeEventListener("dispose", S);
    const C = o.indexOf(T.__bindingPointIndex);
    o.splice(C, 1), n18.deleteBuffer(r[T.id]), delete r[T.id], delete s[T.id];
  }
  function m() {
    for (const E in r) n18.deleteBuffer(r[E]);
    o = [], r = {}, s = {};
  }
  return { bind: u, update: f, dispose: m };
}
class ZS {
  constructor(e = {}) {
    const { canvas: t = J2(), context: i = null, depth: r = true, stencil: s = true, alpha: o = false, antialias: a = false, premultipliedAlpha: u = true, preserveDrawingBuffer: f = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false } = e;
    this.isWebGLRenderer = true;
    let p;
    i !== null ? p = i.getContextAttributes().alpha : p = o;
    const g = new Uint32Array(4), v = new Int32Array(4);
    let M = null, S = null;
    const m = [], E = [];
    this.domElement = t, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Nn, this._useLegacyLights = false, this.toneMapping = ws, this.toneMappingExposure = 1;
    const T = this;
    let C = false, L = 0, b = 0, I = null, U = -1, B = null;
    const R = new Bt(), D = new Bt();
    let j = null;
    const te = new Oe(0);
    let X = 0, Q = t.width, J = t.height, ce = 1, V = null, q = null;
    const Y = new Bt(0, 0, Q, J), $ = new Bt(0, 0, Q, J);
    let ae = false;
    const Ee = new Uh();
    let ne = false, he = false, Ce = null;
    const Ie = new st(), Ke = new me(), Ve = new k(), ot = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function He() {
      return I === null ? ce : 1;
    }
    let W = i;
    function xe(F, ee) {
      for (let oe = 0; oe < F.length; oe++) {
        const le = F[oe], se = t.getContext(le, ee);
        if (se !== null) return se;
      }
      return null;
    }
    try {
      const F = { alpha: true, depth: r, stencil: s, antialias: a, premultipliedAlpha: u, preserveDrawingBuffer: f, powerPreference: h, failIfMajorPerformanceCaveat: d };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Sg}`), t.addEventListener("webglcontextlost", Ft, false), t.addEventListener("webglcontextrestored", G, false), t.addEventListener("webglcontextcreationerror", Te, false), W === null) {
        const ee = ["webgl2", "webgl", "experimental-webgl"];
        if (T.isWebGL1Renderer === true && ee.shift(), W = xe(ee, F), W === null) throw xe(ee) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && W instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), W.getShaderPrecisionFormat === void 0 && (W.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (F) {
      throw console.error("THREE.WebGLRenderer: " + F.message), F;
    }
    let de, Me, pe, Je, De, O, N, ie, ye, _e, ge, We, Pe, Fe, tt, ft, ve, Ct, xt, lt, Qe, Ge, pt, bt;
    function Gt() {
      de = new lk(W), Me = new nk(W, de, e), de.init(Me), Ge = new uP(W, de, Me), pe = new Gz(W, de, Me), Je = new fk(W), De = new Lz(), O = new Wz(W, de, pe, De, Me, Ge, Je), N = new rk(T), ie = new ak(T), ye = new yU(W, Me), pt = new ek(W, de, ye, Me), _e = new uk(W, ye, Je, pt), ge = new mk(W, _e, ye, Je), xt = new pk(W, Me, O), ft = new ik(De), We = new bz(T, N, ie, de, Me, pt, ft), Pe = new Jz(T, De), Fe = new Dz(), tt = new zz(de, Me), Ct = new $F(T, N, ie, pe, ge, p, u), ve = new Hz(T, ge, Me), bt = new Kz(W, Je, Me, pe), lt = new tk(W, de, Je, Me), Qe = new ck(W, de, Je, Me), Je.programs = We.programs, T.capabilities = Me, T.extensions = de, T.properties = De, T.renderLists = Fe, T.shadowMap = ve, T.state = pe, T.info = Je;
    }
    Gt();
    const wt = new Zz(T, W);
    this.xr = wt, this.getContext = function() {
      return W;
    }, this.getContextAttributes = function() {
      return W.getContextAttributes();
    }, this.forceContextLoss = function() {
      const F = de.get("WEBGL_lose_context");
      F && F.loseContext();
    }, this.forceContextRestore = function() {
      const F = de.get("WEBGL_lose_context");
      F && F.restoreContext();
    }, this.getPixelRatio = function() {
      return ce;
    }, this.setPixelRatio = function(F) {
      F !== void 0 && (ce = F, this.setSize(Q, J, false));
    }, this.getSize = function(F) {
      return F.set(Q, J);
    }, this.setSize = function(F, ee, oe = true) {
      if (wt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      Q = F, J = ee, t.width = Math.floor(F * ce), t.height = Math.floor(ee * ce), oe === true && (t.style.width = F + "px", t.style.height = ee + "px"), this.setViewport(0, 0, F, ee);
    }, this.getDrawingBufferSize = function(F) {
      return F.set(Q * ce, J * ce).floor();
    }, this.setDrawingBufferSize = function(F, ee, oe) {
      Q = F, J = ee, ce = oe, t.width = Math.floor(F * oe), t.height = Math.floor(ee * oe), this.setViewport(0, 0, F, ee);
    }, this.getCurrentViewport = function(F) {
      return F.copy(R);
    }, this.getViewport = function(F) {
      return F.copy(Y);
    }, this.setViewport = function(F, ee, oe, le) {
      F.isVector4 ? Y.set(F.x, F.y, F.z, F.w) : Y.set(F, ee, oe, le), pe.viewport(R.copy(Y).multiplyScalar(ce).floor());
    }, this.getScissor = function(F) {
      return F.copy($);
    }, this.setScissor = function(F, ee, oe, le) {
      F.isVector4 ? $.set(F.x, F.y, F.z, F.w) : $.set(F, ee, oe, le), pe.scissor(D.copy($).multiplyScalar(ce).floor());
    }, this.getScissorTest = function() {
      return ae;
    }, this.setScissorTest = function(F) {
      pe.setScissorTest(ae = F);
    }, this.setOpaqueSort = function(F) {
      V = F;
    }, this.setTransparentSort = function(F) {
      q = F;
    }, this.getClearColor = function(F) {
      return F.copy(Ct.getClearColor());
    }, this.setClearColor = function() {
      Ct.setClearColor.apply(Ct, arguments);
    }, this.getClearAlpha = function() {
      return Ct.getClearAlpha();
    }, this.setClearAlpha = function() {
      Ct.setClearAlpha.apply(Ct, arguments);
    }, this.clear = function(F = true, ee = true, oe = true) {
      let le = 0;
      if (F) {
        let se = false;
        if (I !== null) {
          const Ue = I.texture.format;
          se = Ue === US || Ue === NS || Ue === DS;
        }
        if (se) {
          const Ue = I.texture.type, je = Ue === Es || Ue === Js || Ue === Eg || Ue === Zo || Ue === LS || Ue === IS, nt = Ct.getClearColor(), it = Ct.getClearAlpha(), ut = nt.r, at = nt.g, ct = nt.b;
          je ? (g[0] = ut, g[1] = at, g[2] = ct, g[3] = it, W.clearBufferuiv(W.COLOR, 0, g)) : (v[0] = ut, v[1] = at, v[2] = ct, v[3] = it, W.clearBufferiv(W.COLOR, 0, v));
        } else le |= W.COLOR_BUFFER_BIT;
      }
      ee && (le |= W.DEPTH_BUFFER_BIT), oe && (le |= W.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), W.clear(le);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Ft, false), t.removeEventListener("webglcontextrestored", G, false), t.removeEventListener("webglcontextcreationerror", Te, false), Fe.dispose(), tt.dispose(), De.dispose(), N.dispose(), ie.dispose(), ge.dispose(), pt.dispose(), bt.dispose(), We.dispose(), wt.dispose(), wt.removeEventListener("sessionstart", yi), wt.removeEventListener("sessionend", Ht), Ce && (Ce.dispose(), Ce = null), jn.stop();
    };
    function Ft(F) {
      F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = true;
    }
    function G() {
      console.log("THREE.WebGLRenderer: Context Restored."), C = false;
      const F = Je.autoReset, ee = ve.enabled, oe = ve.autoUpdate, le = ve.needsUpdate, se = ve.type;
      Gt(), Je.autoReset = F, ve.enabled = ee, ve.autoUpdate = oe, ve.needsUpdate = le, ve.type = se;
    }
    function Te(F) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage);
    }
    function Ae(F) {
      const ee = F.target;
      ee.removeEventListener("dispose", Ae), Xe(ee);
    }
    function Xe(F) {
      $e(F), De.remove(F);
    }
    function $e(F) {
      const ee = De.get(F).programs;
      ee !== void 0 && (ee.forEach(function(oe) {
        We.releaseProgram(oe);
      }), F.isShaderMaterial && We.releaseShaderCache(F));
    }
    this.renderBufferDirect = function(F, ee, oe, le, se, Ue) {
      ee === null && (ee = ot);
      const je = se.isMesh && se.matrixWorld.determinant() < 0, nt = $g(F, ee, oe, le, se);
      pe.setMaterial(le, je);
      let it = oe.index, ut = 1;
      if (le.wireframe === true) {
        if (it = _e.getWireframeAttribute(oe), it === void 0) return;
        ut = 2;
      }
      const at = oe.drawRange, ct = oe.attributes.position;
      let tn = at.start * ut, Zn = (at.start + at.count) * ut;
      Ue !== null && (tn = Math.max(tn, Ue.start * ut), Zn = Math.min(Zn, (Ue.start + Ue.count) * ut)), it !== null ? (tn = Math.max(tn, 0), Zn = Math.min(Zn, it.count)) : ct != null && (tn = Math.max(tn, 0), Zn = Math.min(Zn, ct.count));
      const jt = Zn - tn;
      if (jt < 0 || jt === 1 / 0) return;
      pt.setup(se, le, nt, oe, it);
      let kn, rt = lt;
      if (it !== null && (kn = ye.get(it), rt = Qe, rt.setIndex(kn)), se.isMesh) le.wireframe === true ? (pe.setLineWidth(le.wireframeLinewidth * He()), rt.setMode(W.LINES)) : rt.setMode(W.TRIANGLES);
      else if (se.isLine) {
        let ze = le.linewidth;
        ze === void 0 && (ze = 1), pe.setLineWidth(ze * He()), se.isLineSegments ? rt.setMode(W.LINES) : se.isLineLoop ? rt.setMode(W.LINE_LOOP) : rt.setMode(W.LINE_STRIP);
      } else se.isPoints ? rt.setMode(W.POINTS) : se.isSprite && rt.setMode(W.TRIANGLES);
      if (se.isBatchedMesh) rt.renderMultiDraw(se._multiDrawStarts, se._multiDrawCounts, se._multiDrawCount);
      else if (se.isInstancedMesh) rt.renderInstances(tn, jt, se.count);
      else if (oe.isInstancedBufferGeometry) {
        const ze = oe._maxInstanceCount !== void 0 ? oe._maxInstanceCount : 1 / 0, yr = Math.min(oe.instanceCount, ze);
        rt.renderInstances(tn, jt, yr);
      } else rt.render(tn, jt);
    };
    function Ut(F, ee, oe) {
      F.transparent === true && F.side === gs && F.forceSinglePass === false ? (F.side = Pi, F.needsUpdate = true, Tl(F, ee, oe), F.side = ro, F.needsUpdate = true, Tl(F, ee, oe), F.side = gs) : Tl(F, ee, oe);
    }
    this.compile = function(F, ee, oe = null) {
      oe === null && (oe = F), S = tt.get(oe), S.init(), E.push(S), oe.traverseVisible(function(se) {
        se.isLight && se.layers.test(ee.layers) && (S.pushLight(se), se.castShadow && S.pushShadow(se));
      }), F !== oe && F.traverseVisible(function(se) {
        se.isLight && se.layers.test(ee.layers) && (S.pushLight(se), se.castShadow && S.pushShadow(se));
      }), S.setupLights(T._useLegacyLights);
      const le = /* @__PURE__ */ new Set();
      return F.traverse(function(se) {
        const Ue = se.material;
        if (Ue) if (Array.isArray(Ue)) for (let je = 0; je < Ue.length; je++) {
          const nt = Ue[je];
          Ut(nt, oe, se), le.add(nt);
        }
        else Ut(Ue, oe, se), le.add(Ue);
      }), E.pop(), S = null, le;
    }, this.compileAsync = function(F, ee, oe = null) {
      const le = this.compile(F, ee, oe);
      return new Promise((se) => {
        function Ue() {
          if (le.forEach(function(je) {
            De.get(je).currentProgram.isReady() && le.delete(je);
          }), le.size === 0) {
            se(F);
            return;
          }
          setTimeout(Ue, 10);
        }
        de.get("KHR_parallel_shader_compile") !== null ? Ue() : setTimeout(Ue, 10);
      });
    };
    let kt = null;
    function En(F) {
      kt && kt(F);
    }
    function yi() {
      jn.stop();
    }
    function Ht() {
      jn.start();
    }
    const jn = new iP();
    jn.setAnimationLoop(En), typeof self < "u" && jn.setContext(self), this.setAnimationLoop = function(F) {
      kt = F, wt.setAnimationLoop(F), F === null ? jn.stop() : jn.start();
    }, wt.addEventListener("sessionstart", yi), wt.addEventListener("sessionend", Ht), this.render = function(F, ee) {
      if (ee !== void 0 && ee.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (C === true) return;
      F.matrixWorldAutoUpdate === true && F.updateMatrixWorld(), ee.parent === null && ee.matrixWorldAutoUpdate === true && ee.updateMatrixWorld(), wt.enabled === true && wt.isPresenting === true && (wt.cameraAutoUpdate === true && wt.updateCamera(ee), ee = wt.getCamera()), F.isScene === true && F.onBeforeRender(T, F, ee, I), S = tt.get(F, E.length), S.init(), E.push(S), Ie.multiplyMatrices(ee.projectionMatrix, ee.matrixWorldInverse), Ee.setFromProjectionMatrix(Ie), he = this.localClippingEnabled, ne = ft.init(this.clippingPlanes, he), M = Fe.get(F, m.length), M.init(), m.push(M), vr(F, ee, 0, T.sortObjects), M.finish(), T.sortObjects === true && M.sort(V, q), this.info.render.frame++, ne === true && ft.beginShadows();
      const oe = S.state.shadowsArray;
      if (ve.render(oe, F, ee), ne === true && ft.endShadows(), this.info.autoReset === true && this.info.reset(), (wt.enabled === false || wt.isPresenting === false || wt.hasDepthSensing() === false) && Ct.render(M, F), S.setupLights(T._useLegacyLights), ee.isArrayCamera) {
        const le = ee.cameras;
        for (let se = 0, Ue = le.length; se < Ue; se++) {
          const je = le[se];
          vc(M, F, je, je.viewport);
        }
      } else vc(M, F, ee);
      I !== null && (O.updateMultisampleRenderTarget(I), O.updateRenderTargetMipmap(I)), F.isScene === true && F.onAfterRender(T, F, ee), pt.resetDefaultState(), U = -1, B = null, E.pop(), E.length > 0 ? S = E[E.length - 1] : S = null, m.pop(), m.length > 0 ? M = m[m.length - 1] : M = null;
    };
    function vr(F, ee, oe, le) {
      if (F.visible === false) return;
      if (F.layers.test(ee.layers)) {
        if (F.isGroup) oe = F.renderOrder;
        else if (F.isLOD) F.autoUpdate === true && F.update(ee);
        else if (F.isLight) S.pushLight(F), F.castShadow && S.pushShadow(F);
        else if (F.isSprite) {
          if (!F.frustumCulled || Ee.intersectsSprite(F)) {
            le && Ve.setFromMatrixPosition(F.matrixWorld).applyMatrix4(Ie);
            const je = ge.update(F), nt = F.material;
            nt.visible && M.push(F, je, nt, oe, Ve.z, null);
          }
        } else if ((F.isMesh || F.isLine || F.isPoints) && (!F.frustumCulled || Ee.intersectsObject(F))) {
          const je = ge.update(F), nt = F.material;
          if (le && (F.boundingSphere !== void 0 ? (F.boundingSphere === null && F.computeBoundingSphere(), Ve.copy(F.boundingSphere.center)) : (je.boundingSphere === null && je.computeBoundingSphere(), Ve.copy(je.boundingSphere.center)), Ve.applyMatrix4(F.matrixWorld).applyMatrix4(Ie)), Array.isArray(nt)) {
            const it = je.groups;
            for (let ut = 0, at = it.length; ut < at; ut++) {
              const ct = it[ut], tn = nt[ct.materialIndex];
              tn && tn.visible && M.push(F, je, tn, oe, Ve.z, ct);
            }
          } else nt.visible && M.push(F, je, nt, oe, Ve.z, null);
        }
      }
      const Ue = F.children;
      for (let je = 0, nt = Ue.length; je < nt; je++) vr(Ue[je], ee, oe, le);
    }
    function vc(F, ee, oe, le) {
      const se = F.opaque, Ue = F.transmissive, je = F.transparent;
      S.setupLightsView(oe), ne === true && ft.setGlobalState(T.clippingPlanes, oe), Ue.length > 0 && yc(se, Ue, ee, oe), le && pe.viewport(R.copy(le)), se.length > 0 && El(se, ee, oe), Ue.length > 0 && El(Ue, ee, oe), je.length > 0 && El(je, ee, oe), pe.buffers.depth.setTest(true), pe.buffers.depth.setMask(true), pe.buffers.color.setMask(true), pe.setPolygonOffset(false);
    }
    function yc(F, ee, oe, le) {
      if ((oe.isScene === true ? oe.overrideMaterial : null) !== null) return;
      const Ue = Me.isWebGL2;
      Ce === null && (Ce = new $r(1, 1, { generateMipmaps: true, type: de.has("EXT_color_buffer_half_float") ? Ku : Es, minFilter: vs, samples: Ue ? 4 : 0 })), T.getDrawingBufferSize(Ke), Ue ? Ce.setSize(Ke.x, Ke.y) : Ce.setSize(jm(Ke.x), jm(Ke.y));
      const je = T.getRenderTarget();
      T.setRenderTarget(Ce), T.getClearColor(te), X = T.getClearAlpha(), X < 1 && T.setClearColor(16777215, 0.5), T.clear();
      const nt = T.toneMapping;
      T.toneMapping = ws, El(F, oe, le), O.updateMultisampleRenderTarget(Ce), O.updateRenderTargetMipmap(Ce);
      let it = false;
      for (let ut = 0, at = ee.length; ut < at; ut++) {
        const ct = ee[ut], tn = ct.object, Zn = ct.geometry, jt = ct.material, kn = ct.group;
        if (jt.side === gs && tn.layers.test(le.layers)) {
          const rt = jt.side;
          jt.side = Pi, jt.needsUpdate = true, fo(tn, oe, le, Zn, jt, kn), jt.side = rt, jt.needsUpdate = true, it = true;
        }
      }
      it === true && (O.updateMultisampleRenderTarget(Ce), O.updateRenderTargetMipmap(Ce)), T.setRenderTarget(je), T.setClearColor(te, X), T.toneMapping = nt;
    }
    function El(F, ee, oe) {
      const le = ee.isScene === true ? ee.overrideMaterial : null;
      for (let se = 0, Ue = F.length; se < Ue; se++) {
        const je = F[se], nt = je.object, it = je.geometry, ut = le === null ? je.material : le, at = je.group;
        nt.layers.test(oe.layers) && fo(nt, ee, oe, it, ut, at);
      }
    }
    function fo(F, ee, oe, le, se, Ue) {
      F.onBeforeRender(T, ee, oe, le, se, Ue), F.modelViewMatrix.multiplyMatrices(oe.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), se.onBeforeRender(T, ee, oe, le, F, Ue), se.transparent === true && se.side === gs && se.forceSinglePass === false ? (se.side = Pi, se.needsUpdate = true, T.renderBufferDirect(oe, ee, le, se, F, Ue), se.side = ro, se.needsUpdate = true, T.renderBufferDirect(oe, ee, le, se, F, Ue), se.side = gs) : T.renderBufferDirect(oe, ee, le, se, F, Ue), F.onAfterRender(T, ee, oe, le, se, Ue);
    }
    function Tl(F, ee, oe) {
      ee.isScene !== true && (ee = ot);
      const le = De.get(F), se = S.state.lights, Ue = S.state.shadowsArray, je = se.state.version, nt = We.getParameters(F, se.state, Ue, ee, oe), it = We.getProgramCacheKey(nt);
      let ut = le.programs;
      le.environment = F.isMeshStandardMaterial ? ee.environment : null, le.fog = ee.fog, le.envMap = (F.isMeshStandardMaterial ? ie : N).get(F.envMap || le.environment), ut === void 0 && (F.addEventListener("dispose", Ae), ut = /* @__PURE__ */ new Map(), le.programs = ut);
      let at = ut.get(it);
      if (at !== void 0) {
        if (le.currentProgram === at && le.lightsStateVersion === je) return Wh(F, nt), at;
      } else nt.uniforms = We.getUniforms(F), F.onBuild(oe, nt, T), F.onBeforeCompile(nt, T), at = We.acquireProgram(nt, it), ut.set(it, at), le.uniforms = nt.uniforms;
      const ct = le.uniforms;
      return (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === true) && (ct.clippingPlanes = ft.uniform), Wh(F, nt), le.needsLights = t0(F), le.lightsStateVersion = je, le.needsLights && (ct.ambientLightColor.value = se.state.ambient, ct.lightProbe.value = se.state.probe, ct.directionalLights.value = se.state.directional, ct.directionalLightShadows.value = se.state.directionalShadow, ct.spotLights.value = se.state.spot, ct.spotLightShadows.value = se.state.spotShadow, ct.rectAreaLights.value = se.state.rectArea, ct.ltc_1.value = se.state.rectAreaLTC1, ct.ltc_2.value = se.state.rectAreaLTC2, ct.pointLights.value = se.state.point, ct.pointLightShadows.value = se.state.pointShadow, ct.hemisphereLights.value = se.state.hemi, ct.directionalShadowMap.value = se.state.directionalShadowMap, ct.directionalShadowMatrix.value = se.state.directionalShadowMatrix, ct.spotShadowMap.value = se.state.spotShadowMap, ct.spotLightMatrix.value = se.state.spotLightMatrix, ct.spotLightMap.value = se.state.spotLightMap, ct.pointShadowMap.value = se.state.pointShadowMap, ct.pointShadowMatrix.value = se.state.pointShadowMatrix), le.currentProgram = at, le.uniformsList = null, at;
    }
    function Gh(F) {
      if (F.uniformsList === null) {
        const ee = F.currentProgram.getUniforms();
        F.uniformsList = pm.seqWithValue(ee.seq, F.uniforms);
      }
      return F.uniformsList;
    }
    function Wh(F, ee) {
      const oe = De.get(F);
      oe.outputColorSpace = ee.outputColorSpace, oe.batching = ee.batching, oe.instancing = ee.instancing, oe.instancingColor = ee.instancingColor, oe.skinning = ee.skinning, oe.morphTargets = ee.morphTargets, oe.morphNormals = ee.morphNormals, oe.morphColors = ee.morphColors, oe.morphTargetsCount = ee.morphTargetsCount, oe.numClippingPlanes = ee.numClippingPlanes, oe.numIntersection = ee.numClipIntersection, oe.vertexAlphas = ee.vertexAlphas, oe.vertexTangents = ee.vertexTangents, oe.toneMapping = ee.toneMapping;
    }
    function $g(F, ee, oe, le, se) {
      ee.isScene !== true && (ee = ot), O.resetTextureUnits();
      const Ue = ee.fog, je = le.isMeshStandardMaterial ? ee.environment : null, nt = I === null ? T.outputColorSpace : I.isXRRenderTarget === true ? I.texture.colorSpace : Rs, it = (le.isMeshStandardMaterial ? ie : N).get(le.envMap || je), ut = le.vertexColors === true && !!oe.attributes.color && oe.attributes.color.itemSize === 4, at = !!oe.attributes.tangent && (!!le.normalMap || le.anisotropy > 0), ct = !!oe.morphAttributes.position, tn = !!oe.morphAttributes.normal, Zn = !!oe.morphAttributes.color;
      let jt = ws;
      le.toneMapped && (I === null || I.isXRRenderTarget === true) && (jt = T.toneMapping);
      const kn = oe.morphAttributes.position || oe.morphAttributes.normal || oe.morphAttributes.color, rt = kn !== void 0 ? kn.length : 0, ze = De.get(le), yr = S.state.lights;
      if (ne === true && (he === true || F !== B)) {
        const Jn = F === B && le.id === U;
        ft.setState(le, F, Jn);
      }
      let St = false;
      le.version === ze.__version ? (ze.needsLights && ze.lightsStateVersion !== yr.state.version || ze.outputColorSpace !== nt || se.isBatchedMesh && ze.batching === false || !se.isBatchedMesh && ze.batching === true || se.isInstancedMesh && ze.instancing === false || !se.isInstancedMesh && ze.instancing === true || se.isSkinnedMesh && ze.skinning === false || !se.isSkinnedMesh && ze.skinning === true || se.isInstancedMesh && ze.instancingColor === true && se.instanceColor === null || se.isInstancedMesh && ze.instancingColor === false && se.instanceColor !== null || ze.envMap !== it || le.fog === true && ze.fog !== Ue || ze.numClippingPlanes !== void 0 && (ze.numClippingPlanes !== ft.numPlanes || ze.numIntersection !== ft.numIntersection) || ze.vertexAlphas !== ut || ze.vertexTangents !== at || ze.morphTargets !== ct || ze.morphNormals !== tn || ze.morphColors !== Zn || ze.toneMapping !== jt || Me.isWebGL2 === true && ze.morphTargetsCount !== rt) && (St = true) : (St = true, ze.__version = le.version);
      let fn = ze.currentProgram;
      St === true && (fn = Tl(le, ee, se));
      let is = false, xr = false, zn = false;
      const vn = fn.getUniforms(), rs = ze.uniforms;
      if (pe.useProgram(fn.program) && (is = true, xr = true, zn = true), le.id !== U && (U = le.id, xr = true), is || B !== F) {
        vn.setValue(W, "projectionMatrix", F.projectionMatrix), vn.setValue(W, "viewMatrix", F.matrixWorldInverse);
        const Jn = vn.map.cameraPosition;
        Jn !== void 0 && Jn.setValue(W, Ve.setFromMatrixPosition(F.matrixWorld)), Me.logarithmicDepthBuffer && vn.setValue(W, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)), (le.isMeshPhongMaterial || le.isMeshToonMaterial || le.isMeshLambertMaterial || le.isMeshBasicMaterial || le.isMeshStandardMaterial || le.isShaderMaterial) && vn.setValue(W, "isOrthographic", F.isOrthographicCamera === true), B !== F && (B = F, xr = true, zn = true);
      }
      if (se.isSkinnedMesh) {
        vn.setOptional(W, se, "bindMatrix"), vn.setOptional(W, se, "bindMatrixInverse");
        const Jn = se.skeleton;
        Jn && (Me.floatVertexTextures ? (Jn.boneTexture === null && Jn.computeBoneTexture(), vn.setValue(W, "boneTexture", Jn.boneTexture, O)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      se.isBatchedMesh && (vn.setOptional(W, se, "batchingTexture"), vn.setValue(W, "batchingTexture", se._matricesTexture, O));
      const Al = oe.morphAttributes;
      if ((Al.position !== void 0 || Al.normal !== void 0 || Al.color !== void 0 && Me.isWebGL2 === true) && xt.update(se, oe, fn), (xr || ze.receiveShadow !== se.receiveShadow) && (ze.receiveShadow = se.receiveShadow, vn.setValue(W, "receiveShadow", se.receiveShadow)), le.isMeshGouraudMaterial && le.envMap !== null && (rs.envMap.value = it, rs.flipEnvMap.value = it.isCubeTexture && it.isRenderTargetTexture === false ? -1 : 1), xr && (vn.setValue(W, "toneMappingExposure", T.toneMappingExposure), ze.needsLights && e0(rs, zn), Ue && le.fog === true && Pe.refreshFogUniforms(rs, Ue), Pe.refreshMaterialUniforms(rs, le, ce, J, Ce), pm.upload(W, Gh(ze), rs, O)), le.isShaderMaterial && le.uniformsNeedUpdate === true && (pm.upload(W, Gh(ze), rs, O), le.uniformsNeedUpdate = false), le.isSpriteMaterial && vn.setValue(W, "center", se.center), vn.setValue(W, "modelViewMatrix", se.modelViewMatrix), vn.setValue(W, "normalMatrix", se.normalMatrix), vn.setValue(W, "modelMatrix", se.matrixWorld), le.isShaderMaterial || le.isRawShaderMaterial) {
        const Jn = le.uniformsGroups;
        for (let Cl = 0, Ji = Jn.length; Cl < Ji; Cl++) if (Me.isWebGL2) {
          const Xh = Jn[Cl];
          bt.update(Xh, fn), bt.bind(Xh, fn);
        } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return fn;
    }
    function e0(F, ee) {
      F.ambientLightColor.needsUpdate = ee, F.lightProbe.needsUpdate = ee, F.directionalLights.needsUpdate = ee, F.directionalLightShadows.needsUpdate = ee, F.pointLights.needsUpdate = ee, F.pointLightShadows.needsUpdate = ee, F.spotLights.needsUpdate = ee, F.spotLightShadows.needsUpdate = ee, F.rectAreaLights.needsUpdate = ee, F.hemisphereLights.needsUpdate = ee;
    }
    function t0(F) {
      return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === true;
    }
    this.getActiveCubeFace = function() {
      return L;
    }, this.getActiveMipmapLevel = function() {
      return b;
    }, this.getRenderTarget = function() {
      return I;
    }, this.setRenderTargetTextures = function(F, ee, oe) {
      De.get(F.texture).__webglTexture = ee, De.get(F.depthTexture).__webglTexture = oe;
      const le = De.get(F);
      le.__hasExternalTextures = true, le.__hasExternalTextures && (le.__autoAllocateDepthBuffer = oe === void 0, le.__autoAllocateDepthBuffer || de.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), le.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(F, ee) {
      const oe = De.get(F);
      oe.__webglFramebuffer = ee, oe.__useDefaultFramebuffer = ee === void 0;
    }, this.setRenderTarget = function(F, ee = 0, oe = 0) {
      I = F, L = ee, b = oe;
      let le = true, se = null, Ue = false, je = false;
      if (F) {
        const it = De.get(F);
        it.__useDefaultFramebuffer !== void 0 ? (pe.bindFramebuffer(W.FRAMEBUFFER, null), le = false) : it.__webglFramebuffer === void 0 ? O.setupRenderTarget(F) : it.__hasExternalTextures && O.rebindTextures(F, De.get(F.texture).__webglTexture, De.get(F.depthTexture).__webglTexture);
        const ut = F.texture;
        (ut.isData3DTexture || ut.isDataArrayTexture || ut.isCompressedArrayTexture) && (je = true);
        const at = De.get(F).__webglFramebuffer;
        F.isWebGLCubeRenderTarget ? (Array.isArray(at[ee]) ? se = at[ee][oe] : se = at[ee], Ue = true) : Me.isWebGL2 && F.samples > 0 && O.useMultisampledRTT(F) === false ? se = De.get(F).__webglMultisampledFramebuffer : Array.isArray(at) ? se = at[oe] : se = at, R.copy(F.viewport), D.copy(F.scissor), j = F.scissorTest;
      } else R.copy(Y).multiplyScalar(ce).floor(), D.copy($).multiplyScalar(ce).floor(), j = ae;
      if (pe.bindFramebuffer(W.FRAMEBUFFER, se) && Me.drawBuffers && le && pe.drawBuffers(F, se), pe.viewport(R), pe.scissor(D), pe.setScissorTest(j), Ue) {
        const it = De.get(F.texture);
        W.framebufferTexture2D(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, W.TEXTURE_CUBE_MAP_POSITIVE_X + ee, it.__webglTexture, oe);
      } else if (je) {
        const it = De.get(F.texture), ut = ee || 0;
        W.framebufferTextureLayer(W.FRAMEBUFFER, W.COLOR_ATTACHMENT0, it.__webglTexture, oe || 0, ut);
      }
      U = -1;
    }, this.readRenderTargetPixels = function(F, ee, oe, le, se, Ue, je) {
      if (!(F && F.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let nt = De.get(F).__webglFramebuffer;
      if (F.isWebGLCubeRenderTarget && je !== void 0 && (nt = nt[je]), nt) {
        pe.bindFramebuffer(W.FRAMEBUFFER, nt);
        try {
          const it = F.texture, ut = it.format, at = it.type;
          if (ut !== Ti && Ge.convert(ut) !== W.getParameter(W.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const ct = at === Ku && (de.has("EXT_color_buffer_half_float") || Me.isWebGL2 && de.has("EXT_color_buffer_float"));
          if (at !== Es && Ge.convert(at) !== W.getParameter(W.IMPLEMENTATION_COLOR_READ_TYPE) && !(at === Dr && (Me.isWebGL2 || de.has("OES_texture_float") || de.has("WEBGL_color_buffer_float"))) && !ct) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          ee >= 0 && ee <= F.width - le && oe >= 0 && oe <= F.height - se && W.readPixels(ee, oe, le, se, Ge.convert(ut), Ge.convert(at), Ue);
        } finally {
          const it = I !== null ? De.get(I).__webglFramebuffer : null;
          pe.bindFramebuffer(W.FRAMEBUFFER, it);
        }
      }
    }, this.copyFramebufferToTexture = function(F, ee, oe = 0) {
      const le = Math.pow(2, -oe), se = Math.floor(ee.image.width * le), Ue = Math.floor(ee.image.height * le);
      O.setTexture2D(ee, 0), W.copyTexSubImage2D(W.TEXTURE_2D, oe, 0, 0, F.x, F.y, se, Ue), pe.unbindTexture();
    }, this.copyTextureToTexture = function(F, ee, oe, le = 0) {
      const se = ee.image.width, Ue = ee.image.height, je = Ge.convert(oe.format), nt = Ge.convert(oe.type);
      O.setTexture2D(oe, 0), W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, oe.flipY), W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, oe.premultiplyAlpha), W.pixelStorei(W.UNPACK_ALIGNMENT, oe.unpackAlignment), ee.isDataTexture ? W.texSubImage2D(W.TEXTURE_2D, le, F.x, F.y, se, Ue, je, nt, ee.image.data) : ee.isCompressedTexture ? W.compressedTexSubImage2D(W.TEXTURE_2D, le, F.x, F.y, ee.mipmaps[0].width, ee.mipmaps[0].height, je, ee.mipmaps[0].data) : W.texSubImage2D(W.TEXTURE_2D, le, F.x, F.y, je, nt, ee.image), le === 0 && oe.generateMipmaps && W.generateMipmap(W.TEXTURE_2D), pe.unbindTexture();
    }, this.copyTextureToTexture3D = function(F, ee, oe, le, se = 0) {
      if (T.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Ue = F.max.x - F.min.x + 1, je = F.max.y - F.min.y + 1, nt = F.max.z - F.min.z + 1, it = Ge.convert(le.format), ut = Ge.convert(le.type);
      let at;
      if (le.isData3DTexture) O.setTexture3D(le, 0), at = W.TEXTURE_3D;
      else if (le.isDataArrayTexture || le.isCompressedArrayTexture) O.setTexture2DArray(le, 0), at = W.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      W.pixelStorei(W.UNPACK_FLIP_Y_WEBGL, le.flipY), W.pixelStorei(W.UNPACK_PREMULTIPLY_ALPHA_WEBGL, le.premultiplyAlpha), W.pixelStorei(W.UNPACK_ALIGNMENT, le.unpackAlignment);
      const ct = W.getParameter(W.UNPACK_ROW_LENGTH), tn = W.getParameter(W.UNPACK_IMAGE_HEIGHT), Zn = W.getParameter(W.UNPACK_SKIP_PIXELS), jt = W.getParameter(W.UNPACK_SKIP_ROWS), kn = W.getParameter(W.UNPACK_SKIP_IMAGES), rt = oe.isCompressedTexture ? oe.mipmaps[se] : oe.image;
      W.pixelStorei(W.UNPACK_ROW_LENGTH, rt.width), W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, rt.height), W.pixelStorei(W.UNPACK_SKIP_PIXELS, F.min.x), W.pixelStorei(W.UNPACK_SKIP_ROWS, F.min.y), W.pixelStorei(W.UNPACK_SKIP_IMAGES, F.min.z), oe.isDataTexture || oe.isData3DTexture ? W.texSubImage3D(at, se, ee.x, ee.y, ee.z, Ue, je, nt, it, ut, rt.data) : oe.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), W.compressedTexSubImage3D(at, se, ee.x, ee.y, ee.z, Ue, je, nt, it, rt.data)) : W.texSubImage3D(at, se, ee.x, ee.y, ee.z, Ue, je, nt, it, ut, rt), W.pixelStorei(W.UNPACK_ROW_LENGTH, ct), W.pixelStorei(W.UNPACK_IMAGE_HEIGHT, tn), W.pixelStorei(W.UNPACK_SKIP_PIXELS, Zn), W.pixelStorei(W.UNPACK_SKIP_ROWS, jt), W.pixelStorei(W.UNPACK_SKIP_IMAGES, kn), se === 0 && le.generateMipmaps && W.generateMipmap(at), pe.unbindTexture();
    }, this.initTexture = function(F) {
      F.isCubeTexture ? O.setTextureCube(F, 0) : F.isData3DTexture ? O.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? O.setTexture2DArray(F, 0) : O.setTexture2D(F, 0), pe.unbindTexture();
    }, this.resetState = function() {
      L = 0, b = 0, I = null, pe.reset(), pt.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return ys;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === Ag ? "display-p3" : "srgb", t.unpackColorSpace = zt.workingColorSpace === Lh ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Nn ? Ko : kS;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Ko ? Nn : Rs;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class fP extends ZS {
}
fP.prototype.isWebGL1Renderer = true;
class Pg {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = true, this.name = "", this.color = new Oe(e), this.density = t;
  }
  clone() {
    return new Pg(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
  }
}
class bg {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = true, this.name = "", this.color = new Oe(e), this.near = t, this.far = i;
  }
  clone() {
    return new bg(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
  }
}
class JS extends Nt {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class Lg {
  constructor(e, t) {
    this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ah, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = fr();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  get updateRange() {
    return el("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = fr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const Mi = new k();
class pl {
  constructor(e, t, i, r = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++) Mi.fromBufferAttribute(this, t), Mi.applyMatrix4(e), this.setXYZ(t, Mi.x, Mi.y, Mi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) Mi.fromBufferAttribute(this, t), Mi.applyNormalMatrix(e), this.setXYZ(t, Mi.x, Mi.y, Mi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) Mi.fromBufferAttribute(this, t), Mi.transformDirection(e), this.setXYZ(t, Mi.x, Mi.y, Mi.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = Ai(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = mt(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
  }
  setX(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = mt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Ai(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), i = mt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = mt(t, this.array), i = mt(i, this.array), r = mt(r, this.array), s = mt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Ot(new this.array.constructor(t), this.itemSize, this.normalized);
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new pl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class KS extends vi {
  constructor(e) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Oe(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let nu;
const Kc = new k(), iu = new k(), ru = new k(), su = new me(), Qc = new me(), hP = new st(), Mp = new k(), $c = new k(), wp = new k(), lT = new me(), tv = new me(), uT = new me();
class dP extends Nt {
  constructor(e = new KS()) {
    if (super(), this.isSprite = true, this.type = "Sprite", nu === void 0) {
      nu = new _t();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), i = new Lg(t, 5);
      nu.setIndex([0, 1, 2, 0, 2, 3]), nu.setAttribute("position", new pl(i, 3, 0, false)), nu.setAttribute("uv", new pl(i, 2, 3, false));
    }
    this.geometry = nu, this.material = e, this.center = new me(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), iu.setFromMatrixScale(this.matrixWorld), hP.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), ru.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && iu.multiplyScalar(-ru.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && (s = Math.cos(i), r = Math.sin(i));
    const o = this.center;
    Ep(Mp.set(-0.5, -0.5, 0), ru, o, iu, r, s), Ep($c.set(0.5, -0.5, 0), ru, o, iu, r, s), Ep(wp.set(0.5, 0.5, 0), ru, o, iu, r, s), lT.set(0, 0), tv.set(1, 0), uT.set(1, 1);
    let a = e.ray.intersectTriangle(Mp, $c, wp, false, Kc);
    if (a === null && (Ep($c.set(-0.5, 0.5, 0), ru, o, iu, r, s), tv.set(0, 1), a = e.ray.intersectTriangle(Mp, wp, $c, false, Kc), a === null)) return;
    const u = e.ray.origin.distanceTo(Kc);
    u < e.near || u > e.far || t.push({ distance: u, point: Kc.clone(), uv: or.getInterpolation(Kc, Mp, $c, wp, lT, tv, uT, new me()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function Ep(n18, e, t, i, r, s) {
  su.subVectors(n18, t).addScalar(0.5).multiply(i), r !== void 0 ? (Qc.x = s * su.x - r * su.y, Qc.y = r * su.x + s * su.y) : Qc.copy(su), n18.copy(e), n18.x += Qc.x, n18.y += Qc.y, n18.applyMatrix4(hP);
}
const Tp = new k(), cT = new k();
class pP extends Nt {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
  }
  copy(e) {
    super.copy(e, false);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++) ;
    return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Tp.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Tp);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Tp.setFromMatrixPosition(e.matrixWorld), cT.setFromMatrixPosition(this.matrixWorld);
      const i = Tp.distanceTo(cT) / e.zoom;
      t[0].object.visible = true;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = false, t[r].object.visible = true;
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = false;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === false && (t.object.autoUpdate = false), t.object.levels = [];
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis });
    }
    return t;
  }
}
const fT = new k(), hT = new Bt(), dT = new Bt(), Qz = new k(), pT = new st(), Ap = new k(), nv = new mi(), mT = new st(), iv = new dc();
class mP extends Ln {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Ly, this.bindMatrix = new st(), this.bindMatrixInverse = new st(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new bi()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Ap), this.boundingBox.expandByPoint(Ap);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new mi()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Ap), this.boundingSphere.expandByPoint(Ap);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, r = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), nv.copy(this.boundingSphere), nv.applyMatrix4(r), e.ray.intersectsSphere(nv) !== false && (mT.copy(r).invert(), iv.copy(e.ray).applyMatrix4(mT), !(this.boundingBox !== null && iv.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, iv)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Bt(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === Ly ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === C2 ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton, r = this.geometry;
    hT.fromBufferAttribute(r.attributes.skinIndex, e), dT.fromBufferAttribute(r.attributes.skinWeight, e), fT.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = dT.getComponent(s);
      if (o !== 0) {
        const a = hT.getComponent(s);
        pT.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(Qz.copy(fT).applyMatrix4(pT), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class QS extends Nt {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
}
class nl extends _n {
  constructor(e = null, t = 1, i = 1, r, s, o, a, u, f = Mn, h = Mn, d, p) {
    super(null, o, a, u, f, h, r, s, d, p), this.isDataTexture = true, this.image = { data: e, width: t, height: i }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
const gT = new st(), $z = new st();
class Ig {
  constructor(e = [], t = []) {
    this.uuid = fr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new st());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new st();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : $z;
      gT.multiplyMatrices(a, t[s]), gT.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = true);
  }
  clone() {
    return new Ig(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new nl(t, e, e, Ti, Dr);
    return i.needsUpdate = true, this.boneMatrices = t, this.boneTexture = i, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new QS()), this.bones.push(o), this.boneInverses.push(new st().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class ec extends Ot {
  constructor(e, t, i, r = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
  }
}
const ou = new st(), _T = new st(), Cp = [], vT = new bi(), eB = new st(), ef = new Ln(), tf = new mi();
class gP extends Ln {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new ec(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < i; r++) this.setMatrixAt(r, eB);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new bi()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++) this.getMatrixAt(i, ou), vT.copy(e.boundingBox).applyMatrix4(ou), this.boundingBox.union(vT);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new mi()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++) this.getMatrixAt(i, ou), tf.copy(e.boundingSphere).applyMatrix4(ou), this.boundingSphere.union(tf);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, r = this.count;
    if (ef.geometry = this.geometry, ef.material = this.material, ef.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), tf.copy(this.boundingSphere), tf.applyMatrix4(i), e.ray.intersectsSphere(tf) !== false)) for (let s = 0; s < r; s++) {
      this.getMatrixAt(s, ou), _T.multiplyMatrices(i, ou), ef.matrixWorld = _T, ef.raycast(e, Cp);
      for (let o = 0, a = Cp.length; o < a; o++) {
        const u = Cp[o];
        u.instanceId = s, u.object = this, t.push(u);
      }
      Cp.length = 0;
    }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new ec(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function tB(n18, e) {
  return n18.z - e.z;
}
function nB(n18, e) {
  return e.z - n18.z;
}
class iB {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const i = this.pool, r = this.list;
    this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
    const s = i[this.index];
    r.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const au = "batchId", Ro = new st(), yT = new st(), rB = new st(), xT = new st(), rv = new Uh(), Rp = new bi(), Ca = new mi(), nf = new k(), sv = new iB(), ci = new Ln(), Pp = [];
function sB(n18, e, t = 0) {
  const i = e.itemSize;
  if (n18.isInterleavedBufferAttribute || n18.array.constructor !== e.array.constructor) {
    const r = n18.count;
    for (let s = 0; s < r; s++) for (let o = 0; o < i; o++) e.setComponent(s + t, o, n18.getComponent(s, o));
  } else e.array.set(n18.array, t * i);
  e.needsUpdate = true;
}
class _P extends Ln {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, i = t * 2, r) {
    super(new _t(), r), this.isBatchedMesh = true, this.perObjectFrustumCulled = true, this.sortObjects = true, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._geometryInitialized = false, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = true, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), i = new nl(t, e, e, Ti, Dr);
    this._matricesTexture = i;
  }
  _initializeGeometry(e) {
    const t = this.geometry, i = this._maxVertexCount, r = this._maxGeometryCount, s = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (const a in e.attributes) {
        const u = e.getAttribute(a), { array: f, itemSize: h, normalized: d } = u, p = new f.constructor(i * h), g = new u.constructor(p, h, d);
        g.setUsage(u.usage), t.setAttribute(a, g);
      }
      if (e.getIndex() !== null) {
        const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new Ot(a, 1));
      }
      const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
      t.setAttribute(au, new Ot(o, 1)), this._geometryInitialized = true;
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(au)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${au}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const i in t.attributes) {
      if (i === au) continue;
      if (!e.hasAttribute(i)) throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(i), s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new bi());
    const e = this._geometryCount, t = this.boundingBox, i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++) i[r] !== false && (this.getMatrixAt(r, Ro), this.getBoundingBoxAt(r, Rp).applyMatrix4(Ro), t.union(Rp));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new mi());
    const e = this._geometryCount, t = this.boundingSphere, i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++) i[r] !== false && (this.getMatrixAt(r, Ro), this.getBoundingSphereAt(r, Ca).applyMatrix4(Ro), t.union(Ca));
  }
  addGeometry(e, t = -1, i = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
    let s = null;
    const o = this._reservedRanges, a = this._drawRanges, u = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]), t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t, s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
    const f = e.getIndex(), h = f !== null;
    if (h && (i === -1 ? r.indexCount = f.count : r.indexCount = i, s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const d = this._visibility, p = this._active, g = this._matricesTexture, v = this._matricesTexture.image.data;
    d.push(true), p.push(true);
    const M = this._geometryCount;
    this._geometryCount++, rB.toArray(v, M * 16), g.needsUpdate = true, o.push(r), a.push({ start: h ? r.indexStart : r.vertexStart, count: -1 }), u.push({ boxInitialized: false, box: new bi(), sphereInitialized: false, sphere: new mi() });
    const S = this.geometry.getAttribute(au);
    for (let m = 0; m < r.vertexCount; m++) S.setX(r.vertexStart + m, M);
    return S.needsUpdate = true, this.setGeometryAt(M, e), M;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry, r = i.getIndex() !== null, s = i.getIndex(), o = t.getIndex(), a = this._reservedRanges[e];
    if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const u = a.vertexStart, f = a.vertexCount;
    for (const g in i.attributes) {
      if (g === au) continue;
      const v = t.getAttribute(g), M = i.getAttribute(g);
      sB(v, M, u);
      const S = v.itemSize;
      for (let m = v.count, E = f; m < E; m++) {
        const T = u + m;
        for (let C = 0; C < S; C++) M.setComponent(T, C, 0);
      }
      M.needsUpdate = true;
    }
    if (r) {
      const g = a.indexStart;
      for (let v = 0; v < o.count; v++) s.setX(g + v, u + o.getX(v));
      for (let v = o.count, M = a.indexCount; v < M; v++) s.setX(g + v, u);
      s.needsUpdate = true;
    }
    const h = this._bounds[e];
    t.boundingBox !== null ? (h.box.copy(t.boundingBox), h.boxInitialized = true) : h.boxInitialized = false, t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere), h.sphereInitialized = true) : h.sphereInitialized = false;
    const d = this._drawRanges[e], p = t.getAttribute("position");
    return d.count = r ? o.count : p.count, this._visibilityChanged = true, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === false ? this : (t[e] = false, this._visibilityChanged = true, this);
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === false) return null;
    const r = this._bounds[e], s = r.box, o = this.geometry;
    if (r.boxInitialized === false) {
      s.makeEmpty();
      const a = o.index, u = o.attributes.position, f = this._drawRanges[e];
      for (let h = f.start, d = f.start + f.count; h < d; h++) {
        let p = h;
        a && (p = a.getX(p)), s.expandByPoint(nf.fromBufferAttribute(u, p));
      }
      r.boxInitialized = true;
    }
    return t.copy(s), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === false) return null;
    const r = this._bounds[e], s = r.sphere, o = this.geometry;
    if (r.sphereInitialized === false) {
      s.makeEmpty(), this.getBoundingBoxAt(e, Rp), Rp.getCenter(s.center);
      const a = o.index, u = o.attributes.position, f = this._drawRanges[e];
      let h = 0;
      for (let d = f.start, p = f.start + f.count; d < p; d++) {
        let g = d;
        a && (g = a.getX(g)), nf.fromBufferAttribute(u, g), h = Math.max(h, s.center.distanceToSquared(nf));
      }
      s.radius = Math.sqrt(h), r.sphereInitialized = true;
    }
    return t.copy(s), t;
  }
  setMatrixAt(e, t) {
    const i = this._active, r = this._matricesTexture, s = this._matricesTexture.image.data, o = this._geometryCount;
    return e >= o || i[e] === false ? this : (t.toArray(s, e * 16), r.needsUpdate = true, this);
  }
  getMatrixAt(e, t) {
    const i = this._active, r = this._matricesTexture.image.data, s = this._geometryCount;
    return e >= s || i[e] === false ? null : t.fromArray(r, e * 16);
  }
  setVisibleAt(e, t) {
    const i = this._visibility, r = this._active, s = this._geometryCount;
    return e >= s || r[e] === false || i[e] === t ? this : (i[e] = t, this._visibilityChanged = true, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === false ? false : t[e];
  }
  raycast(e, t) {
    const i = this._visibility, r = this._active, s = this._drawRanges, o = this._geometryCount, a = this.matrixWorld, u = this.geometry;
    ci.material = this.material, ci.geometry.index = u.index, ci.geometry.attributes = u.attributes, ci.geometry.boundingBox === null && (ci.geometry.boundingBox = new bi()), ci.geometry.boundingSphere === null && (ci.geometry.boundingSphere = new mi());
    for (let f = 0; f < o; f++) {
      if (!i[f] || !r[f]) continue;
      const h = s[f];
      ci.geometry.setDrawRange(h.start, h.count), this.getMatrixAt(f, ci.matrixWorld).premultiply(a), this.getBoundingBoxAt(f, ci.geometry.boundingBox), this.getBoundingSphereAt(f, ci.geometry.boundingSphere), ci.raycast(e, Pp);
      for (let d = 0, p = Pp.length; d < p; d++) {
        const g = Pp[d];
        g.object = this, g.batchId = f, t.push(g);
      }
      Pp.length = 0;
    }
    ci.material = null, ci.geometry.index = null, ci.geometry.attributes = {}, ci.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({ boxInitialized: t.boxInitialized, box: t.box.clone(), sphereInitialized: t.sphereInitialized, sphere: t.sphere.clone() })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, i, r, s) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
    const o = r.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, u = this._active, f = this._visibility, h = this._multiDrawStarts, d = this._multiDrawCounts, p = this._drawRanges, g = this.perObjectFrustumCulled;
    g && (xT.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), rv.setFromProjectionMatrix(xT, e.coordinateSystem));
    let v = 0;
    if (this.sortObjects) {
      yT.copy(this.matrixWorld).invert(), nf.setFromMatrixPosition(i.matrixWorld).applyMatrix4(yT);
      for (let m = 0, E = f.length; m < E; m++) if (f[m] && u[m]) {
        this.getMatrixAt(m, Ro), this.getBoundingSphereAt(m, Ca).applyMatrix4(Ro);
        let T = false;
        if (g && (T = !rv.intersectsSphere(Ca)), !T) {
          const C = nf.distanceTo(Ca.center);
          sv.push(p[m], C);
        }
      }
      const M = sv.list, S = this.customSort;
      S === null ? M.sort(s.transparent ? nB : tB) : S.call(this, M, i);
      for (let m = 0, E = M.length; m < E; m++) {
        const T = M[m];
        h[v] = T.start * a, d[v] = T.count, v++;
      }
      sv.reset();
    } else for (let M = 0, S = f.length; M < S; M++) if (f[M] && u[M]) {
      let m = false;
      if (g && (this.getMatrixAt(M, Ro), this.getBoundingSphereAt(M, Ca).applyMatrix4(Ro), m = !rv.intersectsSphere(Ca)), !m) {
        const E = p[M];
        h[v] = E.start * a, d[v] = E.count, v++;
      }
    }
    this._multiDrawCount = v, this._visibilityChanged = false;
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class Di extends vi {
  constructor(e) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Oe(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const ST = new k(), MT = new k(), wT = new st(), ov = new dc(), bp = new mi();
class ia extends Nt {
  constructor(e = new _t(), t = new Di()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let r = 1, s = t.count; r < s; r++) ST.fromBufferAttribute(t, r - 1), MT.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += ST.distanceTo(MT);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), bp.copy(i.boundingSphere), bp.applyMatrix4(r), bp.radius += s, e.ray.intersectsSphere(bp) === false) return;
    wT.copy(r).invert(), ov.copy(e.ray).applyMatrix4(wT);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = a * a, f = new k(), h = new k(), d = new k(), p = new k(), g = this.isLineSegments ? 2 : 1, v = i.index, S = i.attributes.position;
    if (v !== null) {
      const m = Math.max(0, o.start), E = Math.min(v.count, o.start + o.count);
      for (let T = m, C = E - 1; T < C; T += g) {
        const L = v.getX(T), b = v.getX(T + 1);
        if (f.fromBufferAttribute(S, L), h.fromBufferAttribute(S, b), ov.distanceSqToSegment(f, h, p, d) > u) continue;
        p.applyMatrix4(this.matrixWorld);
        const U = e.ray.origin.distanceTo(p);
        U < e.near || U > e.far || t.push({ distance: U, point: d.clone().applyMatrix4(this.matrixWorld), index: T, face: null, faceIndex: null, object: this });
      }
    } else {
      const m = Math.max(0, o.start), E = Math.min(S.count, o.start + o.count);
      for (let T = m, C = E - 1; T < C; T += g) {
        if (f.fromBufferAttribute(S, T), h.fromBufferAttribute(S, T + 1), ov.distanceSqToSegment(f, h, p, d) > u) continue;
        p.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(p);
        b < e.near || b > e.far || t.push({ distance: b, point: d.clone().applyMatrix4(this.matrixWorld), index: T, face: null, faceIndex: null, object: this });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
const ET = new k(), TT = new k();
class bs extends ia {
  constructor(e, t) {
    super(e, t), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let r = 0, s = t.count; r < s; r += 2) ET.fromBufferAttribute(t, r), TT.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + ET.distanceTo(TT);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class vP extends ia {
  constructor(e, t) {
    super(e, t), this.isLineLoop = true, this.type = "LineLoop";
  }
}
class $S extends vi {
  constructor(e) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Oe(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const AT = new st(), ux = new dc(), Lp = new mi(), Ip = new k();
class yP extends Nt {
  constructor(e = new _t(), t = new $S()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Lp.copy(i.boundingSphere), Lp.applyMatrix4(r), Lp.radius += s, e.ray.intersectsSphere(Lp) === false) return;
    AT.copy(r).invert(), ux.copy(e.ray).applyMatrix4(AT);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), u = a * a, f = i.index, d = i.attributes.position;
    if (f !== null) {
      const p = Math.max(0, o.start), g = Math.min(f.count, o.start + o.count);
      for (let v = p, M = g; v < M; v++) {
        const S = f.getX(v);
        Ip.fromBufferAttribute(d, S), CT(Ip, S, u, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start), g = Math.min(d.count, o.start + o.count);
      for (let v = p, M = g; v < M; v++) Ip.fromBufferAttribute(d, v), CT(Ip, v, u, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function CT(n18, e, t, i, r, s, o) {
  const a = ux.distanceSqToPoint(n18);
  if (a < t) {
    const u = new k();
    ux.closestPointToPoint(n18, u), u.applyMatrix4(i);
    const f = r.ray.origin.distanceTo(u);
    if (f < r.near || f > r.far) return;
    s.push({ distance: f, distanceToRay: Math.sqrt(a), point: u, index: e, face: null, object: o });
  }
}
class oB extends _n {
  constructor(e, t, i, r, s, o, a, u, f) {
    super(e, t, i, r, s, o, a, u, f), this.isVideoTexture = true, this.minFilter = o !== void 0 ? o : sn, this.magFilter = s !== void 0 ? s : sn, this.generateMipmaps = false;
    const h = this;
    function d() {
      h.needsUpdate = true, e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === false && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
}
class aB extends _n {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = true, this.magFilter = Mn, this.minFilter = Mn, this.generateMipmaps = false, this.needsUpdate = true;
  }
}
class Dg extends _n {
  constructor(e, t, i, r, s, o, a, u, f, h, d, p) {
    super(null, o, a, u, f, h, r, s, d, p), this.isCompressedTexture = true, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
  }
}
class lB extends Dg {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o), this.isCompressedArrayTexture = true, this.image.depth = r, this.wrapR = hi;
  }
}
class uB extends Dg {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, so), this.isCompressedCubeTexture = true, this.isCubeTexture = true, this.image = e;
  }
}
class cB extends _n {
  constructor(e, t, i, r, s, o, a, u, f) {
    super(e, t, i, r, s, o, a, u, f), this.isCanvasTexture = true, this.needsUpdate = true;
  }
}
class ts {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    const t = [];
    let i, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++) i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? o = t : o = e * i[s - 1];
    let a = 0, u = s - 1, f;
    for (; a <= u; ) if (r = Math.floor(a + (u - a) / 2), f = i[r] - o, f < 0) a = r + 1;
    else if (f > 0) u = r - 1;
    else {
      u = r;
      break;
    }
    if (r = u, i[r] === o) return r / (s - 1);
    const h = i[r], p = i[r + 1] - h, g = (o - h) / p;
    return (r + g) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), u = t || (o.isVector2 ? new me() : new k());
    return u.copy(a).sub(o).normalize(), u;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new k(), r = [], s = [], o = [], a = new k(), u = new st();
    for (let g = 0; g <= e; g++) {
      const v = g / e;
      r[g] = this.getTangentAt(v, new k());
    }
    s[0] = new k(), o[0] = new k();
    let f = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z);
    h <= f && (f = h, i.set(1, 0, 0)), d <= f && (f = d, i.set(0, 1, 0)), p <= f && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let g = 1; g <= e; g++) {
      if (s[g] = s[g - 1].clone(), o[g] = o[g - 1].clone(), a.crossVectors(r[g - 1], r[g]), a.length() > Number.EPSILON) {
        a.normalize();
        const v = Math.acos(mn(r[g - 1].dot(r[g]), -1, 1));
        s[g].applyMatrix4(u.makeRotationAxis(a, v));
      }
      o[g].crossVectors(r[g], s[g]);
    }
    if (t === true) {
      let g = Math.acos(mn(s[0].dot(s[e]), -1, 1));
      g /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (g = -g);
      for (let v = 1; v <= e; v++) s[v].applyMatrix4(u.makeRotationAxis(r[v], g * v)), o[v].crossVectors(r[v], s[v]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class Ng extends ts {
  constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = false, u = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = u;
  }
  getPoint(e, t) {
    const i = t || new me(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === true && !o && (s === r ? s = -r : s = s - r);
    const a = this.aStartAngle + e * s;
    let u = this.aX + this.xRadius * Math.cos(a), f = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = u - this.aX, g = f - this.aY;
      u = p * h - g * d + this.aX, f = p * d + g * h + this.aY;
    }
    return i.set(u, f);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class xP extends Ng {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), this.isArcCurve = true, this.type = "ArcCurve";
  }
}
function e1() {
  let n18 = 0, e = 0, t = 0, i = 0;
  function r(s, o, a, u) {
    n18 = s, e = a, t = -3 * s + 3 * o - 2 * a - u, i = 2 * s - 2 * o + a + u;
  }
  return { initCatmullRom: function(s, o, a, u, f) {
    r(o, a, f * (a - s), f * (u - o));
  }, initNonuniformCatmullRom: function(s, o, a, u, f, h, d) {
    let p = (o - s) / f - (a - s) / (f + h) + (a - o) / h, g = (a - o) / h - (u - o) / (h + d) + (u - a) / d;
    p *= h, g *= h, r(o, a, p, g);
  }, calc: function(s) {
    const o = s * s, a = o * s;
    return n18 + e * s + t * o + i * a;
  } };
}
const Dp = new k(), av = new e1(), lv = new e1(), uv = new e1();
class SP extends ts {
  constructor(e = [], t = false, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
  }
  getPoint(e, t = new k()) {
    const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), u = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : u === 0 && a === s - 1 && (a = s - 2, u = 1);
    let f, h;
    this.closed || a > 0 ? f = r[(a - 1) % s] : (Dp.subVectors(r[0], r[1]).add(r[0]), f = Dp);
    const d = r[a % s], p = r[(a + 1) % s];
    if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (Dp.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = Dp), this.curveType === "centripetal" || this.curveType === "chordal") {
      const g = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(f.distanceToSquared(d), g), M = Math.pow(d.distanceToSquared(p), g), S = Math.pow(p.distanceToSquared(h), g);
      M < 1e-4 && (M = 1), v < 1e-4 && (v = M), S < 1e-4 && (S = M), av.initNonuniformCatmullRom(f.x, d.x, p.x, h.x, v, M, S), lv.initNonuniformCatmullRom(f.y, d.y, p.y, h.y, v, M, S), uv.initNonuniformCatmullRom(f.z, d.z, p.z, h.z, v, M, S);
    } else this.curveType === "catmullrom" && (av.initCatmullRom(f.x, d.x, p.x, h.x, this.tension), lv.initCatmullRom(f.y, d.y, p.y, h.y, this.tension), uv.initCatmullRom(f.z, d.z, p.z, h.z, this.tension));
    return i.set(av.calc(u), lv.calc(u), uv.calc(u)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new k().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function RT(n18, e, t, i, r) {
  const s = (i - e) * 0.5, o = (r - t) * 0.5, a = n18 * n18, u = n18 * a;
  return (2 * t - 2 * i + s + o) * u + (-3 * t + 3 * i - 2 * s - o) * a + s * n18 + t;
}
function fB(n18, e) {
  const t = 1 - n18;
  return t * t * e;
}
function hB(n18, e) {
  return 2 * (1 - n18) * n18 * e;
}
function dB(n18, e) {
  return n18 * n18 * e;
}
function Rf(n18, e, t, i) {
  return fB(n18, e) + hB(n18, t) + dB(n18, i);
}
function pB(n18, e) {
  const t = 1 - n18;
  return t * t * t * e;
}
function mB(n18, e) {
  const t = 1 - n18;
  return 3 * t * t * n18 * e;
}
function gB(n18, e) {
  return 3 * (1 - n18) * n18 * n18 * e;
}
function _B(n18, e) {
  return n18 * n18 * n18 * e;
}
function Pf(n18, e, t, i, r) {
  return pB(n18, e) + mB(n18, t) + gB(n18, i) + _B(n18, r);
}
class t1 extends ts {
  constructor(e = new me(), t = new me(), i = new me(), r = new me()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(Pf(e, r.x, s.x, o.x, a.x), Pf(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class MP extends ts {
  constructor(e = new k(), t = new k(), i = new k(), r = new k()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new k()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(Pf(e, r.x, s.x, o.x, a.x), Pf(e, r.y, s.y, o.y, a.y), Pf(e, r.z, s.z, o.z, a.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class n1 extends ts {
  constructor(e = new me(), t = new me()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new me()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new me()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class wP extends ts {
  constructor(e = new k(), t = new k()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new k()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new k()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class i1 extends ts {
  constructor(e = new me(), t = new me(), i = new me()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(Rf(e, r.x, s.x, o.x), Rf(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class r1 extends ts {
  constructor(e = new k(), t = new k(), i = new k()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new k()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(Rf(e, r.x, s.x, o.x), Rf(e, r.y, s.y, o.y), Rf(e, r.z, s.z, o.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class s1 extends ts {
  constructor(e = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new me()) {
    const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, u = r[o === 0 ? o : o - 1], f = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(RT(a, u.x, f.x, h.x, d.x), RT(a, u.y, f.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new me().fromArray(r));
    }
    return this;
  }
}
var Zm = Object.freeze({ __proto__: null, ArcCurve: xP, CatmullRomCurve3: SP, CubicBezierCurve: t1, CubicBezierCurve3: MP, EllipseCurve: Ng, LineCurve: n1, LineCurve3: wP, QuadraticBezierCurve: i1, QuadraticBezierCurve3: r1, SplineCurve: s1 });
class EP extends ts {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Zm[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i, a = this.curves[s], u = a.getLength(), f = u === 0 ? 0 : 1 - o / u;
        return a.getPointAt(f, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++) t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, u = o.getPoints(a);
      for (let f = 0; f < u.length; f++) {
        const h = u[f];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new Zm[r.type]().fromJSON(r));
    }
    return this;
  }
}
class ch extends EP {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new me(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new n1(this.currentPoint.clone(), new me(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new i1(this.currentPoint.clone(), new me(e, t), new me(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new t1(this.currentPoint.clone(), new me(e, t), new me(i, r), new me(s, o));
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new s1(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x, u = this.currentPoint.y;
    return this.absarc(e + a, t + u, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, u) {
    const f = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, i, r, s, o, a, u), this;
  }
  absellipse(e, t, i, r, s, o, a, u) {
    const f = new Ng(e, t, i, r, s, o, a, u);
    if (this.curves.length > 0) {
      const d = f.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class Fh extends _t {
  constructor(e = [new me(0, -0.5), new me(0.5, 0), new me(0, 0.5)], t = 12, i = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = mn(r, 0, Math.PI * 2);
    const s = [], o = [], a = [], u = [], f = [], h = 1 / t, d = new k(), p = new me(), g = new k(), v = new k(), M = new k();
    let S = 0, m = 0;
    for (let E = 0; E <= e.length - 1; E++) switch (E) {
      case 0:
        S = e[E + 1].x - e[E].x, m = e[E + 1].y - e[E].y, g.x = m * 1, g.y = -S, g.z = m * 0, M.copy(g), g.normalize(), u.push(g.x, g.y, g.z);
        break;
      case e.length - 1:
        u.push(M.x, M.y, M.z);
        break;
      default:
        S = e[E + 1].x - e[E].x, m = e[E + 1].y - e[E].y, g.x = m * 1, g.y = -S, g.z = m * 0, v.copy(g), g.x += M.x, g.y += M.y, g.z += M.z, g.normalize(), u.push(g.x, g.y, g.z), M.copy(v);
    }
    for (let E = 0; E <= t; E++) {
      const T = i + E * h * r, C = Math.sin(T), L = Math.cos(T);
      for (let b = 0; b <= e.length - 1; b++) {
        d.x = e[b].x * C, d.y = e[b].y, d.z = e[b].x * L, o.push(d.x, d.y, d.z), p.x = E / t, p.y = b / (e.length - 1), a.push(p.x, p.y);
        const I = u[3 * b + 0] * C, U = u[3 * b + 1], B = u[3 * b + 0] * L;
        f.push(I, U, B);
      }
    }
    for (let E = 0; E < t; E++) for (let T = 0; T < e.length - 1; T++) {
      const C = T + E * e.length, L = C, b = C + e.length, I = C + e.length + 1, U = C + 1;
      s.push(L, b, U), s.push(I, U, b);
    }
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("uv", new Ye(a, 2)), this.setAttribute("normal", new Ye(f, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Fh(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Ug extends Fh {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new ch();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: i, radialSegments: r };
  }
  static fromJSON(e) {
    return new Ug(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class Og extends _t {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t);
    const s = [], o = [], a = [], u = [], f = new k(), h = new me();
    o.push(0, 0, 0), a.push(0, 0, 1), u.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const g = i + d / t * r;
      f.x = e * Math.cos(g), f.y = e * Math.sin(g), o.push(f.x, f.y, f.z), a.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, u.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("normal", new Ye(a, 3)), this.setAttribute("uv", new Ye(u, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Og(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class gc extends _t {
  constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = false, a = 0, u = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: u };
    const f = this;
    r = Math.floor(r), s = Math.floor(s);
    const h = [], d = [], p = [], g = [];
    let v = 0;
    const M = [], S = i / 2;
    let m = 0;
    E(), o === false && (e > 0 && T(true), t > 0 && T(false)), this.setIndex(h), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(p, 3)), this.setAttribute("uv", new Ye(g, 2));
    function E() {
      const C = new k(), L = new k();
      let b = 0;
      const I = (t - e) / i;
      for (let U = 0; U <= s; U++) {
        const B = [], R = U / s, D = R * (t - e) + e;
        for (let j = 0; j <= r; j++) {
          const te = j / r, X = te * u + a, Q = Math.sin(X), J = Math.cos(X);
          L.x = D * Q, L.y = -R * i + S, L.z = D * J, d.push(L.x, L.y, L.z), C.set(Q, I, J).normalize(), p.push(C.x, C.y, C.z), g.push(te, 1 - R), B.push(v++);
        }
        M.push(B);
      }
      for (let U = 0; U < r; U++) for (let B = 0; B < s; B++) {
        const R = M[B][U], D = M[B + 1][U], j = M[B + 1][U + 1], te = M[B][U + 1];
        h.push(R, D, te), h.push(D, j, te), b += 6;
      }
      f.addGroup(m, b, 0), m += b;
    }
    function T(C) {
      const L = v, b = new me(), I = new k();
      let U = 0;
      const B = C === true ? e : t, R = C === true ? 1 : -1;
      for (let j = 1; j <= r; j++) d.push(0, S * R, 0), p.push(0, R, 0), g.push(0.5, 0.5), v++;
      const D = v;
      for (let j = 0; j <= r; j++) {
        const X = j / r * u + a, Q = Math.cos(X), J = Math.sin(X);
        I.x = B * J, I.y = S * R, I.z = B * Q, d.push(I.x, I.y, I.z), p.push(0, R, 0), b.x = Q * 0.5 + 0.5, b.y = J * 0.5 * R + 0.5, g.push(b.x, b.y), v++;
      }
      for (let j = 0; j < r; j++) {
        const te = L + j, X = D + j;
        C === true ? h.push(X, X + 1, te) : h.push(X + 1, X, te), U += 3;
      }
      f.addGroup(m, U, C === true ? 1 : 2), m += U;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new gc(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Fg extends gc {
  constructor(e = 1, t = 1, i = 32, r = 1, s = false, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a };
  }
  static fromJSON(e) {
    return new Fg(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class fa extends _t {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r };
    const s = [], o = [];
    a(r), f(i), h(), this.setAttribute("position", new Ye(s, 3)), this.setAttribute("normal", new Ye(s.slice(), 3)), this.setAttribute("uv", new Ye(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(E) {
      const T = new k(), C = new k(), L = new k();
      for (let b = 0; b < t.length; b += 3) g(t[b + 0], T), g(t[b + 1], C), g(t[b + 2], L), u(T, C, L, E);
    }
    function u(E, T, C, L) {
      const b = L + 1, I = [];
      for (let U = 0; U <= b; U++) {
        I[U] = [];
        const B = E.clone().lerp(C, U / b), R = T.clone().lerp(C, U / b), D = b - U;
        for (let j = 0; j <= D; j++) j === 0 && U === b ? I[U][j] = B : I[U][j] = B.clone().lerp(R, j / D);
      }
      for (let U = 0; U < b; U++) for (let B = 0; B < 2 * (b - U) - 1; B++) {
        const R = Math.floor(B / 2);
        B % 2 === 0 ? (p(I[U][R + 1]), p(I[U + 1][R]), p(I[U][R])) : (p(I[U][R + 1]), p(I[U + 1][R + 1]), p(I[U + 1][R]));
      }
    }
    function f(E) {
      const T = new k();
      for (let C = 0; C < s.length; C += 3) T.x = s[C + 0], T.y = s[C + 1], T.z = s[C + 2], T.normalize().multiplyScalar(E), s[C + 0] = T.x, s[C + 1] = T.y, s[C + 2] = T.z;
    }
    function h() {
      const E = new k();
      for (let T = 0; T < s.length; T += 3) {
        E.x = s[T + 0], E.y = s[T + 1], E.z = s[T + 2];
        const C = S(E) / 2 / Math.PI + 0.5, L = m(E) / Math.PI + 0.5;
        o.push(C, 1 - L);
      }
      v(), d();
    }
    function d() {
      for (let E = 0; E < o.length; E += 6) {
        const T = o[E + 0], C = o[E + 2], L = o[E + 4], b = Math.max(T, C, L), I = Math.min(T, C, L);
        b > 0.9 && I < 0.1 && (T < 0.2 && (o[E + 0] += 1), C < 0.2 && (o[E + 2] += 1), L < 0.2 && (o[E + 4] += 1));
      }
    }
    function p(E) {
      s.push(E.x, E.y, E.z);
    }
    function g(E, T) {
      const C = E * 3;
      T.x = e[C + 0], T.y = e[C + 1], T.z = e[C + 2];
    }
    function v() {
      const E = new k(), T = new k(), C = new k(), L = new k(), b = new me(), I = new me(), U = new me();
      for (let B = 0, R = 0; B < s.length; B += 9, R += 6) {
        E.set(s[B + 0], s[B + 1], s[B + 2]), T.set(s[B + 3], s[B + 4], s[B + 5]), C.set(s[B + 6], s[B + 7], s[B + 8]), b.set(o[R + 0], o[R + 1]), I.set(o[R + 2], o[R + 3]), U.set(o[R + 4], o[R + 5]), L.copy(E).add(T).add(C).divideScalar(3);
        const D = S(L);
        M(b, R + 0, E, D), M(I, R + 2, T, D), M(U, R + 4, C, D);
      }
    }
    function M(E, T, C, L) {
      L < 0 && E.x === 1 && (o[T] = E.x - 1), C.x === 0 && C.z === 0 && (o[T] = L / 2 / Math.PI + 0.5);
    }
    function S(E) {
      return Math.atan2(E.z, -E.x);
    }
    function m(E) {
      return Math.atan2(-E.y, Math.sqrt(E.x * E.x + E.z * E.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new fa(e.vertices, e.indices, e.radius, e.details);
  }
}
class kg extends fa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = 1 / i, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new kg(e.radius, e.detail);
  }
}
const Np = new k(), Up = new k(), cv = new k(), Op = new or();
class TP extends _t {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos($a * t), o = e.getIndex(), a = e.getAttribute("position"), u = o ? o.count : a.count, f = [0, 0, 0], h = ["a", "b", "c"], d = new Array(3), p = {}, g = [];
      for (let v = 0; v < u; v += 3) {
        o ? (f[0] = o.getX(v), f[1] = o.getX(v + 1), f[2] = o.getX(v + 2)) : (f[0] = v, f[1] = v + 1, f[2] = v + 2);
        const { a: M, b: S, c: m } = Op;
        if (M.fromBufferAttribute(a, f[0]), S.fromBufferAttribute(a, f[1]), m.fromBufferAttribute(a, f[2]), Op.getNormal(cv), d[0] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`, d[1] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(S.z * r)}`, d[2] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let E = 0; E < 3; E++) {
          const T = (E + 1) % 3, C = d[E], L = d[T], b = Op[h[E]], I = Op[h[T]], U = `${C}_${L}`, B = `${L}_${C}`;
          B in p && p[B] ? (cv.dot(p[B].normal) <= s && (g.push(b.x, b.y, b.z), g.push(I.x, I.y, I.z)), p[B] = null) : U in p || (p[U] = { index0: f[E], index1: f[T], normal: cv.clone() });
        }
      }
      for (const v in p) if (p[v]) {
        const { index0: M, index1: S } = p[v];
        Np.fromBufferAttribute(a, M), Up.fromBufferAttribute(a, S), g.push(Np.x, Np.y, Np.z), g.push(Up.x, Up.y, Up.z);
      }
      this.setAttribute("position", new Ye(g, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class il extends ch {
  constructor(e) {
    super(e), this.uuid = fr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new ch().fromJSON(r));
    }
    return this;
  }
}
const vB = { triangulate: function(n18, e, t = 2) {
  const i = e && e.length, r = i ? e[0] * t : n18.length;
  let s = AP(n18, 0, r, t, true);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let a, u, f, h, d, p, g;
  if (i && (s = wB(n18, e, s, t)), n18.length > 80 * t) {
    a = f = n18[0], u = h = n18[1];
    for (let v = t; v < r; v += t) d = n18[v], p = n18[v + 1], d < a && (a = d), p < u && (u = p), d > f && (f = d), p > h && (h = p);
    g = Math.max(f - a, h - u), g = g !== 0 ? 32767 / g : 0;
  }
  return fh(s, o, t, a, u, g, 0), o;
} };
function AP(n18, e, t, i, r) {
  let s, o;
  if (r === NB(n18, e, t, i) > 0) for (s = e; s < t; s += i) o = PT(s, n18[s], n18[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = PT(s, n18[s], n18[s + 1], o);
  return o && zg(o, o.next) && (dh(o), o = o.next), o;
}
function ml(n18, e) {
  if (!n18) return n18;
  e || (e = n18);
  let t = n18, i;
  do
    if (i = false, !t.steiner && (zg(t, t.next) || an(t.prev, t, t.next) === 0)) {
      if (dh(t), t = e = t.prev, t === t.next) break;
      i = true;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function fh(n18, e, t, i, r, s, o) {
  if (!n18) return;
  !o && s && RB(n18, i, r, s);
  let a = n18, u, f;
  for (; n18.prev !== n18.next; ) {
    if (u = n18.prev, f = n18.next, s ? xB(n18, i, r, s) : yB(n18)) {
      e.push(u.i / t | 0), e.push(n18.i / t | 0), e.push(f.i / t | 0), dh(n18), n18 = f.next, a = f.next;
      continue;
    }
    if (n18 = f, n18 === a) {
      o ? o === 1 ? (n18 = SB(ml(n18), e, t), fh(n18, e, t, i, r, s, 2)) : o === 2 && MB(n18, e, t, i, r, s) : fh(ml(n18), e, t, i, r, s, 1);
      break;
    }
  }
}
function yB(n18) {
  const e = n18.prev, t = n18, i = n18.next;
  if (an(e, t, i) >= 0) return false;
  const r = e.x, s = t.x, o = i.x, a = e.y, u = t.y, f = i.y, h = r < s ? r < o ? r : o : s < o ? s : o, d = a < u ? a < f ? a : f : u < f ? u : f, p = r > s ? r > o ? r : o : s > o ? s : o, g = a > u ? a > f ? a : f : u > f ? u : f;
  let v = i.next;
  for (; v !== e; ) {
    if (v.x >= h && v.x <= p && v.y >= d && v.y <= g && Pu(r, a, s, u, o, f, v.x, v.y) && an(v.prev, v, v.next) >= 0) return false;
    v = v.next;
  }
  return true;
}
function xB(n18, e, t, i) {
  const r = n18.prev, s = n18, o = n18.next;
  if (an(r, s, o) >= 0) return false;
  const a = r.x, u = s.x, f = o.x, h = r.y, d = s.y, p = o.y, g = a < u ? a < f ? a : f : u < f ? u : f, v = h < d ? h < p ? h : p : d < p ? d : p, M = a > u ? a > f ? a : f : u > f ? u : f, S = h > d ? h > p ? h : p : d > p ? d : p, m = cx(g, v, e, t, i), E = cx(M, S, e, t, i);
  let T = n18.prevZ, C = n18.nextZ;
  for (; T && T.z >= m && C && C.z <= E; ) {
    if (T.x >= g && T.x <= M && T.y >= v && T.y <= S && T !== r && T !== o && Pu(a, h, u, d, f, p, T.x, T.y) && an(T.prev, T, T.next) >= 0 || (T = T.prevZ, C.x >= g && C.x <= M && C.y >= v && C.y <= S && C !== r && C !== o && Pu(a, h, u, d, f, p, C.x, C.y) && an(C.prev, C, C.next) >= 0)) return false;
    C = C.nextZ;
  }
  for (; T && T.z >= m; ) {
    if (T.x >= g && T.x <= M && T.y >= v && T.y <= S && T !== r && T !== o && Pu(a, h, u, d, f, p, T.x, T.y) && an(T.prev, T, T.next) >= 0) return false;
    T = T.prevZ;
  }
  for (; C && C.z <= E; ) {
    if (C.x >= g && C.x <= M && C.y >= v && C.y <= S && C !== r && C !== o && Pu(a, h, u, d, f, p, C.x, C.y) && an(C.prev, C, C.next) >= 0) return false;
    C = C.nextZ;
  }
  return true;
}
function SB(n18, e, t) {
  let i = n18;
  do {
    const r = i.prev, s = i.next.next;
    !zg(r, s) && CP(r, i, i.next, s) && hh(r, s) && hh(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), dh(i), dh(i.next), i = n18 = s), i = i.next;
  } while (i !== n18);
  return ml(i);
}
function MB(n18, e, t, i, r, s) {
  let o = n18;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && LB(o, a)) {
        let u = RP(o, a);
        o = ml(o, o.next), u = ml(u, u.next), fh(o, e, t, i, r, s, 0), fh(u, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n18);
}
function wB(n18, e, t, i) {
  const r = [];
  let s, o, a, u, f;
  for (s = 0, o = e.length; s < o; s++) a = e[s] * i, u = s < o - 1 ? e[s + 1] * i : n18.length, f = AP(n18, a, u, i, false), f === f.next && (f.steiner = true), r.push(bB(f));
  for (r.sort(EB), s = 0; s < r.length; s++) t = TB(r[s], t);
  return t;
}
function EB(n18, e) {
  return n18.x - e.x;
}
function TB(n18, e) {
  const t = AB(n18, e);
  if (!t) return e;
  const i = RP(t, n18);
  return ml(i, i.next), ml(t, t.next);
}
function AB(n18, e) {
  let t = e, i = -1 / 0, r;
  const s = n18.x, o = n18.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (p <= s && p > i && (i = p, r = t.x < t.next.x ? t : t.next, p === s)) return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r, u = r.x, f = r.y;
  let h = 1 / 0, d;
  t = r;
  do
    s >= t.x && t.x >= u && s !== t.x && Pu(o < f ? s : i, o, u, f, o < f ? i : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x), hh(t, n18) && (d < h || d === h && (t.x > r.x || t.x === r.x && CB(r, t))) && (r = t, h = d)), t = t.next;
  while (t !== a);
  return r;
}
function CB(n18, e) {
  return an(n18.prev, n18, e.prev) < 0 && an(e.next, n18, n18.next) < 0;
}
function RB(n18, e, t, i) {
  let r = n18;
  do
    r.z === 0 && (r.z = cx(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n18);
  r.prevZ.nextZ = null, r.prevZ = null, PB(r);
}
function PB(n18) {
  let e, t, i, r, s, o, a, u, f = 1;
  do {
    for (t = n18, n18 = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < f && (a++, i = i.nextZ, !!i); e++) ;
      for (u = f; a > 0 || u > 0 && i; ) a !== 0 && (u === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, u--), s ? s.nextZ = r : n18 = r, r.prevZ = s, s = r;
      t = i;
    }
    s.nextZ = null, f *= 2;
  } while (o > 1);
  return n18;
}
function cx(n18, e, t, i, r) {
  return n18 = (n18 - t) * r | 0, e = (e - i) * r | 0, n18 = (n18 | n18 << 8) & 16711935, n18 = (n18 | n18 << 4) & 252645135, n18 = (n18 | n18 << 2) & 858993459, n18 = (n18 | n18 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n18 | e << 1;
}
function bB(n18) {
  let e = n18, t = n18;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n18);
  return t;
}
function Pu(n18, e, t, i, r, s, o, a) {
  return (r - o) * (e - a) >= (n18 - o) * (s - a) && (n18 - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a);
}
function LB(n18, e) {
  return n18.next.i !== e.i && n18.prev.i !== e.i && !IB(n18, e) && (hh(n18, e) && hh(e, n18) && DB(n18, e) && (an(n18.prev, n18, e.prev) || an(n18, e.prev, e)) || zg(n18, e) && an(n18.prev, n18, n18.next) > 0 && an(e.prev, e, e.next) > 0);
}
function an(n18, e, t) {
  return (e.y - n18.y) * (t.x - e.x) - (e.x - n18.x) * (t.y - e.y);
}
function zg(n18, e) {
  return n18.x === e.x && n18.y === e.y;
}
function CP(n18, e, t, i) {
  const r = kp(an(n18, e, t)), s = kp(an(n18, e, i)), o = kp(an(t, i, n18)), a = kp(an(t, i, e));
  return !!(r !== s && o !== a || r === 0 && Fp(n18, t, e) || s === 0 && Fp(n18, i, e) || o === 0 && Fp(t, n18, i) || a === 0 && Fp(t, e, i));
}
function Fp(n18, e, t) {
  return e.x <= Math.max(n18.x, t.x) && e.x >= Math.min(n18.x, t.x) && e.y <= Math.max(n18.y, t.y) && e.y >= Math.min(n18.y, t.y);
}
function kp(n18) {
  return n18 > 0 ? 1 : n18 < 0 ? -1 : 0;
}
function IB(n18, e) {
  let t = n18;
  do {
    if (t.i !== n18.i && t.next.i !== n18.i && t.i !== e.i && t.next.i !== e.i && CP(t, t.next, n18, e)) return true;
    t = t.next;
  } while (t !== n18);
  return false;
}
function hh(n18, e) {
  return an(n18.prev, n18, n18.next) < 0 ? an(n18, e, n18.next) >= 0 && an(n18, n18.prev, e) >= 0 : an(n18, e, n18.prev) < 0 || an(n18, n18.next, e) < 0;
}
function DB(n18, e) {
  let t = n18, i = false;
  const r = (n18.x + e.x) / 2, s = (n18.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== n18);
  return i;
}
function RP(n18, e) {
  const t = new fx(n18.i, n18.x, n18.y), i = new fx(e.i, e.x, e.y), r = n18.next, s = e.prev;
  return n18.next = e, e.prev = n18, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function PT(n18, e, t, i) {
  const r = new fx(n18, e, t);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function dh(n18) {
  n18.next.prev = n18.prev, n18.prev.next = n18.next, n18.prevZ && (n18.prevZ.nextZ = n18.nextZ), n18.nextZ && (n18.nextZ.prevZ = n18.prevZ);
}
function fx(n18, e, t) {
  this.i = n18, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
function NB(n18, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i) r += (n18[o] - n18[s]) * (n18[s + 1] + n18[o + 1]), o = s;
  return r;
}
class Ts {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return Ts.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], r = [], s = [];
    bT(e), LT(i, e);
    let o = e.length;
    t.forEach(bT);
    for (let u = 0; u < t.length; u++) r.push(o), o += t[u].length, LT(i, t[u]);
    const a = vB.triangulate(i, r);
    for (let u = 0; u < a.length; u += 3) s.push(a.slice(u, u + 3));
    return s;
  }
}
function bT(n18) {
  const e = n18.length;
  e > 2 && n18[e - 1].equals(n18[0]) && n18.pop();
}
function LT(n18, e) {
  for (let t = 0; t < e.length; t++) n18.push(e[t].x), n18.push(e[t].y);
}
class Bg extends _t {
  constructor(e = new il([new me(0.5, 0.5), new me(-0.5, 0.5), new me(-0.5, -0.5), new me(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const i = this, r = [], s = [];
    for (let a = 0, u = e.length; a < u; a++) {
      const f = e[a];
      o(f);
    }
    this.setAttribute("position", new Ye(r, 3)), this.setAttribute("uv", new Ye(s, 2)), this.computeVertexNormals();
    function o(a) {
      const u = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, g = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, v = t.bevelSize !== void 0 ? t.bevelSize : g - 0.1, M = t.bevelOffset !== void 0 ? t.bevelOffset : 0, S = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const m = t.extrudePath, E = t.UVGenerator !== void 0 ? t.UVGenerator : UB;
      let T, C = false, L, b, I, U;
      m && (T = m.getSpacedPoints(h), C = true, p = false, L = m.computeFrenetFrames(h, false), b = new k(), I = new k(), U = new k()), p || (S = 0, g = 0, v = 0, M = 0);
      const B = a.extractPoints(f);
      let R = B.shape;
      const D = B.holes;
      if (!Ts.isClockWise(R)) {
        R = R.reverse();
        for (let W = 0, xe = D.length; W < xe; W++) {
          const de = D[W];
          Ts.isClockWise(de) && (D[W] = de.reverse());
        }
      }
      const te = Ts.triangulateShape(R, D), X = R;
      for (let W = 0, xe = D.length; W < xe; W++) {
        const de = D[W];
        R = R.concat(de);
      }
      function Q(W, xe, de) {
        return xe || console.error("THREE.ExtrudeGeometry: vec does not exist"), W.clone().addScaledVector(xe, de);
      }
      const J = R.length, ce = te.length;
      function V(W, xe, de) {
        let Me, pe, Je;
        const De = W.x - xe.x, O = W.y - xe.y, N = de.x - W.x, ie = de.y - W.y, ye = De * De + O * O, _e = De * ie - O * N;
        if (Math.abs(_e) > Number.EPSILON) {
          const ge = Math.sqrt(ye), We = Math.sqrt(N * N + ie * ie), Pe = xe.x - O / ge, Fe = xe.y + De / ge, tt = de.x - ie / We, ft = de.y + N / We, ve = ((tt - Pe) * ie - (ft - Fe) * N) / (De * ie - O * N);
          Me = Pe + De * ve - W.x, pe = Fe + O * ve - W.y;
          const Ct = Me * Me + pe * pe;
          if (Ct <= 2) return new me(Me, pe);
          Je = Math.sqrt(Ct / 2);
        } else {
          let ge = false;
          De > Number.EPSILON ? N > Number.EPSILON && (ge = true) : De < -Number.EPSILON ? N < -Number.EPSILON && (ge = true) : Math.sign(O) === Math.sign(ie) && (ge = true), ge ? (Me = -O, pe = De, Je = Math.sqrt(ye)) : (Me = De, pe = O, Je = Math.sqrt(ye / 2));
        }
        return new me(Me / Je, pe / Je);
      }
      const q = [];
      for (let W = 0, xe = X.length, de = xe - 1, Me = W + 1; W < xe; W++, de++, Me++) de === xe && (de = 0), Me === xe && (Me = 0), q[W] = V(X[W], X[de], X[Me]);
      const Y = [];
      let $, ae = q.concat();
      for (let W = 0, xe = D.length; W < xe; W++) {
        const de = D[W];
        $ = [];
        for (let Me = 0, pe = de.length, Je = pe - 1, De = Me + 1; Me < pe; Me++, Je++, De++) Je === pe && (Je = 0), De === pe && (De = 0), $[Me] = V(de[Me], de[Je], de[De]);
        Y.push($), ae = ae.concat($);
      }
      for (let W = 0; W < S; W++) {
        const xe = W / S, de = g * Math.cos(xe * Math.PI / 2), Me = v * Math.sin(xe * Math.PI / 2) + M;
        for (let pe = 0, Je = X.length; pe < Je; pe++) {
          const De = Q(X[pe], q[pe], Me);
          Ie(De.x, De.y, -de);
        }
        for (let pe = 0, Je = D.length; pe < Je; pe++) {
          const De = D[pe];
          $ = Y[pe];
          for (let O = 0, N = De.length; O < N; O++) {
            const ie = Q(De[O], $[O], Me);
            Ie(ie.x, ie.y, -de);
          }
        }
      }
      const Ee = v + M;
      for (let W = 0; W < J; W++) {
        const xe = p ? Q(R[W], ae[W], Ee) : R[W];
        C ? (I.copy(L.normals[0]).multiplyScalar(xe.x), b.copy(L.binormals[0]).multiplyScalar(xe.y), U.copy(T[0]).add(I).add(b), Ie(U.x, U.y, U.z)) : Ie(xe.x, xe.y, 0);
      }
      for (let W = 1; W <= h; W++) for (let xe = 0; xe < J; xe++) {
        const de = p ? Q(R[xe], ae[xe], Ee) : R[xe];
        C ? (I.copy(L.normals[W]).multiplyScalar(de.x), b.copy(L.binormals[W]).multiplyScalar(de.y), U.copy(T[W]).add(I).add(b), Ie(U.x, U.y, U.z)) : Ie(de.x, de.y, d / h * W);
      }
      for (let W = S - 1; W >= 0; W--) {
        const xe = W / S, de = g * Math.cos(xe * Math.PI / 2), Me = v * Math.sin(xe * Math.PI / 2) + M;
        for (let pe = 0, Je = X.length; pe < Je; pe++) {
          const De = Q(X[pe], q[pe], Me);
          Ie(De.x, De.y, d + de);
        }
        for (let pe = 0, Je = D.length; pe < Je; pe++) {
          const De = D[pe];
          $ = Y[pe];
          for (let O = 0, N = De.length; O < N; O++) {
            const ie = Q(De[O], $[O], Me);
            C ? Ie(ie.x, ie.y + T[h - 1].y, T[h - 1].x + de) : Ie(ie.x, ie.y, d + de);
          }
        }
      }
      ne(), he();
      function ne() {
        const W = r.length / 3;
        if (p) {
          let xe = 0, de = J * xe;
          for (let Me = 0; Me < ce; Me++) {
            const pe = te[Me];
            Ke(pe[2] + de, pe[1] + de, pe[0] + de);
          }
          xe = h + S * 2, de = J * xe;
          for (let Me = 0; Me < ce; Me++) {
            const pe = te[Me];
            Ke(pe[0] + de, pe[1] + de, pe[2] + de);
          }
        } else {
          for (let xe = 0; xe < ce; xe++) {
            const de = te[xe];
            Ke(de[2], de[1], de[0]);
          }
          for (let xe = 0; xe < ce; xe++) {
            const de = te[xe];
            Ke(de[0] + J * h, de[1] + J * h, de[2] + J * h);
          }
        }
        i.addGroup(W, r.length / 3 - W, 0);
      }
      function he() {
        const W = r.length / 3;
        let xe = 0;
        Ce(X, xe), xe += X.length;
        for (let de = 0, Me = D.length; de < Me; de++) {
          const pe = D[de];
          Ce(pe, xe), xe += pe.length;
        }
        i.addGroup(W, r.length / 3 - W, 1);
      }
      function Ce(W, xe) {
        let de = W.length;
        for (; --de >= 0; ) {
          const Me = de;
          let pe = de - 1;
          pe < 0 && (pe = W.length - 1);
          for (let Je = 0, De = h + S * 2; Je < De; Je++) {
            const O = J * Je, N = J * (Je + 1), ie = xe + Me + O, ye = xe + pe + O, _e = xe + pe + N, ge = xe + Me + N;
            Ve(ie, ye, _e, ge);
          }
        }
      }
      function Ie(W, xe, de) {
        u.push(W), u.push(xe), u.push(de);
      }
      function Ke(W, xe, de) {
        ot(W), ot(xe), ot(de);
        const Me = r.length / 3, pe = E.generateTopUV(i, r, Me - 3, Me - 2, Me - 1);
        He(pe[0]), He(pe[1]), He(pe[2]);
      }
      function Ve(W, xe, de, Me) {
        ot(W), ot(xe), ot(Me), ot(xe), ot(de), ot(Me);
        const pe = r.length / 3, Je = E.generateSideWallUV(i, r, pe - 6, pe - 3, pe - 2, pe - 1);
        He(Je[0]), He(Je[1]), He(Je[3]), He(Je[1]), He(Je[2]), He(Je[3]);
      }
      function ot(W) {
        r.push(u[W * 3 + 0]), r.push(u[W * 3 + 1]), r.push(u[W * 3 + 2]);
      }
      function He(W) {
        s.push(W.x), s.push(W.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return OB(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new Zm[r.type]().fromJSON(r)), new Bg(i, e.options);
  }
}
const UB = { generateTopUV: function(n18, e, t, i, r) {
  const s = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], u = e[i * 3 + 1], f = e[r * 3], h = e[r * 3 + 1];
  return [new me(s, o), new me(a, u), new me(f, h)];
}, generateSideWallUV: function(n18, e, t, i, r, s) {
  const o = e[t * 3], a = e[t * 3 + 1], u = e[t * 3 + 2], f = e[i * 3], h = e[i * 3 + 1], d = e[i * 3 + 2], p = e[r * 3], g = e[r * 3 + 1], v = e[r * 3 + 2], M = e[s * 3], S = e[s * 3 + 1], m = e[s * 3 + 2];
  return Math.abs(a - h) < Math.abs(o - f) ? [new me(o, 1 - u), new me(f, 1 - d), new me(p, 1 - v), new me(M, 1 - m)] : [new me(a, 1 - u), new me(h, 1 - d), new me(g, 1 - v), new me(S, 1 - m)];
} };
function OB(n18, e, t) {
  if (t.shapes = [], Array.isArray(n18)) for (let i = 0, r = n18.length; i < r; i++) {
    const s = n18[i];
    t.shapes.push(s.uuid);
  }
  else t.shapes.push(n18.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class Vg extends fa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new Vg(e.radius, e.detail);
  }
}
class kh extends fa {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new kh(e.radius, e.detail);
  }
}
class Hg extends _t {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: s, thetaLength: o }, i = Math.max(3, i), r = Math.max(1, r);
    const a = [], u = [], f = [], h = [];
    let d = e;
    const p = (t - e) / r, g = new k(), v = new me();
    for (let M = 0; M <= r; M++) {
      for (let S = 0; S <= i; S++) {
        const m = s + S / i * o;
        g.x = d * Math.cos(m), g.y = d * Math.sin(m), u.push(g.x, g.y, g.z), f.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, h.push(v.x, v.y);
      }
      d += p;
    }
    for (let M = 0; M < r; M++) {
      const S = M * (i + 1);
      for (let m = 0; m < i; m++) {
        const E = m + S, T = E, C = E + i + 1, L = E + i + 2, b = E + 1;
        a.push(T, C, b), a.push(C, L, b);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Ye(u, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Hg(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class Gg extends _t {
  constructor(e = new il([new me(0, 0.5), new me(-0.5, -0.5), new me(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const i = [], r = [], s = [], o = [];
    let a = 0, u = 0;
    if (Array.isArray(e) === false) f(e);
    else for (let h = 0; h < e.length; h++) f(e[h]), this.addGroup(a, u, h), a += u, u = 0;
    this.setIndex(i), this.setAttribute("position", new Ye(r, 3)), this.setAttribute("normal", new Ye(s, 3)), this.setAttribute("uv", new Ye(o, 2));
    function f(h) {
      const d = r.length / 3, p = h.extractPoints(t);
      let g = p.shape;
      const v = p.holes;
      Ts.isClockWise(g) === false && (g = g.reverse());
      for (let S = 0, m = v.length; S < m; S++) {
        const E = v[S];
        Ts.isClockWise(E) === true && (v[S] = E.reverse());
      }
      const M = Ts.triangulateShape(g, v);
      for (let S = 0, m = v.length; S < m; S++) {
        const E = v[S];
        g = g.concat(E);
      }
      for (let S = 0, m = g.length; S < m; S++) {
        const E = g[S];
        r.push(E.x, E.y, 0), s.push(0, 0, 1), o.push(E.x, E.y);
      }
      for (let S = 0, m = M.length; S < m; S++) {
        const E = M[S], T = E[0] + d, C = E[1] + d, L = E[2] + d;
        i.push(T, C, L), u += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return FB(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new Gg(i, e.curveSegments);
  }
}
function FB(n18, e) {
  if (e.shapes = [], Array.isArray(n18)) for (let t = 0, i = n18.length; t < i; t++) {
    const r = n18[t];
    e.shapes.push(r.uuid);
  }
  else e.shapes.push(n18.uuid);
  return e;
}
class zh extends _t {
  constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const u = Math.min(o + a, Math.PI);
    let f = 0;
    const h = [], d = new k(), p = new k(), g = [], v = [], M = [], S = [];
    for (let m = 0; m <= i; m++) {
      const E = [], T = m / i;
      let C = 0;
      m === 0 && o === 0 ? C = 0.5 / t : m === i && u === Math.PI && (C = -0.5 / t);
      for (let L = 0; L <= t; L++) {
        const b = L / t;
        d.x = -e * Math.cos(r + b * s) * Math.sin(o + T * a), d.y = e * Math.cos(o + T * a), d.z = e * Math.sin(r + b * s) * Math.sin(o + T * a), v.push(d.x, d.y, d.z), p.copy(d).normalize(), M.push(p.x, p.y, p.z), S.push(b + C, 1 - T), E.push(f++);
      }
      h.push(E);
    }
    for (let m = 0; m < i; m++) for (let E = 0; E < t; E++) {
      const T = h[m][E + 1], C = h[m][E], L = h[m + 1][E], b = h[m + 1][E + 1];
      (m !== 0 || o > 0) && g.push(T, C, b), (m !== i - 1 || u < Math.PI) && g.push(C, L, b);
    }
    this.setIndex(g), this.setAttribute("position", new Ye(v, 3)), this.setAttribute("normal", new Ye(M, 3)), this.setAttribute("uv", new Ye(S, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new zh(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class Wg extends fa {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new Wg(e.radius, e.detail);
  }
}
class Xg extends _t {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }, i = Math.floor(i), r = Math.floor(r);
    const o = [], a = [], u = [], f = [], h = new k(), d = new k(), p = new k();
    for (let g = 0; g <= i; g++) for (let v = 0; v <= r; v++) {
      const M = v / r * s, S = g / i * Math.PI * 2;
      d.x = (e + t * Math.cos(S)) * Math.cos(M), d.y = (e + t * Math.cos(S)) * Math.sin(M), d.z = t * Math.sin(S), a.push(d.x, d.y, d.z), h.x = e * Math.cos(M), h.y = e * Math.sin(M), p.subVectors(d, h).normalize(), u.push(p.x, p.y, p.z), f.push(v / r), f.push(g / i);
    }
    for (let g = 1; g <= i; g++) for (let v = 1; v <= r; v++) {
      const M = (r + 1) * g + v - 1, S = (r + 1) * (g - 1) + v - 1, m = (r + 1) * (g - 1) + v, E = (r + 1) * g + v;
      o.push(M, S, E), o.push(S, m, E);
    }
    this.setIndex(o), this.setAttribute("position", new Ye(a, 3)), this.setAttribute("normal", new Ye(u, 3)), this.setAttribute("uv", new Ye(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Xg(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Yg extends _t {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: s, q: o }, i = Math.floor(i), r = Math.floor(r);
    const a = [], u = [], f = [], h = [], d = new k(), p = new k(), g = new k(), v = new k(), M = new k(), S = new k(), m = new k();
    for (let T = 0; T <= i; ++T) {
      const C = T / i * s * Math.PI * 2;
      E(C, s, o, e, g), E(C + 0.01, s, o, e, v), S.subVectors(v, g), m.addVectors(v, g), M.crossVectors(S, m), m.crossVectors(M, S), M.normalize(), m.normalize();
      for (let L = 0; L <= r; ++L) {
        const b = L / r * Math.PI * 2, I = -t * Math.cos(b), U = t * Math.sin(b);
        d.x = g.x + (I * m.x + U * M.x), d.y = g.y + (I * m.y + U * M.y), d.z = g.z + (I * m.z + U * M.z), u.push(d.x, d.y, d.z), p.subVectors(d, g).normalize(), f.push(p.x, p.y, p.z), h.push(T / i), h.push(L / r);
      }
    }
    for (let T = 1; T <= i; T++) for (let C = 1; C <= r; C++) {
      const L = (r + 1) * (T - 1) + (C - 1), b = (r + 1) * T + (C - 1), I = (r + 1) * T + C, U = (r + 1) * (T - 1) + C;
      a.push(L, b, U), a.push(b, I, U);
    }
    this.setIndex(a), this.setAttribute("position", new Ye(u, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
    function E(T, C, L, b, I) {
      const U = Math.cos(T), B = Math.sin(T), R = L / C * T, D = Math.cos(R);
      I.x = b * (2 + D) * 0.5 * U, I.y = b * (2 + D) * B * 0.5, I.z = b * Math.sin(R) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Yg(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class qg extends _t {
  constructor(e = new r1(new k(-1, -1, 0), new k(-1, 1, 0), new k(1, 1, 0)), t = 64, i = 1, r = 8, s = false) {
    super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: s };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const a = new k(), u = new k(), f = new me();
    let h = new k();
    const d = [], p = [], g = [], v = [];
    M(), this.setIndex(v), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(p, 3)), this.setAttribute("uv", new Ye(g, 2));
    function M() {
      for (let T = 0; T < t; T++) S(T);
      S(s === false ? t : 0), E(), m();
    }
    function S(T) {
      h = e.getPointAt(T / t, h);
      const C = o.normals[T], L = o.binormals[T];
      for (let b = 0; b <= r; b++) {
        const I = b / r * Math.PI * 2, U = Math.sin(I), B = -Math.cos(I);
        u.x = B * C.x + U * L.x, u.y = B * C.y + U * L.y, u.z = B * C.z + U * L.z, u.normalize(), p.push(u.x, u.y, u.z), a.x = h.x + i * u.x, a.y = h.y + i * u.y, a.z = h.z + i * u.z, d.push(a.x, a.y, a.z);
      }
    }
    function m() {
      for (let T = 1; T <= t; T++) for (let C = 1; C <= r; C++) {
        const L = (r + 1) * (T - 1) + (C - 1), b = (r + 1) * T + (C - 1), I = (r + 1) * T + C, U = (r + 1) * (T - 1) + C;
        v.push(L, b, U), v.push(b, I, U);
      }
    }
    function E() {
      for (let T = 0; T <= t; T++) for (let C = 0; C <= r; C++) f.x = T / t, f.y = C / r, g.push(f.x, f.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new qg(new Zm[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
  }
}
class PP extends _t {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), r = new k(), s = new k();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let u = e.groups;
        u.length === 0 && (u = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let f = 0, h = u.length; f < h; ++f) {
          const d = u[f], p = d.start, g = d.count;
          for (let v = p, M = p + g; v < M; v += 3) for (let S = 0; S < 3; S++) {
            const m = a.getX(v + S), E = a.getX(v + (S + 1) % 3);
            r.fromBufferAttribute(o, m), s.fromBufferAttribute(o, E), IT(r, s, i) === true && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, u = o.count / 3; a < u; a++) for (let f = 0; f < 3; f++) {
          const h = 3 * a + f, d = 3 * a + (f + 1) % 3;
          r.fromBufferAttribute(o, h), s.fromBufferAttribute(o, d), IT(r, s, i) === true && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
        }
      }
      this.setAttribute("position", new Ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function IT(n18, e, t) {
  const i = `${n18.x},${n18.y},${n18.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n18.x},${n18.y},${n18.z}`;
  return t.has(i) === true || t.has(r) === true ? false : (t.add(i), t.add(r), true);
}
var DT = Object.freeze({ __proto__: null, BoxGeometry: yl, CapsuleGeometry: Ug, CircleGeometry: Og, ConeGeometry: Fg, CylinderGeometry: gc, DodecahedronGeometry: kg, EdgesGeometry: TP, ExtrudeGeometry: Bg, IcosahedronGeometry: Vg, LatheGeometry: Fh, OctahedronGeometry: kh, PlaneGeometry: pc, PolyhedronGeometry: fa, RingGeometry: Hg, ShapeGeometry: Gg, SphereGeometry: zh, TetrahedronGeometry: Wg, TorusGeometry: Xg, TorusKnotGeometry: Yg, TubeGeometry: qg, WireframeGeometry: PP });
class bP extends vi {
  constructor(e) {
    super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Oe(0), this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class LP extends es {
  constructor(e) {
    super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
  }
}
class o1 extends vi {
  constructor(e) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Oe(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class IP extends o1 {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new me(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return mn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t) {
      this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Oe(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Oe(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Oe(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class DP extends vi {
  constructor(e) {
    super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Oe(16777215), this.specular = new Oe(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class NP extends vi {
  constructor(e) {
    super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Oe(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class UP extends vi {
  constructor(e) {
    super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class OP extends vi {
  constructor(e) {
    super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Oe(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Oe(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = bh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class FP extends vi {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Oe(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = ua, this.normalScale = new me(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class kP extends Di {
  constructor(e) {
    super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function ja(n18, e, t) {
  return !n18 || !t && n18.constructor === e ? n18 : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n18) : Array.prototype.slice.call(n18);
}
function zP(n18) {
  return ArrayBuffer.isView(n18) && !(n18 instanceof DataView);
}
function BP(n18) {
  function e(r, s) {
    return n18[r] - n18[s];
  }
  const t = n18.length, i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function hx(n18, e, t) {
  const i = n18.length, r = new n18.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let u = 0; u !== e; ++u) r[o++] = n18[a + u];
  }
  return r;
}
function a1(n18, e, t, i) {
  let r = 1, s = n18[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n18[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0) if (Array.isArray(o)) do
    o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n18[r++];
  while (s !== void 0);
  else if (o.toArray !== void 0) do
    o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n18[r++];
  while (s !== void 0);
  else do
    o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n18[r++];
  while (s !== void 0);
}
function kB(n18, e, t, i, r = 30) {
  const s = n18.clone();
  s.name = e;
  const o = [];
  for (let u = 0; u < s.tracks.length; ++u) {
    const f = s.tracks[u], h = f.getValueSize(), d = [], p = [];
    for (let g = 0; g < f.times.length; ++g) {
      const v = f.times[g] * r;
      if (!(v < t || v >= i)) {
        d.push(f.times[g]);
        for (let M = 0; M < h; ++M) p.push(f.values[g * h + M]);
      }
    }
    d.length !== 0 && (f.times = ja(d, f.times.constructor), f.values = ja(p, f.values.constructor), o.push(f));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let u = 0; u < s.tracks.length; ++u) a > s.tracks[u].times[0] && (a = s.tracks[u].times[0]);
  for (let u = 0; u < s.tracks.length; ++u) s.tracks[u].shift(-1 * a);
  return s.resetDuration(), s;
}
function zB(n18, e = 0, t = n18, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length, s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o], u = a.ValueTypeName;
    if (u === "bool" || u === "string") continue;
    const f = n18.tracks.find(function(m) {
      return m.name === a.name && m.ValueTypeName === u;
    });
    if (f === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
    let p = 0;
    const g = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = g / 3);
    const v = a.times.length - 1;
    let M;
    if (s <= a.times[0]) {
      const m = h, E = d - h;
      M = a.values.slice(m, E);
    } else if (s >= a.times[v]) {
      const m = v * d + h, E = m + d - h;
      M = a.values.slice(m, E);
    } else {
      const m = a.createInterpolant(), E = h, T = d - h;
      m.evaluate(s), M = m.resultBuffer.slice(E, T);
    }
    u === "quaternion" && new Gi().fromArray(M).normalize().conjugate().toArray(M);
    const S = f.times.length;
    for (let m = 0; m < S; ++m) {
      const E = m * g + p;
      if (u === "quaternion") Gi.multiplyQuaternionsFlat(f.values, E, M, 0, f.values, E);
      else {
        const T = g - p * 2;
        for (let C = 0; C < T; ++C) f.values[E + C] -= M[C];
      }
    }
  }
  return n18.blendMode = FS, n18;
}
const BB = { convertArray: ja, isTypedArray: zP, getKeyframeOrder: BP, sortedArray: hx, flattenJSON: a1, subclip: kB, makeClipAdditive: zB };
class Bh {
  constructor(e, t, i, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, r = t[i], s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === a) break;
              if (s = r, r = t[++i], e < r) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && (i = 2, s = a);
            for (let u = i - 2; ; ) {
              if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === u) break;
              if (r = s, s = t[--i - 1], e >= s) break t;
            }
            o = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = i + o >>> 1;
          e < t[a] ? o = a : i = a + 1;
        }
        if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class VP extends Bh {
  constructor(e, t, i, r) {
    super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Xa, endingEnd: Xa };
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2, o = e + 1, a = r[s], u = r[o];
    if (a === void 0) switch (this.getSettings_().endingStart) {
      case Ya:
        s = e, a = 2 * t - i;
        break;
      case ih:
        s = r.length - 2, a = t + r[s] - r[s + 1];
        break;
      default:
        s = e, a = i;
    }
    if (u === void 0) switch (this.getSettings_().endingEnd) {
      case Ya:
        o = e, u = 2 * i - t;
        break;
      case ih:
        o = 1, u = i + r[1] - r[0];
        break;
      default:
        o = e - 1, u = t;
    }
    const f = (i - t) * 0.5, h = this.valueSize;
    this._weightPrev = f / (t - a), this._weightNext = f / (u - i), this._offsetPrev = s * h, this._offsetNext = o * h;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, u = e * a, f = u - a, h = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, g = this._weightNext, v = (i - t) / (r - t), M = v * v, S = M * v, m = -p * S + 2 * p * M - p * v, E = (1 + p) * S + (-1.5 - 2 * p) * M + (-0.5 + p) * v + 1, T = (-1 - g) * S + (1.5 + g) * M + 0.5 * v, C = g * S - g * M;
    for (let L = 0; L !== a; ++L) s[L] = m * o[h + L] + E * o[f + L] + T * o[u + L] + C * o[d + L];
    return s;
  }
}
class l1 extends Bh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, u = e * a, f = u - a, h = (i - t) / (r - t), d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[f + p] * d + o[u + p] * h;
    return s;
  }
}
class HP extends Bh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ns {
  constructor(e, t, i, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = ja(t, this.TimeBufferType), this.values = ja(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = { name: e.name, times: ja(e.times, Array), values: ja(e.values, Array) };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new HP(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new l1(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new VP(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case th:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case nh:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case dm:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
      else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return th;
      case this.InterpolantFactoryMethodLinear:
        return nh;
      case this.InterpolantFactoryMethodSmooth:
        return dm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times, r = i.length;
    let s = 0, o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = i.slice(s, o), this.values = this.values.slice(s * a, o * a);
    }
    return this;
  }
  validate() {
    let e = true;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
    const i = this.times, r = this.values, s = i.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const u = i[a];
      if (typeof u == "number" && isNaN(u)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, u), e = false;
        break;
      }
      if (o !== null && o > u) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, u, o), e = false;
        break;
      }
      o = u;
    }
    if (r !== void 0 && zP(r)) for (let a = 0, u = r.length; a !== u; ++a) {
      const f = r[a];
      if (isNaN(f)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f), e = false;
        break;
      }
    }
    return e;
  }
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), r = this.getInterpolation() === dm, s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let u = false;
      const f = e[a], h = e[a + 1];
      if (f !== h && (a !== 1 || f !== e[0])) if (r) u = true;
      else {
        const d = a * i, p = d - i, g = d + i;
        for (let v = 0; v !== i; ++v) {
          const M = t[d + v];
          if (M !== t[p + v] || M !== t[g + v]) {
            u = true;
            break;
          }
        }
      }
      if (u) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i, p = o * i;
          for (let g = 0; g !== i; ++g) t[p + g] = t[d + g];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, u = o * i, f = 0; f !== i; ++f) t[u + f] = t[a + f];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), i = this.constructor, r = new i(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
ns.prototype.TimeBufferType = Float32Array;
ns.prototype.ValueBufferType = Float32Array;
ns.prototype.DefaultInterpolation = nh;
class xl extends ns {
}
xl.prototype.ValueTypeName = "bool";
xl.prototype.ValueBufferType = Array;
xl.prototype.DefaultInterpolation = th;
xl.prototype.InterpolantFactoryMethodLinear = void 0;
xl.prototype.InterpolantFactoryMethodSmooth = void 0;
class u1 extends ns {
}
u1.prototype.ValueTypeName = "color";
class ph extends ns {
}
ph.prototype.ValueTypeName = "number";
class GP extends Bh {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, u = (i - t) / (r - t);
    let f = e * a;
    for (let h = f + a; f !== h; f += 4) Gi.slerpFlat(s, 0, o, f - a, o, f, u);
    return s;
  }
}
class _c extends ns {
  InterpolantFactoryMethodLinear(e) {
    return new GP(this.times, this.values, this.getValueSize(), e);
  }
}
_c.prototype.ValueTypeName = "quaternion";
_c.prototype.DefaultInterpolation = nh;
_c.prototype.InterpolantFactoryMethodSmooth = void 0;
class Sl extends ns {
}
Sl.prototype.ValueTypeName = "string";
Sl.prototype.ValueBufferType = Array;
Sl.prototype.DefaultInterpolation = th;
Sl.prototype.InterpolantFactoryMethodLinear = void 0;
Sl.prototype.InterpolantFactoryMethodSmooth = void 0;
class mh extends ns {
}
mh.prototype.ValueTypeName = "vector";
class gh {
  constructor(e, t = -1, i, r = Tg) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = fr(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(HB(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(ns.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length, o = [];
    for (let a = 0; a < s; a++) {
      let u = [], f = [];
      u.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
      const h = BP(u);
      u = hx(u, 1, h), f = hx(f, 1, h), !r && u[0] === 0 && (u.push(s), f.push(f[0])), o.push(new ph(".morphTargetInfluences[" + t[a].name + "]", u, f).scale(1 / i));
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, u = e.length; a < u; a++) {
      const f = e[a], h = f.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(f);
      }
    }
    const o = [];
    for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(d, p, g, v, M) {
      if (g.length !== 0) {
        const S = [], m = [];
        a1(g, S, m, v), S.length !== 0 && M.push(new d(p, S, m));
      }
    }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let u = e.length || -1;
    const f = e.hierarchy || [];
    for (let d = 0; d < f.length; d++) {
      const p = f[d].keys;
      if (!(!p || p.length === 0)) if (p[0].morphTargets) {
        const g = {};
        let v;
        for (v = 0; v < p.length; v++) if (p[v].morphTargets) for (let M = 0; M < p[v].morphTargets.length; M++) g[p[v].morphTargets[M]] = -1;
        for (const M in g) {
          const S = [], m = [];
          for (let E = 0; E !== p[v].morphTargets.length; ++E) {
            const T = p[v];
            S.push(T.time), m.push(T.morphTarget === M ? 1 : 0);
          }
          r.push(new ph(".morphTargetInfluence[" + M + "]", S, m));
        }
        u = g.length * o;
      } else {
        const g = ".bones[" + t[d].name + "]";
        i(mh, g + ".position", p, "pos", r), i(_c, g + ".quaternion", p, "rot", r), i(mh, g + ".scale", p, "scl", r);
      }
    }
    return r.length === 0 ? null : new this(s, u, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = true;
    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function VB(n18) {
  switch (n18.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return ph;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return mh;
    case "color":
      return u1;
    case "quaternion":
      return _c;
    case "bool":
    case "boolean":
      return xl;
    case "string":
      return Sl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n18);
}
function HB(n18) {
  if (n18.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = VB(n18.type);
  if (n18.times === void 0) {
    const t = [], i = [];
    a1(n18.keys, t, i, "value"), n18.times = t, n18.values = i;
  }
  return e.parse !== void 0 ? e.parse(n18) : new e(n18.name, n18.times, n18.values, n18.interpolation);
}
const Ks = { enabled: false, files: {}, add: function(n18, e) {
  this.enabled !== false && (this.files[n18] = e);
}, get: function(n18) {
  if (this.enabled !== false) return this.files[n18];
}, remove: function(n18) {
  delete this.files[n18];
}, clear: function() {
  this.files = {};
} };
class c1 {
  constructor(e, t, i) {
    const r = this;
    let s = false, o = 0, a = 0, u;
    const f = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
      a++, s === false && r.onStart !== void 0 && r.onStart(h, o, a), s = true;
    }, this.itemEnd = function(h) {
      o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (s = false, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(h) {
      r.onError !== void 0 && r.onError(h);
    }, this.resolveURL = function(h) {
      return u ? u(h) : h;
    }, this.setURLModifier = function(h) {
      return u = h, this;
    }, this.addHandler = function(h, d) {
      return f.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = f.indexOf(h);
      return d !== -1 && f.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = f.length; d < p; d += 2) {
        const g = f[d], v = f[d + 1];
        if (g.global && (g.lastIndex = 0), g.test(h)) return v;
      }
      return null;
    };
  }
}
const WP = new c1();
class Zi {
  constructor(e) {
    this.manager = e !== void 0 ? e : WP, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
Zi.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const Hs = {};
class GB extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class oo extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = Ks.get(e);
    if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
      t && t(s), this.manager.itemEnd(e);
    }, 0), s;
    if (Hs[e] !== void 0) {
      Hs[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    Hs[e] = [], Hs[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, u = this.responseType;
    fetch(o).then((f) => {
      if (f.status === 200 || f.status === 0) {
        if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0) return f;
        const h = Hs[e], d = f.body.getReader(), p = f.headers.get("Content-Length") || f.headers.get("X-File-Size"), g = p ? parseInt(p) : 0, v = g !== 0;
        let M = 0;
        const S = new ReadableStream({ start(m) {
          E();
          function E() {
            d.read().then(({ done: T, value: C }) => {
              if (T) m.close();
              else {
                M += C.byteLength;
                const L = new ProgressEvent("progress", { lengthComputable: v, loaded: M, total: g });
                for (let b = 0, I = h.length; b < I; b++) {
                  const U = h[b];
                  U.onProgress && U.onProgress(L);
                }
                m.enqueue(C), E();
              }
            });
          }
        } });
        return new Response(S);
      } else throw new GB(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`, f);
    }).then((f) => {
      switch (u) {
        case "arraybuffer":
          return f.arrayBuffer();
        case "blob":
          return f.blob();
        case "document":
          return f.text().then((h) => new DOMParser().parseFromString(h, a));
        case "json":
          return f.json();
        default:
          if (a === void 0) return f.text();
          {
            const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, g = new TextDecoder(p);
            return f.arrayBuffer().then((v) => g.decode(v));
          }
      }
    }).then((f) => {
      Ks.add(e, f);
      const h = Hs[e];
      delete Hs[e];
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        g.onLoad && g.onLoad(f);
      }
    }).catch((f) => {
      const h = Hs[e];
      if (h === void 0) throw this.manager.itemError(e), f;
      delete Hs[e];
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        g.onError && g.onError(f);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class WB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new oo(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (u) {
        r ? r(u) : console.error(u), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = gh.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class XB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = [], a = new Dg(), u = new oo(this.manager);
    u.setPath(this.path), u.setResponseType("arraybuffer"), u.setRequestHeader(this.requestHeader), u.setWithCredentials(s.withCredentials);
    let f = 0;
    function h(d) {
      u.load(e[d], function(p) {
        const g = s.parse(p, true);
        o[d] = { width: g.width, height: g.height, format: g.format, mipmaps: g.mipmaps }, f += 1, f === 6 && (g.mipmapCount === 1 && (a.minFilter = sn), a.image = o, a.format = g.format, a.needsUpdate = true, t && t(a));
      }, i, r);
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else u.load(e, function(d) {
      const p = s.parse(d, true);
      if (p.isCubemap) {
        const g = p.mipmaps.length / p.mipmapCount;
        for (let v = 0; v < g; v++) {
          o[v] = { mipmaps: [] };
          for (let M = 0; M < p.mipmapCount; M++) o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + M]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height;
        }
        a.image = o;
      } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps;
      p.mipmapCount === 1 && (a.minFilter = sn), a.format = p.format, a.needsUpdate = true, t && t(a);
    }, i, r);
    return a;
  }
}
class _h extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = Ks.get(e);
    if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
      t && t(o), s.manager.itemEnd(e);
    }, 0), o;
    const a = uh("img");
    function u() {
      h(), Ks.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function f(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", u, false), a.removeEventListener("error", f, false);
    }
    return a.addEventListener("load", u, false), a.addEventListener("error", f, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
  }
}
class YB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Nh();
    s.colorSpace = Nn;
    const o = new _h(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function u(f) {
      o.load(e[f], function(h) {
        s.images[f] = h, a++, a === 6 && (s.needsUpdate = true, t && t(s));
      }, void 0, r);
    }
    for (let f = 0; f < e.length; ++f) u(f);
    return s;
  }
}
class qB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new nl(), a = new oo(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(u) {
      let f;
      try {
        f = s.parse(u);
      } catch (h) {
        if (r !== void 0) r(h);
        else {
          console.error(h);
          return;
        }
      }
      f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width, o.image.height = f.height, o.image.data = f.data), o.wrapS = f.wrapS !== void 0 ? f.wrapS : hi, o.wrapT = f.wrapT !== void 0 ? f.wrapT : hi, o.magFilter = f.magFilter !== void 0 ? f.magFilter : sn, o.minFilter = f.minFilter !== void 0 ? f.minFilter : sn, o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.colorSpace !== void 0 ? o.colorSpace = f.colorSpace : f.encoding !== void 0 && (o.encoding = f.encoding), f.flipY !== void 0 && (o.flipY = f.flipY), f.format !== void 0 && (o.format = f.format), f.type !== void 0 && (o.type = f.type), f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps, o.minFilter = vs), f.mipmapCount === 1 && (o.minFilter = sn), f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps), o.needsUpdate = true, t && t(o, f);
    }, i, r), o;
  }
}
class jB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new _n(), o = new _h(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      s.image = a, s.needsUpdate = true, t !== void 0 && t(s);
    }, i, r), s;
  }
}
class ha extends Nt {
  constructor(e, t = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Oe(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class XP extends ha {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Nt.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Oe(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const fv = new st(), NT = new k(), UT = new k();
class f1 {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new me(512, 512), this.map = null, this.mapPass = null, this.matrix = new st(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Uh(), this._frameExtents = new me(1, 1), this._viewportCount = 1, this._viewports = [new Bt(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    NT.setFromMatrixPosition(e.matrixWorld), t.position.copy(NT), UT.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(UT), t.updateMatrixWorld(), fv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(fv), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(fv);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
  }
}
class ZB extends f1 {
  constructor() {
    super(new Xn(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = Qu * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class YP extends ha {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Nt.DEFAULT_UP), this.updateMatrix(), this.target = new Nt(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new ZB();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const OT = new st(), rf = new k(), hv = new k();
class JB extends f1 {
  constructor() {
    super(new Xn(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new me(4, 2), this._viewportCount = 6, this._viewports = [new Bt(2, 1, 1, 1), new Bt(0, 1, 1, 1), new Bt(3, 1, 1, 1), new Bt(1, 1, 1, 1), new Bt(3, 0, 1, 1), new Bt(1, 0, 1, 1)], this._cubeDirections = [new k(1, 0, 0), new k(-1, 0, 0), new k(0, 0, 1), new k(0, 0, -1), new k(0, 1, 0), new k(0, -1, 0)], this._cubeUps = [new k(0, 1, 0), new k(0, 1, 0), new k(0, 1, 0), new k(0, 1, 0), new k(0, 0, 1), new k(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, r = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), rf.setFromMatrixPosition(e.matrixWorld), i.position.copy(rf), hv.copy(i.position), hv.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(hv), i.updateMatrixWorld(), r.makeTranslation(-rf.x, -rf.y, -rf.z), OT.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(OT);
  }
}
class qP extends ha {
  constructor(e, t, i = 0, r = 2) {
    super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new JB();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class KB extends f1 {
  constructor() {
    super(new Oh(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
}
class jP extends ha {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Nt.DEFAULT_UP), this.updateMatrix(), this.target = new Nt(), this.shadow = new KB();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class ZP extends ha {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
  }
}
class JP extends ha {
  constructor(e, t, i = 10, r = 10) {
    super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = i, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class KP {
  constructor() {
    this.isSphericalHarmonics3 = true, this.coefficients = [];
    for (let e = 0; e < 9; e++) this.coefficients.push(new k());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * r), t.addScaledVector(o[2], 0.488603 * s), t.addScaledVector(o[3], 0.488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], 0.546274 * (i * i - r * r)), t;
  }
  getIrradianceAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * r), t.addScaledVector(o[2], 2 * 0.511664 * s), t.addScaledVector(o[3], 2 * 0.511664 * i), t.addScaledVector(o[4], 2 * 0.429043 * i * r), t.addScaledVector(o[5], 2 * 0.429043 * r * s), t.addScaledVector(o[6], 0.743125 * s * s - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * i * s), t.addScaledVector(o[8], 0.429043 * (i * i - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
    return true;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = 0.546274 * (i * i - r * r);
  }
}
class QP extends ha {
  constructor(e = new KP(), t = 1) {
    super(void 0, t), this.isLightProbe = true, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class jg extends Zi {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, r) {
    const s = this, o = new oo(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (u) {
        r ? r(u) : console.error(u), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const r = jg.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Oe().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) {
      const o = e.uniforms[s];
      switch (r.uniforms[s] = {}, o.type) {
        case "t":
          r.uniforms[s].value = i(o.value);
          break;
        case "c":
          r.uniforms[s].value = new Oe().setHex(o.value);
          break;
        case "v2":
          r.uniforms[s].value = new me().fromArray(o.value);
          break;
        case "v3":
          r.uniforms[s].value = new k().fromArray(o.value);
          break;
        case "v4":
          r.uniforms[s].value = new Bt().fromArray(o.value);
          break;
        case "m3":
          r.uniforms[s].value = new yt().fromArray(o.value);
          break;
        case "m4":
          r.uniforms[s].value = new st().fromArray(o.value);
          break;
        default:
          r.uniforms[s].value = o.value;
      }
    }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === false && (s = [s, s]), r.normalScale = new me().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new me().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = { ShadowMaterial: bP, SpriteMaterial: KS, RawShaderMaterial: LP, ShaderMaterial: es, PointsMaterial: $S, MeshPhysicalMaterial: IP, MeshStandardMaterial: o1, MeshPhongMaterial: DP, MeshToonMaterial: NP, MeshNormalMaterial: UP, MeshLambertMaterial: OP, MeshDepthMaterial: qS, MeshDistanceMaterial: jS, MeshBasicMaterial: ca, MeshMatcapMaterial: FP, LineDashedMaterial: kP, LineBasicMaterial: Di, Material: vi };
    return new t[e]();
  }
}
class dx {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class $P extends _t {
  constructor() {
    super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e;
  }
}
class eb extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new oo(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (u) {
        r ? r(u) : console.error(u), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = {}, i = {};
    function r(g, v) {
      if (t[v] !== void 0) return t[v];
      const S = g.interleavedBuffers[v], m = s(g, S.buffer), E = Tu(S.type, m), T = new Lg(E, S.stride);
      return T.uuid = S.uuid, t[v] = T, T;
    }
    function s(g, v) {
      if (i[v] !== void 0) return i[v];
      const S = g.arrayBuffers[v], m = new Uint32Array(S).buffer;
      return i[v] = m, m;
    }
    const o = e.isInstancedBufferGeometry ? new $P() : new _t(), a = e.data.index;
    if (a !== void 0) {
      const g = Tu(a.type, a.array);
      o.setIndex(new Ot(g, 1));
    }
    const u = e.data.attributes;
    for (const g in u) {
      const v = u[g];
      let M;
      if (v.isInterleavedBufferAttribute) {
        const S = r(e.data, v.data);
        M = new pl(S, v.itemSize, v.offset, v.normalized);
      } else {
        const S = Tu(v.type, v.array), m = v.isInstancedBufferAttribute ? ec : Ot;
        M = new m(S, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (M.name = v.name), v.usage !== void 0 && M.setUsage(v.usage), o.setAttribute(g, M);
    }
    const f = e.data.morphAttributes;
    if (f) for (const g in f) {
      const v = f[g], M = [];
      for (let S = 0, m = v.length; S < m; S++) {
        const E = v[S];
        let T;
        if (E.isInterleavedBufferAttribute) {
          const C = r(e.data, E.data);
          T = new pl(C, E.itemSize, E.offset, E.normalized);
        } else {
          const C = Tu(E.type, E.array);
          T = new Ot(C, E.itemSize, E.normalized);
        }
        E.name !== void 0 && (T.name = E.name), M.push(T);
      }
      o.morphAttributes[g] = M;
    }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = true);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0) for (let g = 0, v = d.length; g !== v; ++g) {
      const M = d[g];
      o.addGroup(M.start, M.count, M.materialIndex);
    }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const g = new k();
      p.center !== void 0 && g.fromArray(p.center), o.boundingSphere = new mi(g, p.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class QB extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = this.path === "" ? dx.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new oo(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(u) {
      let f = null;
      try {
        f = JSON.parse(u);
      } catch (d) {
        r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
        return;
      }
      const h = f.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(f, t);
    }, i, r);
  }
  async loadAsync(e, t) {
    const i = this, r = this.path === "" ? dx.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new oo(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t), a = JSON.parse(o), u = a.metadata;
    if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function() {
      t !== void 0 && t(f);
    }), a = this.parseTextures(e.textures, o), u = this.parseMaterials(e.materials, a), f = this.parseObject(e.object, s, u, a, i), h = this.parseSkeletons(e.skeletons, f);
    if (this.bindSkeletons(f, h), t !== void 0) {
      let d = false;
      for (const p in o) if (o[p].data instanceof HTMLImageElement) {
        d = true;
        break;
      }
      d === false && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), u = this.parseObject(e.object, r, a, o, t), f = this.parseSkeletons(e.skeletons, u);
    return this.bindSkeletons(u, f), u;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0) for (let i = 0, r = e.length; i < r; i++) {
      const s = new il().fromJSON(e[i]);
      t[s.uuid] = s;
    }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, r = {};
    if (t.traverse(function(s) {
      s.isBone && (r[s.uuid] = s);
    }), e !== void 0) for (let s = 0, o = e.length; s < o; s++) {
      const a = new Ig().fromJSON(e[s], r);
      i[a.uuid] = a;
    }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new eb();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const u = e[s];
        switch (u.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(u);
            break;
          default:
            u.type in DT ? a = DT[u.type].fromJSON(u, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${u.type}"`);
        }
        a.uuid = u.uuid, u.name !== void 0 && (a.name = u.name), u.userData !== void 0 && (a.userData = u.userData), i[u.uuid] = a;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, r = {};
    if (e !== void 0) {
      const s = new jg();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o];
        i[u.uuid] === void 0 && (i[u.uuid] = s.parse(u)), r[u.uuid] = i[u.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0) for (let i = 0; i < e.length; i++) {
      const r = e[i], s = gh.parse(r);
      t[s.uuid] = s;
    }
    return t;
  }
  parseImages(e, t) {
    const i = this, r = {};
    let s;
    function o(u) {
      return i.manager.itemStart(u), s.load(u, function() {
        i.manager.itemEnd(u);
      }, void 0, function() {
        i.manager.itemError(u), i.manager.itemEnd(u);
      });
    }
    function a(u) {
      if (typeof u == "string") {
        const f = u, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
        return o(h);
      } else return u.data ? { data: Tu(u.type, u.data), width: u.width, height: u.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const u = new c1(t);
      s = new _h(u), s.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f], p = d.url;
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, M = p.length; v < M; v++) {
            const S = p[v], m = a(S);
            m !== null && (m instanceof HTMLImageElement ? g.push(m) : g.push(new nl(m.data, m.width, m.height)));
          }
          r[d.uuid] = new qa(g);
        } else {
          const g = a(d.url);
          r[d.uuid] = new qa(g);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o, u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(u);
      } else return o.data ? { data: Tu(o.type, o.data), width: o.width, height: o.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new _h(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const u = e[o], f = u.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let d = 0, p = f.length; d < p; d++) {
            const g = f[d], v = await s(g);
            v !== null && (v instanceof HTMLImageElement ? h.push(v) : h.push(new nl(v.data, v.width, v.height)));
          }
          i[u.uuid] = new qa(h);
        } else {
          const h = await s(u.url);
          i[u.uuid] = new qa(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]);
    }
    const r = {};
    if (e !== void 0) for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
      const u = t[a.image], f = u.data;
      let h;
      Array.isArray(f) ? (h = new Nh(), f.length === 6 && (h.needsUpdate = true)) : (f && f.data ? h = new nl() : h = new _n(), f && (h.needsUpdate = true)), h.source = u, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = i(a.mapping, $B)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = i(a.wrap[0], FT), h.wrapT = i(a.wrap[1], FT)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, kT)), a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, kT)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), r[a.uuid] = h;
    }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function u(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, M = p.length; v < M; v++) {
            const S = p[v];
            i[S] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", S), g.push(i[S]);
          }
          return g;
        }
        return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p];
      }
    }
    function f(p) {
      return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p];
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        o = new JS(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Oe(e.background) : o.background = f(e.background)), e.environment !== void 0 && (o.environment = f(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new bg(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new Pg(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        o = new Xn(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new Oh(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new ZP(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new jP(e.color, e.intensity);
        break;
      case "PointLight":
        o = new qP(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new JP(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new YP(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        o = new XP(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new QP().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = a(e.geometry), d = u(e.material), o = new mP(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = a(e.geometry), d = u(e.material), o = new Ln(h, d);
        break;
      case "InstancedMesh":
        h = a(e.geometry), d = u(e.material);
        const p = e.count, g = e.instanceMatrix, v = e.instanceColor;
        o = new gP(h, d, p), o.instanceMatrix = new ec(new Float32Array(g.array), 16), v !== void 0 && (o.instanceColor = new ec(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        h = a(e.geometry), d = u(e.material), o = new _P(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, d), o.geometry = h, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((M) => {
          const S = new bi();
          S.min.fromArray(M.boxMin), S.max.fromArray(M.boxMax);
          const m = new mi();
          return m.radius = M.sphereRadius, m.center.fromArray(M.sphereCenter), { boxInitialized: M.boxInitialized, box: S, sphereInitialized: M.sphereInitialized, sphere: m };
        }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = f(e.matricesTexture.uuid);
        break;
      case "LOD":
        o = new pP();
        break;
      case "Line":
        o = new ia(a(e.geometry), u(e.material));
        break;
      case "LineLoop":
        o = new vP(a(e.geometry), u(e.material));
        break;
      case "LineSegments":
        o = new bs(a(e.geometry), u(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new yP(a(e.geometry), u(e.material));
        break;
      case "Sprite":
        o = new dP(u(e.material));
        break;
      case "Group":
        o = new Ru();
        break;
      case "Bone":
        o = new QS();
        break;
      default:
        o = new Nt();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const p = e.children;
      for (let g = 0; g < p.length; g++) o.add(this.parseObject(p[g], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let g = 0; g < p.length; g++) {
        const v = p[g];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let g = 0; g < p.length; g++) {
        const v = p[g], M = o.getObjectByProperty("uuid", v.object);
        M !== void 0 && o.addLevel(M, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === true && i.skeleton !== void 0) {
        const r = t[i.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix);
      }
    });
  }
}
const $B = { UVMapping: wg, CubeReflectionMapping: so, CubeRefractionMapping: na, EquirectangularReflectionMapping: Kf, EquirectangularRefractionMapping: Qf, CubeUVReflectionMapping: hc }, FT = { RepeatWrapping: $f, ClampToEdgeWrapping: hi, MirroredRepeatWrapping: eh }, kT = { NearestFilter: Mn, NearestMipmapNearestFilter: Ym, NearestMipmapLinearFilter: Ba, LinearFilter: sn, LinearMipmapNearestFilter: Af, LinearMipmapLinearFilter: vs };
class e4 extends Zi {
  constructor(e) {
    super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = Ks.get(e);
    if (o !== void 0) {
      if (s.manager.itemStart(e), o.then) {
        o.then((f) => {
          t && t(f), s.manager.itemEnd(e);
        }).catch((f) => {
          r && r(f);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    }
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
    const u = fetch(e, a).then(function(f) {
      return f.blob();
    }).then(function(f) {
      return createImageBitmap(f, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(f) {
      return Ks.add(e, f), t && t(f), s.manager.itemEnd(e), f;
    }).catch(function(f) {
      r && r(f), Ks.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
    });
    Ks.add(e, u), s.manager.itemStart(e);
  }
}
let zp;
class h1 {
  static getContext() {
    return zp === void 0 && (zp = new (window.AudioContext || window.webkitAudioContext)()), zp;
  }
  static setContext(e) {
    zp = e;
  }
}
class t4 extends Zi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new oo(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(u) {
      try {
        const f = u.slice(0);
        h1.getContext().decodeAudioData(f, function(d) {
          t(d);
        }).catch(a);
      } catch (f) {
        a(f);
      }
    }, i, r);
    function a(u) {
      r ? r(u) : console.error(u), s.manager.itemError(e);
    }
  }
}
const zT = new st(), BT = new st(), Ra = new st();
class n4 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new Xn(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new Xn(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, Ra.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan($a * t.fov * 0.5) / t.zoom;
      let a, u;
      BT.elements[12] = -r, zT.elements[12] = r, a = -o * t.aspect + s, u = o * t.aspect + s, Ra.elements[0] = 2 * t.near / (u - a), Ra.elements[8] = (u + a) / (u - a), this.cameraL.projectionMatrix.copy(Ra), a = -o * t.aspect - s, u = o * t.aspect - s, Ra.elements[0] = 2 * t.near / (u - a), Ra.elements[8] = (u + a) / (u - a), this.cameraR.projectionMatrix.copy(Ra);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(BT), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(zT);
  }
}
class d1 {
  constructor(e = true) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = VT(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = VT();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function VT() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Pa = new k(), HT = new Gi(), i4 = new k(), ba = new k();
class r4 extends Nt {
  constructor() {
    super(), this.type = "AudioListener", this.context = h1.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new d1();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Pa, HT, i4), ba.set(0, 0, -1).applyQuaternion(HT), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(Pa.x, r), t.positionY.linearRampToValueAtTime(Pa.y, r), t.positionZ.linearRampToValueAtTime(Pa.z, r), t.forwardX.linearRampToValueAtTime(ba.x, r), t.forwardY.linearRampToValueAtTime(ba.y, r), t.forwardZ.linearRampToValueAtTime(ba.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r);
    } else t.setPosition(Pa.x, Pa.y, Pa.z), t.setOrientation(ba.x, ba.y, ba.z, i.x, i.y, i.z);
  }
}
class tb extends Nt {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = false, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return this._connected = true, this;
  }
  disconnect() {
    if (this._connected !== false) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === true ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === true && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === true && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const La = new k(), GT = new Gi(), s4 = new k(), Ia = new k();
class o4 extends tb {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(La, GT, s4), Ia.set(0, 0, 1).applyQuaternion(GT);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(La.x, i), t.positionY.linearRampToValueAtTime(La.y, i), t.positionZ.linearRampToValueAtTime(La.z, i), t.orientationX.linearRampToValueAtTime(Ia.x, i), t.orientationY.linearRampToValueAtTime(Ia.y, i), t.orientationZ.linearRampToValueAtTime(Ia.z, i);
    } else t.setPosition(La.x, La.y, La.z), t.setOrientation(Ia.x, Ia.y, Ia.z);
  }
}
class a4 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class nb {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let r, s, o;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const i = this.buffer, r = this.valueSize, s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const u = t * this._origIndex;
      this._mixBufferRegion(i, r, u, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let u = t, f = t + t; u !== f; ++u) if (i[u] !== i[u + t]) {
      a.setValue(i, r);
      break;
    }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + s % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    Gi.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    Gi.multiplyQuaternionsFlat(e, o, e, t, e, i), Gi.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const u = t + a;
      e[u] = e[u] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const p1 = "\\[\\]\\.:\\/", l4 = new RegExp("[" + p1 + "]", "g"), m1 = "[^" + p1 + "]", u4 = "[^" + p1.replace("\\.", "") + "]", c4 = /((?:WC+[\/:])*)/.source.replace("WC", m1), f4 = /(WCOD+)?/.source.replace("WCOD", u4), h4 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", m1), d4 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", m1), p4 = new RegExp("^" + c4 + f4 + h4 + d4 + "$"), m4 = ["material", "materials", "bones", "map"];
class g4 {
  constructor(e, t, i) {
    const r = i || Rt.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
  }
}
class Rt {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || Rt.parseTrackName(t), this.node = Rt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Rt.Composite(e, t, i) : new Rt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(l4, "");
  }
  static parseTrackName(e) {
    const t = p4.exec(e);
    if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      m4.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === t || a.uuid === t) return a;
          const u = i(a.children);
          if (u) return u;
        }
        return null;
      }, r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Rt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let f = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++) if (e[h].name === f) {
            f = h;
            break;
          }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[f];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const f = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let u = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      u = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (u = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Rt.Composite = g4;
Rt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
Rt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
Rt.prototype.GetterByBindingType = [Rt.prototype._getValue_direct, Rt.prototype._getValue_array, Rt.prototype._getValue_arrayElement, Rt.prototype._getValue_toArray];
Rt.prototype.SetterByBindingTypeAndVersioning = [[Rt.prototype._setValue_direct, Rt.prototype._setValue_direct_setNeedsUpdate, Rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_array, Rt.prototype._setValue_array_setNeedsUpdate, Rt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_arrayElement, Rt.prototype._setValue_arrayElement_setNeedsUpdate, Rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_fromArray, Rt.prototype._setValue_fromArray_setNeedsUpdate, Rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class _4 {
  constructor() {
    this.isAnimationObjectGroup = true, this.uuid = fr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = { objects: { get total() {
      return t._objects.length;
    }, get inUse() {
      return this.total - t.nCachedObjects_;
    } }, get bindingsPerObject() {
      return t._bindings.length;
    } };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let a, u = e.length, f = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h], g = p.uuid;
      let v = t[g];
      if (v === void 0) {
        v = u++, t[g] = v, e.push(p);
        for (let M = 0, S = o; M !== S; ++M) s[M].push(new Rt(p, i[M], r[M]));
      } else if (v < f) {
        a = e[v];
        const M = --f, S = e[M];
        t[S.uuid] = v, e[v] = S, t[g] = M, e[M] = p;
        for (let m = 0, E = o; m !== E; ++m) {
          const T = s[m], C = T[M];
          let L = T[v];
          T[v] = C, L === void 0 && (L = new Rt(p, i[m], r[m])), T[M] = L;
        }
      } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const u = arguments[o], f = u.uuid, h = t[f];
      if (h !== void 0 && h >= s) {
        const d = s++, p = e[d];
        t[p.uuid] = h, e[h] = p, t[f] = d, e[d] = u;
        for (let g = 0, v = r; g !== v; ++g) {
          const M = i[g], S = M[d], m = M[h];
          M[h] = S, M[d] = m;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_, o = e.length;
    for (let a = 0, u = arguments.length; a !== u; ++a) {
      const f = arguments[a], h = f.uuid, d = t[h];
      if (d !== void 0) if (delete t[h], d < s) {
        const p = --s, g = e[p], v = --o, M = e[v];
        t[g.uuid] = d, e[d] = g, t[M.uuid] = p, e[p] = M, e.pop();
        for (let S = 0, m = r; S !== m; ++S) {
          const E = i[S], T = E[p], C = E[v];
          E[d] = T, E[p] = C, E.pop();
        }
      } else {
        const p = --o, g = e[p];
        p > 0 && (t[g.uuid] = d), e[d] = g, e.pop();
        for (let v = 0, M = r; v !== M; ++v) {
          const S = i[v];
          S[d] = S[p], S.pop();
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths, a = this._parsedPaths, u = this._objects, f = u.length, h = this.nCachedObjects_, d = new Array(f);
    r = s.length, i[e] = r, o.push(e), a.push(t), s.push(d);
    for (let p = h, g = u.length; p !== g; ++p) {
      const v = u[p];
      d[p] = new Rt(v, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, u = o[a], f = e[a];
      t[f] = i, o[i] = u, o.pop(), s[i] = s[a], s.pop(), r[i] = r[a], r.pop();
    }
  }
}
class ib {
  constructor(e, t, i = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r;
    const s = t.tracks, o = s.length, a = new Array(o), u = { endingStart: Xa, endingEnd: Xa };
    for (let f = 0; f !== o; ++f) {
      const h = s[f].createInterpolant(null);
      a[f] = h, h.settings = u;
    }
    this._interpolantSettings = u, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = F2, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer, s = r.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const u = a.parameterPositions, f = a.sampleValues;
    return u[0] = s, u[1] = s + i, f[0] = e / o, f[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const u = (e - s) * i;
      u < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * u);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const u = this._interpolants, f = this._propertyBindings;
      switch (this.blendMode) {
        case FS:
          for (let h = 0, d = u.length; h !== d; ++h) u[h].evaluate(o), f[h].accumulateAdditive(a);
          break;
        case Tg:
        default:
          for (let h = 0, d = u.length; h !== d; ++h) u[h].evaluate(o), f[h].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = false));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = true : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let r = this.time + e, s = this._loopCount;
    const o = i === k2;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === O2) {
      s === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(true, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, true, o)), r >= t || r < 0) {
        const a = Math.floor(r / t);
        r -= t * a, s += Math.abs(a);
        const u = this.repetitions - s;
        if (u <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
        else {
          if (u === 1) {
            const f = e < 0;
            this._setEndings(f, !f, o);
          } else this._setEndings(false, false, o);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i ? (r.endingStart = Ya, r.endingEnd = Ya) : (e ? r.endingStart = this.zeroSlopeAtStart ? Ya : Xa : r.endingStart = ih, t ? r.endingEnd = this.zeroSlopeAtEnd ? Ya : Xa : r.endingEnd = ih);
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer, s = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, u = o.sampleValues;
    return a[0] = s, u[0] = t, a[1] = s + e, u[1] = i, this;
  }
}
const v4 = new Float32Array(1);
class y4 extends co {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, u = i.uuid, f = this._bindingsByRootAndName;
    let h = f[u];
    h === void 0 && (h = {}, f[u] = h);
    for (let d = 0; d !== s; ++d) {
      const p = r[d], g = p.name;
      let v = h[g];
      if (v !== void 0) ++v.referenceCount, o[d] = v;
      else {
        if (v = o[d], v !== void 0) {
          v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, u, g));
          continue;
        }
        const M = t && t._propertyBindings[d].binding.parsedPath;
        v = new nb(Rt.create(i, g, M), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, u, g), o[d] = v;
      }
      a[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = { actions: { get total() {
      return e._actions.length;
    }, get inUse() {
      return e._nActiveActions;
    } }, bindings: { get total() {
      return e._bindings.length;
    }, get inUse() {
      return e._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return e._controlInterpolants.length;
    }, get inUse() {
      return e._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[t];
    if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], r = e._cacheIndex;
    i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, o = this._actionsByClip, a = o[s], u = a.knownActions, f = u[u.length - 1], h = e._byClipCacheIndex;
    f._byClipCacheIndex = h, u[h] = f, u.pop(), e._byClipCacheIndex = null;
    const d = a.actionByRoot, p = (e._localRoot || this._root).uuid;
    delete d[p], u.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[t];
    o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, a = o[r], u = t[t.length - 1], f = e._cacheIndex;
    u._cacheIndex = f, t[f] = u, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new l1(new Float32Array(2), new Float32Array(2), 1, v4), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s;
  }
  clipAction(e, t, i) {
    const r = t || this._root, s = r.uuid;
    let o = typeof e == "string" ? gh.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e, u = this._actionsByClip[a];
    let f = null;
    if (i === void 0 && (o !== null ? i = o.blendMode : i = Tg), u !== void 0) {
      const d = u.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      f = u.knownActions[0], o === null && (o = f._clip);
    }
    if (o === null) return null;
    const h = new ib(this, o, t, i);
    return this._bindAction(h, f), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root, r = i.uuid, s = typeof e == "string" ? gh.findByName(i, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  }
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
    for (let f = 0; f !== i; ++f) t[f]._update(r, e, s, o);
    const a = this._bindings, u = this._nActiveBindings;
    for (let f = 0; f !== u; ++f) a[f].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, u = o.length; a !== u; ++a) {
        const f = o[a];
        this._deactivateAction(f);
        const h = f._cacheIndex, d = t[t.length - 1];
        f._cacheIndex = null, f._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(f);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot, u = a[t];
      u !== void 0 && (this._deactivateAction(u), this._removeInactiveAction(u));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0) for (const o in s) {
      const a = s[o];
      a.restoreOriginalState(), this._removeInactiveBinding(a);
    }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class g1 {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new g1(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let x4 = 0;
class S4 extends co {
  constructor() {
    super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: x4++ }), this.name = "", this.usage = ah, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class M4 extends Lg {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class w4 {
  constructor(e, t, i, r, s) {
    this.isGLBufferAttribute = true, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class rb {
  constructor(e, t, i = 0, r = 1 / 0) {
    this.ray = new dc(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new tl(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = true, i = []) {
    return px(e, this, i, t), i.sort(WT), i;
  }
  intersectObjects(e, t = true, i = []) {
    for (let r = 0, s = e.length; r < s; r++) px(e[r], this, i, t);
    return i.sort(WT), i;
  }
}
function WT(n18, e) {
  return n18.distance - e.distance;
}
function px(n18, e, t, i) {
  if (n18.layers.test(e.layers) && n18.raycast(e, t), i === true) {
    const r = n18.children;
    for (let s = 0, o = r.length; s < o; s++) px(r[s], e, t, true);
  }
}
class E4 {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(mn(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class T4 {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const XT = new me();
class A4 {
  constructor(e = new me(1 / 0, 1 / 0), t = new me(-1 / 0, -1 / 0)) {
    this.isBox2 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = XT.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, XT).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const YT = new k(), Bp = new k();
class C4 {
  constructor(e = new k(), t = new k()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    YT.subVectors(e, this.start), Bp.subVectors(this.end, this.start);
    const i = Bp.dot(Bp);
    let s = Bp.dot(YT) / i;
    return t && (s = mn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const qT = new k();
class R4 extends Nt {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = t, this.type = "SpotLightHelper";
    const i = new _t(), r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let o = 0, a = 1, u = 32; o < u; o++, a++) {
      const f = o / u * Math.PI * 2, h = a / u * Math.PI * 2;
      r.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ye(r, 3));
    const s = new Di({ fog: false, toneMapped: false });
    this.cone = new bs(i, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), qT.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(qT), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const Po = new k(), Vp = new st(), dv = new st();
class P4 extends bs {
  constructor(e) {
    const t = sb(e), i = new _t(), r = [], s = [], o = new Oe(0, 0, 1), a = new Oe(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Ye(r, 3)), i.setAttribute("color", new Ye(s, 3));
    const u = new Di({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(i, u), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, r = i.getAttribute("position");
    dv.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent && a.parent.isBone && (Vp.multiplyMatrices(dv, a.matrixWorld), Po.setFromMatrixPosition(Vp), r.setXYZ(o, Po.x, Po.y, Po.z), Vp.multiplyMatrices(dv, a.parent.matrixWorld), Po.setFromMatrixPosition(Vp), r.setXYZ(o + 1, Po.x, Po.y, Po.z), o += 2);
    }
    i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function sb(n18) {
  const e = [];
  n18.isBone === true && e.push(n18);
  for (let t = 0; t < n18.children.length; t++) e.push.apply(e, sb(n18.children[t]));
  return e;
}
class b4 extends Ln {
  constructor(e, t, i) {
    const r = new zh(t, 4, 2), s = new ca({ wireframe: true, fog: false, toneMapped: false });
    super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const L4 = new k(), jT = new Oe(), ZT = new Oe();
class I4 extends Nt {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "HemisphereLightHelper";
    const r = new kh(t);
    r.rotateY(Math.PI * 0.5), this.material = new ca({ wireframe: true, fog: false, toneMapped: false }), this.color === void 0 && (this.material.vertexColors = true);
    const s = r.getAttribute("position"), o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Ot(o, 3)), this.add(new Ln(r, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      jT.copy(this.light.color), ZT.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? jT : ZT;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false), e.lookAt(L4.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class D4 extends bs {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    i = new Oe(i), r = new Oe(r);
    const s = t / 2, o = e / t, a = e / 2, u = [], f = [];
    for (let p = 0, g = 0, v = -a; p <= t; p++, v += o) {
      u.push(-a, 0, v, a, 0, v), u.push(v, 0, -a, v, 0, a);
      const M = p === s ? i : r;
      M.toArray(f, g), g += 3, M.toArray(f, g), g += 3, M.toArray(f, g), g += 3, M.toArray(f, g), g += 3;
    }
    const h = new _t();
    h.setAttribute("position", new Ye(u, 3)), h.setAttribute("color", new Ye(f, 3));
    const d = new Di({ vertexColors: true, toneMapped: false });
    super(h, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class N4 extends bs {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    s = new Oe(s), o = new Oe(o);
    const a = [], u = [];
    if (t > 1) for (let d = 0; d < t; d++) {
      const p = d / t * (Math.PI * 2), g = Math.sin(p) * e, v = Math.cos(p) * e;
      a.push(0, 0, 0), a.push(g, 0, v);
      const M = d & 1 ? s : o;
      u.push(M.r, M.g, M.b), u.push(M.r, M.g, M.b);
    }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o, g = e - e / i * d;
      for (let v = 0; v < r; v++) {
        let M = v / r * (Math.PI * 2), S = Math.sin(M) * g, m = Math.cos(M) * g;
        a.push(S, 0, m), u.push(p.r, p.g, p.b), M = (v + 1) / r * (Math.PI * 2), S = Math.sin(M) * g, m = Math.cos(M) * g, a.push(S, 0, m), u.push(p.r, p.g, p.b);
      }
    }
    const f = new _t();
    f.setAttribute("position", new Ye(a, 3)), f.setAttribute("color", new Ye(u, 3));
    const h = new Di({ vertexColors: true, toneMapped: false });
    super(f, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const JT = new k(), Hp = new k(), KT = new k();
class U4 extends Nt {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new _t();
    r.setAttribute("position", new Ye([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
    const s = new Di({ fog: false, toneMapped: false });
    this.lightPlane = new ia(r, s), this.add(this.lightPlane), r = new _t(), r.setAttribute("position", new Ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new ia(r, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), JT.setFromMatrixPosition(this.light.matrixWorld), Hp.setFromMatrixPosition(this.light.target.matrixWorld), KT.subVectors(Hp, JT), this.lightPlane.lookAt(Hp), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(Hp), this.targetLine.scale.z = KT.length();
  }
}
const Gp = new k(), dn = new Dh();
class O4 extends bs {
  constructor(e) {
    const t = new _t(), i = new Di({ color: 16777215, vertexColors: true, toneMapped: false }), r = [], s = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(v, M) {
      u(v), u(M);
    }
    function u(v) {
      r.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ye(r, 3)), t.setAttribute("color", new Ye(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = o, this.update();
    const f = new Oe(16755200), h = new Oe(16711680), d = new Oe(43775), p = new Oe(16777215), g = new Oe(3355443);
    this.setColors(f, h, d, p, g);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = true;
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, r = 1;
    dn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), xn("c", t, e, dn, 0, 0, -1), xn("t", t, e, dn, 0, 0, 1), xn("n1", t, e, dn, -1, -1, -1), xn("n2", t, e, dn, i, -1, -1), xn("n3", t, e, dn, -1, r, -1), xn("n4", t, e, dn, i, r, -1), xn("f1", t, e, dn, -1, -1, 1), xn("f2", t, e, dn, i, -1, 1), xn("f3", t, e, dn, -1, r, 1), xn("f4", t, e, dn, i, r, 1), xn("u1", t, e, dn, i * 0.7, r * 1.1, -1), xn("u2", t, e, dn, -1 * 0.7, r * 1.1, -1), xn("u3", t, e, dn, 0, r * 2, -1), xn("cf1", t, e, dn, -1, 0, 1), xn("cf2", t, e, dn, i, 0, 1), xn("cf3", t, e, dn, 0, -1, 1), xn("cf4", t, e, dn, 0, r, 1), xn("cn1", t, e, dn, -1, 0, -1), xn("cn2", t, e, dn, i, 0, -1), xn("cn3", t, e, dn, 0, -1, -1), xn("cn4", t, e, dn, 0, r, -1), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function xn(n18, e, t, i, r, s, o) {
  Gp.set(r, s, o).unproject(i);
  const a = e[n18];
  if (a !== void 0) {
    const u = t.getAttribute("position");
    for (let f = 0, h = a.length; f < h; f++) u.setXYZ(a[f], Gp.x, Gp.y, Gp.z);
  }
}
const Wp = new bi();
class F4 extends bs {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new _t();
    s.setIndex(new Ot(i, 1)), s.setAttribute("position", new Ot(r, 3)), super(s, new Di({ color: t, toneMapped: false })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && Wp.setFromObject(this.object), Wp.isEmpty()) return;
    const t = Wp.min, i = Wp.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = true, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class k4 extends bs {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new _t();
    s.setIndex(new Ot(i, 1)), s.setAttribute("position", new Ye(r, 3)), super(s, new Di({ color: t, toneMapped: false })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class z4 extends ia {
  constructor(e, t = 1, i = 16776960) {
    const r = i, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new _t();
    o.setAttribute("position", new Ye(s, 3)), o.computeBoundingSphere(), super(o, new Di({ color: r, toneMapped: false })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], u = new _t();
    u.setAttribute("position", new Ye(a, 3)), u.computeBoundingSphere(), this.add(new Ln(u, new ca({ color: r, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const QT = new k();
let Xp, pv;
class B4 extends Nt {
  constructor(e = new k(0, 0, 1), t = new k(0, 0, 0), i = 1, r = 16776960, s = i * 0.2, o = s * 0.2) {
    super(), this.type = "ArrowHelper", Xp === void 0 && (Xp = new _t(), Xp.setAttribute("position", new Ye([0, 0, 0, 0, 1, 0], 3)), pv = new gc(0, 0.5, 1, 5, 1), pv.translate(0, -0.5, 0)), this.position.copy(t), this.line = new ia(Xp, new Di({ color: r, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Ln(pv, new ca({ color: r, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      QT.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(QT, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class V4 extends bs {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], r = new _t();
    r.setAttribute("position", new Ye(t, 3)), r.setAttribute("color", new Ye(i, 3));
    const s = new Di({ vertexColors: true, toneMapped: false });
    super(r, s), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const r = new Oe(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = true, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class H4 {
  constructor() {
    this.type = "ShapePath", this.color = new Oe(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new ch(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(m) {
      const E = [];
      for (let T = 0, C = m.length; T < C; T++) {
        const L = m[T], b = new il();
        b.curves = L.curves, E.push(b);
      }
      return E;
    }
    function i(m, E) {
      const T = E.length;
      let C = false;
      for (let L = T - 1, b = 0; b < T; L = b++) {
        let I = E[L], U = E[b], B = U.x - I.x, R = U.y - I.y;
        if (Math.abs(R) > Number.EPSILON) {
          if (R < 0 && (I = E[b], B = -B, U = E[L], R = -R), m.y < I.y || m.y > U.y) continue;
          if (m.y === I.y) {
            if (m.x === I.x) return true;
          } else {
            const D = R * (m.x - I.x) - B * (m.y - I.y);
            if (D === 0) return true;
            if (D < 0) continue;
            C = !C;
          }
        } else {
          if (m.y !== I.y) continue;
          if (U.x <= m.x && m.x <= I.x || I.x <= m.x && m.x <= U.x) return true;
        }
      }
      return C;
    }
    const r = Ts.isClockWise, s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, u;
    const f = [];
    if (s.length === 1) return a = s[0], u = new il(), u.curves = a.curves, f.push(u), f;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [], p = [];
    let g = [], v = 0, M;
    p[v] = void 0, g[v] = [];
    for (let m = 0, E = s.length; m < E; m++) a = s[m], M = a.getPoints(), o = r(M), o = e ? !o : o, o ? (!h && p[v] && v++, p[v] = { s: new il(), p: M }, p[v].s.curves = a.curves, h && v++, g[v] = []) : g[v].push({ h: a, p: M[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let m = false, E = 0;
      for (let T = 0, C = p.length; T < C; T++) d[T] = [];
      for (let T = 0, C = p.length; T < C; T++) {
        const L = g[T];
        for (let b = 0; b < L.length; b++) {
          const I = L[b];
          let U = true;
          for (let B = 0; B < p.length; B++) i(I.p, p[B].p) && (T !== B && E++, U ? (U = false, d[B].push(I)) : m = true);
          U && d[T].push(I);
        }
      }
      E > 0 && m === false && (g = d);
    }
    let S;
    for (let m = 0, E = p.length; m < E; m++) {
      u = p[m].s, f.push(u), S = g[m];
      for (let T = 0, C = S.length; T < C; T++) u.holes.push(S[T].h);
    }
    return f;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: Sg } }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Sg);
const G4 = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: PS, AddEquation: Uo, AddOperation: S2, AdditiveAnimationBlendMode: FS, AdditiveBlending: Ay, AgXToneMapping: A2, AlphaFormat: b2, AlwaysCompare: j2, AlwaysDepth: p2, AlwaysStencilFunc: ix, AmbientLight: ZP, AnimationAction: ib, AnimationClip: gh, AnimationLoader: WB, AnimationMixer: y4, AnimationObjectGroup: _4, AnimationUtils: BB, ArcCurve: xP, ArrayCamera: cP, ArrowHelper: B4, AttachedBindMode: Ly, Audio: tb, AudioAnalyser: a4, AudioContext: h1, AudioListener: r4, AudioLoader: t4, AxesHelper: V4, BackSide: Pi, BasicDepthPacking: z2, BasicShadowMap: JR, BatchedMesh: _P, Bone: QS, BooleanKeyframeTrack: xl, Box2: A4, Box3: bi, Box3Helper: k4, BoxGeometry: yl, BoxHelper: F4, BufferAttribute: Ot, BufferGeometry: _t, BufferGeometryLoader: eb, ByteType: R2, Cache: Ks, Camera: Dh, CameraHelper: O4, CanvasTexture: cB, CapsuleGeometry: Ug, CatmullRomCurve3: SP, CineonToneMapping: E2, CircleGeometry: Og, ClampToEdgeWrapping: hi, Clock: d1, Color: Oe, ColorKeyframeTrack: u1, ColorManagement: zt, CompressedArrayTexture: lB, CompressedCubeTexture: uB, CompressedTexture: Dg, CompressedTextureLoader: XB, ConeGeometry: Fg, ConstantAlphaFactor: f2, ConstantColorFactor: u2, CubeCamera: tP, CubeReflectionMapping: so, CubeRefractionMapping: na, CubeTexture: Nh, CubeTextureLoader: YB, CubeUVReflectionMapping: hc, CubicBezierCurve: t1, CubicBezierCurve3: MP, CubicInterpolant: VP, CullFaceBack: Ty, CullFaceFront: ZR, CullFaceFrontBack: JD, CullFaceNone: jR, Curve: ts, CurvePath: EP, CustomBlending: KR, CustomToneMapping: T2, CylinderGeometry: gc, Cylindrical: T4, Data3DTexture: HS, DataArrayTexture: Cg, DataTexture: nl, DataTextureLoader: qB, DataUtils: rU, DecrementStencilOp: aN, DecrementWrapStencilOp: uN, DefaultLoadingManager: WP, DepthFormat: Jo, DepthStencilFormat: dl, DepthTexture: YS, DetachedBindMode: C2, DirectionalLight: jP, DirectionalLightHelper: U4, DiscreteInterpolant: HP, DisplayP3ColorSpace: Ag, DodecahedronGeometry: kg, DoubleSide: gs, DstAlphaFactor: r2, DstColorFactor: o2, DynamicCopyUsage: EN, DynamicDrawUsage: vN, DynamicReadUsage: SN, EdgesGeometry: TP, EllipseCurve: Ng, EqualCompare: W2, EqualDepth: g2, EqualStencilFunc: dN, EquirectangularReflectionMapping: Kf, EquirectangularRefractionMapping: Qf, Euler: Ih, EventDispatcher: co, ExtrudeGeometry: Bg, FileLoader: oo, Float16BufferAttribute: cU, Float32BufferAttribute: Ye, Float64BufferAttribute: fU, FloatType: Dr, Fog: bg, FogExp2: Pg, FramebufferTexture: aB, FrontSide: ro, Frustum: Uh, GLBufferAttribute: w4, GLSL1: AN, GLSL3: rx, GreaterCompare: X2, GreaterDepth: v2, GreaterEqualCompare: q2, GreaterEqualDepth: _2, GreaterEqualStencilFunc: _N, GreaterStencilFunc: mN, GridHelper: D4, Group: Ru, HalfFloatType: Ku, HemisphereLight: XP, HemisphereLightHelper: I4, IcosahedronGeometry: Vg, ImageBitmapLoader: e4, ImageLoader: _h, ImageUtils: VS, IncrementStencilOp: oN, IncrementWrapStencilOp: lN, InstancedBufferAttribute: ec, InstancedBufferGeometry: $P, InstancedInterleavedBuffer: M4, InstancedMesh: gP, Int16BufferAttribute: lU, Int32BufferAttribute: uU, Int8BufferAttribute: sU, IntType: bS, InterleavedBuffer: Lg, InterleavedBufferAttribute: pl, Interpolant: Bh, InterpolateDiscrete: th, InterpolateLinear: nh, InterpolateSmooth: dm, InvertStencilOp: cN, KeepStencilOp: Fa, KeyframeTrack: ns, LOD: pP, LatheGeometry: Fh, Layers: tl, LessCompare: G2, LessDepth: m2, LessEqualCompare: zS, LessEqualDepth: Jf, LessEqualStencilFunc: pN, LessStencilFunc: hN, Light: ha, LightProbe: QP, Line: ia, Line3: C4, LineBasicMaterial: Di, LineCurve: n1, LineCurve3: wP, LineDashedMaterial: kP, LineLoop: vP, LineSegments: bs, LinearDisplayP3ColorSpace: Lh, LinearEncoding: kS, LinearFilter: sn, LinearInterpolant: l1, LinearMipMapLinearFilter: eN, LinearMipMapNearestFilter: $D, LinearMipmapLinearFilter: vs, LinearMipmapNearestFilter: Af, LinearSRGBColorSpace: Rs, LinearToneMapping: M2, LinearTransfer: rh, Loader: Zi, LoaderUtils: dx, LoadingManager: c1, LoopOnce: O2, LoopPingPong: k2, LoopRepeat: F2, LuminanceAlphaFormat: I2, LuminanceFormat: L2, MOUSE: jD, Material: vi, MaterialLoader: jg, MathUtils: ox, Matrix3: yt, Matrix4: st, MaxEquation: by, Mesh: Ln, MeshBasicMaterial: ca, MeshDepthMaterial: qS, MeshDistanceMaterial: jS, MeshLambertMaterial: OP, MeshMatcapMaterial: FP, MeshNormalMaterial: UP, MeshPhongMaterial: DP, MeshPhysicalMaterial: IP, MeshStandardMaterial: o1, MeshToonMaterial: NP, MinEquation: Py, MirroredRepeatWrapping: eh, MixOperation: x2, MultiplyBlending: Ry, MultiplyOperation: bh, NearestFilter: Mn, NearestMipMapLinearFilter: QD, NearestMipMapNearestFilter: KD, NearestMipmapLinearFilter: Ba, NearestMipmapNearestFilter: Ym, NeverCompare: H2, NeverDepth: d2, NeverStencilFunc: fN, NoBlending: $s, NoColorSpace: sr, NoToneMapping: ws, NormalAnimationBlendMode: Tg, NormalBlending: Qa, NotEqualCompare: Y2, NotEqualDepth: y2, NotEqualStencilFunc: gN, NumberKeyframeTrack: ph, Object3D: Nt, ObjectLoader: QB, ObjectSpaceNormalMap: V2, OctahedronGeometry: kh, OneFactor: t2, OneMinusConstantAlphaFactor: h2, OneMinusConstantColorFactor: c2, OneMinusDstAlphaFactor: s2, OneMinusDstColorFactor: a2, OneMinusSrcAlphaFactor: Xm, OneMinusSrcColorFactor: i2, OrthographicCamera: Oh, P3Primaries: oh, PCFShadowMap: Mg, PCFSoftShadowMap: Tf, PMREMGenerator: ax, Path: ch, PerspectiveCamera: Xn, Plane: Io, PlaneGeometry: pc, PlaneHelper: z4, PointLight: qP, PointLightHelper: b4, Points: yP, PointsMaterial: $S, PolarGridHelper: N4, PolyhedronGeometry: fa, PositionalAudio: o4, PropertyBinding: Rt, PropertyMixer: nb, QuadraticBezierCurve: i1, QuadraticBezierCurve3: r1, Quaternion: Gi, QuaternionKeyframeTrack: _c, QuaternionLinearInterpolant: GP, RED_GREEN_RGTC2_Format: tx, RED_RGTC1_Format: U2, REVISION: Sg, RGBADepthPacking: B2, RGBAFormat: Ti, RGBAIntegerFormat: US, RGBA_ASTC_10x10_Format: Zy, RGBA_ASTC_10x5_Format: Yy, RGBA_ASTC_10x6_Format: qy, RGBA_ASTC_10x8_Format: jy, RGBA_ASTC_12x10_Format: Jy, RGBA_ASTC_12x12_Format: Ky, RGBA_ASTC_4x4_Format: ky, RGBA_ASTC_5x4_Format: zy, RGBA_ASTC_5x5_Format: By, RGBA_ASTC_6x5_Format: Vy, RGBA_ASTC_6x6_Format: Hy, RGBA_ASTC_8x5_Format: Gy, RGBA_ASTC_8x6_Format: Wy, RGBA_ASTC_8x8_Format: Xy, RGBA_BPTC_Format: hm, RGBA_ETC2_EAC_Format: Fy, RGBA_PVRTC_2BPPV1_Format: Uy, RGBA_PVRTC_4BPPV1_Format: Ny, RGBA_S3TC_DXT1_Format: um, RGBA_S3TC_DXT3_Format: cm, RGBA_S3TC_DXT5_Format: fm, RGB_BPTC_SIGNED_Format: Qy, RGB_BPTC_UNSIGNED_Format: $y, RGB_ETC1_Format: OS, RGB_ETC2_Format: Oy, RGB_PVRTC_2BPPV1_Format: Dy, RGB_PVRTC_4BPPV1_Format: Iy, RGB_S3TC_DXT1_Format: lm, RGFormat: N2, RGIntegerFormat: NS, RawShaderMaterial: LP, Ray: dc, Raycaster: rb, Rec709Primaries: sh, RectAreaLight: JP, RedFormat: D2, RedIntegerFormat: DS, ReinhardToneMapping: w2, RenderTarget: K2, RepeatWrapping: $f, ReplaceStencilOp: sN, ReverseSubtractEquation: $R, RingGeometry: Hg, SIGNED_RED_GREEN_RGTC2_Format: nx, SIGNED_RED_RGTC1_Format: ex, SRGBColorSpace: Nn, SRGBTransfer: Yt, Scene: JS, ShaderChunk: gt, ShaderLib: Zr, ShaderMaterial: es, ShadowMaterial: bP, Shape: il, ShapeGeometry: Gg, ShapePath: H4, ShapeUtils: Ts, ShortType: P2, Skeleton: Ig, SkeletonHelper: P4, SkinnedMesh: mP, Source: qa, Sphere: mi, SphereGeometry: zh, Spherical: E4, SphericalHarmonics3: KP, SplineCurve: s1, SpotLight: YP, SpotLightHelper: R4, Sprite: dP, SpriteMaterial: KS, SrcAlphaFactor: Wm, SrcAlphaSaturateFactor: l2, SrcColorFactor: n2, StaticCopyUsage: wN, StaticDrawUsage: ah, StaticReadUsage: xN, StereoCamera: n4, StreamCopyUsage: TN, StreamDrawUsage: yN, StreamReadUsage: MN, StringKeyframeTrack: Sl, SubtractEquation: QR, SubtractiveBlending: Cy, TOUCH: ZD, TangentSpaceNormalMap: ua, TetrahedronGeometry: Wg, Texture: _n, TextureLoader: jB, TorusGeometry: Xg, TorusKnotGeometry: Yg, Triangle: or, TriangleFanDrawMode: iN, TriangleStripDrawMode: nN, TrianglesDrawMode: tN, TubeGeometry: qg, UVMapping: wg, Uint16BufferAttribute: GS, Uint32BufferAttribute: WS, Uint8BufferAttribute: oU, Uint8ClampedBufferAttribute: aU, Uniform: g1, UniformsGroup: S4, UniformsLib: Re, UniformsUtils: eP, UnsignedByteType: Es, UnsignedInt248Type: Zo, UnsignedIntType: Js, UnsignedShort4444Type: LS, UnsignedShort5551Type: IS, UnsignedShortType: Eg, VSMShadowMap: Yr, Vector2: me, Vector3: k, Vector4: Bt, VectorKeyframeTrack: mh, VideoTexture: oB, WebGL1Renderer: fP, WebGL3DRenderTarget: YN, WebGLArrayRenderTarget: XN, WebGLCoordinateSystem: ys, WebGLCubeRenderTarget: nP, WebGLMultipleRenderTargets: qN, WebGLRenderTarget: $r, WebGLRenderer: ZS, WebGLUtils: uP, WebGPUCoordinateSystem: lh, WireframeGeometry: PP, WrapAroundEnding: ih, ZeroCurvatureEnding: Xa, ZeroFactor: e2, ZeroSlopeEnding: Ya, ZeroStencilOp: rN, _SRGBAFormat: qm, createCanvasElement: J2, sRGBEncoding: Ko }, Symbol.toStringTag, { value: "Module" }));
var ob = { exports: {} }, Ml = {};
/**
* @license React
* react-reconciler-constants.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
Ml.ConcurrentRoot = 1;
Ml.ContinuousEventPriority = 4;
Ml.DefaultEventPriority = 16;
Ml.DiscreteEventPriority = 1;
Ml.IdleEventPriority = 536870912;
Ml.LegacyRoot = 0;
ob.exports = Ml;
var bu = ob.exports;
function W4(n18) {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (f, h) => {
    const d = typeof f == "function" ? f(e) : f;
    if (d !== e) {
      const p = e;
      e = h ? d : Object.assign({}, e, d), t.forEach((g) => g(e, p));
    }
  }, r = () => e, s = (f, h = r, d = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let p = h(e);
    function g() {
      const v = h(e);
      if (!d(p, v)) {
        const M = p;
        f(p = v, M);
      }
    }
    return t.add(g), () => t.delete(g);
  }, u = { setState: i, getState: r, subscribe: (f, h, d) => h || d ? s(f, h, d) : (t.add(f), () => t.delete(f)), destroy: () => t.clear() };
  return e = n18(i, r, u), u;
}
const X4 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), $T = X4 ? be.useEffect : be.useLayoutEffect;
function Y4(n18) {
  const e = typeof n18 == "function" ? W4(n18) : n18, t = (i = e.getState, r = Object.is) => {
    const [, s] = be.useReducer((S) => S + 1, 0), o = e.getState(), a = be.useRef(o), u = be.useRef(i), f = be.useRef(r), h = be.useRef(false), d = be.useRef();
    d.current === void 0 && (d.current = i(o));
    let p, g = false;
    (a.current !== o || u.current !== i || f.current !== r || h.current) && (p = i(o), g = !r(d.current, p)), $T(() => {
      g && (d.current = p), a.current = o, u.current = i, f.current = r, h.current = false;
    });
    const v = be.useRef(o);
    $T(() => {
      const S = () => {
        try {
          const E = e.getState(), T = u.current(E);
          f.current(d.current, T) || (a.current = E, d.current = T, s());
        } catch {
          h.current = true, s();
        }
      }, m = e.subscribe(S);
      return e.getState() !== v.current && S(), m;
    }, []);
    const M = g ? p : d.current;
    return be.useDebugValue(M), M;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const i = [t, e];
    return { next() {
      const r = i.length <= 0;
      return { value: i.shift(), done: r };
    } };
  }, t;
}
var ab = { exports: {} }, lb = { exports: {} }, ub = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(n18) {
  function e(V, q) {
    var Y = V.length;
    V.push(q);
    e: for (; 0 < Y; ) {
      var $ = Y - 1 >>> 1, ae = V[$];
      if (0 < r(ae, q)) V[$] = q, V[Y] = ae, Y = $;
      else break e;
    }
  }
  function t(V) {
    return V.length === 0 ? null : V[0];
  }
  function i(V) {
    if (V.length === 0) return null;
    var q = V[0], Y = V.pop();
    if (Y !== q) {
      V[0] = Y;
      e: for (var $ = 0, ae = V.length, Ee = ae >>> 1; $ < Ee; ) {
        var ne = 2 * ($ + 1) - 1, he = V[ne], Ce = ne + 1, Ie = V[Ce];
        if (0 > r(he, Y)) Ce < ae && 0 > r(Ie, he) ? (V[$] = Ie, V[Ce] = Y, $ = Ce) : (V[$] = he, V[ne] = Y, $ = ne);
        else if (Ce < ae && 0 > r(Ie, Y)) V[$] = Ie, V[Ce] = Y, $ = Ce;
        else break e;
      }
    }
    return q;
  }
  function r(V, q) {
    var Y = V.sortIndex - q.sortIndex;
    return Y !== 0 ? Y : V.id - q.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n18.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    n18.unstable_now = function() {
      return o.now() - a;
    };
  }
  var u = [], f = [], h = 1, d = null, p = 3, g = false, v = false, M = false, S = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function T(V) {
    for (var q = t(f); q !== null; ) {
      if (q.callback === null) i(f);
      else if (q.startTime <= V) i(f), q.sortIndex = q.expirationTime, e(u, q);
      else break;
      q = t(f);
    }
  }
  function C(V) {
    if (M = false, T(V), !v) if (t(u) !== null) v = true, J(L);
    else {
      var q = t(f);
      q !== null && ce(C, q.startTime - V);
    }
  }
  function L(V, q) {
    v = false, M && (M = false, m(U), U = -1), g = true;
    var Y = p;
    try {
      for (T(q), d = t(u); d !== null && (!(d.expirationTime > q) || V && !D()); ) {
        var $ = d.callback;
        if (typeof $ == "function") {
          d.callback = null, p = d.priorityLevel;
          var ae = $(d.expirationTime <= q);
          q = n18.unstable_now(), typeof ae == "function" ? d.callback = ae : d === t(u) && i(u), T(q);
        } else i(u);
        d = t(u);
      }
      if (d !== null) var Ee = true;
      else {
        var ne = t(f);
        ne !== null && ce(C, ne.startTime - q), Ee = false;
      }
      return Ee;
    } finally {
      d = null, p = Y, g = false;
    }
  }
  var b = false, I = null, U = -1, B = 5, R = -1;
  function D() {
    return !(n18.unstable_now() - R < B);
  }
  function j() {
    if (I !== null) {
      var V = n18.unstable_now();
      R = V;
      var q = true;
      try {
        q = I(true, V);
      } finally {
        q ? te() : (b = false, I = null);
      }
    } else b = false;
  }
  var te;
  if (typeof E == "function") te = function() {
    E(j);
  };
  else if (typeof MessageChannel < "u") {
    var X = new MessageChannel(), Q = X.port2;
    X.port1.onmessage = j, te = function() {
      Q.postMessage(null);
    };
  } else te = function() {
    S(j, 0);
  };
  function J(V) {
    I = V, b || (b = true, te());
  }
  function ce(V, q) {
    U = S(function() {
      V(n18.unstable_now());
    }, q);
  }
  n18.unstable_IdlePriority = 5, n18.unstable_ImmediatePriority = 1, n18.unstable_LowPriority = 4, n18.unstable_NormalPriority = 3, n18.unstable_Profiling = null, n18.unstable_UserBlockingPriority = 2, n18.unstable_cancelCallback = function(V) {
    V.callback = null;
  }, n18.unstable_continueExecution = function() {
    v || g || (v = true, J(L));
  }, n18.unstable_forceFrameRate = function(V) {
    0 > V || 125 < V ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < V ? Math.floor(1e3 / V) : 5;
  }, n18.unstable_getCurrentPriorityLevel = function() {
    return p;
  }, n18.unstable_getFirstCallbackNode = function() {
    return t(u);
  }, n18.unstable_next = function(V) {
    switch (p) {
      case 1:
      case 2:
      case 3:
        var q = 3;
        break;
      default:
        q = p;
    }
    var Y = p;
    p = q;
    try {
      return V();
    } finally {
      p = Y;
    }
  }, n18.unstable_pauseExecution = function() {
  }, n18.unstable_requestPaint = function() {
  }, n18.unstable_runWithPriority = function(V, q) {
    switch (V) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        V = 3;
    }
    var Y = p;
    p = V;
    try {
      return q();
    } finally {
      p = Y;
    }
  }, n18.unstable_scheduleCallback = function(V, q, Y) {
    var $ = n18.unstable_now();
    switch (typeof Y == "object" && Y !== null ? (Y = Y.delay, Y = typeof Y == "number" && 0 < Y ? $ + Y : $) : Y = $, V) {
      case 1:
        var ae = -1;
        break;
      case 2:
        ae = 250;
        break;
      case 5:
        ae = 1073741823;
        break;
      case 4:
        ae = 1e4;
        break;
      default:
        ae = 5e3;
    }
    return ae = Y + ae, V = { id: h++, callback: q, priorityLevel: V, startTime: Y, expirationTime: ae, sortIndex: -1 }, Y > $ ? (V.sortIndex = Y, e(f, V), t(u) === null && V === t(f) && (M ? (m(U), U = -1) : M = true, ce(C, Y - $))) : (V.sortIndex = ae, e(u, V), v || g || (v = true, J(L))), V;
  }, n18.unstable_shouldYield = D, n18.unstable_wrapCallback = function(V) {
    var q = p;
    return function() {
      var Y = p;
      p = q;
      try {
        return V.apply(this, arguments);
      } finally {
        p = Y;
      }
    };
  };
})(ub);
lb.exports = ub;
var mx = lb.exports;
/**
* @license React
* react-reconciler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var q4 = function(e) {
  var t = {}, i = be, r = mx, s = Object.assign;
  function o(l) {
    for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + l, _ = 1; _ < arguments.length; _++) c += "&args[]=" + encodeURIComponent(arguments[_]);
    return "Minified React error #" + l + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, u = Symbol.for("react.element"), f = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), v = Symbol.for("react.context"), M = Symbol.for("react.forward_ref"), S = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), T = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), L = Symbol.iterator;
  function b(l) {
    return l === null || typeof l != "object" ? null : (l = L && l[L] || l["@@iterator"], typeof l == "function" ? l : null);
  }
  function I(l) {
    if (l == null) return null;
    if (typeof l == "function") return l.displayName || l.name || null;
    if (typeof l == "string") return l;
    switch (l) {
      case h:
        return "Fragment";
      case f:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case S:
        return "Suspense";
      case m:
        return "SuspenseList";
    }
    if (typeof l == "object") switch (l.$$typeof) {
      case v:
        return (l.displayName || "Context") + ".Consumer";
      case g:
        return (l._context.displayName || "Context") + ".Provider";
      case M:
        var c = l.render;
        return l = l.displayName, l || (l = c.displayName || c.name || "", l = l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef"), l;
      case E:
        return c = l.displayName || null, c !== null ? c : I(l.type) || "Memo";
      case T:
        c = l._payload, l = l._init;
        try {
          return I(l(c));
        } catch {
        }
    }
    return null;
  }
  function U(l) {
    var c = l.type;
    switch (l.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return l = c.render, l = l.displayName || l.name || "", c.displayName || (l !== "" ? "ForwardRef(" + l + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return I(c);
      case 8:
        return c === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function B(l) {
    var c = l, _ = l;
    if (l.alternate) for (; c.return; ) c = c.return;
    else {
      l = c;
      do
        c = l, c.flags & 4098 && (_ = c.return), l = c.return;
      while (l);
    }
    return c.tag === 3 ? _ : null;
  }
  function R(l) {
    if (B(l) !== l) throw Error(o(188));
  }
  function D(l) {
    var c = l.alternate;
    if (!c) {
      if (c = B(l), c === null) throw Error(o(188));
      return c !== l ? null : l;
    }
    for (var _ = l, w = c; ; ) {
      var A = _.return;
      if (A === null) break;
      var P = A.alternate;
      if (P === null) {
        if (w = A.return, w !== null) {
          _ = w;
          continue;
        }
        break;
      }
      if (A.child === P.child) {
        for (P = A.child; P; ) {
          if (P === _) return R(A), l;
          if (P === w) return R(A), c;
          P = P.sibling;
        }
        throw Error(o(188));
      }
      if (_.return !== w.return) _ = A, w = P;
      else {
        for (var H = false, Z = A.child; Z; ) {
          if (Z === _) {
            H = true, _ = A, w = P;
            break;
          }
          if (Z === w) {
            H = true, w = A, _ = P;
            break;
          }
          Z = Z.sibling;
        }
        if (!H) {
          for (Z = P.child; Z; ) {
            if (Z === _) {
              H = true, _ = P, w = A;
              break;
            }
            if (Z === w) {
              H = true, w = P, _ = A;
              break;
            }
            Z = Z.sibling;
          }
          if (!H) throw Error(o(189));
        }
      }
      if (_.alternate !== w) throw Error(o(190));
    }
    if (_.tag !== 3) throw Error(o(188));
    return _.stateNode.current === _ ? l : c;
  }
  function j(l) {
    return l = D(l), l !== null ? te(l) : null;
  }
  function te(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      var c = te(l);
      if (c !== null) return c;
      l = l.sibling;
    }
    return null;
  }
  function X(l) {
    if (l.tag === 5 || l.tag === 6) return l;
    for (l = l.child; l !== null; ) {
      if (l.tag !== 4) {
        var c = X(l);
        if (c !== null) return c;
      }
      l = l.sibling;
    }
    return null;
  }
  var Q = Array.isArray, J = e.getPublicInstance, ce = e.getRootHostContext, V = e.getChildHostContext, q = e.prepareForCommit, Y = e.resetAfterCommit, $ = e.createInstance, ae = e.appendInitialChild, Ee = e.finalizeInitialChildren, ne = e.prepareUpdate, he = e.shouldSetTextContent, Ce = e.createTextInstance, Ie = e.scheduleTimeout, Ke = e.cancelTimeout, Ve = e.noTimeout, ot = e.isPrimaryRenderer, He = e.supportsMutation, W = e.supportsPersistence, xe = e.supportsHydration, de = e.getInstanceFromNode, Me = e.preparePortalMount, pe = e.getCurrentEventPriority, Je = e.detachDeletedInstance, De = e.supportsMicrotasks, O = e.scheduleMicrotask, N = e.supportsTestSelectors, ie = e.findFiberRoot, ye = e.getBoundingRect, _e = e.getTextContent, ge = e.isHiddenSubtree, We = e.matchAccessibilityRole, Pe = e.setFocusIfFocusable, Fe = e.setupIntersectionObserver, tt = e.appendChild, ft = e.appendChildToContainer, ve = e.commitTextUpdate, Ct = e.commitMount, xt = e.commitUpdate, lt = e.insertBefore, Qe = e.insertInContainerBefore, Ge = e.removeChild, pt = e.removeChildFromContainer, bt = e.resetTextContent, Gt = e.hideInstance, wt = e.hideTextInstance, Ft = e.unhideInstance, G = e.unhideTextInstance, Te = e.clearContainer, Ae = e.cloneInstance, Xe = e.createContainerChildSet, $e = e.appendChildToContainerChildSet, Ut = e.finalizeContainerChildren, kt = e.replaceContainerChildren, En = e.cloneHiddenInstance, yi = e.cloneHiddenTextInstance, Ht = e.canHydrateInstance, jn = e.canHydrateTextInstance, vr = e.canHydrateSuspenseInstance, vc = e.isSuspenseInstancePending, yc = e.isSuspenseInstanceFallback, El = e.registerSuspenseInstanceRetry, fo = e.getNextHydratableSibling, Tl = e.getFirstHydratableChild, Gh = e.getFirstHydratableChildWithinContainer, Wh = e.getFirstHydratableChildWithinSuspenseInstance, $g = e.hydrateInstance, e0 = e.hydrateTextInstance, t0 = e.hydrateSuspenseInstance, F = e.getNextHydratableInstanceAfterSuspenseInstance, ee = e.commitHydratedContainer, oe = e.commitHydratedSuspenseInstance, le = e.clearSuspenseBoundary, se = e.clearSuspenseBoundaryFromContainer, Ue = e.shouldDeleteUnhydratedTailInstances, je = e.didNotMatchHydratedContainerTextInstance, nt = e.didNotMatchHydratedTextInstance, it;
  function ut(l) {
    if (it === void 0) try {
      throw Error();
    } catch (_) {
      var c = _.stack.trim().match(/\n( *(at )?)/);
      it = c && c[1] || "";
    }
    return `
` + it + l;
  }
  var at = false;
  function ct(l, c) {
    if (!l || at) return "";
    at = true;
    var _ = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c) if (c = function() {
        throw Error();
      }, Object.defineProperty(c.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(c, []);
        } catch (we) {
          var w = we;
        }
        Reflect.construct(l, [], c);
      } else {
        try {
          c.call();
        } catch (we) {
          w = we;
        }
        l.call(c.prototype);
      }
      else {
        try {
          throw Error();
        } catch (we) {
          w = we;
        }
        l();
      }
    } catch (we) {
      if (we && w && typeof we.stack == "string") {
        for (var A = we.stack.split(`
`), P = w.stack.split(`
`), H = A.length - 1, Z = P.length - 1; 1 <= H && 0 <= Z && A[H] !== P[Z]; ) Z--;
        for (; 1 <= H && 0 <= Z; H--, Z--) if (A[H] !== P[Z]) {
          if (H !== 1 || Z !== 1) do
            if (H--, Z--, 0 > Z || A[H] !== P[Z]) {
              var fe = `
` + A[H].replace(" at new ", " at ");
              return l.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", l.displayName)), fe;
            }
          while (1 <= H && 0 <= Z);
          break;
        }
      }
    } finally {
      at = false, Error.prepareStackTrace = _;
    }
    return (l = l ? l.displayName || l.name : "") ? ut(l) : "";
  }
  var tn = Object.prototype.hasOwnProperty, Zn = [], jt = -1;
  function kn(l) {
    return { current: l };
  }
  function rt(l) {
    0 > jt || (l.current = Zn[jt], Zn[jt] = null, jt--);
  }
  function ze(l, c) {
    jt++, Zn[jt] = l.current, l.current = c;
  }
  var yr = {}, St = kn(yr), fn = kn(false), is = yr;
  function xr(l, c) {
    var _ = l.type.contextTypes;
    if (!_) return yr;
    var w = l.stateNode;
    if (w && w.__reactInternalMemoizedUnmaskedChildContext === c) return w.__reactInternalMemoizedMaskedChildContext;
    var A = {}, P;
    for (P in _) A[P] = c[P];
    return w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = c, l.__reactInternalMemoizedMaskedChildContext = A), A;
  }
  function zn(l) {
    return l = l.childContextTypes, l != null;
  }
  function vn() {
    rt(fn), rt(St);
  }
  function rs(l, c, _) {
    if (St.current !== yr) throw Error(o(168));
    ze(St, c), ze(fn, _);
  }
  function Al(l, c, _) {
    var w = l.stateNode;
    if (c = c.childContextTypes, typeof w.getChildContext != "function") return _;
    w = w.getChildContext();
    for (var A in w) if (!(A in c)) throw Error(o(108, U(l) || "Unknown", A));
    return s({}, _, w);
  }
  function Jn(l) {
    return l = (l = l.stateNode) && l.__reactInternalMemoizedMergedChildContext || yr, is = St.current, ze(St, l), ze(fn, fn.current), true;
  }
  function Cl(l, c, _) {
    var w = l.stateNode;
    if (!w) throw Error(o(169));
    _ ? (l = Al(l, c, is), w.__reactInternalMemoizedMergedChildContext = l, rt(fn), rt(St), ze(St, l)) : rt(fn), ze(fn, _);
  }
  var Ji = Math.clz32 ? Math.clz32 : IL, Xh = Math.log, LL = Math.LN2;
  function IL(l) {
    return l >>>= 0, l === 0 ? 32 : 31 - (Xh(l) / LL | 0) | 0;
  }
  var Yh = 64, qh = 4194304;
  function xc(l) {
    switch (l & -l) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return l & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return l & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return l;
    }
  }
  function jh(l, c) {
    var _ = l.pendingLanes;
    if (_ === 0) return 0;
    var w = 0, A = l.suspendedLanes, P = l.pingedLanes, H = _ & 268435455;
    if (H !== 0) {
      var Z = H & ~A;
      Z !== 0 ? w = xc(Z) : (P &= H, P !== 0 && (w = xc(P)));
    } else H = _ & ~A, H !== 0 ? w = xc(H) : P !== 0 && (w = xc(P));
    if (w === 0) return 0;
    if (c !== 0 && c !== w && !(c & A) && (A = w & -w, P = c & -c, A >= P || A === 16 && (P & 4194240) !== 0)) return c;
    if (w & 4 && (w |= _ & 16), c = l.entangledLanes, c !== 0) for (l = l.entanglements, c &= w; 0 < c; ) _ = 31 - Ji(c), A = 1 << _, w |= l[_], c &= ~A;
    return w;
  }
  function DL(l, c) {
    switch (l) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function NL(l, c) {
    for (var _ = l.suspendedLanes, w = l.pingedLanes, A = l.expirationTimes, P = l.pendingLanes; 0 < P; ) {
      var H = 31 - Ji(P), Z = 1 << H, fe = A[H];
      fe === -1 ? (!(Z & _) || Z & w) && (A[H] = DL(Z, c)) : fe <= c && (l.expiredLanes |= Z), P &= ~Z;
    }
  }
  function n0(l) {
    return l = l.pendingLanes & -1073741825, l !== 0 ? l : l & 1073741824 ? 1073741824 : 0;
  }
  function i0(l) {
    for (var c = [], _ = 0; 31 > _; _++) c.push(l);
    return c;
  }
  function Sc(l, c, _) {
    l.pendingLanes |= c, c !== 536870912 && (l.suspendedLanes = 0, l.pingedLanes = 0), l = l.eventTimes, c = 31 - Ji(c), l[c] = _;
  }
  function UL(l, c) {
    var _ = l.pendingLanes & ~c;
    l.pendingLanes = c, l.suspendedLanes = 0, l.pingedLanes = 0, l.expiredLanes &= c, l.mutableReadLanes &= c, l.entangledLanes &= c, c = l.entanglements;
    var w = l.eventTimes;
    for (l = l.expirationTimes; 0 < _; ) {
      var A = 31 - Ji(_), P = 1 << A;
      c[A] = 0, w[A] = -1, l[A] = -1, _ &= ~P;
    }
  }
  function r0(l, c) {
    var _ = l.entangledLanes |= c;
    for (l = l.entanglements; _; ) {
      var w = 31 - Ji(_), A = 1 << w;
      A & c | l[w] & c && (l[w] |= c), _ &= ~A;
    }
  }
  var Lt = 0;
  function O1(l) {
    return l &= -l, 1 < l ? 4 < l ? l & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var s0 = r.unstable_scheduleCallback, F1 = r.unstable_cancelCallback, OL = r.unstable_shouldYield, FL = r.unstable_requestPaint, Bn = r.unstable_now, o0 = r.unstable_ImmediatePriority, kL = r.unstable_UserBlockingPriority, a0 = r.unstable_NormalPriority, zL = r.unstable_IdlePriority, Zh = null, ss = null;
  function BL(l) {
    if (ss && typeof ss.onCommitFiberRoot == "function") try {
      ss.onCommitFiberRoot(Zh, l, void 0, (l.current.flags & 128) === 128);
    } catch {
    }
  }
  function VL(l, c) {
    return l === c && (l !== 0 || 1 / l === 1 / c) || l !== l && c !== c;
  }
  var os = typeof Object.is == "function" ? Object.is : VL, Ls = null, Jh = false, l0 = false;
  function k1(l) {
    Ls === null ? Ls = [l] : Ls.push(l);
  }
  function HL(l) {
    Jh = true, k1(l);
  }
  function as() {
    if (!l0 && Ls !== null) {
      l0 = true;
      var l = 0, c = Lt;
      try {
        var _ = Ls;
        for (Lt = 1; l < _.length; l++) {
          var w = _[l];
          do
            w = w(true);
          while (w !== null);
        }
        Ls = null, Jh = false;
      } catch (A) {
        throw Ls !== null && (Ls = Ls.slice(l + 1)), s0(o0, as), A;
      } finally {
        Lt = c, l0 = false;
      }
    }
    return null;
  }
  var GL = a.ReactCurrentBatchConfig;
  function Kh(l, c) {
    if (os(l, c)) return true;
    if (typeof l != "object" || l === null || typeof c != "object" || c === null) return false;
    var _ = Object.keys(l), w = Object.keys(c);
    if (_.length !== w.length) return false;
    for (w = 0; w < _.length; w++) {
      var A = _[w];
      if (!tn.call(c, A) || !os(l[A], c[A])) return false;
    }
    return true;
  }
  function WL(l) {
    switch (l.tag) {
      case 5:
        return ut(l.type);
      case 16:
        return ut("Lazy");
      case 13:
        return ut("Suspense");
      case 19:
        return ut("SuspenseList");
      case 0:
      case 2:
      case 15:
        return l = ct(l.type, false), l;
      case 11:
        return l = ct(l.type.render, false), l;
      case 1:
        return l = ct(l.type, true), l;
      default:
        return "";
    }
  }
  function zr(l, c) {
    if (l && l.defaultProps) {
      c = s({}, c), l = l.defaultProps;
      for (var _ in l) c[_] === void 0 && (c[_] = l[_]);
      return c;
    }
    return c;
  }
  var Qh = kn(null), $h = null, Rl = null, u0 = null;
  function c0() {
    u0 = Rl = $h = null;
  }
  function z1(l, c, _) {
    ot ? (ze(Qh, c._currentValue), c._currentValue = _) : (ze(Qh, c._currentValue2), c._currentValue2 = _);
  }
  function f0(l) {
    var c = Qh.current;
    rt(Qh), ot ? l._currentValue = c : l._currentValue2 = c;
  }
  function h0(l, c, _) {
    for (; l !== null; ) {
      var w = l.alternate;
      if ((l.childLanes & c) !== c ? (l.childLanes |= c, w !== null && (w.childLanes |= c)) : w !== null && (w.childLanes & c) !== c && (w.childLanes |= c), l === _) break;
      l = l.return;
    }
  }
  function Pl(l, c) {
    $h = l, u0 = Rl = null, l = l.dependencies, l !== null && l.firstContext !== null && (l.lanes & c && ($i = true), l.firstContext = null);
  }
  function Sr(l) {
    var c = ot ? l._currentValue : l._currentValue2;
    if (u0 !== l) if (l = { context: l, memoizedValue: c, next: null }, Rl === null) {
      if ($h === null) throw Error(o(308));
      Rl = l, $h.dependencies = { lanes: 0, firstContext: l };
    } else Rl = Rl.next = l;
    return c;
  }
  var ls = null, ho = false;
  function d0(l) {
    l.updateQueue = { baseState: l.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function B1(l, c) {
    l = l.updateQueue, c.updateQueue === l && (c.updateQueue = { baseState: l.baseState, firstBaseUpdate: l.firstBaseUpdate, lastBaseUpdate: l.lastBaseUpdate, shared: l.shared, effects: l.effects });
  }
  function Is(l, c) {
    return { eventTime: l, lane: c, tag: 0, payload: null, callback: null, next: null };
  }
  function po(l, c) {
    var _ = l.updateQueue;
    _ !== null && (_ = _.shared, Tn !== null && l.mode & 1 && !(Mt & 2) ? (l = _.interleaved, l === null ? (c.next = c, ls === null ? ls = [_] : ls.push(_)) : (c.next = l.next, l.next = c), _.interleaved = c) : (l = _.pending, l === null ? c.next = c : (c.next = l.next, l.next = c), _.pending = c));
  }
  function ed(l, c, _) {
    if (c = c.updateQueue, c !== null && (c = c.shared, (_ & 4194240) !== 0)) {
      var w = c.lanes;
      w &= l.pendingLanes, _ |= w, c.lanes = _, r0(l, _);
    }
  }
  function V1(l, c) {
    var _ = l.updateQueue, w = l.alternate;
    if (w !== null && (w = w.updateQueue, _ === w)) {
      var A = null, P = null;
      if (_ = _.firstBaseUpdate, _ !== null) {
        do {
          var H = { eventTime: _.eventTime, lane: _.lane, tag: _.tag, payload: _.payload, callback: _.callback, next: null };
          P === null ? A = P = H : P = P.next = H, _ = _.next;
        } while (_ !== null);
        P === null ? A = P = c : P = P.next = c;
      } else A = P = c;
      _ = { baseState: w.baseState, firstBaseUpdate: A, lastBaseUpdate: P, shared: w.shared, effects: w.effects }, l.updateQueue = _;
      return;
    }
    l = _.lastBaseUpdate, l === null ? _.firstBaseUpdate = c : l.next = c, _.lastBaseUpdate = c;
  }
  function td(l, c, _, w) {
    var A = l.updateQueue;
    ho = false;
    var P = A.firstBaseUpdate, H = A.lastBaseUpdate, Z = A.shared.pending;
    if (Z !== null) {
      A.shared.pending = null;
      var fe = Z, we = fe.next;
      fe.next = null, H === null ? P = we : H.next = we, H = fe;
      var Be = l.alternate;
      Be !== null && (Be = Be.updateQueue, Z = Be.lastBaseUpdate, Z !== H && (Z === null ? Be.firstBaseUpdate = we : Z.next = we, Be.lastBaseUpdate = fe));
    }
    if (P !== null) {
      var ht = A.baseState;
      H = 0, Be = we = fe = null, Z = P;
      do {
        var et = Z.lane, Wt = Z.eventTime;
        if ((w & et) === et) {
          Be !== null && (Be = Be.next = { eventTime: Wt, lane: 0, tag: Z.tag, payload: Z.payload, callback: Z.callback, next: null });
          e: {
            var Ze = l, si = Z;
            switch (et = c, Wt = _, si.tag) {
              case 1:
                if (Ze = si.payload, typeof Ze == "function") {
                  ht = Ze.call(Wt, ht, et);
                  break e;
                }
                ht = Ze;
                break e;
              case 3:
                Ze.flags = Ze.flags & -65537 | 128;
              case 0:
                if (Ze = si.payload, et = typeof Ze == "function" ? Ze.call(Wt, ht, et) : Ze, et == null) break e;
                ht = s({}, ht, et);
                break e;
              case 2:
                ho = true;
            }
          }
          Z.callback !== null && Z.lane !== 0 && (l.flags |= 64, et = A.effects, et === null ? A.effects = [Z] : et.push(Z));
        } else Wt = { eventTime: Wt, lane: et, tag: Z.tag, payload: Z.payload, callback: Z.callback, next: null }, Be === null ? (we = Be = Wt, fe = ht) : Be = Be.next = Wt, H |= et;
        if (Z = Z.next, Z === null) {
          if (Z = A.shared.pending, Z === null) break;
          et = Z, Z = et.next, et.next = null, A.lastBaseUpdate = et, A.shared.pending = null;
        }
      } while (true);
      if (Be === null && (fe = ht), A.baseState = fe, A.firstBaseUpdate = we, A.lastBaseUpdate = Be, c = A.shared.interleaved, c !== null) {
        A = c;
        do
          H |= A.lane, A = A.next;
        while (A !== c);
      } else P === null && (A.shared.lanes = 0);
      kl |= H, l.lanes = H, l.memoizedState = ht;
    }
  }
  function H1(l, c, _) {
    if (l = c.effects, c.effects = null, l !== null) for (c = 0; c < l.length; c++) {
      var w = l[c], A = w.callback;
      if (A !== null) {
        if (w.callback = null, w = _, typeof A != "function") throw Error(o(191, A));
        A.call(w);
      }
    }
  }
  var G1 = new i.Component().refs;
  function p0(l, c, _, w) {
    c = l.memoizedState, _ = _(w, c), _ = _ == null ? c : s({}, c, _), l.memoizedState = _, l.lanes === 0 && (l.updateQueue.baseState = _);
  }
  var nd = { isMounted: function(l) {
    return (l = l._reactInternals) ? B(l) === l : false;
  }, enqueueSetState: function(l, c, _) {
    l = l._reactInternals;
    var w = Si(), A = _o(l), P = Is(w, A);
    P.payload = c, _ != null && (P.callback = _), po(l, P), c = Ar(l, A, w), c !== null && ed(c, l, A);
  }, enqueueReplaceState: function(l, c, _) {
    l = l._reactInternals;
    var w = Si(), A = _o(l), P = Is(w, A);
    P.tag = 1, P.payload = c, _ != null && (P.callback = _), po(l, P), c = Ar(l, A, w), c !== null && ed(c, l, A);
  }, enqueueForceUpdate: function(l, c) {
    l = l._reactInternals;
    var _ = Si(), w = _o(l), A = Is(_, w);
    A.tag = 2, c != null && (A.callback = c), po(l, A), c = Ar(l, w, _), c !== null && ed(c, l, w);
  } };
  function W1(l, c, _, w, A, P, H) {
    return l = l.stateNode, typeof l.shouldComponentUpdate == "function" ? l.shouldComponentUpdate(w, P, H) : c.prototype && c.prototype.isPureReactComponent ? !Kh(_, w) || !Kh(A, P) : true;
  }
  function X1(l, c, _) {
    var w = false, A = yr, P = c.contextType;
    return typeof P == "object" && P !== null ? P = Sr(P) : (A = zn(c) ? is : St.current, w = c.contextTypes, P = (w = w != null) ? xr(l, A) : yr), c = new c(_, P), l.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, c.updater = nd, l.stateNode = c, c._reactInternals = l, w && (l = l.stateNode, l.__reactInternalMemoizedUnmaskedChildContext = A, l.__reactInternalMemoizedMaskedChildContext = P), c;
  }
  function Y1(l, c, _, w) {
    l = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(_, w), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(_, w), c.state !== l && nd.enqueueReplaceState(c, c.state, null);
  }
  function m0(l, c, _, w) {
    var A = l.stateNode;
    A.props = _, A.state = l.memoizedState, A.refs = G1, d0(l);
    var P = c.contextType;
    typeof P == "object" && P !== null ? A.context = Sr(P) : (P = zn(c) ? is : St.current, A.context = xr(l, P)), A.state = l.memoizedState, P = c.getDerivedStateFromProps, typeof P == "function" && (p0(l, c, P, _), A.state = l.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function" || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (c = A.state, typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount(), c !== A.state && nd.enqueueReplaceState(A, A.state, null), td(l, _, A, w), A.state = l.memoizedState), typeof A.componentDidMount == "function" && (l.flags |= 4194308);
  }
  var bl = [], Ll = 0, id = null, rd = 0, Mr = [], wr = 0, pa = null, Ds = 1, Ns = "";
  function ma(l, c) {
    bl[Ll++] = rd, bl[Ll++] = id, id = l, rd = c;
  }
  function q1(l, c, _) {
    Mr[wr++] = Ds, Mr[wr++] = Ns, Mr[wr++] = pa, pa = l;
    var w = Ds;
    l = Ns;
    var A = 32 - Ji(w) - 1;
    w &= ~(1 << A), _ += 1;
    var P = 32 - Ji(c) + A;
    if (30 < P) {
      var H = A - A % 5;
      P = (w & (1 << H) - 1).toString(32), w >>= H, A -= H, Ds = 1 << 32 - Ji(c) + A | _ << A | w, Ns = P + l;
    } else Ds = 1 << P | _ << A | w, Ns = l;
  }
  function g0(l) {
    l.return !== null && (ma(l, 1), q1(l, 1, 0));
  }
  function _0(l) {
    for (; l === id; ) id = bl[--Ll], bl[Ll] = null, rd = bl[--Ll], bl[Ll] = null;
    for (; l === pa; ) pa = Mr[--wr], Mr[wr] = null, Ns = Mr[--wr], Mr[wr] = null, Ds = Mr[--wr], Mr[wr] = null;
  }
  var Ki = null, Qi = null, Qt = false, Mc = false, Br = null;
  function j1(l, c) {
    var _ = Cr(5, null, null, 0);
    _.elementType = "DELETED", _.stateNode = c, _.return = l, c = l.deletions, c === null ? (l.deletions = [_], l.flags |= 16) : c.push(_);
  }
  function Z1(l, c) {
    switch (l.tag) {
      case 5:
        return c = Ht(c, l.type, l.pendingProps), c !== null ? (l.stateNode = c, Ki = l, Qi = Tl(c), true) : false;
      case 6:
        return c = jn(c, l.pendingProps), c !== null ? (l.stateNode = c, Ki = l, Qi = null, true) : false;
      case 13:
        if (c = vr(c), c !== null) {
          var _ = pa !== null ? { id: Ds, overflow: Ns } : null;
          return l.memoizedState = { dehydrated: c, treeContext: _, retryLane: 1073741824 }, _ = Cr(18, null, null, 0), _.stateNode = c, _.return = l, l.child = _, Ki = l, Qi = null, true;
        }
        return false;
      default:
        return false;
    }
  }
  function v0(l) {
    return (l.mode & 1) !== 0 && (l.flags & 128) === 0;
  }
  function y0(l) {
    if (Qt) {
      var c = Qi;
      if (c) {
        var _ = c;
        if (!Z1(l, c)) {
          if (v0(l)) throw Error(o(418));
          c = fo(_);
          var w = Ki;
          c && Z1(l, c) ? j1(w, _) : (l.flags = l.flags & -4097 | 2, Qt = false, Ki = l);
        }
      } else {
        if (v0(l)) throw Error(o(418));
        l.flags = l.flags & -4097 | 2, Qt = false, Ki = l;
      }
    }
  }
  function J1(l) {
    for (l = l.return; l !== null && l.tag !== 5 && l.tag !== 3 && l.tag !== 13; ) l = l.return;
    Ki = l;
  }
  function wc(l) {
    if (!xe || l !== Ki) return false;
    if (!Qt) return J1(l), Qt = true, false;
    if (l.tag !== 3 && (l.tag !== 5 || Ue(l.type) && !he(l.type, l.memoizedProps))) {
      var c = Qi;
      if (c) {
        if (v0(l)) {
          for (l = Qi; l; ) l = fo(l);
          throw Error(o(418));
        }
        for (; c; ) j1(l, c), c = fo(c);
      }
    }
    if (J1(l), l.tag === 13) {
      if (!xe) throw Error(o(316));
      if (l = l.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(o(317));
      Qi = F(l);
    } else Qi = Ki ? fo(l.stateNode) : null;
    return true;
  }
  function Il() {
    xe && (Qi = Ki = null, Mc = Qt = false);
  }
  function x0(l) {
    Br === null ? Br = [l] : Br.push(l);
  }
  function Ec(l, c, _) {
    if (l = _.ref, l !== null && typeof l != "function" && typeof l != "object") {
      if (_._owner) {
        if (_ = _._owner, _) {
          if (_.tag !== 1) throw Error(o(309));
          var w = _.stateNode;
        }
        if (!w) throw Error(o(147, l));
        var A = w, P = "" + l;
        return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === P ? c.ref : (c = function(H) {
          var Z = A.refs;
          Z === G1 && (Z = A.refs = {}), H === null ? delete Z[P] : Z[P] = H;
        }, c._stringRef = P, c);
      }
      if (typeof l != "string") throw Error(o(284));
      if (!_._owner) throw Error(o(290, l));
    }
    return l;
  }
  function sd(l, c) {
    throw l = Object.prototype.toString.call(c), Error(o(31, l === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : l));
  }
  function K1(l) {
    var c = l._init;
    return c(l._payload);
  }
  function Q1(l) {
    function c(re, K) {
      if (l) {
        var ue = re.deletions;
        ue === null ? (re.deletions = [K], re.flags |= 16) : ue.push(K);
      }
    }
    function _(re, K) {
      if (!l) return null;
      for (; K !== null; ) c(re, K), K = K.sibling;
      return null;
    }
    function w(re, K) {
      for (re = /* @__PURE__ */ new Map(); K !== null; ) K.key !== null ? re.set(K.key, K) : re.set(K.index, K), K = K.sibling;
      return re;
    }
    function A(re, K) {
      return re = yo(re, K), re.index = 0, re.sibling = null, re;
    }
    function P(re, K, ue) {
      return re.index = ue, l ? (ue = re.alternate, ue !== null ? (ue = ue.index, ue < K ? (re.flags |= 2, K) : ue) : (re.flags |= 2, K)) : (re.flags |= 1048576, K);
    }
    function H(re) {
      return l && re.alternate === null && (re.flags |= 2), re;
    }
    function Z(re, K, ue, Ne) {
      return K === null || K.tag !== 6 ? (K = i_(ue, re.mode, Ne), K.return = re, K) : (K = A(K, ue), K.return = re, K);
    }
    function fe(re, K, ue, Ne) {
      var qe = ue.type;
      return qe === h ? Be(re, K, ue.props.children, Ne, ue.key) : K !== null && (K.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === T && K1(qe) === K.type) ? (Ne = A(K, ue.props), Ne.ref = Ec(re, K, ue), Ne.return = re, Ne) : (Ne = Od(ue.type, ue.key, ue.props, null, re.mode, Ne), Ne.ref = Ec(re, K, ue), Ne.return = re, Ne);
    }
    function we(re, K, ue, Ne) {
      return K === null || K.tag !== 4 || K.stateNode.containerInfo !== ue.containerInfo || K.stateNode.implementation !== ue.implementation ? (K = r_(ue, re.mode, Ne), K.return = re, K) : (K = A(K, ue.children || []), K.return = re, K);
    }
    function Be(re, K, ue, Ne, qe) {
      return K === null || K.tag !== 7 ? (K = Ma(ue, re.mode, Ne, qe), K.return = re, K) : (K = A(K, ue), K.return = re, K);
    }
    function ht(re, K, ue) {
      if (typeof K == "string" && K !== "" || typeof K == "number") return K = i_("" + K, re.mode, ue), K.return = re, K;
      if (typeof K == "object" && K !== null) {
        switch (K.$$typeof) {
          case u:
            return ue = Od(K.type, K.key, K.props, null, re.mode, ue), ue.ref = Ec(re, null, K), ue.return = re, ue;
          case f:
            return K = r_(K, re.mode, ue), K.return = re, K;
          case T:
            var Ne = K._init;
            return ht(re, Ne(K._payload), ue);
        }
        if (Q(K) || b(K)) return K = Ma(K, re.mode, ue, null), K.return = re, K;
        sd(re, K);
      }
      return null;
    }
    function et(re, K, ue, Ne) {
      var qe = K !== null ? K.key : null;
      if (typeof ue == "string" && ue !== "" || typeof ue == "number") return qe !== null ? null : Z(re, K, "" + ue, Ne);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case u:
            return ue.key === qe ? fe(re, K, ue, Ne) : null;
          case f:
            return ue.key === qe ? we(re, K, ue, Ne) : null;
          case T:
            return qe = ue._init, et(re, K, qe(ue._payload), Ne);
        }
        if (Q(ue) || b(ue)) return qe !== null ? null : Be(re, K, ue, Ne, null);
        sd(re, ue);
      }
      return null;
    }
    function Wt(re, K, ue, Ne, qe) {
      if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number") return re = re.get(ue) || null, Z(K, re, "" + Ne, qe);
      if (typeof Ne == "object" && Ne !== null) {
        switch (Ne.$$typeof) {
          case u:
            return re = re.get(Ne.key === null ? ue : Ne.key) || null, fe(K, re, Ne, qe);
          case f:
            return re = re.get(Ne.key === null ? ue : Ne.key) || null, we(K, re, Ne, qe);
          case T:
            var vt = Ne._init;
            return Wt(re, K, ue, vt(Ne._payload), qe);
        }
        if (Q(Ne) || b(Ne)) return re = re.get(ue) || null, Be(K, re, Ne, qe, null);
        sd(K, Ne);
      }
      return null;
    }
    function Ze(re, K, ue, Ne) {
      for (var qe = null, vt = null, dt = K, It = K = 0, Hn = null; dt !== null && It < ue.length; It++) {
        dt.index > It ? (Hn = dt, dt = null) : Hn = dt.sibling;
        var Dt = et(re, dt, ue[It], Ne);
        if (Dt === null) {
          dt === null && (dt = Hn);
          break;
        }
        l && dt && Dt.alternate === null && c(re, dt), K = P(Dt, K, It), vt === null ? qe = Dt : vt.sibling = Dt, vt = Dt, dt = Hn;
      }
      if (It === ue.length) return _(re, dt), Qt && ma(re, It), qe;
      if (dt === null) {
        for (; It < ue.length; It++) dt = ht(re, ue[It], Ne), dt !== null && (K = P(dt, K, It), vt === null ? qe = dt : vt.sibling = dt, vt = dt);
        return Qt && ma(re, It), qe;
      }
      for (dt = w(re, dt); It < ue.length; It++) Hn = Wt(dt, re, It, ue[It], Ne), Hn !== null && (l && Hn.alternate !== null && dt.delete(Hn.key === null ? It : Hn.key), K = P(Hn, K, It), vt === null ? qe = Hn : vt.sibling = Hn, vt = Hn);
      return l && dt.forEach(function(xo) {
        return c(re, xo);
      }), Qt && ma(re, It), qe;
    }
    function si(re, K, ue, Ne) {
      var qe = b(ue);
      if (typeof qe != "function") throw Error(o(150));
      if (ue = qe.call(ue), ue == null) throw Error(o(151));
      for (var vt = qe = null, dt = K, It = K = 0, Hn = null, Dt = ue.next(); dt !== null && !Dt.done; It++, Dt = ue.next()) {
        dt.index > It ? (Hn = dt, dt = null) : Hn = dt.sibling;
        var xo = et(re, dt, Dt.value, Ne);
        if (xo === null) {
          dt === null && (dt = Hn);
          break;
        }
        l && dt && xo.alternate === null && c(re, dt), K = P(xo, K, It), vt === null ? qe = xo : vt.sibling = xo, vt = xo, dt = Hn;
      }
      if (Dt.done) return _(re, dt), Qt && ma(re, It), qe;
      if (dt === null) {
        for (; !Dt.done; It++, Dt = ue.next()) Dt = ht(re, Dt.value, Ne), Dt !== null && (K = P(Dt, K, It), vt === null ? qe = Dt : vt.sibling = Dt, vt = Dt);
        return Qt && ma(re, It), qe;
      }
      for (dt = w(re, dt); !Dt.done; It++, Dt = ue.next()) Dt = Wt(dt, re, It, Dt.value, Ne), Dt !== null && (l && Dt.alternate !== null && dt.delete(Dt.key === null ? It : Dt.key), K = P(Dt, K, It), vt === null ? qe = Dt : vt.sibling = Dt, vt = Dt);
      return l && dt.forEach(function(x3) {
        return c(re, x3);
      }), Qt && ma(re, It), qe;
    }
    function Rr(re, K, ue, Ne) {
      if (typeof ue == "object" && ue !== null && ue.type === h && ue.key === null && (ue = ue.props.children), typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case u:
            e: {
              for (var qe = ue.key, vt = K; vt !== null; ) {
                if (vt.key === qe) {
                  if (qe = ue.type, qe === h) {
                    if (vt.tag === 7) {
                      _(re, vt.sibling), K = A(vt, ue.props.children), K.return = re, re = K;
                      break e;
                    }
                  } else if (vt.elementType === qe || typeof qe == "object" && qe !== null && qe.$$typeof === T && K1(qe) === vt.type) {
                    _(re, vt.sibling), K = A(vt, ue.props), K.ref = Ec(re, vt, ue), K.return = re, re = K;
                    break e;
                  }
                  _(re, vt);
                  break;
                } else c(re, vt);
                vt = vt.sibling;
              }
              ue.type === h ? (K = Ma(ue.props.children, re.mode, Ne, ue.key), K.return = re, re = K) : (Ne = Od(ue.type, ue.key, ue.props, null, re.mode, Ne), Ne.ref = Ec(re, K, ue), Ne.return = re, re = Ne);
            }
            return H(re);
          case f:
            e: {
              for (vt = ue.key; K !== null; ) {
                if (K.key === vt) if (K.tag === 4 && K.stateNode.containerInfo === ue.containerInfo && K.stateNode.implementation === ue.implementation) {
                  _(re, K.sibling), K = A(K, ue.children || []), K.return = re, re = K;
                  break e;
                } else {
                  _(re, K);
                  break;
                }
                else c(re, K);
                K = K.sibling;
              }
              K = r_(ue, re.mode, Ne), K.return = re, re = K;
            }
            return H(re);
          case T:
            return vt = ue._init, Rr(re, K, vt(ue._payload), Ne);
        }
        if (Q(ue)) return Ze(re, K, ue, Ne);
        if (b(ue)) return si(re, K, ue, Ne);
        sd(re, ue);
      }
      return typeof ue == "string" && ue !== "" || typeof ue == "number" ? (ue = "" + ue, K !== null && K.tag === 6 ? (_(re, K.sibling), K = A(K, ue), K.return = re, re = K) : (_(re, K), K = i_(ue, re.mode, Ne), K.return = re, re = K), H(re)) : _(re, K);
    }
    return Rr;
  }
  var Dl = Q1(true), $1 = Q1(false), Tc = {}, Er = kn(Tc), Ac = kn(Tc), Nl = kn(Tc);
  function us(l) {
    if (l === Tc) throw Error(o(174));
    return l;
  }
  function S0(l, c) {
    ze(Nl, c), ze(Ac, l), ze(Er, Tc), l = ce(c), rt(Er), ze(Er, l);
  }
  function Ul() {
    rt(Er), rt(Ac), rt(Nl);
  }
  function eM(l) {
    var c = us(Nl.current), _ = us(Er.current);
    c = V(_, l.type, c), _ !== c && (ze(Ac, l), ze(Er, c));
  }
  function M0(l) {
    Ac.current === l && (rt(Er), rt(Ac));
  }
  var nn = kn(0);
  function od(l) {
    for (var c = l; c !== null; ) {
      if (c.tag === 13) {
        var _ = c.memoizedState;
        if (_ !== null && (_ = _.dehydrated, _ === null || vc(_) || yc(_))) return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128) return c;
      } else if (c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === l) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === l) return null;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
    return null;
  }
  var w0 = [];
  function E0() {
    for (var l = 0; l < w0.length; l++) {
      var c = w0[l];
      ot ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null;
    }
    w0.length = 0;
  }
  var ad = a.ReactCurrentDispatcher, Tr = a.ReactCurrentBatchConfig, Ol = 0, hn = null, ni = null, Vn = null, ld = false, Cc = false, Rc = 0, XL = 0;
  function ii() {
    throw Error(o(321));
  }
  function T0(l, c) {
    if (c === null) return false;
    for (var _ = 0; _ < c.length && _ < l.length; _++) if (!os(l[_], c[_])) return false;
    return true;
  }
  function A0(l, c, _, w, A, P) {
    if (Ol = P, hn = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, ad.current = l === null || l.memoizedState === null ? ZL : JL, l = _(w, A), Cc) {
      P = 0;
      do {
        if (Cc = false, Rc = 0, 25 <= P) throw Error(o(301));
        P += 1, Vn = ni = null, c.updateQueue = null, ad.current = KL, l = _(w, A);
      } while (Cc);
    }
    if (ad.current = dd, c = ni !== null && ni.next !== null, Ol = 0, Vn = ni = hn = null, ld = false, c) throw Error(o(300));
    return l;
  }
  function C0() {
    var l = Rc !== 0;
    return Rc = 0, l;
  }
  function Us() {
    var l = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Vn === null ? hn.memoizedState = Vn = l : Vn = Vn.next = l, Vn;
  }
  function cs() {
    if (ni === null) {
      var l = hn.alternate;
      l = l !== null ? l.memoizedState : null;
    } else l = ni.next;
    var c = Vn === null ? hn.memoizedState : Vn.next;
    if (c !== null) Vn = c, ni = l;
    else {
      if (l === null) throw Error(o(310));
      ni = l, l = { memoizedState: ni.memoizedState, baseState: ni.baseState, baseQueue: ni.baseQueue, queue: ni.queue, next: null }, Vn === null ? hn.memoizedState = Vn = l : Vn = Vn.next = l;
    }
    return Vn;
  }
  function ga(l, c) {
    return typeof c == "function" ? c(l) : c;
  }
  function ud(l) {
    var c = cs(), _ = c.queue;
    if (_ === null) throw Error(o(311));
    _.lastRenderedReducer = l;
    var w = ni, A = w.baseQueue, P = _.pending;
    if (P !== null) {
      if (A !== null) {
        var H = A.next;
        A.next = P.next, P.next = H;
      }
      w.baseQueue = A = P, _.pending = null;
    }
    if (A !== null) {
      P = A.next, w = w.baseState;
      var Z = H = null, fe = null, we = P;
      do {
        var Be = we.lane;
        if ((Ol & Be) === Be) fe !== null && (fe = fe.next = { lane: 0, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null }), w = we.hasEagerState ? we.eagerState : l(w, we.action);
        else {
          var ht = { lane: Be, action: we.action, hasEagerState: we.hasEagerState, eagerState: we.eagerState, next: null };
          fe === null ? (Z = fe = ht, H = w) : fe = fe.next = ht, hn.lanes |= Be, kl |= Be;
        }
        we = we.next;
      } while (we !== null && we !== P);
      fe === null ? H = w : fe.next = Z, os(w, c.memoizedState) || ($i = true), c.memoizedState = w, c.baseState = H, c.baseQueue = fe, _.lastRenderedState = w;
    }
    if (l = _.interleaved, l !== null) {
      A = l;
      do
        P = A.lane, hn.lanes |= P, kl |= P, A = A.next;
      while (A !== l);
    } else A === null && (_.lanes = 0);
    return [c.memoizedState, _.dispatch];
  }
  function cd(l) {
    var c = cs(), _ = c.queue;
    if (_ === null) throw Error(o(311));
    _.lastRenderedReducer = l;
    var w = _.dispatch, A = _.pending, P = c.memoizedState;
    if (A !== null) {
      _.pending = null;
      var H = A = A.next;
      do
        P = l(P, H.action), H = H.next;
      while (H !== A);
      os(P, c.memoizedState) || ($i = true), c.memoizedState = P, c.baseQueue === null && (c.baseState = P), _.lastRenderedState = P;
    }
    return [P, w];
  }
  function tM() {
  }
  function nM(l, c) {
    var _ = hn, w = cs(), A = c(), P = !os(w.memoizedState, A);
    if (P && (w.memoizedState = A, $i = true), w = w.queue, bc(sM.bind(null, _, w, l), [l]), w.getSnapshot !== c || P || Vn !== null && Vn.memoizedState.tag & 1) {
      if (_.flags |= 2048, Pc(9, rM.bind(null, _, w, A, c), void 0, null), Tn === null) throw Error(o(349));
      Ol & 30 || iM(_, c, A);
    }
    return A;
  }
  function iM(l, c, _) {
    l.flags |= 16384, l = { getSnapshot: c, value: _ }, c = hn.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, hn.updateQueue = c, c.stores = [l]) : (_ = c.stores, _ === null ? c.stores = [l] : _.push(l));
  }
  function rM(l, c, _, w) {
    c.value = _, c.getSnapshot = w, oM(c) && Ar(l, 1, -1);
  }
  function sM(l, c, _) {
    return _(function() {
      oM(c) && Ar(l, 1, -1);
    });
  }
  function oM(l) {
    var c = l.getSnapshot;
    l = l.value;
    try {
      var _ = c();
      return !os(l, _);
    } catch {
      return true;
    }
  }
  function R0(l) {
    var c = Us();
    return typeof l == "function" && (l = l()), c.memoizedState = c.baseState = l, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ga, lastRenderedState: l }, c.queue = l, l = l.dispatch = jL.bind(null, hn, l), [c.memoizedState, l];
  }
  function Pc(l, c, _, w) {
    return l = { tag: l, create: c, destroy: _, deps: w, next: null }, c = hn.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, hn.updateQueue = c, c.lastEffect = l.next = l) : (_ = c.lastEffect, _ === null ? c.lastEffect = l.next = l : (w = _.next, _.next = l, l.next = w, c.lastEffect = l)), l;
  }
  function aM() {
    return cs().memoizedState;
  }
  function fd(l, c, _, w) {
    var A = Us();
    hn.flags |= l, A.memoizedState = Pc(1 | c, _, void 0, w === void 0 ? null : w);
  }
  function hd(l, c, _, w) {
    var A = cs();
    w = w === void 0 ? null : w;
    var P = void 0;
    if (ni !== null) {
      var H = ni.memoizedState;
      if (P = H.destroy, w !== null && T0(w, H.deps)) {
        A.memoizedState = Pc(c, _, P, w);
        return;
      }
    }
    hn.flags |= l, A.memoizedState = Pc(1 | c, _, P, w);
  }
  function P0(l, c) {
    return fd(8390656, 8, l, c);
  }
  function bc(l, c) {
    return hd(2048, 8, l, c);
  }
  function lM(l, c) {
    return hd(4, 2, l, c);
  }
  function uM(l, c) {
    return hd(4, 4, l, c);
  }
  function cM(l, c) {
    if (typeof c == "function") return l = l(), c(l), function() {
      c(null);
    };
    if (c != null) return l = l(), c.current = l, function() {
      c.current = null;
    };
  }
  function fM(l, c, _) {
    return _ = _ != null ? _.concat([l]) : null, hd(4, 4, cM.bind(null, c, l), _);
  }
  function b0() {
  }
  function hM(l, c) {
    var _ = cs();
    c = c === void 0 ? null : c;
    var w = _.memoizedState;
    return w !== null && c !== null && T0(c, w[1]) ? w[0] : (_.memoizedState = [l, c], l);
  }
  function dM(l, c) {
    var _ = cs();
    c = c === void 0 ? null : c;
    var w = _.memoizedState;
    return w !== null && c !== null && T0(c, w[1]) ? w[0] : (l = l(), _.memoizedState = [l, c], l);
  }
  function YL(l, c) {
    var _ = Lt;
    Lt = _ !== 0 && 4 > _ ? _ : 4, l(true);
    var w = Tr.transition;
    Tr.transition = {};
    try {
      l(false), c();
    } finally {
      Lt = _, Tr.transition = w;
    }
  }
  function pM() {
    return cs().memoizedState;
  }
  function qL(l, c, _) {
    var w = _o(l);
    _ = { lane: w, action: _, hasEagerState: false, eagerState: null, next: null }, mM(l) ? gM(c, _) : (_M(l, c, _), _ = Si(), l = Ar(l, w, _), l !== null && vM(l, c, w));
  }
  function jL(l, c, _) {
    var w = _o(l), A = { lane: w, action: _, hasEagerState: false, eagerState: null, next: null };
    if (mM(l)) gM(c, A);
    else {
      _M(l, c, A);
      var P = l.alternate;
      if (l.lanes === 0 && (P === null || P.lanes === 0) && (P = c.lastRenderedReducer, P !== null)) try {
        var H = c.lastRenderedState, Z = P(H, _);
        if (A.hasEagerState = true, A.eagerState = Z, os(Z, H)) return;
      } catch {
      } finally {
      }
      _ = Si(), l = Ar(l, w, _), l !== null && vM(l, c, w);
    }
  }
  function mM(l) {
    var c = l.alternate;
    return l === hn || c !== null && c === hn;
  }
  function gM(l, c) {
    Cc = ld = true;
    var _ = l.pending;
    _ === null ? c.next = c : (c.next = _.next, _.next = c), l.pending = c;
  }
  function _M(l, c, _) {
    Tn !== null && l.mode & 1 && !(Mt & 2) ? (l = c.interleaved, l === null ? (_.next = _, ls === null ? ls = [c] : ls.push(c)) : (_.next = l.next, l.next = _), c.interleaved = _) : (l = c.pending, l === null ? _.next = _ : (_.next = l.next, l.next = _), c.pending = _);
  }
  function vM(l, c, _) {
    if (_ & 4194240) {
      var w = c.lanes;
      w &= l.pendingLanes, _ |= w, c.lanes = _, r0(l, _);
    }
  }
  var dd = { readContext: Sr, useCallback: ii, useContext: ii, useEffect: ii, useImperativeHandle: ii, useInsertionEffect: ii, useLayoutEffect: ii, useMemo: ii, useReducer: ii, useRef: ii, useState: ii, useDebugValue: ii, useDeferredValue: ii, useTransition: ii, useMutableSource: ii, useSyncExternalStore: ii, useId: ii, unstable_isNewReconciler: false }, ZL = { readContext: Sr, useCallback: function(l, c) {
    return Us().memoizedState = [l, c === void 0 ? null : c], l;
  }, useContext: Sr, useEffect: P0, useImperativeHandle: function(l, c, _) {
    return _ = _ != null ? _.concat([l]) : null, fd(4194308, 4, cM.bind(null, c, l), _);
  }, useLayoutEffect: function(l, c) {
    return fd(4194308, 4, l, c);
  }, useInsertionEffect: function(l, c) {
    return fd(4, 2, l, c);
  }, useMemo: function(l, c) {
    var _ = Us();
    return c = c === void 0 ? null : c, l = l(), _.memoizedState = [l, c], l;
  }, useReducer: function(l, c, _) {
    var w = Us();
    return c = _ !== void 0 ? _(c) : c, w.memoizedState = w.baseState = c, l = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: l, lastRenderedState: c }, w.queue = l, l = l.dispatch = qL.bind(null, hn, l), [w.memoizedState, l];
  }, useRef: function(l) {
    var c = Us();
    return l = { current: l }, c.memoizedState = l;
  }, useState: R0, useDebugValue: b0, useDeferredValue: function(l) {
    var c = R0(l), _ = c[0], w = c[1];
    return P0(function() {
      var A = Tr.transition;
      Tr.transition = {};
      try {
        w(l);
      } finally {
        Tr.transition = A;
      }
    }, [l]), _;
  }, useTransition: function() {
    var l = R0(false), c = l[0];
    return l = YL.bind(null, l[1]), Us().memoizedState = l, [c, l];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(l, c, _) {
    var w = hn, A = Us();
    if (Qt) {
      if (_ === void 0) throw Error(o(407));
      _ = _();
    } else {
      if (_ = c(), Tn === null) throw Error(o(349));
      Ol & 30 || iM(w, c, _);
    }
    A.memoizedState = _;
    var P = { value: _, getSnapshot: c };
    return A.queue = P, P0(sM.bind(null, w, P, l), [l]), w.flags |= 2048, Pc(9, rM.bind(null, w, P, _, c), void 0, null), _;
  }, useId: function() {
    var l = Us(), c = Tn.identifierPrefix;
    if (Qt) {
      var _ = Ns, w = Ds;
      _ = (w & ~(1 << 32 - Ji(w) - 1)).toString(32) + _, c = ":" + c + "R" + _, _ = Rc++, 0 < _ && (c += "H" + _.toString(32)), c += ":";
    } else _ = XL++, c = ":" + c + "r" + _.toString(32) + ":";
    return l.memoizedState = c;
  }, unstable_isNewReconciler: false }, JL = { readContext: Sr, useCallback: hM, useContext: Sr, useEffect: bc, useImperativeHandle: fM, useInsertionEffect: lM, useLayoutEffect: uM, useMemo: dM, useReducer: ud, useRef: aM, useState: function() {
    return ud(ga);
  }, useDebugValue: b0, useDeferredValue: function(l) {
    var c = ud(ga), _ = c[0], w = c[1];
    return bc(function() {
      var A = Tr.transition;
      Tr.transition = {};
      try {
        w(l);
      } finally {
        Tr.transition = A;
      }
    }, [l]), _;
  }, useTransition: function() {
    var l = ud(ga)[0], c = cs().memoizedState;
    return [l, c];
  }, useMutableSource: tM, useSyncExternalStore: nM, useId: pM, unstable_isNewReconciler: false }, KL = { readContext: Sr, useCallback: hM, useContext: Sr, useEffect: bc, useImperativeHandle: fM, useInsertionEffect: lM, useLayoutEffect: uM, useMemo: dM, useReducer: cd, useRef: aM, useState: function() {
    return cd(ga);
  }, useDebugValue: b0, useDeferredValue: function(l) {
    var c = cd(ga), _ = c[0], w = c[1];
    return bc(function() {
      var A = Tr.transition;
      Tr.transition = {};
      try {
        w(l);
      } finally {
        Tr.transition = A;
      }
    }, [l]), _;
  }, useTransition: function() {
    var l = cd(ga)[0], c = cs().memoizedState;
    return [l, c];
  }, useMutableSource: tM, useSyncExternalStore: nM, useId: pM, unstable_isNewReconciler: false };
  function L0(l, c) {
    try {
      var _ = "", w = c;
      do
        _ += WL(w), w = w.return;
      while (w);
      var A = _;
    } catch (P) {
      A = `
Error generating stack: ` + P.message + `
` + P.stack;
    }
    return { value: l, source: c, stack: A };
  }
  function I0(l, c) {
    try {
      console.error(c.value);
    } catch (_) {
      setTimeout(function() {
        throw _;
      });
    }
  }
  var QL = typeof WeakMap == "function" ? WeakMap : Map;
  function yM(l, c, _) {
    _ = Is(-1, _), _.tag = 3, _.payload = { element: null };
    var w = c.value;
    return _.callback = function() {
      Pd || (Pd = true, J0 = w), I0(l, c);
    }, _;
  }
  function xM(l, c, _) {
    _ = Is(-1, _), _.tag = 3;
    var w = l.type.getDerivedStateFromError;
    if (typeof w == "function") {
      var A = c.value;
      _.payload = function() {
        return w(A);
      }, _.callback = function() {
        I0(l, c);
      };
    }
    var P = l.stateNode;
    return P !== null && typeof P.componentDidCatch == "function" && (_.callback = function() {
      I0(l, c), typeof w != "function" && (mo === null ? mo = /* @__PURE__ */ new Set([this]) : mo.add(this));
      var H = c.stack;
      this.componentDidCatch(c.value, { componentStack: H !== null ? H : "" });
    }), _;
  }
  function SM(l, c, _) {
    var w = l.pingCache;
    if (w === null) {
      w = l.pingCache = new QL();
      var A = /* @__PURE__ */ new Set();
      w.set(c, A);
    } else A = w.get(c), A === void 0 && (A = /* @__PURE__ */ new Set(), w.set(c, A));
    A.has(_) || (A.add(_), l = h3.bind(null, l, c, _), c.then(l, l));
  }
  function MM(l) {
    do {
      var c;
      if ((c = l.tag === 13) && (c = l.memoizedState, c = c !== null ? c.dehydrated !== null : true), c) return l;
      l = l.return;
    } while (l !== null);
    return null;
  }
  function wM(l, c, _, w, A) {
    return l.mode & 1 ? (l.flags |= 65536, l.lanes = A, l) : (l === c ? l.flags |= 65536 : (l.flags |= 128, _.flags |= 131072, _.flags &= -52805, _.tag === 1 && (_.alternate === null ? _.tag = 17 : (c = Is(-1, 1), c.tag = 2, po(_, c))), _.lanes |= 1), l);
  }
  function fs(l) {
    l.flags |= 4;
  }
  function EM(l, c) {
    if (l !== null && l.child === c.child) return true;
    if (c.flags & 16) return false;
    for (l = c.child; l !== null; ) {
      if (l.flags & 12854 || l.subtreeFlags & 12854) return false;
      l = l.sibling;
    }
    return true;
  }
  var Lc, Ic, pd, md;
  if (He) Lc = function(l, c) {
    for (var _ = c.child; _ !== null; ) {
      if (_.tag === 5 || _.tag === 6) ae(l, _.stateNode);
      else if (_.tag !== 4 && _.child !== null) {
        _.child.return = _, _ = _.child;
        continue;
      }
      if (_ === c) break;
      for (; _.sibling === null; ) {
        if (_.return === null || _.return === c) return;
        _ = _.return;
      }
      _.sibling.return = _.return, _ = _.sibling;
    }
  }, Ic = function() {
  }, pd = function(l, c, _, w, A) {
    if (l = l.memoizedProps, l !== w) {
      var P = c.stateNode, H = us(Er.current);
      _ = ne(P, _, l, w, A, H), (c.updateQueue = _) && fs(c);
    }
  }, md = function(l, c, _, w) {
    _ !== w && fs(c);
  };
  else if (W) {
    Lc = function(l, c, _, w) {
      for (var A = c.child; A !== null; ) {
        if (A.tag === 5) {
          var P = A.stateNode;
          _ && w && (P = En(P, A.type, A.memoizedProps, A)), ae(l, P);
        } else if (A.tag === 6) P = A.stateNode, _ && w && (P = yi(P, A.memoizedProps, A)), ae(l, P);
        else if (A.tag !== 4) {
          if (A.tag === 22 && A.memoizedState !== null) P = A.child, P !== null && (P.return = A), Lc(l, A, true, true);
          else if (A.child !== null) {
            A.child.return = A, A = A.child;
            continue;
          }
        }
        if (A === c) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === c) return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    };
    var TM = function(l, c, _, w) {
      for (var A = c.child; A !== null; ) {
        if (A.tag === 5) {
          var P = A.stateNode;
          _ && w && (P = En(P, A.type, A.memoizedProps, A)), $e(l, P);
        } else if (A.tag === 6) P = A.stateNode, _ && w && (P = yi(P, A.memoizedProps, A)), $e(l, P);
        else if (A.tag !== 4) {
          if (A.tag === 22 && A.memoizedState !== null) P = A.child, P !== null && (P.return = A), TM(l, A, true, true);
          else if (A.child !== null) {
            A.child.return = A, A = A.child;
            continue;
          }
        }
        if (A === c) break;
        for (; A.sibling === null; ) {
          if (A.return === null || A.return === c) return;
          A = A.return;
        }
        A.sibling.return = A.return, A = A.sibling;
      }
    };
    Ic = function(l, c) {
      var _ = c.stateNode;
      if (!EM(l, c)) {
        l = _.containerInfo;
        var w = Xe(l);
        TM(w, c, false, false), _.pendingChildren = w, fs(c), Ut(l, w);
      }
    }, pd = function(l, c, _, w, A) {
      var P = l.stateNode, H = l.memoizedProps;
      if ((l = EM(l, c)) && H === w) c.stateNode = P;
      else {
        var Z = c.stateNode, fe = us(Er.current), we = null;
        H !== w && (we = ne(Z, _, H, w, A, fe)), l && we === null ? c.stateNode = P : (P = Ae(P, we, _, H, w, c, l, Z), Ee(P, _, w, A, fe) && fs(c), c.stateNode = P, l ? fs(c) : Lc(P, c, false, false));
      }
    }, md = function(l, c, _, w) {
      _ !== w ? (l = us(Nl.current), _ = us(Er.current), c.stateNode = Ce(w, l, _, c), fs(c)) : c.stateNode = l.stateNode;
    };
  } else Ic = function() {
  }, pd = function() {
  }, md = function() {
  };
  function Dc(l, c) {
    if (!Qt) switch (l.tailMode) {
      case "hidden":
        c = l.tail;
        for (var _ = null; c !== null; ) c.alternate !== null && (_ = c), c = c.sibling;
        _ === null ? l.tail = null : _.sibling = null;
        break;
      case "collapsed":
        _ = l.tail;
        for (var w = null; _ !== null; ) _.alternate !== null && (w = _), _ = _.sibling;
        w === null ? c || l.tail === null ? l.tail = null : l.tail.sibling = null : w.sibling = null;
    }
  }
  function ri(l) {
    var c = l.alternate !== null && l.alternate.child === l.child, _ = 0, w = 0;
    if (c) for (var A = l.child; A !== null; ) _ |= A.lanes | A.childLanes, w |= A.subtreeFlags & 14680064, w |= A.flags & 14680064, A.return = l, A = A.sibling;
    else for (A = l.child; A !== null; ) _ |= A.lanes | A.childLanes, w |= A.subtreeFlags, w |= A.flags, A.return = l, A = A.sibling;
    return l.subtreeFlags |= w, l.childLanes = _, c;
  }
  function $L(l, c, _) {
    var w = c.pendingProps;
    switch (_0(c), c.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return ri(c), null;
      case 1:
        return zn(c.type) && vn(), ri(c), null;
      case 3:
        return w = c.stateNode, Ul(), rt(fn), rt(St), E0(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (l === null || l.child === null) && (wc(c) ? fs(c) : l === null || l.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024, Br !== null && ($0(Br), Br = null))), Ic(l, c), ri(c), null;
      case 5:
        M0(c), _ = us(Nl.current);
        var A = c.type;
        if (l !== null && c.stateNode != null) pd(l, c, A, w, _), l.ref !== c.ref && (c.flags |= 512, c.flags |= 2097152);
        else {
          if (!w) {
            if (c.stateNode === null) throw Error(o(166));
            return ri(c), null;
          }
          if (l = us(Er.current), wc(c)) {
            if (!xe) throw Error(o(175));
            l = $g(c.stateNode, c.type, c.memoizedProps, _, l, c, !Mc), c.updateQueue = l, l !== null && fs(c);
          } else {
            var P = $(A, w, _, l, c);
            Lc(P, c, false, false), c.stateNode = P, Ee(P, A, w, _, l) && fs(c);
          }
          c.ref !== null && (c.flags |= 512, c.flags |= 2097152);
        }
        return ri(c), null;
      case 6:
        if (l && c.stateNode != null) md(l, c, l.memoizedProps, w);
        else {
          if (typeof w != "string" && c.stateNode === null) throw Error(o(166));
          if (l = us(Nl.current), _ = us(Er.current), wc(c)) {
            if (!xe) throw Error(o(176));
            if (l = c.stateNode, w = c.memoizedProps, (_ = e0(l, w, c, !Mc)) && (A = Ki, A !== null)) switch (P = (A.mode & 1) !== 0, A.tag) {
              case 3:
                je(A.stateNode.containerInfo, l, w, P);
                break;
              case 5:
                nt(A.type, A.memoizedProps, A.stateNode, l, w, P);
            }
            _ && fs(c);
          } else c.stateNode = Ce(w, l, _, c);
        }
        return ri(c), null;
      case 13:
        if (rt(nn), w = c.memoizedState, Qt && Qi !== null && c.mode & 1 && !(c.flags & 128)) {
          for (l = Qi; l; ) l = fo(l);
          return Il(), c.flags |= 98560, c;
        }
        if (w !== null && w.dehydrated !== null) {
          if (w = wc(c), l === null) {
            if (!w) throw Error(o(318));
            if (!xe) throw Error(o(344));
            if (l = c.memoizedState, l = l !== null ? l.dehydrated : null, !l) throw Error(o(317));
            t0(l, c);
          } else Il(), !(c.flags & 128) && (c.memoizedState = null), c.flags |= 4;
          return ri(c), null;
        }
        return Br !== null && ($0(Br), Br = null), c.flags & 128 ? (c.lanes = _, c) : (w = w !== null, _ = false, l === null ? wc(c) : _ = l.memoizedState !== null, w && !_ && (c.child.flags |= 8192, c.mode & 1 && (l === null || nn.current & 1 ? In === 0 && (In = 3) : t_())), c.updateQueue !== null && (c.flags |= 4), ri(c), null);
      case 4:
        return Ul(), Ic(l, c), l === null && Me(c.stateNode.containerInfo), ri(c), null;
      case 10:
        return f0(c.type._context), ri(c), null;
      case 17:
        return zn(c.type) && vn(), ri(c), null;
      case 19:
        if (rt(nn), A = c.memoizedState, A === null) return ri(c), null;
        if (w = (c.flags & 128) !== 0, P = A.rendering, P === null) if (w) Dc(A, false);
        else {
          if (In !== 0 || l !== null && l.flags & 128) for (l = c.child; l !== null; ) {
            if (P = od(l), P !== null) {
              for (c.flags |= 128, Dc(A, false), l = P.updateQueue, l !== null && (c.updateQueue = l, c.flags |= 4), c.subtreeFlags = 0, l = _, w = c.child; w !== null; ) _ = w, A = l, _.flags &= 14680066, P = _.alternate, P === null ? (_.childLanes = 0, _.lanes = A, _.child = null, _.subtreeFlags = 0, _.memoizedProps = null, _.memoizedState = null, _.updateQueue = null, _.dependencies = null, _.stateNode = null) : (_.childLanes = P.childLanes, _.lanes = P.lanes, _.child = P.child, _.subtreeFlags = 0, _.deletions = null, _.memoizedProps = P.memoizedProps, _.memoizedState = P.memoizedState, _.updateQueue = P.updateQueue, _.type = P.type, A = P.dependencies, _.dependencies = A === null ? null : { lanes: A.lanes, firstContext: A.firstContext }), w = w.sibling;
              return ze(nn, nn.current & 1 | 2), c.child;
            }
            l = l.sibling;
          }
          A.tail !== null && Bn() > Z0 && (c.flags |= 128, w = true, Dc(A, false), c.lanes = 4194304);
        }
        else {
          if (!w) if (l = od(P), l !== null) {
            if (c.flags |= 128, w = true, l = l.updateQueue, l !== null && (c.updateQueue = l, c.flags |= 4), Dc(A, true), A.tail === null && A.tailMode === "hidden" && !P.alternate && !Qt) return ri(c), null;
          } else 2 * Bn() - A.renderingStartTime > Z0 && _ !== 1073741824 && (c.flags |= 128, w = true, Dc(A, false), c.lanes = 4194304);
          A.isBackwards ? (P.sibling = c.child, c.child = P) : (l = A.last, l !== null ? l.sibling = P : c.child = P, A.last = P);
        }
        return A.tail !== null ? (c = A.tail, A.rendering = c, A.tail = c.sibling, A.renderingStartTime = Bn(), c.sibling = null, l = nn.current, ze(nn, w ? l & 1 | 2 : l & 1), c) : (ri(c), null);
      case 22:
      case 23:
        return e_(), w = c.memoizedState !== null, l !== null && l.memoizedState !== null !== w && (c.flags |= 8192), w && c.mode & 1 ? er & 1073741824 && (ri(c), He && c.subtreeFlags & 6 && (c.flags |= 8192)) : ri(c), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, c.tag));
  }
  var e3 = a.ReactCurrentOwner, $i = false;
  function xi(l, c, _, w) {
    c.child = l === null ? $1(c, null, _, w) : Dl(c, l.child, _, w);
  }
  function AM(l, c, _, w, A) {
    _ = _.render;
    var P = c.ref;
    return Pl(c, A), w = A0(l, c, _, w, P, A), _ = C0(), l !== null && !$i ? (c.updateQueue = l.updateQueue, c.flags &= -2053, l.lanes &= ~A, Os(l, c, A)) : (Qt && _ && g0(c), c.flags |= 1, xi(l, c, w, A), c.child);
  }
  function CM(l, c, _, w, A) {
    if (l === null) {
      var P = _.type;
      return typeof P == "function" && !n_(P) && P.defaultProps === void 0 && _.compare === null && _.defaultProps === void 0 ? (c.tag = 15, c.type = P, RM(l, c, P, w, A)) : (l = Od(_.type, null, w, c, c.mode, A), l.ref = c.ref, l.return = c, c.child = l);
    }
    if (P = l.child, !(l.lanes & A)) {
      var H = P.memoizedProps;
      if (_ = _.compare, _ = _ !== null ? _ : Kh, _(H, w) && l.ref === c.ref) return Os(l, c, A);
    }
    return c.flags |= 1, l = yo(P, w), l.ref = c.ref, l.return = c, c.child = l;
  }
  function RM(l, c, _, w, A) {
    if (l !== null && Kh(l.memoizedProps, w) && l.ref === c.ref) if ($i = false, (l.lanes & A) !== 0) l.flags & 131072 && ($i = true);
    else return c.lanes = l.lanes, Os(l, c, A);
    return D0(l, c, _, w, A);
  }
  function PM(l, c, _) {
    var w = c.pendingProps, A = w.children, P = l !== null ? l.memoizedState : null;
    if (w.mode === "hidden") if (!(c.mode & 1)) c.memoizedState = { baseLanes: 0, cachePool: null }, ze(Fl, er), er |= _;
    else if (_ & 1073741824) c.memoizedState = { baseLanes: 0, cachePool: null }, w = P !== null ? P.baseLanes : _, ze(Fl, er), er |= w;
    else return l = P !== null ? P.baseLanes | _ : _, c.lanes = c.childLanes = 1073741824, c.memoizedState = { baseLanes: l, cachePool: null }, c.updateQueue = null, ze(Fl, er), er |= l, null;
    else P !== null ? (w = P.baseLanes | _, c.memoizedState = null) : w = _, ze(Fl, er), er |= w;
    return xi(l, c, A, _), c.child;
  }
  function bM(l, c) {
    var _ = c.ref;
    (l === null && _ !== null || l !== null && l.ref !== _) && (c.flags |= 512, c.flags |= 2097152);
  }
  function D0(l, c, _, w, A) {
    var P = zn(_) ? is : St.current;
    return P = xr(c, P), Pl(c, A), _ = A0(l, c, _, w, P, A), w = C0(), l !== null && !$i ? (c.updateQueue = l.updateQueue, c.flags &= -2053, l.lanes &= ~A, Os(l, c, A)) : (Qt && w && g0(c), c.flags |= 1, xi(l, c, _, A), c.child);
  }
  function LM(l, c, _, w, A) {
    if (zn(_)) {
      var P = true;
      Jn(c);
    } else P = false;
    if (Pl(c, A), c.stateNode === null) l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2), X1(c, _, w), m0(c, _, w, A), w = true;
    else if (l === null) {
      var H = c.stateNode, Z = c.memoizedProps;
      H.props = Z;
      var fe = H.context, we = _.contextType;
      typeof we == "object" && we !== null ? we = Sr(we) : (we = zn(_) ? is : St.current, we = xr(c, we));
      var Be = _.getDerivedStateFromProps, ht = typeof Be == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      ht || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Z !== w || fe !== we) && Y1(c, H, w, we), ho = false;
      var et = c.memoizedState;
      H.state = et, td(c, w, H, A), fe = c.memoizedState, Z !== w || et !== fe || fn.current || ho ? (typeof Be == "function" && (p0(c, _, Be, w), fe = c.memoizedState), (Z = ho || W1(c, _, Z, w, et, fe, we)) ? (ht || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = w, c.memoizedState = fe), H.props = w, H.state = fe, H.context = we, w = Z) : (typeof H.componentDidMount == "function" && (c.flags |= 4194308), w = false);
    } else {
      H = c.stateNode, B1(l, c), Z = c.memoizedProps, we = c.type === c.elementType ? Z : zr(c.type, Z), H.props = we, ht = c.pendingProps, et = H.context, fe = _.contextType, typeof fe == "object" && fe !== null ? fe = Sr(fe) : (fe = zn(_) ? is : St.current, fe = xr(c, fe));
      var Wt = _.getDerivedStateFromProps;
      (Be = typeof Wt == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (Z !== ht || et !== fe) && Y1(c, H, w, fe), ho = false, et = c.memoizedState, H.state = et, td(c, w, H, A);
      var Ze = c.memoizedState;
      Z !== ht || et !== Ze || fn.current || ho ? (typeof Wt == "function" && (p0(c, _, Wt, w), Ze = c.memoizedState), (we = ho || W1(c, _, we, w, et, Ze, fe) || false) ? (Be || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(w, Ze, fe), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(w, Ze, fe)), typeof H.componentDidUpdate == "function" && (c.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || Z === l.memoizedProps && et === l.memoizedState || (c.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Z === l.memoizedProps && et === l.memoizedState || (c.flags |= 1024), c.memoizedProps = w, c.memoizedState = Ze), H.props = w, H.state = Ze, H.context = fe, w = we) : (typeof H.componentDidUpdate != "function" || Z === l.memoizedProps && et === l.memoizedState || (c.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || Z === l.memoizedProps && et === l.memoizedState || (c.flags |= 1024), w = false);
    }
    return N0(l, c, _, w, P, A);
  }
  function N0(l, c, _, w, A, P) {
    bM(l, c);
    var H = (c.flags & 128) !== 0;
    if (!w && !H) return A && Cl(c, _, false), Os(l, c, P);
    w = c.stateNode, e3.current = c;
    var Z = H && typeof _.getDerivedStateFromError != "function" ? null : w.render();
    return c.flags |= 1, l !== null && H ? (c.child = Dl(c, l.child, null, P), c.child = Dl(c, null, Z, P)) : xi(l, c, Z, P), c.memoizedState = w.state, A && Cl(c, _, true), c.child;
  }
  function IM(l) {
    var c = l.stateNode;
    c.pendingContext ? rs(l, c.pendingContext, c.pendingContext !== c.context) : c.context && rs(l, c.context, false), S0(l, c.containerInfo);
  }
  function DM(l, c, _, w, A) {
    return Il(), x0(A), c.flags |= 256, xi(l, c, _, w), c.child;
  }
  var gd = { dehydrated: null, treeContext: null, retryLane: 0 };
  function _d(l) {
    return { baseLanes: l, cachePool: null };
  }
  function NM(l, c, _) {
    var w = c.pendingProps, A = nn.current, P = false, H = (c.flags & 128) !== 0, Z;
    if ((Z = H) || (Z = l !== null && l.memoizedState === null ? false : (A & 2) !== 0), Z ? (P = true, c.flags &= -129) : (l === null || l.memoizedState !== null) && (A |= 1), ze(nn, A & 1), l === null) return y0(c), l = c.memoizedState, l !== null && (l = l.dehydrated, l !== null) ? (c.mode & 1 ? yc(l) ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1, null) : (A = w.children, l = w.fallback, P ? (w = c.mode, P = c.child, A = { mode: "hidden", children: A }, !(w & 1) && P !== null ? (P.childLanes = 0, P.pendingProps = A) : P = Fd(A, w, 0, null), l = Ma(l, w, _, null), P.return = c, l.return = c, P.sibling = l, c.child = P, c.child.memoizedState = _d(_), c.memoizedState = gd, l) : U0(c, A));
    if (A = l.memoizedState, A !== null) {
      if (Z = A.dehydrated, Z !== null) {
        if (H) return c.flags & 256 ? (c.flags &= -257, vd(l, c, _, Error(o(422)))) : c.memoizedState !== null ? (c.child = l.child, c.flags |= 128, null) : (P = w.fallback, A = c.mode, w = Fd({ mode: "visible", children: w.children }, A, 0, null), P = Ma(P, A, _, null), P.flags |= 2, w.return = c, P.return = c, w.sibling = P, c.child = w, c.mode & 1 && Dl(c, l.child, null, _), c.child.memoizedState = _d(_), c.memoizedState = gd, P);
        if (!(c.mode & 1)) c = vd(l, c, _, null);
        else if (yc(Z)) c = vd(l, c, _, Error(o(419)));
        else if (w = (_ & l.childLanes) !== 0, $i || w) {
          if (w = Tn, w !== null) {
            switch (_ & -_) {
              case 4:
                P = 2;
                break;
              case 16:
                P = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                P = 32;
                break;
              case 536870912:
                P = 268435456;
                break;
              default:
                P = 0;
            }
            w = P & (w.suspendedLanes | _) ? 0 : P, w !== 0 && w !== A.retryLane && (A.retryLane = w, Ar(l, w, -1));
          }
          t_(), c = vd(l, c, _, Error(o(421)));
        } else vc(Z) ? (c.flags |= 128, c.child = l.child, c = d3.bind(null, l), El(Z, c), c = null) : (_ = A.treeContext, xe && (Qi = Wh(Z), Ki = c, Qt = true, Br = null, Mc = false, _ !== null && (Mr[wr++] = Ds, Mr[wr++] = Ns, Mr[wr++] = pa, Ds = _.id, Ns = _.overflow, pa = c)), c = U0(c, c.pendingProps.children), c.flags |= 4096);
        return c;
      }
      return P ? (w = OM(l, c, w.children, w.fallback, _), P = c.child, A = l.child.memoizedState, P.memoizedState = A === null ? _d(_) : { baseLanes: A.baseLanes | _, cachePool: null }, P.childLanes = l.childLanes & ~_, c.memoizedState = gd, w) : (_ = UM(l, c, w.children, _), c.memoizedState = null, _);
    }
    return P ? (w = OM(l, c, w.children, w.fallback, _), P = c.child, A = l.child.memoizedState, P.memoizedState = A === null ? _d(_) : { baseLanes: A.baseLanes | _, cachePool: null }, P.childLanes = l.childLanes & ~_, c.memoizedState = gd, w) : (_ = UM(l, c, w.children, _), c.memoizedState = null, _);
  }
  function U0(l, c) {
    return c = Fd({ mode: "visible", children: c }, l.mode, 0, null), c.return = l, l.child = c;
  }
  function UM(l, c, _, w) {
    var A = l.child;
    return l = A.sibling, _ = yo(A, { mode: "visible", children: _ }), !(c.mode & 1) && (_.lanes = w), _.return = c, _.sibling = null, l !== null && (w = c.deletions, w === null ? (c.deletions = [l], c.flags |= 16) : w.push(l)), c.child = _;
  }
  function OM(l, c, _, w, A) {
    var P = c.mode;
    l = l.child;
    var H = l.sibling, Z = { mode: "hidden", children: _ };
    return !(P & 1) && c.child !== l ? (_ = c.child, _.childLanes = 0, _.pendingProps = Z, c.deletions = null) : (_ = yo(l, Z), _.subtreeFlags = l.subtreeFlags & 14680064), H !== null ? w = yo(H, w) : (w = Ma(w, P, A, null), w.flags |= 2), w.return = c, _.return = c, _.sibling = w, c.child = _, w;
  }
  function vd(l, c, _, w) {
    return w !== null && x0(w), Dl(c, l.child, null, _), l = U0(c, c.pendingProps.children), l.flags |= 2, c.memoizedState = null, l;
  }
  function FM(l, c, _) {
    l.lanes |= c;
    var w = l.alternate;
    w !== null && (w.lanes |= c), h0(l.return, c, _);
  }
  function O0(l, c, _, w, A) {
    var P = l.memoizedState;
    P === null ? l.memoizedState = { isBackwards: c, rendering: null, renderingStartTime: 0, last: w, tail: _, tailMode: A } : (P.isBackwards = c, P.rendering = null, P.renderingStartTime = 0, P.last = w, P.tail = _, P.tailMode = A);
  }
  function kM(l, c, _) {
    var w = c.pendingProps, A = w.revealOrder, P = w.tail;
    if (xi(l, c, w.children, _), w = nn.current, w & 2) w = w & 1 | 2, c.flags |= 128;
    else {
      if (l !== null && l.flags & 128) e: for (l = c.child; l !== null; ) {
        if (l.tag === 13) l.memoizedState !== null && FM(l, _, c);
        else if (l.tag === 19) FM(l, _, c);
        else if (l.child !== null) {
          l.child.return = l, l = l.child;
          continue;
        }
        if (l === c) break e;
        for (; l.sibling === null; ) {
          if (l.return === null || l.return === c) break e;
          l = l.return;
        }
        l.sibling.return = l.return, l = l.sibling;
      }
      w &= 1;
    }
    if (ze(nn, w), !(c.mode & 1)) c.memoizedState = null;
    else switch (A) {
      case "forwards":
        for (_ = c.child, A = null; _ !== null; ) l = _.alternate, l !== null && od(l) === null && (A = _), _ = _.sibling;
        _ = A, _ === null ? (A = c.child, c.child = null) : (A = _.sibling, _.sibling = null), O0(c, false, A, _, P);
        break;
      case "backwards":
        for (_ = null, A = c.child, c.child = null; A !== null; ) {
          if (l = A.alternate, l !== null && od(l) === null) {
            c.child = A;
            break;
          }
          l = A.sibling, A.sibling = _, _ = A, A = l;
        }
        O0(c, true, _, null, P);
        break;
      case "together":
        O0(c, false, null, null, void 0);
        break;
      default:
        c.memoizedState = null;
    }
    return c.child;
  }
  function Os(l, c, _) {
    if (l !== null && (c.dependencies = l.dependencies), kl |= c.lanes, !(_ & c.childLanes)) return null;
    if (l !== null && c.child !== l.child) throw Error(o(153));
    if (c.child !== null) {
      for (l = c.child, _ = yo(l, l.pendingProps), c.child = _, _.return = c; l.sibling !== null; ) l = l.sibling, _ = _.sibling = yo(l, l.pendingProps), _.return = c;
      _.sibling = null;
    }
    return c.child;
  }
  function t3(l, c, _) {
    switch (c.tag) {
      case 3:
        IM(c), Il();
        break;
      case 5:
        eM(c);
        break;
      case 1:
        zn(c.type) && Jn(c);
        break;
      case 4:
        S0(c, c.stateNode.containerInfo);
        break;
      case 10:
        z1(c, c.type._context, c.memoizedProps.value);
        break;
      case 13:
        var w = c.memoizedState;
        if (w !== null) return w.dehydrated !== null ? (ze(nn, nn.current & 1), c.flags |= 128, null) : _ & c.child.childLanes ? NM(l, c, _) : (ze(nn, nn.current & 1), l = Os(l, c, _), l !== null ? l.sibling : null);
        ze(nn, nn.current & 1);
        break;
      case 19:
        if (w = (_ & c.childLanes) !== 0, l.flags & 128) {
          if (w) return kM(l, c, _);
          c.flags |= 128;
        }
        var A = c.memoizedState;
        if (A !== null && (A.rendering = null, A.tail = null, A.lastEffect = null), ze(nn, nn.current), w) break;
        return null;
      case 22:
      case 23:
        return c.lanes = 0, PM(l, c, _);
    }
    return Os(l, c, _);
  }
  function n32(l, c) {
    switch (_0(c), c.tag) {
      case 1:
        return zn(c.type) && vn(), l = c.flags, l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
      case 3:
        return Ul(), rt(fn), rt(St), E0(), l = c.flags, l & 65536 && !(l & 128) ? (c.flags = l & -65537 | 128, c) : null;
      case 5:
        return M0(c), null;
      case 13:
        if (rt(nn), l = c.memoizedState, l !== null && l.dehydrated !== null) {
          if (c.alternate === null) throw Error(o(340));
          Il();
        }
        return l = c.flags, l & 65536 ? (c.flags = l & -65537 | 128, c) : null;
      case 19:
        return rt(nn), null;
      case 4:
        return Ul(), null;
      case 10:
        return f0(c.type._context), null;
      case 22:
      case 23:
        return e_(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var yd = false, _a = false, i3 = typeof WeakSet == "function" ? WeakSet : Set, Le = null;
  function xd(l, c) {
    var _ = l.ref;
    if (_ !== null) if (typeof _ == "function") try {
      _(null);
    } catch (w) {
      Oi(l, c, w);
    }
    else _.current = null;
  }
  function F0(l, c, _) {
    try {
      _();
    } catch (w) {
      Oi(l, c, w);
    }
  }
  var zM = false;
  function r3(l, c) {
    for (q(l.containerInfo), Le = c; Le !== null; ) if (l = Le, c = l.child, (l.subtreeFlags & 1028) !== 0 && c !== null) c.return = l, Le = c;
    else for (; Le !== null; ) {
      l = Le;
      try {
        var _ = l.alternate;
        if (l.flags & 1024) switch (l.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (_ !== null) {
              var w = _.memoizedProps, A = _.memoizedState, P = l.stateNode, H = P.getSnapshotBeforeUpdate(l.elementType === l.type ? w : zr(l.type, w), A);
              P.__reactInternalSnapshotBeforeUpdate = H;
            }
            break;
          case 3:
            He && Te(l.stateNode.containerInfo);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(o(163));
        }
      } catch (Z) {
        Oi(l, l.return, Z);
      }
      if (c = l.sibling, c !== null) {
        c.return = l.return, Le = c;
        break;
      }
      Le = l.return;
    }
    return _ = zM, zM = false, _;
  }
  function va(l, c, _) {
    var w = c.updateQueue;
    if (w = w !== null ? w.lastEffect : null, w !== null) {
      var A = w = w.next;
      do {
        if ((A.tag & l) === l) {
          var P = A.destroy;
          A.destroy = void 0, P !== void 0 && F0(c, _, P);
        }
        A = A.next;
      } while (A !== w);
    }
  }
  function Nc(l, c) {
    if (c = c.updateQueue, c = c !== null ? c.lastEffect : null, c !== null) {
      var _ = c = c.next;
      do {
        if ((_.tag & l) === l) {
          var w = _.create;
          _.destroy = w();
        }
        _ = _.next;
      } while (_ !== c);
    }
  }
  function k0(l) {
    var c = l.ref;
    if (c !== null) {
      var _ = l.stateNode;
      switch (l.tag) {
        case 5:
          l = J(_);
          break;
        default:
          l = _;
      }
      typeof c == "function" ? c(l) : c.current = l;
    }
  }
  function BM(l, c, _) {
    if (ss && typeof ss.onCommitFiberUnmount == "function") try {
      ss.onCommitFiberUnmount(Zh, c);
    } catch {
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (l = c.updateQueue, l !== null && (l = l.lastEffect, l !== null)) {
          var w = l = l.next;
          do {
            var A = w, P = A.destroy;
            A = A.tag, P !== void 0 && (A & 2 || A & 4) && F0(c, _, P), w = w.next;
          } while (w !== l);
        }
        break;
      case 1:
        if (xd(c, _), l = c.stateNode, typeof l.componentWillUnmount == "function") try {
          l.props = c.memoizedProps, l.state = c.memoizedState, l.componentWillUnmount();
        } catch (H) {
          Oi(c, _, H);
        }
        break;
      case 5:
        xd(c, _);
        break;
      case 4:
        He ? YM(l, c, _) : W && W && (c = c.stateNode.containerInfo, _ = Xe(c), kt(c, _));
    }
  }
  function VM(l, c, _) {
    for (var w = c; ; ) if (BM(l, w, _), w.child === null || He && w.tag === 4) {
      if (w === c) break;
      for (; w.sibling === null; ) {
        if (w.return === null || w.return === c) return;
        w = w.return;
      }
      w.sibling.return = w.return, w = w.sibling;
    } else w.child.return = w, w = w.child;
  }
  function HM(l) {
    var c = l.alternate;
    c !== null && (l.alternate = null, HM(c)), l.child = null, l.deletions = null, l.sibling = null, l.tag === 5 && (c = l.stateNode, c !== null && Je(c)), l.stateNode = null, l.return = null, l.dependencies = null, l.memoizedProps = null, l.memoizedState = null, l.pendingProps = null, l.stateNode = null, l.updateQueue = null;
  }
  function GM(l) {
    return l.tag === 5 || l.tag === 3 || l.tag === 4;
  }
  function WM(l) {
    e: for (; ; ) {
      for (; l.sibling === null; ) {
        if (l.return === null || GM(l.return)) return null;
        l = l.return;
      }
      for (l.sibling.return = l.return, l = l.sibling; l.tag !== 5 && l.tag !== 6 && l.tag !== 18; ) {
        if (l.flags & 2 || l.child === null || l.tag === 4) continue e;
        l.child.return = l, l = l.child;
      }
      if (!(l.flags & 2)) return l.stateNode;
    }
  }
  function XM(l) {
    if (He) {
      e: {
        for (var c = l.return; c !== null; ) {
          if (GM(c)) break e;
          c = c.return;
        }
        throw Error(o(160));
      }
      var _ = c;
      switch (_.tag) {
        case 5:
          c = _.stateNode, _.flags & 32 && (bt(c), _.flags &= -33), _ = WM(l), B0(l, _, c);
          break;
        case 3:
        case 4:
          c = _.stateNode.containerInfo, _ = WM(l), z0(l, _, c);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function z0(l, c, _) {
    var w = l.tag;
    if (w === 5 || w === 6) l = l.stateNode, c ? Qe(_, l, c) : ft(_, l);
    else if (w !== 4 && (l = l.child, l !== null)) for (z0(l, c, _), l = l.sibling; l !== null; ) z0(l, c, _), l = l.sibling;
  }
  function B0(l, c, _) {
    var w = l.tag;
    if (w === 5 || w === 6) l = l.stateNode, c ? lt(_, l, c) : tt(_, l);
    else if (w !== 4 && (l = l.child, l !== null)) for (B0(l, c, _), l = l.sibling; l !== null; ) B0(l, c, _), l = l.sibling;
  }
  function YM(l, c, _) {
    for (var w = c, A = false, P, H; ; ) {
      if (!A) {
        A = w.return;
        e: for (; ; ) {
          if (A === null) throw Error(o(160));
          switch (P = A.stateNode, A.tag) {
            case 5:
              H = false;
              break e;
            case 3:
              P = P.containerInfo, H = true;
              break e;
            case 4:
              P = P.containerInfo, H = true;
              break e;
          }
          A = A.return;
        }
        A = true;
      }
      if (w.tag === 5 || w.tag === 6) VM(l, w, _), H ? pt(P, w.stateNode) : Ge(P, w.stateNode);
      else if (w.tag === 18) H ? se(P, w.stateNode) : le(P, w.stateNode);
      else if (w.tag === 4) {
        if (w.child !== null) {
          P = w.stateNode.containerInfo, H = true, w.child.return = w, w = w.child;
          continue;
        }
      } else if (BM(l, w, _), w.child !== null) {
        w.child.return = w, w = w.child;
        continue;
      }
      if (w === c) break;
      for (; w.sibling === null; ) {
        if (w.return === null || w.return === c) return;
        w = w.return, w.tag === 4 && (A = false);
      }
      w.sibling.return = w.return, w = w.sibling;
    }
  }
  function V0(l, c) {
    if (He) {
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          va(3, c, c.return), Nc(3, c), va(5, c, c.return);
          return;
        case 1:
          return;
        case 5:
          var _ = c.stateNode;
          if (_ != null) {
            var w = c.memoizedProps;
            l = l !== null ? l.memoizedProps : w;
            var A = c.type, P = c.updateQueue;
            c.updateQueue = null, P !== null && xt(_, P, A, l, w, c);
          }
          return;
        case 6:
          if (c.stateNode === null) throw Error(o(162));
          _ = c.memoizedProps, ve(c.stateNode, l !== null ? l.memoizedProps : _, _);
          return;
        case 3:
          xe && l !== null && l.memoizedState.isDehydrated && ee(c.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Sd(c);
          return;
        case 19:
          Sd(c);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        va(3, c, c.return), Nc(3, c), va(5, c, c.return);
        return;
      case 12:
        return;
      case 13:
        Sd(c);
        return;
      case 19:
        Sd(c);
        return;
      case 3:
        xe && l !== null && l.memoizedState.isDehydrated && ee(c.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (W) {
      switch (c.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          c = c.stateNode, kt(c.containerInfo, c.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Sd(l) {
    var c = l.updateQueue;
    if (c !== null) {
      l.updateQueue = null;
      var _ = l.stateNode;
      _ === null && (_ = l.stateNode = new i3()), c.forEach(function(w) {
        var A = p3.bind(null, l, w);
        _.has(w) || (_.add(w), w.then(A, A));
      });
    }
  }
  function s3(l, c) {
    for (Le = c; Le !== null; ) {
      c = Le;
      var _ = c.deletions;
      if (_ !== null) for (var w = 0; w < _.length; w++) {
        var A = _[w];
        try {
          var P = l;
          He ? YM(P, A, c) : VM(P, A, c);
          var H = A.alternate;
          H !== null && (H.return = null), A.return = null;
        } catch (qe) {
          Oi(A, c, qe);
        }
      }
      if (_ = c.child, c.subtreeFlags & 12854 && _ !== null) _.return = c, Le = _;
      else for (; Le !== null; ) {
        c = Le;
        try {
          var Z = c.flags;
          if (Z & 32 && He && bt(c.stateNode), Z & 512) {
            var fe = c.alternate;
            if (fe !== null) {
              var we = fe.ref;
              we !== null && (typeof we == "function" ? we(null) : we.current = null);
            }
          }
          if (Z & 8192) switch (c.tag) {
            case 13:
              if (c.memoizedState !== null) {
                var Be = c.alternate;
                (Be === null || Be.memoizedState === null) && (j0 = Bn());
              }
              break;
            case 22:
              var ht = c.memoizedState !== null, et = c.alternate, Wt = et !== null && et.memoizedState !== null;
              if (_ = c, He) {
                e: if (w = _, A = ht, P = null, He) for (var Ze = w; ; ) {
                  if (Ze.tag === 5) {
                    if (P === null) {
                      P = Ze;
                      var si = Ze.stateNode;
                      A ? Gt(si) : Ft(Ze.stateNode, Ze.memoizedProps);
                    }
                  } else if (Ze.tag === 6) {
                    if (P === null) {
                      var Rr = Ze.stateNode;
                      A ? wt(Rr) : G(Rr, Ze.memoizedProps);
                    }
                  } else if ((Ze.tag !== 22 && Ze.tag !== 23 || Ze.memoizedState === null || Ze === w) && Ze.child !== null) {
                    Ze.child.return = Ze, Ze = Ze.child;
                    continue;
                  }
                  if (Ze === w) break;
                  for (; Ze.sibling === null; ) {
                    if (Ze.return === null || Ze.return === w) break e;
                    P === Ze && (P = null), Ze = Ze.return;
                  }
                  P === Ze && (P = null), Ze.sibling.return = Ze.return, Ze = Ze.sibling;
                }
              }
              if (ht && !Wt && _.mode & 1) {
                Le = _;
                for (var re = _.child; re !== null; ) {
                  for (_ = Le = re; Le !== null; ) {
                    w = Le;
                    var K = w.child;
                    switch (w.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        va(4, w, w.return);
                        break;
                      case 1:
                        xd(w, w.return);
                        var ue = w.stateNode;
                        if (typeof ue.componentWillUnmount == "function") {
                          var Ne = w.return;
                          try {
                            ue.props = w.memoizedProps, ue.state = w.memoizedState, ue.componentWillUnmount();
                          } catch (qe) {
                            Oi(w, Ne, qe);
                          }
                        }
                        break;
                      case 5:
                        xd(w, w.return);
                        break;
                      case 22:
                        if (w.memoizedState !== null) {
                          ZM(_);
                          continue;
                        }
                    }
                    K !== null ? (K.return = w, Le = K) : ZM(_);
                  }
                  re = re.sibling;
                }
              }
          }
          switch (Z & 4102) {
            case 2:
              XM(c), c.flags &= -3;
              break;
            case 6:
              XM(c), c.flags &= -3, V0(c.alternate, c);
              break;
            case 4096:
              c.flags &= -4097;
              break;
            case 4100:
              c.flags &= -4097, V0(c.alternate, c);
              break;
            case 4:
              V0(c.alternate, c);
          }
        } catch (qe) {
          Oi(c, c.return, qe);
        }
        if (_ = c.sibling, _ !== null) {
          _.return = c.return, Le = _;
          break;
        }
        Le = c.return;
      }
    }
  }
  function o3(l, c, _) {
    Le = l, qM(l);
  }
  function qM(l, c, _) {
    for (var w = (l.mode & 1) !== 0; Le !== null; ) {
      var A = Le, P = A.child;
      if (A.tag === 22 && w) {
        var H = A.memoizedState !== null || yd;
        if (!H) {
          var Z = A.alternate, fe = Z !== null && Z.memoizedState !== null || _a;
          Z = yd;
          var we = _a;
          if (yd = H, (_a = fe) && !we) for (Le = A; Le !== null; ) H = Le, fe = H.child, H.tag === 22 && H.memoizedState !== null ? JM(A) : fe !== null ? (fe.return = H, Le = fe) : JM(A);
          for (; P !== null; ) Le = P, qM(P), P = P.sibling;
          Le = A, yd = Z, _a = we;
        }
        jM(l);
      } else A.subtreeFlags & 8772 && P !== null ? (P.return = A, Le = P) : jM(l);
    }
  }
  function jM(l) {
    for (; Le !== null; ) {
      var c = Le;
      if (c.flags & 8772) {
        var _ = c.alternate;
        try {
          if (c.flags & 8772) switch (c.tag) {
            case 0:
            case 11:
            case 15:
              _a || Nc(5, c);
              break;
            case 1:
              var w = c.stateNode;
              if (c.flags & 4 && !_a) if (_ === null) w.componentDidMount();
              else {
                var A = c.elementType === c.type ? _.memoizedProps : zr(c.type, _.memoizedProps);
                w.componentDidUpdate(A, _.memoizedState, w.__reactInternalSnapshotBeforeUpdate);
              }
              var P = c.updateQueue;
              P !== null && H1(c, P, w);
              break;
            case 3:
              var H = c.updateQueue;
              if (H !== null) {
                if (_ = null, c.child !== null) switch (c.child.tag) {
                  case 5:
                    _ = J(c.child.stateNode);
                    break;
                  case 1:
                    _ = c.child.stateNode;
                }
                H1(c, H, _);
              }
              break;
            case 5:
              var Z = c.stateNode;
              _ === null && c.flags & 4 && Ct(Z, c.type, c.memoizedProps, c);
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (xe && c.memoizedState === null) {
                var fe = c.alternate;
                if (fe !== null) {
                  var we = fe.memoizedState;
                  if (we !== null) {
                    var Be = we.dehydrated;
                    Be !== null && oe(Be);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
              break;
            default:
              throw Error(o(163));
          }
          _a || c.flags & 512 && k0(c);
        } catch (ht) {
          Oi(c, c.return, ht);
        }
      }
      if (c === l) {
        Le = null;
        break;
      }
      if (_ = c.sibling, _ !== null) {
        _.return = c.return, Le = _;
        break;
      }
      Le = c.return;
    }
  }
  function ZM(l) {
    for (; Le !== null; ) {
      var c = Le;
      if (c === l) {
        Le = null;
        break;
      }
      var _ = c.sibling;
      if (_ !== null) {
        _.return = c.return, Le = _;
        break;
      }
      Le = c.return;
    }
  }
  function JM(l) {
    for (; Le !== null; ) {
      var c = Le;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var _ = c.return;
            try {
              Nc(4, c);
            } catch (fe) {
              Oi(c, _, fe);
            }
            break;
          case 1:
            var w = c.stateNode;
            if (typeof w.componentDidMount == "function") {
              var A = c.return;
              try {
                w.componentDidMount();
              } catch (fe) {
                Oi(c, A, fe);
              }
            }
            var P = c.return;
            try {
              k0(c);
            } catch (fe) {
              Oi(c, P, fe);
            }
            break;
          case 5:
            var H = c.return;
            try {
              k0(c);
            } catch (fe) {
              Oi(c, H, fe);
            }
        }
      } catch (fe) {
        Oi(c, c.return, fe);
      }
      if (c === l) {
        Le = null;
        break;
      }
      var Z = c.sibling;
      if (Z !== null) {
        Z.return = c.return, Le = Z;
        break;
      }
      Le = c.return;
    }
  }
  var Md = 0, wd = 1, Ed = 2, Td = 3, Ad = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Uc = Symbol.for;
    Md = Uc("selector.component"), wd = Uc("selector.has_pseudo_class"), Ed = Uc("selector.role"), Td = Uc("selector.test_id"), Ad = Uc("selector.text");
  }
  function H0(l) {
    var c = de(l);
    if (c != null) {
      if (typeof c.memoizedProps["data-testname"] != "string") throw Error(o(364));
      return c;
    }
    if (l = ie(l), l === null) throw Error(o(362));
    return l.stateNode.current;
  }
  function G0(l, c) {
    switch (c.$$typeof) {
      case Md:
        if (l.type === c.value) return true;
        break;
      case wd:
        e: {
          c = c.value, l = [l, 0];
          for (var _ = 0; _ < l.length; ) {
            var w = l[_++], A = l[_++], P = c[A];
            if (w.tag !== 5 || !ge(w)) {
              for (; P != null && G0(w, P); ) A++, P = c[A];
              if (A === c.length) {
                c = true;
                break e;
              } else for (w = w.child; w !== null; ) l.push(w, A), w = w.sibling;
            }
          }
          c = false;
        }
        return c;
      case Ed:
        if (l.tag === 5 && We(l.stateNode, c.value)) return true;
        break;
      case Ad:
        if ((l.tag === 5 || l.tag === 6) && (l = _e(l), l !== null && 0 <= l.indexOf(c.value))) return true;
        break;
      case Td:
        if (l.tag === 5 && (l = l.memoizedProps["data-testname"], typeof l == "string" && l.toLowerCase() === c.value.toLowerCase())) return true;
        break;
      default:
        throw Error(o(365));
    }
    return false;
  }
  function W0(l) {
    switch (l.$$typeof) {
      case Md:
        return "<" + (I(l.value) || "Unknown") + ">";
      case wd:
        return ":has(" + (W0(l) || "") + ")";
      case Ed:
        return '[role="' + l.value + '"]';
      case Ad:
        return '"' + l.value + '"';
      case Td:
        return '[data-testname="' + l.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function KM(l, c) {
    var _ = [];
    l = [l, 0];
    for (var w = 0; w < l.length; ) {
      var A = l[w++], P = l[w++], H = c[P];
      if (A.tag !== 5 || !ge(A)) {
        for (; H != null && G0(A, H); ) P++, H = c[P];
        if (P === c.length) _.push(A);
        else for (A = A.child; A !== null; ) l.push(A, P), A = A.sibling;
      }
    }
    return _;
  }
  function X0(l, c) {
    if (!N) throw Error(o(363));
    l = H0(l), l = KM(l, c), c = [], l = Array.from(l);
    for (var _ = 0; _ < l.length; ) {
      var w = l[_++];
      if (w.tag === 5) ge(w) || c.push(w.stateNode);
      else for (w = w.child; w !== null; ) l.push(w), w = w.sibling;
    }
    return c;
  }
  var a3 = Math.ceil, Cd = a.ReactCurrentDispatcher, Y0 = a.ReactCurrentOwner, yn = a.ReactCurrentBatchConfig, Mt = 0, Tn = null, An = null, Kn = 0, er = 0, Fl = kn(0), In = 0, Oc = null, kl = 0, Rd = 0, q0 = 0, Fc = null, Ni = null, j0 = 0, Z0 = 1 / 0;
  function zl() {
    Z0 = Bn() + 500;
  }
  var Pd = false, J0 = null, mo = null, bd = false, go = null, Ld = 0, kc = 0, K0 = null, Id = -1, Dd = 0;
  function Si() {
    return Mt & 6 ? Bn() : Id !== -1 ? Id : Id = Bn();
  }
  function _o(l) {
    return l.mode & 1 ? Mt & 2 && Kn !== 0 ? Kn & -Kn : GL.transition !== null ? (Dd === 0 && (l = Yh, Yh <<= 1, !(Yh & 4194240) && (Yh = 64), Dd = l), Dd) : (l = Lt, l !== 0 ? l : pe()) : 1;
  }
  function Ar(l, c, _) {
    if (50 < kc) throw kc = 0, K0 = null, Error(o(185));
    var w = Nd(l, c);
    return w === null ? null : (Sc(w, c, _), (!(Mt & 2) || w !== Tn) && (w === Tn && (!(Mt & 2) && (Rd |= c), In === 4 && vo(w, Kn)), Ui(w, _), c === 1 && Mt === 0 && !(l.mode & 1) && (zl(), Jh && as())), w);
  }
  function Nd(l, c) {
    l.lanes |= c;
    var _ = l.alternate;
    for (_ !== null && (_.lanes |= c), _ = l, l = l.return; l !== null; ) l.childLanes |= c, _ = l.alternate, _ !== null && (_.childLanes |= c), _ = l, l = l.return;
    return _.tag === 3 ? _.stateNode : null;
  }
  function Ui(l, c) {
    var _ = l.callbackNode;
    NL(l, c);
    var w = jh(l, l === Tn ? Kn : 0);
    if (w === 0) _ !== null && F1(_), l.callbackNode = null, l.callbackPriority = 0;
    else if (c = w & -w, l.callbackPriority !== c) {
      if (_ != null && F1(_), c === 1) l.tag === 0 ? HL($M.bind(null, l)) : k1($M.bind(null, l)), De ? O(function() {
        Mt === 0 && as();
      }) : s0(o0, as), _ = null;
      else {
        switch (O1(w)) {
          case 1:
            _ = o0;
            break;
          case 4:
            _ = kL;
            break;
          case 16:
            _ = a0;
            break;
          case 536870912:
            _ = zL;
            break;
          default:
            _ = a0;
        }
        _ = lw(_, QM.bind(null, l));
      }
      l.callbackPriority = c, l.callbackNode = _;
    }
  }
  function QM(l, c) {
    if (Id = -1, Dd = 0, Mt & 6) throw Error(o(327));
    var _ = l.callbackNode;
    if (Sa() && l.callbackNode !== _) return null;
    var w = jh(l, l === Tn ? Kn : 0);
    if (w === 0) return null;
    if (w & 30 || w & l.expiredLanes || c) c = Ud(l, w);
    else {
      c = w;
      var A = Mt;
      Mt |= 2;
      var P = nw();
      (Tn !== l || Kn !== c) && (zl(), ya(l, c));
      do
        try {
          c3();
          break;
        } catch (Z) {
          tw(l, Z);
        }
      while (true);
      c0(), Cd.current = P, Mt = A, An !== null ? c = 0 : (Tn = null, Kn = 0, c = In);
    }
    if (c !== 0) {
      if (c === 2 && (A = n0(l), A !== 0 && (w = A, c = Q0(l, A))), c === 1) throw _ = Oc, ya(l, 0), vo(l, w), Ui(l, Bn()), _;
      if (c === 6) vo(l, w);
      else {
        if (A = l.current.alternate, !(w & 30) && !l3(A) && (c = Ud(l, w), c === 2 && (P = n0(l), P !== 0 && (w = P, c = Q0(l, P))), c === 1)) throw _ = Oc, ya(l, 0), vo(l, w), Ui(l, Bn()), _;
        switch (l.finishedWork = A, l.finishedLanes = w, c) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            xa(l, Ni);
            break;
          case 3:
            if (vo(l, w), (w & 130023424) === w && (c = j0 + 500 - Bn(), 10 < c)) {
              if (jh(l, 0) !== 0) break;
              if (A = l.suspendedLanes, (A & w) !== w) {
                Si(), l.pingedLanes |= l.suspendedLanes & A;
                break;
              }
              l.timeoutHandle = Ie(xa.bind(null, l, Ni), c);
              break;
            }
            xa(l, Ni);
            break;
          case 4:
            if (vo(l, w), (w & 4194240) === w) break;
            for (c = l.eventTimes, A = -1; 0 < w; ) {
              var H = 31 - Ji(w);
              P = 1 << H, H = c[H], H > A && (A = H), w &= ~P;
            }
            if (w = A, w = Bn() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * a3(w / 1960)) - w, 10 < w) {
              l.timeoutHandle = Ie(xa.bind(null, l, Ni), w);
              break;
            }
            xa(l, Ni);
            break;
          case 5:
            xa(l, Ni);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Ui(l, Bn()), l.callbackNode === _ ? QM.bind(null, l) : null;
  }
  function Q0(l, c) {
    var _ = Fc;
    return l.current.memoizedState.isDehydrated && (ya(l, c).flags |= 256), l = Ud(l, c), l !== 2 && (c = Ni, Ni = _, c !== null && $0(c)), l;
  }
  function $0(l) {
    Ni === null ? Ni = l : Ni.push.apply(Ni, l);
  }
  function l3(l) {
    for (var c = l; ; ) {
      if (c.flags & 16384) {
        var _ = c.updateQueue;
        if (_ !== null && (_ = _.stores, _ !== null)) for (var w = 0; w < _.length; w++) {
          var A = _[w], P = A.getSnapshot;
          A = A.value;
          try {
            if (!os(P(), A)) return false;
          } catch {
            return false;
          }
        }
      }
      if (_ = c.child, c.subtreeFlags & 16384 && _ !== null) _.return = c, c = _;
      else {
        if (c === l) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === l) return true;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    }
    return true;
  }
  function vo(l, c) {
    for (c &= ~q0, c &= ~Rd, l.suspendedLanes |= c, l.pingedLanes &= ~c, l = l.expirationTimes; 0 < c; ) {
      var _ = 31 - Ji(c), w = 1 << _;
      l[_] = -1, c &= ~w;
    }
  }
  function $M(l) {
    if (Mt & 6) throw Error(o(327));
    Sa();
    var c = jh(l, 0);
    if (!(c & 1)) return Ui(l, Bn()), null;
    var _ = Ud(l, c);
    if (l.tag !== 0 && _ === 2) {
      var w = n0(l);
      w !== 0 && (c = w, _ = Q0(l, w));
    }
    if (_ === 1) throw _ = Oc, ya(l, 0), vo(l, c), Ui(l, Bn()), _;
    if (_ === 6) throw Error(o(345));
    return l.finishedWork = l.current.alternate, l.finishedLanes = c, xa(l, Ni), Ui(l, Bn()), null;
  }
  function ew(l) {
    go !== null && go.tag === 0 && !(Mt & 6) && Sa();
    var c = Mt;
    Mt |= 1;
    var _ = yn.transition, w = Lt;
    try {
      if (yn.transition = null, Lt = 1, l) return l();
    } finally {
      Lt = w, yn.transition = _, Mt = c, !(Mt & 6) && as();
    }
  }
  function e_() {
    er = Fl.current, rt(Fl);
  }
  function ya(l, c) {
    l.finishedWork = null, l.finishedLanes = 0;
    var _ = l.timeoutHandle;
    if (_ !== Ve && (l.timeoutHandle = Ve, Ke(_)), An !== null) for (_ = An.return; _ !== null; ) {
      var w = _;
      switch (_0(w), w.tag) {
        case 1:
          w = w.type.childContextTypes, w != null && vn();
          break;
        case 3:
          Ul(), rt(fn), rt(St), E0();
          break;
        case 5:
          M0(w);
          break;
        case 4:
          Ul();
          break;
        case 13:
          rt(nn);
          break;
        case 19:
          rt(nn);
          break;
        case 10:
          f0(w.type._context);
          break;
        case 22:
        case 23:
          e_();
      }
      _ = _.return;
    }
    if (Tn = l, An = l = yo(l.current, null), Kn = er = c, In = 0, Oc = null, q0 = Rd = kl = 0, Ni = Fc = null, ls !== null) {
      for (c = 0; c < ls.length; c++) if (_ = ls[c], w = _.interleaved, w !== null) {
        _.interleaved = null;
        var A = w.next, P = _.pending;
        if (P !== null) {
          var H = P.next;
          P.next = A, w.next = H;
        }
        _.pending = w;
      }
      ls = null;
    }
    return l;
  }
  function tw(l, c) {
    do {
      var _ = An;
      try {
        if (c0(), ad.current = dd, ld) {
          for (var w = hn.memoizedState; w !== null; ) {
            var A = w.queue;
            A !== null && (A.pending = null), w = w.next;
          }
          ld = false;
        }
        if (Ol = 0, Vn = ni = hn = null, Cc = false, Rc = 0, Y0.current = null, _ === null || _.return === null) {
          In = 1, Oc = c, An = null;
          break;
        }
        e: {
          var P = l, H = _.return, Z = _, fe = c;
          if (c = Kn, Z.flags |= 32768, fe !== null && typeof fe == "object" && typeof fe.then == "function") {
            var we = fe, Be = Z, ht = Be.tag;
            if (!(Be.mode & 1) && (ht === 0 || ht === 11 || ht === 15)) {
              var et = Be.alternate;
              et ? (Be.updateQueue = et.updateQueue, Be.memoizedState = et.memoizedState, Be.lanes = et.lanes) : (Be.updateQueue = null, Be.memoizedState = null);
            }
            var Wt = MM(H);
            if (Wt !== null) {
              Wt.flags &= -257, wM(Wt, H, Z, P, c), Wt.mode & 1 && SM(P, we, c), c = Wt, fe = we;
              var Ze = c.updateQueue;
              if (Ze === null) {
                var si = /* @__PURE__ */ new Set();
                si.add(fe), c.updateQueue = si;
              } else Ze.add(fe);
              break e;
            } else {
              if (!(c & 1)) {
                SM(P, we, c), t_();
                break e;
              }
              fe = Error(o(426));
            }
          } else if (Qt && Z.mode & 1) {
            var Rr = MM(H);
            if (Rr !== null) {
              !(Rr.flags & 65536) && (Rr.flags |= 256), wM(Rr, H, Z, P, c), x0(fe);
              break e;
            }
          }
          P = fe, In !== 4 && (In = 2), Fc === null ? Fc = [P] : Fc.push(P), fe = L0(fe, Z), Z = H;
          do {
            switch (Z.tag) {
              case 3:
                Z.flags |= 65536, c &= -c, Z.lanes |= c;
                var re = yM(Z, fe, c);
                V1(Z, re);
                break e;
              case 1:
                P = fe;
                var K = Z.type, ue = Z.stateNode;
                if (!(Z.flags & 128) && (typeof K.getDerivedStateFromError == "function" || ue !== null && typeof ue.componentDidCatch == "function" && (mo === null || !mo.has(ue)))) {
                  Z.flags |= 65536, c &= -c, Z.lanes |= c;
                  var Ne = xM(Z, P, c);
                  V1(Z, Ne);
                  break e;
                }
            }
            Z = Z.return;
          } while (Z !== null);
        }
        rw(_);
      } catch (qe) {
        c = qe, An === _ && _ !== null && (An = _ = _.return);
        continue;
      }
      break;
    } while (true);
  }
  function nw() {
    var l = Cd.current;
    return Cd.current = dd, l === null ? dd : l;
  }
  function t_() {
    (In === 0 || In === 3 || In === 2) && (In = 4), Tn === null || !(kl & 268435455) && !(Rd & 268435455) || vo(Tn, Kn);
  }
  function Ud(l, c) {
    var _ = Mt;
    Mt |= 2;
    var w = nw();
    Tn === l && Kn === c || ya(l, c);
    do
      try {
        u3();
        break;
      } catch (A) {
        tw(l, A);
      }
    while (true);
    if (c0(), Mt = _, Cd.current = w, An !== null) throw Error(o(261));
    return Tn = null, Kn = 0, In;
  }
  function u3() {
    for (; An !== null; ) iw(An);
  }
  function c3() {
    for (; An !== null && !OL(); ) iw(An);
  }
  function iw(l) {
    var c = aw(l.alternate, l, er);
    l.memoizedProps = l.pendingProps, c === null ? rw(l) : An = c, Y0.current = null;
  }
  function rw(l) {
    var c = l;
    do {
      var _ = c.alternate;
      if (l = c.return, c.flags & 32768) {
        if (_ = n32(_, c), _ !== null) {
          _.flags &= 32767, An = _;
          return;
        }
        if (l !== null) l.flags |= 32768, l.subtreeFlags = 0, l.deletions = null;
        else {
          In = 6, An = null;
          return;
        }
      } else if (_ = $L(_, c, er), _ !== null) {
        An = _;
        return;
      }
      if (c = c.sibling, c !== null) {
        An = c;
        return;
      }
      An = c = l;
    } while (c !== null);
    In === 0 && (In = 5);
  }
  function xa(l, c) {
    var _ = Lt, w = yn.transition;
    try {
      yn.transition = null, Lt = 1, f3(l, c, _);
    } finally {
      yn.transition = w, Lt = _;
    }
    return null;
  }
  function f3(l, c, _) {
    do
      Sa();
    while (go !== null);
    if (Mt & 6) throw Error(o(327));
    var w = l.finishedWork, A = l.finishedLanes;
    if (w === null) return null;
    if (l.finishedWork = null, l.finishedLanes = 0, w === l.current) throw Error(o(177));
    l.callbackNode = null, l.callbackPriority = 0;
    var P = w.lanes | w.childLanes;
    if (UL(l, P), l === Tn && (An = Tn = null, Kn = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || bd || (bd = true, lw(a0, function() {
      return Sa(), null;
    })), P = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || P) {
      P = yn.transition, yn.transition = null;
      var H = Lt;
      Lt = 1;
      var Z = Mt;
      Mt |= 4, Y0.current = null, r3(l, w), s3(l, w), Y(l.containerInfo), l.current = w, o3(w), FL(), Mt = Z, Lt = H, yn.transition = P;
    } else l.current = w;
    if (bd && (bd = false, go = l, Ld = A), P = l.pendingLanes, P === 0 && (mo = null), BL(w.stateNode), Ui(l, Bn()), c !== null) for (_ = l.onRecoverableError, w = 0; w < c.length; w++) _(c[w]);
    if (Pd) throw Pd = false, l = J0, J0 = null, l;
    return Ld & 1 && l.tag !== 0 && Sa(), P = l.pendingLanes, P & 1 ? l === K0 ? kc++ : (kc = 0, K0 = l) : kc = 0, as(), null;
  }
  function Sa() {
    if (go !== null) {
      var l = O1(Ld), c = yn.transition, _ = Lt;
      try {
        if (yn.transition = null, Lt = 16 > l ? 16 : l, go === null) var w = false;
        else {
          if (l = go, go = null, Ld = 0, Mt & 6) throw Error(o(331));
          var A = Mt;
          for (Mt |= 4, Le = l.current; Le !== null; ) {
            var P = Le, H = P.child;
            if (Le.flags & 16) {
              var Z = P.deletions;
              if (Z !== null) {
                for (var fe = 0; fe < Z.length; fe++) {
                  var we = Z[fe];
                  for (Le = we; Le !== null; ) {
                    var Be = Le;
                    switch (Be.tag) {
                      case 0:
                      case 11:
                      case 15:
                        va(8, Be, P);
                    }
                    var ht = Be.child;
                    if (ht !== null) ht.return = Be, Le = ht;
                    else for (; Le !== null; ) {
                      Be = Le;
                      var et = Be.sibling, Wt = Be.return;
                      if (HM(Be), Be === we) {
                        Le = null;
                        break;
                      }
                      if (et !== null) {
                        et.return = Wt, Le = et;
                        break;
                      }
                      Le = Wt;
                    }
                  }
                }
                var Ze = P.alternate;
                if (Ze !== null) {
                  var si = Ze.child;
                  if (si !== null) {
                    Ze.child = null;
                    do {
                      var Rr = si.sibling;
                      si.sibling = null, si = Rr;
                    } while (si !== null);
                  }
                }
                Le = P;
              }
            }
            if (P.subtreeFlags & 2064 && H !== null) H.return = P, Le = H;
            else e: for (; Le !== null; ) {
              if (P = Le, P.flags & 2048) switch (P.tag) {
                case 0:
                case 11:
                case 15:
                  va(9, P, P.return);
              }
              var re = P.sibling;
              if (re !== null) {
                re.return = P.return, Le = re;
                break e;
              }
              Le = P.return;
            }
          }
          var K = l.current;
          for (Le = K; Le !== null; ) {
            H = Le;
            var ue = H.child;
            if (H.subtreeFlags & 2064 && ue !== null) ue.return = H, Le = ue;
            else e: for (H = K; Le !== null; ) {
              if (Z = Le, Z.flags & 2048) try {
                switch (Z.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Nc(9, Z);
                }
              } catch (qe) {
                Oi(Z, Z.return, qe);
              }
              if (Z === H) {
                Le = null;
                break e;
              }
              var Ne = Z.sibling;
              if (Ne !== null) {
                Ne.return = Z.return, Le = Ne;
                break e;
              }
              Le = Z.return;
            }
          }
          if (Mt = A, as(), ss && typeof ss.onPostCommitFiberRoot == "function") try {
            ss.onPostCommitFiberRoot(Zh, l);
          } catch {
          }
          w = true;
        }
        return w;
      } finally {
        Lt = _, yn.transition = c;
      }
    }
    return false;
  }
  function sw(l, c, _) {
    c = L0(_, c), c = yM(l, c, 1), po(l, c), c = Si(), l = Nd(l, 1), l !== null && (Sc(l, 1, c), Ui(l, c));
  }
  function Oi(l, c, _) {
    if (l.tag === 3) sw(l, l, _);
    else for (; c !== null; ) {
      if (c.tag === 3) {
        sw(c, l, _);
        break;
      } else if (c.tag === 1) {
        var w = c.stateNode;
        if (typeof c.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (mo === null || !mo.has(w))) {
          l = L0(_, l), l = xM(c, l, 1), po(c, l), l = Si(), c = Nd(c, 1), c !== null && (Sc(c, 1, l), Ui(c, l));
          break;
        }
      }
      c = c.return;
    }
  }
  function h3(l, c, _) {
    var w = l.pingCache;
    w !== null && w.delete(c), c = Si(), l.pingedLanes |= l.suspendedLanes & _, Tn === l && (Kn & _) === _ && (In === 4 || In === 3 && (Kn & 130023424) === Kn && 500 > Bn() - j0 ? ya(l, 0) : q0 |= _), Ui(l, c);
  }
  function ow(l, c) {
    c === 0 && (l.mode & 1 ? (c = qh, qh <<= 1, !(qh & 130023424) && (qh = 4194304)) : c = 1);
    var _ = Si();
    l = Nd(l, c), l !== null && (Sc(l, c, _), Ui(l, _));
  }
  function d3(l) {
    var c = l.memoizedState, _ = 0;
    c !== null && (_ = c.retryLane), ow(l, _);
  }
  function p3(l, c) {
    var _ = 0;
    switch (l.tag) {
      case 13:
        var w = l.stateNode, A = l.memoizedState;
        A !== null && (_ = A.retryLane);
        break;
      case 19:
        w = l.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    w !== null && w.delete(c), ow(l, _);
  }
  var aw;
  aw = function(l, c, _) {
    if (l !== null) if (l.memoizedProps !== c.pendingProps || fn.current) $i = true;
    else {
      if (!(l.lanes & _) && !(c.flags & 128)) return $i = false, t3(l, c, _);
      $i = !!(l.flags & 131072);
    }
    else $i = false, Qt && c.flags & 1048576 && q1(c, rd, c.index);
    switch (c.lanes = 0, c.tag) {
      case 2:
        var w = c.type;
        l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2), l = c.pendingProps;
        var A = xr(c, St.current);
        Pl(c, _), A = A0(null, c, w, l, A, _);
        var P = C0();
        return c.flags |= 1, typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0 ? (c.tag = 1, c.memoizedState = null, c.updateQueue = null, zn(w) ? (P = true, Jn(c)) : P = false, c.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, d0(c), A.updater = nd, c.stateNode = A, A._reactInternals = c, m0(c, w, l, _), c = N0(null, c, w, true, P, _)) : (c.tag = 0, Qt && P && g0(c), xi(null, c, A, _), c = c.child), c;
      case 16:
        w = c.elementType;
        e: {
          switch (l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2), l = c.pendingProps, A = w._init, w = A(w._payload), c.type = w, A = c.tag = g3(w), l = zr(w, l), A) {
            case 0:
              c = D0(null, c, w, l, _);
              break e;
            case 1:
              c = LM(null, c, w, l, _);
              break e;
            case 11:
              c = AM(null, c, w, l, _);
              break e;
            case 14:
              c = CM(null, c, w, zr(w.type, l), _);
              break e;
          }
          throw Error(o(306, w, ""));
        }
        return c;
      case 0:
        return w = c.type, A = c.pendingProps, A = c.elementType === w ? A : zr(w, A), D0(l, c, w, A, _);
      case 1:
        return w = c.type, A = c.pendingProps, A = c.elementType === w ? A : zr(w, A), LM(l, c, w, A, _);
      case 3:
        e: {
          if (IM(c), l === null) throw Error(o(387));
          w = c.pendingProps, P = c.memoizedState, A = P.element, B1(l, c), td(c, w, null, _);
          var H = c.memoizedState;
          if (w = H.element, xe && P.isDehydrated) if (P = { element: w, isDehydrated: false, cache: H.cache, transitions: H.transitions }, c.updateQueue.baseState = P, c.memoizedState = P, c.flags & 256) {
            A = Error(o(423)), c = DM(l, c, w, _, A);
            break e;
          } else if (w !== A) {
            A = Error(o(424)), c = DM(l, c, w, _, A);
            break e;
          } else for (xe && (Qi = Gh(c.stateNode.containerInfo), Ki = c, Qt = true, Br = null, Mc = false), _ = $1(c, null, w, _), c.child = _; _; ) _.flags = _.flags & -3 | 4096, _ = _.sibling;
          else {
            if (Il(), w === A) {
              c = Os(l, c, _);
              break e;
            }
            xi(l, c, w, _);
          }
          c = c.child;
        }
        return c;
      case 5:
        return eM(c), l === null && y0(c), w = c.type, A = c.pendingProps, P = l !== null ? l.memoizedProps : null, H = A.children, he(w, A) ? H = null : P !== null && he(w, P) && (c.flags |= 32), bM(l, c), xi(l, c, H, _), c.child;
      case 6:
        return l === null && y0(c), null;
      case 13:
        return NM(l, c, _);
      case 4:
        return S0(c, c.stateNode.containerInfo), w = c.pendingProps, l === null ? c.child = Dl(c, null, w, _) : xi(l, c, w, _), c.child;
      case 11:
        return w = c.type, A = c.pendingProps, A = c.elementType === w ? A : zr(w, A), AM(l, c, w, A, _);
      case 7:
        return xi(l, c, c.pendingProps, _), c.child;
      case 8:
        return xi(l, c, c.pendingProps.children, _), c.child;
      case 12:
        return xi(l, c, c.pendingProps.children, _), c.child;
      case 10:
        e: {
          if (w = c.type._context, A = c.pendingProps, P = c.memoizedProps, H = A.value, z1(c, w, H), P !== null) if (os(P.value, H)) {
            if (P.children === A.children && !fn.current) {
              c = Os(l, c, _);
              break e;
            }
          } else for (P = c.child, P !== null && (P.return = c); P !== null; ) {
            var Z = P.dependencies;
            if (Z !== null) {
              H = P.child;
              for (var fe = Z.firstContext; fe !== null; ) {
                if (fe.context === w) {
                  if (P.tag === 1) {
                    fe = Is(-1, _ & -_), fe.tag = 2;
                    var we = P.updateQueue;
                    if (we !== null) {
                      we = we.shared;
                      var Be = we.pending;
                      Be === null ? fe.next = fe : (fe.next = Be.next, Be.next = fe), we.pending = fe;
                    }
                  }
                  P.lanes |= _, fe = P.alternate, fe !== null && (fe.lanes |= _), h0(P.return, _, c), Z.lanes |= _;
                  break;
                }
                fe = fe.next;
              }
            } else if (P.tag === 10) H = P.type === c.type ? null : P.child;
            else if (P.tag === 18) {
              if (H = P.return, H === null) throw Error(o(341));
              H.lanes |= _, Z = H.alternate, Z !== null && (Z.lanes |= _), h0(H, _, c), H = P.sibling;
            } else H = P.child;
            if (H !== null) H.return = P;
            else for (H = P; H !== null; ) {
              if (H === c) {
                H = null;
                break;
              }
              if (P = H.sibling, P !== null) {
                P.return = H.return, H = P;
                break;
              }
              H = H.return;
            }
            P = H;
          }
          xi(l, c, A.children, _), c = c.child;
        }
        return c;
      case 9:
        return A = c.type, w = c.pendingProps.children, Pl(c, _), A = Sr(A), w = w(A), c.flags |= 1, xi(l, c, w, _), c.child;
      case 14:
        return w = c.type, A = zr(w, c.pendingProps), A = zr(w.type, A), CM(l, c, w, A, _);
      case 15:
        return RM(l, c, c.type, c.pendingProps, _);
      case 17:
        return w = c.type, A = c.pendingProps, A = c.elementType === w ? A : zr(w, A), l !== null && (l.alternate = null, c.alternate = null, c.flags |= 2), c.tag = 1, zn(w) ? (l = true, Jn(c)) : l = false, Pl(c, _), X1(c, w, A), m0(c, w, A, _), N0(null, c, w, true, l, _);
      case 19:
        return kM(l, c, _);
      case 22:
        return PM(l, c, _);
    }
    throw Error(o(156, c.tag));
  };
  function lw(l, c) {
    return s0(l, c);
  }
  function m3(l, c, _, w) {
    this.tag = l, this.key = _, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Cr(l, c, _, w) {
    return new m3(l, c, _, w);
  }
  function n_(l) {
    return l = l.prototype, !(!l || !l.isReactComponent);
  }
  function g3(l) {
    if (typeof l == "function") return n_(l) ? 1 : 0;
    if (l != null) {
      if (l = l.$$typeof, l === M) return 11;
      if (l === E) return 14;
    }
    return 2;
  }
  function yo(l, c) {
    var _ = l.alternate;
    return _ === null ? (_ = Cr(l.tag, c, l.key, l.mode), _.elementType = l.elementType, _.type = l.type, _.stateNode = l.stateNode, _.alternate = l, l.alternate = _) : (_.pendingProps = c, _.type = l.type, _.flags = 0, _.subtreeFlags = 0, _.deletions = null), _.flags = l.flags & 14680064, _.childLanes = l.childLanes, _.lanes = l.lanes, _.child = l.child, _.memoizedProps = l.memoizedProps, _.memoizedState = l.memoizedState, _.updateQueue = l.updateQueue, c = l.dependencies, _.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }, _.sibling = l.sibling, _.index = l.index, _.ref = l.ref, _;
  }
  function Od(l, c, _, w, A, P) {
    var H = 2;
    if (w = l, typeof l == "function") n_(l) && (H = 1);
    else if (typeof l == "string") H = 5;
    else e: switch (l) {
      case h:
        return Ma(_.children, A, P, c);
      case d:
        H = 8, A |= 8;
        break;
      case p:
        return l = Cr(12, _, c, A | 2), l.elementType = p, l.lanes = P, l;
      case S:
        return l = Cr(13, _, c, A), l.elementType = S, l.lanes = P, l;
      case m:
        return l = Cr(19, _, c, A), l.elementType = m, l.lanes = P, l;
      case C:
        return Fd(_, A, P, c);
      default:
        if (typeof l == "object" && l !== null) switch (l.$$typeof) {
          case g:
            H = 10;
            break e;
          case v:
            H = 9;
            break e;
          case M:
            H = 11;
            break e;
          case E:
            H = 14;
            break e;
          case T:
            H = 16, w = null;
            break e;
        }
        throw Error(o(130, l == null ? l : typeof l, ""));
    }
    return c = Cr(H, _, c, A), c.elementType = l, c.type = w, c.lanes = P, c;
  }
  function Ma(l, c, _, w) {
    return l = Cr(7, l, w, c), l.lanes = _, l;
  }
  function Fd(l, c, _, w) {
    return l = Cr(22, l, w, c), l.elementType = C, l.lanes = _, l.stateNode = {}, l;
  }
  function i_(l, c, _) {
    return l = Cr(6, l, null, c), l.lanes = _, l;
  }
  function r_(l, c, _) {
    return c = Cr(4, l.children !== null ? l.children : [], l.key, c), c.lanes = _, c.stateNode = { containerInfo: l.containerInfo, pendingChildren: null, implementation: l.implementation }, c;
  }
  function _3(l, c, _, w, A) {
    this.tag = c, this.containerInfo = l, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Ve, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = i0(0), this.expirationTimes = i0(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = i0(0), this.identifierPrefix = w, this.onRecoverableError = A, xe && (this.mutableSourceEagerHydrationData = null);
  }
  function uw(l, c, _, w, A, P, H, Z, fe) {
    return l = new _3(l, c, _, Z, fe), c === 1 ? (c = 1, P === true && (c |= 8)) : c = 0, P = Cr(3, null, null, c), l.current = P, P.stateNode = l, P.memoizedState = { element: w, isDehydrated: _, cache: null, transitions: null }, d0(P), l;
  }
  function cw(l) {
    if (!l) return yr;
    l = l._reactInternals;
    e: {
      if (B(l) !== l || l.tag !== 1) throw Error(o(170));
      var c = l;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (zn(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(o(171));
    }
    if (l.tag === 1) {
      var _ = l.type;
      if (zn(_)) return Al(l, _, c);
    }
    return c;
  }
  function fw(l) {
    var c = l._reactInternals;
    if (c === void 0) throw typeof l.render == "function" ? Error(o(188)) : (l = Object.keys(l).join(","), Error(o(268, l)));
    return l = j(c), l === null ? null : l.stateNode;
  }
  function hw(l, c) {
    if (l = l.memoizedState, l !== null && l.dehydrated !== null) {
      var _ = l.retryLane;
      l.retryLane = _ !== 0 && _ < c ? _ : c;
    }
  }
  function s_(l, c) {
    hw(l, c), (l = l.alternate) && hw(l, c);
  }
  function v3(l) {
    return l = j(l), l === null ? null : l.stateNode;
  }
  function y3() {
    return null;
  }
  return t.attemptContinuousHydration = function(l) {
    if (l.tag === 13) {
      var c = Si();
      Ar(l, 134217728, c), s_(l, 134217728);
    }
  }, t.attemptHydrationAtCurrentPriority = function(l) {
    if (l.tag === 13) {
      var c = Si(), _ = _o(l);
      Ar(l, _, c), s_(l, _);
    }
  }, t.attemptSynchronousHydration = function(l) {
    switch (l.tag) {
      case 3:
        var c = l.stateNode;
        if (c.current.memoizedState.isDehydrated) {
          var _ = xc(c.pendingLanes);
          _ !== 0 && (r0(c, _ | 1), Ui(c, Bn()), !(Mt & 6) && (zl(), as()));
        }
        break;
      case 13:
        var w = Si();
        ew(function() {
          return Ar(l, 1, w);
        }), s_(l, 1);
    }
  }, t.batchedUpdates = function(l, c) {
    var _ = Mt;
    Mt |= 1;
    try {
      return l(c);
    } finally {
      Mt = _, Mt === 0 && (zl(), Jh && as());
    }
  }, t.createComponentSelector = function(l) {
    return { $$typeof: Md, value: l };
  }, t.createContainer = function(l, c, _, w, A, P, H) {
    return uw(l, c, false, null, _, w, A, P, H);
  }, t.createHasPseudoClassSelector = function(l) {
    return { $$typeof: wd, value: l };
  }, t.createHydrationContainer = function(l, c, _, w, A, P, H, Z, fe) {
    return l = uw(_, w, true, l, A, P, H, Z, fe), l.context = cw(null), _ = l.current, w = Si(), A = _o(_), P = Is(w, A), P.callback = c ?? null, po(_, P), l.current.lanes = A, Sc(l, A, w), Ui(l, w), l;
  }, t.createPortal = function(l, c, _) {
    var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: f, key: w == null ? null : "" + w, children: l, containerInfo: c, implementation: _ };
  }, t.createRoleSelector = function(l) {
    return { $$typeof: Ed, value: l };
  }, t.createTestNameSelector = function(l) {
    return { $$typeof: Td, value: l };
  }, t.createTextSelector = function(l) {
    return { $$typeof: Ad, value: l };
  }, t.deferredUpdates = function(l) {
    var c = Lt, _ = yn.transition;
    try {
      return yn.transition = null, Lt = 16, l();
    } finally {
      Lt = c, yn.transition = _;
    }
  }, t.discreteUpdates = function(l, c, _, w, A) {
    var P = Lt, H = yn.transition;
    try {
      return yn.transition = null, Lt = 1, l(c, _, w, A);
    } finally {
      Lt = P, yn.transition = H, Mt === 0 && zl();
    }
  }, t.findAllNodes = X0, t.findBoundingRects = function(l, c) {
    if (!N) throw Error(o(363));
    c = X0(l, c), l = [];
    for (var _ = 0; _ < c.length; _++) l.push(ye(c[_]));
    for (c = l.length - 1; 0 < c; c--) {
      _ = l[c];
      for (var w = _.x, A = w + _.width, P = _.y, H = P + _.height, Z = c - 1; 0 <= Z; Z--) if (c !== Z) {
        var fe = l[Z], we = fe.x, Be = we + fe.width, ht = fe.y, et = ht + fe.height;
        if (w >= we && P >= ht && A <= Be && H <= et) {
          l.splice(c, 1);
          break;
        } else if (w !== we || _.width !== fe.width || et < P || ht > H) {
          if (!(P !== ht || _.height !== fe.height || Be < w || we > A)) {
            we > w && (fe.width += we - w, fe.x = w), Be < A && (fe.width = A - we), l.splice(c, 1);
            break;
          }
        } else {
          ht > P && (fe.height += ht - P, fe.y = P), et < H && (fe.height = H - ht), l.splice(c, 1);
          break;
        }
      }
    }
    return l;
  }, t.findHostInstance = fw, t.findHostInstanceWithNoPortals = function(l) {
    return l = D(l), l = l !== null ? X(l) : null, l === null ? null : l.stateNode;
  }, t.findHostInstanceWithWarning = function(l) {
    return fw(l);
  }, t.flushControlled = function(l) {
    var c = Mt;
    Mt |= 1;
    var _ = yn.transition, w = Lt;
    try {
      yn.transition = null, Lt = 1, l();
    } finally {
      Lt = w, yn.transition = _, Mt = c, Mt === 0 && (zl(), as());
    }
  }, t.flushPassiveEffects = Sa, t.flushSync = ew, t.focusWithin = function(l, c) {
    if (!N) throw Error(o(363));
    for (l = H0(l), c = KM(l, c), c = Array.from(c), l = 0; l < c.length; ) {
      var _ = c[l++];
      if (!ge(_)) {
        if (_.tag === 5 && Pe(_.stateNode)) return true;
        for (_ = _.child; _ !== null; ) c.push(_), _ = _.sibling;
      }
    }
    return false;
  }, t.getCurrentUpdatePriority = function() {
    return Lt;
  }, t.getFindAllNodesFailureDescription = function(l, c) {
    if (!N) throw Error(o(363));
    var _ = 0, w = [];
    l = [H0(l), 0];
    for (var A = 0; A < l.length; ) {
      var P = l[A++], H = l[A++], Z = c[H];
      if ((P.tag !== 5 || !ge(P)) && (G0(P, Z) && (w.push(W0(Z)), H++, H > _ && (_ = H)), H < c.length)) for (P = P.child; P !== null; ) l.push(P, H), P = P.sibling;
    }
    if (_ < c.length) {
      for (l = []; _ < c.length; _++) l.push(W0(c[_]));
      return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + l.join(" > ");
    }
    return null;
  }, t.getPublicRootInstance = function(l) {
    if (l = l.current, !l.child) return null;
    switch (l.child.tag) {
      case 5:
        return J(l.child.stateNode);
      default:
        return l.child.stateNode;
    }
  }, t.injectIntoDevTools = function(l) {
    if (l = { bundleType: l.bundleType, version: l.version, rendererPackageName: l.rendererPackageName, rendererConfig: l.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: v3, findFiberByHostInstance: l.findFiberByHostInstance || y3, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") l = false;
    else {
      var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (c.isDisabled || !c.supportsFiber) l = true;
      else {
        try {
          Zh = c.inject(l), ss = c;
        } catch {
        }
        l = !!c.checkDCE;
      }
    }
    return l;
  }, t.isAlreadyRendering = function() {
    return false;
  }, t.observeVisibleRects = function(l, c, _, w) {
    if (!N) throw Error(o(363));
    l = X0(l, c);
    var A = Fe(l, _, w).disconnect;
    return { disconnect: function() {
      A();
    } };
  }, t.registerMutableSourceForHydration = function(l, c) {
    var _ = c._getVersion;
    _ = _(c._source), l.mutableSourceEagerHydrationData == null ? l.mutableSourceEagerHydrationData = [c, _] : l.mutableSourceEagerHydrationData.push(c, _);
  }, t.runWithPriority = function(l, c) {
    var _ = Lt;
    try {
      return Lt = l, c();
    } finally {
      Lt = _;
    }
  }, t.shouldError = function() {
    return null;
  }, t.shouldSuspend = function() {
    return false;
  }, t.updateContainer = function(l, c, _, w) {
    var A = c.current, P = Si(), H = _o(A);
    return _ = cw(_), c.context === null ? c.context = _ : c.pendingContext = _, c = Is(P, H), c.payload = { element: l }, w = w === void 0 ? null : w, w !== null && (c.callback = w), po(A, c), l = Ar(A, H, P), l !== null && ed(l, A, H), H;
  }, t;
};
ab.exports = q4;
var j4 = ab.exports;
const Z4 = Nx(j4), _1 = {}, J4 = (n18) => void Object.assign(_1, n18);
function K4(n18, e) {
  function t(h, { args: d = [], attach: p, ...g }, v) {
    let M = `${h[0].toUpperCase()}${h.slice(1)}`, S;
    if (h === "primitive") {
      if (g.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const m = g.object;
      S = fu(m, { type: h, root: v, attach: p, primitive: true });
    } else {
      const m = _1[M];
      if (!m) throw new Error(`R3F: ${M} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!");
      S = fu(new m(...d), { type: h, root: v, attach: p, memoizedProps: { args: d } });
    }
    return S.__r3f.attach === void 0 && (S.isBufferGeometry ? S.__r3f.attach = "geometry" : S.isMaterial && (S.__r3f.attach = "material")), M !== "inject" && _v(S, g), S;
  }
  function i(h, d) {
    let p = false;
    if (d) {
      var g, v;
      (g = d.__r3f) != null && g.attach ? gv(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d), p = true), p || (v = h.__r3f) == null || v.objects.push(d), d.__r3f || fu(d, {}), d.__r3f.parent = h, _x(d), hu(d);
    }
  }
  function r(h, d, p) {
    let g = false;
    if (d) {
      var v, M;
      if ((v = d.__r3f) != null && v.attach) gv(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        d.parent = h, d.dispatchEvent({ type: "added" }), h.dispatchEvent({ type: "childadded", child: d });
        const S = h.children.filter((E) => E !== d), m = S.indexOf(p);
        h.children = [...S.slice(0, m), d, ...S.slice(m)], g = true;
      }
      g || (M = h.__r3f) == null || M.objects.push(d), d.__r3f || fu(d, {}), d.__r3f.parent = h, _x(d), hu(d);
    }
  }
  function s(h, d, p = false) {
    h && [...h].forEach((g) => o(d, g, p));
  }
  function o(h, d, p) {
    if (d) {
      var g, v, M;
      if (d.__r3f && (d.__r3f.parent = null), (g = h.__r3f) != null && g.objects && (h.__r3f.objects = h.__r3f.objects.filter((C) => C !== d)), (v = d.__r3f) != null && v.attach) rA(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var S;
        h.remove(d), (S = d.__r3f) != null && S.root && r5(mm(d), d);
      }
      const E = (M = d.__r3f) == null ? void 0 : M.primitive, T = !E && (p === void 0 ? d.dispose !== null : p);
      if (!E) {
        var m;
        s((m = d.__r3f) == null ? void 0 : m.objects, d, T), s(d.children, d, T);
      }
      if (delete d.__r3f, T && d.dispose && d.type !== "Scene") {
        const C = () => {
          try {
            d.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? mx.unstable_scheduleCallback(mx.unstable_IdlePriority, C) : C();
      }
      hu(h);
    }
  }
  function a(h, d, p, g) {
    var v;
    const M = (v = h.__r3f) == null ? void 0 : v.parent;
    if (!M) return;
    const S = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const m of h.children) m.__r3f && i(S, m);
      h.children = h.children.filter((m) => !m.__r3f);
    }
    h.__r3f.objects.forEach((m) => i(S, m)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || o(M, h), S.parent && (S.__r3f.autoRemovedBeforeAppend = true), i(M, S), S.raycast && S.__r3f.eventCount && mm(S).getState().internal.interaction.push(S), [g, g.alternate].forEach((m) => {
      m !== null && (m.stateNode = S, m.ref && (typeof m.ref == "function" ? m.ref(S) : m.ref.current = S));
    });
  }
  const u = () => {
  };
  return { reconciler: Z4({ createInstance: t, removeChild: o, appendChild: i, appendInitialChild: i, insertBefore: r, supportsMutation: true, isPrimaryRenderer: false, supportsPersistence: false, supportsHydration: false, noTimeout: -1, appendChildToContainer: (h, d) => {
    if (!d) return;
    const p = h.getState().scene;
    p.__r3f && (p.__r3f.root = h, i(p, d));
  }, removeChildFromContainer: (h, d) => {
    d && o(h.getState().scene, d);
  }, insertInContainerBefore: (h, d, p) => {
    if (!d || !p) return;
    const g = h.getState().scene;
    g.__r3f && r(g, d, p);
  }, getRootHostContext: () => null, getChildHostContext: (h) => h, finalizeInitialChildren(h) {
    var d;
    return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
  }, prepareUpdate(h, d, p, g) {
    var v;
    if (((v = h == null ? void 0 : h.__r3f) != null ? v : {}).primitive && g.object && g.object !== h) return [true];
    {
      const { args: S = [], children: m, ...E } = g, { args: T = [], children: C, ...L } = p;
      if (!Array.isArray(S)) throw new Error("R3F: the args prop must be an array!");
      if (S.some((I, U) => I !== T[U])) return [true];
      const b = gb(h, E, L, true);
      return b.changes.length ? [false, b] : null;
    }
  }, commitUpdate(h, [d, p], g, v, M, S) {
    d ? a(h, g, M, S) : _v(h, p);
  }, commitMount(h, d, p, g) {
    var v;
    const M = (v = h.__r3f) != null ? v : {};
    h.raycast && M.handlers && M.eventCount && mm(h).getState().internal.interaction.push(h);
  }, getPublicInstance: (h) => h, prepareForCommit: () => null, preparePortalMount: (h) => fu(h.getState().scene), resetAfterCommit: () => {
  }, shouldSetTextContent: () => false, clearContainer: () => false, hideInstance(h) {
    var d;
    const { attach: p, parent: g } = (d = h.__r3f) != null ? d : {};
    p && g && rA(g, h, p), h.isObject3D && (h.visible = false), hu(h);
  }, unhideInstance(h, d) {
    var p;
    const { attach: g, parent: v } = (p = h.__r3f) != null ? p : {};
    g && v && gv(v, h, g), (h.isObject3D && d.visible == null || d.visible) && (h.visible = true), hu(h);
  }, createTextInstance: u, hideTextInstance: u, unhideTextInstance: u, getCurrentEventPriority: () => e ? e() : bu.DefaultEventPriority, beforeActiveInstanceBlur: () => {
  }, afterActiveInstanceBlur: () => {
  }, detachDeletedInstance: () => {
  }, now: typeof performance < "u" && Jt.fun(performance.now) ? performance.now : Jt.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: Jt.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: Jt.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: _v };
}
var eA, tA;
const mv = (n18) => "colorSpace" in n18 || "outputColorSpace" in n18, cb = () => {
  var n18;
  return (n18 = _1.ColorManagement) != null ? n18 : null;
}, fb = (n18) => n18 && n18.isOrthographicCamera, Q4 = (n18) => n18 && n18.hasOwnProperty("current"), Vh = typeof window < "u" && ((eA = window.document) != null && eA.createElement || ((tA = window.navigator) == null ? void 0 : tA.product) === "ReactNative") ? be.useLayoutEffect : be.useEffect;
function hb(n18) {
  const e = be.useRef(n18);
  return Vh(() => void (e.current = n18), [n18]), e;
}
function $4({ set: n18 }) {
  return Vh(() => (n18(new Promise(() => null)), () => n18(false)), [n18]), null;
}
class db extends be.Component {
  constructor(...e) {
    super(...e), this.state = { error: false };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
db.getDerivedStateFromError = () => ({ error: true });
const pb = "__default", nA = /* @__PURE__ */ new Map(), e5 = (n18) => n18 && !!n18.memoized && !!n18.changes;
function mb(n18) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n18) ? Math.min(Math.max(n18[0], t), n18[1]) : n18;
}
const sf = (n18) => {
  var e;
  return (e = n18.__r3f) == null ? void 0 : e.root.getState();
};
function mm(n18) {
  let e = n18.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const Jt = { obj: (n18) => n18 === Object(n18) && !Jt.arr(n18) && typeof n18 != "function", fun: (n18) => typeof n18 == "function", str: (n18) => typeof n18 == "string", num: (n18) => typeof n18 == "number", boo: (n18) => typeof n18 == "boolean", und: (n18) => n18 === void 0, arr: (n18) => Array.isArray(n18), equ(n18, e, { arrays: t = "shallow", objects: i = "reference", strict: r = true } = {}) {
  if (typeof n18 != typeof e || !!n18 != !!e) return false;
  if (Jt.str(n18) || Jt.num(n18) || Jt.boo(n18)) return n18 === e;
  const s = Jt.obj(n18);
  if (s && i === "reference") return n18 === e;
  const o = Jt.arr(n18);
  if (o && t === "reference") return n18 === e;
  if ((o || s) && n18 === e) return true;
  let a;
  for (a in n18) if (!(a in e)) return false;
  if (s && t === "shallow" && i === "shallow") {
    for (a in r ? e : n18) if (!Jt.equ(n18[a], e[a], { strict: r, objects: "reference" })) return false;
  } else for (a in r ? e : n18) if (n18[a] !== e[a]) return false;
  if (Jt.und(a)) {
    if (o && n18.length === 0 && e.length === 0 || s && Object.keys(n18).length === 0 && Object.keys(e).length === 0) return true;
    if (n18 !== e) return false;
  }
  return true;
} };
function t5(n18) {
  n18.dispose && n18.type !== "Scene" && n18.dispose();
  for (const e in n18) e.dispose == null || e.dispose(), delete n18[e];
}
function fu(n18, e) {
  const t = n18;
  return t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, n18;
}
function gx(n18, e) {
  let t = n18;
  if (e.includes("-")) {
    const i = e.split("-"), r = i.pop();
    return t = i.reduce((s, o) => s[o], n18), { target: t, key: r };
  } else return { target: t, key: e };
}
const iA = /-\d+$/;
function gv(n18, e, t) {
  if (Jt.str(t)) {
    if (iA.test(t)) {
      const s = t.replace(iA, ""), { target: o, key: a } = gx(n18, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = gx(n18, t);
    e.__r3f.previousAttach = i[r], i[r] = e;
  } else e.__r3f.previousAttach = t(n18, e);
}
function rA(n18, e, t) {
  var i, r;
  if (Jt.str(t)) {
    const { target: s, key: o } = gx(n18, t), a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : s[o] = a;
  } else (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n18, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function gb(n18, { children: e, key: t, ref: i, ...r }, { children: s, key: o, ref: a, ...u } = {}, f = false) {
  const h = n18.__r3f, d = Object.entries(r), p = [];
  if (f) {
    const v = Object.keys(u);
    for (let M = 0; M < v.length; M++) r.hasOwnProperty(v[M]) || d.unshift([v[M], pb + "remove"]);
  }
  d.forEach(([v, M]) => {
    var S;
    if ((S = n18.__r3f) != null && S.primitive && v === "object" || Jt.equ(M, u[v])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v)) return p.push([v, M, true, []]);
    let m = [];
    v.includes("-") && (m = v.split("-")), p.push([v, M, false, m]);
    for (const E in r) {
      const T = r[E];
      E.startsWith(`${v}-`) && p.push([E, T, false, E.split("-")]);
    }
  });
  const g = { ...r };
  return h != null && h.memoizedProps && h != null && h.memoizedProps.args && (g.args = h.memoizedProps.args), h != null && h.memoizedProps && h != null && h.memoizedProps.attach && (g.attach = h.memoizedProps.attach), { memoized: g, changes: p };
}
function _v(n18, e) {
  var t;
  const i = n18.__r3f, r = i == null ? void 0 : i.root, s = r == null || r.getState == null ? void 0 : r.getState(), { memoized: o, changes: a } = e5(e) ? e : gb(n18, e), u = i == null ? void 0 : i.eventCount;
  n18.__r3f && (n18.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [g, v, M, S] = a[p];
    if (mv(n18)) {
      const C = "srgb", L = "srgb-linear";
      g === "encoding" ? (g = "colorSpace", v = v === 3001 ? C : L) : g === "outputEncoding" && (g = "outputColorSpace", v = v === 3001 ? C : L);
    }
    let m = n18, E = m[g];
    if (S.length && (E = S.reduce((T, C) => T[C], n18), !(E && E.set))) {
      const [T, ...C] = S.reverse();
      m = C.reverse().reduce((L, b) => L[b], n18), g = T;
    }
    if (v === pb + "remove") if (m.constructor) {
      let T = nA.get(m.constructor);
      T || (T = new m.constructor(), nA.set(m.constructor, T)), v = T[g];
    } else v = 0;
    if (M && i) v ? i.handlers[g] = v : delete i.handlers[g], i.eventCount = Object.keys(i.handlers).length;
    else if (E && E.set && (E.copy || E instanceof tl)) {
      if (Array.isArray(v)) E.fromArray ? E.fromArray(v) : E.set(...v);
      else if (E.copy && v && v.constructor && E.constructor === v.constructor) E.copy(v);
      else if (v !== void 0) {
        var f;
        const T = (f = E) == null ? void 0 : f.isColor;
        !T && E.setScalar ? E.setScalar(v) : E instanceof tl && v instanceof tl ? E.mask = v.mask : E.set(v), !cb() && s && !s.linear && T && E.convertSRGBToLinear();
      }
    } else {
      var h;
      if (m[g] = v, (h = m[g]) != null && h.isTexture && m[g].format === Ti && m[g].type === Es && s) {
        const T = m[g];
        mv(T) && mv(s.gl) ? T.colorSpace = s.gl.outputColorSpace : T.encoding = s.gl.outputEncoding;
      }
    }
    hu(n18);
  }
  if (i && i.parent && n18.raycast && u !== i.eventCount) {
    const p = mm(n18).getState().internal, g = p.interaction.indexOf(n18);
    g > -1 && p.interaction.splice(g, 1), i.eventCount && p.interaction.push(n18);
  }
  return !(a.length === 1 && a[0][0] === "onUpdate") && a.length && (t = n18.__r3f) != null && t.parent && _x(n18), n18;
}
function hu(n18) {
  var e, t;
  const i = (e = n18.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function _x(n18) {
  n18.onUpdate == null || n18.onUpdate(n18);
}
function n5(n18, e) {
  n18.manual || (fb(n18) ? (n18.left = e.width / -2, n18.right = e.width / 2, n18.top = e.height / 2, n18.bottom = e.height / -2) : n18.aspect = e.width / e.height, n18.updateProjectionMatrix(), n18.updateMatrixWorld());
}
function Yp(n18) {
  return (n18.eventObject || n18.object).uuid + "/" + n18.index + n18.instanceId;
}
function i5() {
  var n18;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return bu.DefaultEventPriority;
  switch ((n18 = e.event) == null ? void 0 : n18.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return bu.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return bu.ContinuousEventPriority;
    default:
      return bu.DefaultEventPriority;
  }
}
function _b(n18, e, t, i) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (n18.delete(i), r.target.releasePointerCapture(i)));
}
function r5(n18, e) {
  const { internal: t } = n18.getState();
  t.interaction = t.interaction.filter((i) => i !== e), t.initialHits = t.initialHits.filter((i) => i !== e), t.hovered.forEach((i, r) => {
    (i.eventObject === e || i.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((i, r) => {
    _b(t.capturedMap, e, i, r);
  });
}
function s5(n18) {
  function e(u) {
    const { internal: f } = n18.getState(), h = u.offsetX - f.initialClick[0], d = u.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(u) {
    return u.filter((f) => ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
      var d;
      return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
    }));
  }
  function i(u, f) {
    const h = n18.getState(), d = /* @__PURE__ */ new Set(), p = [], g = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let m = 0; m < g.length; m++) {
      const E = sf(g[m]);
      E && (E.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(u, h);
    function v(m) {
      const E = sf(m);
      if (!E || !E.events.enabled || E.raycaster.camera === null) return [];
      if (E.raycaster.camera === void 0) {
        var T;
        E.events.compute == null || E.events.compute(u, E, (T = E.previousRoot) == null ? void 0 : T.getState()), E.raycaster.camera === void 0 && (E.raycaster.camera = null);
      }
      return E.raycaster.camera ? E.raycaster.intersectObject(m, true) : [];
    }
    let M = g.flatMap(v).sort((m, E) => {
      const T = sf(m.object), C = sf(E.object);
      return !T || !C ? m.distance - E.distance : C.events.priority - T.events.priority || m.distance - E.distance;
    }).filter((m) => {
      const E = Yp(m);
      return d.has(E) ? false : (d.add(E), true);
    });
    h.events.filter && (M = h.events.filter(M, h));
    for (const m of M) {
      let E = m.object;
      for (; E; ) {
        var S;
        (S = E.__r3f) != null && S.eventCount && p.push({ ...m, eventObject: E }), E = E.parent;
      }
    }
    if ("pointerId" in u && h.internal.capturedMap.has(u.pointerId)) for (let m of h.internal.capturedMap.get(u.pointerId).values()) d.has(Yp(m.intersection)) || p.push(m.intersection);
    return p;
  }
  function r(u, f, h, d) {
    const p = n18.getState();
    if (u.length) {
      const g = { stopped: false };
      for (const v of u) {
        const M = sf(v.object) || p, { raycaster: S, pointer: m, camera: E, internal: T } = M, C = new k(m.x, m.y, 0).unproject(E), L = (R) => {
          var D, j;
          return (D = (j = T.capturedMap.get(R)) == null ? void 0 : j.has(v.eventObject)) != null ? D : false;
        }, b = (R) => {
          const D = { intersection: v, target: f.target };
          T.capturedMap.has(R) ? T.capturedMap.get(R).set(v.eventObject, D) : T.capturedMap.set(R, /* @__PURE__ */ new Map([[v.eventObject, D]])), f.target.setPointerCapture(R);
        }, I = (R) => {
          const D = T.capturedMap.get(R);
          D && _b(T.capturedMap, v.eventObject, D, R);
        };
        let U = {};
        for (let R in f) {
          let D = f[R];
          typeof D != "function" && (U[R] = D);
        }
        let B = { ...v, ...U, pointer: m, intersections: u, stopped: g.stopped, delta: h, unprojectedPoint: C, ray: S.ray, camera: E, stopPropagation() {
          const R = "pointerId" in f && T.capturedMap.get(f.pointerId);
          if ((!R || R.has(v.eventObject)) && (B.stopped = g.stopped = true, T.hovered.size && Array.from(T.hovered.values()).find((D) => D.eventObject === v.eventObject))) {
            const D = u.slice(0, u.indexOf(v));
            s([...D, v]);
          }
        }, target: { hasPointerCapture: L, setPointerCapture: b, releasePointerCapture: I }, currentTarget: { hasPointerCapture: L, setPointerCapture: b, releasePointerCapture: I }, nativeEvent: f };
        if (d(B), g.stopped === true) break;
      }
    }
    return u;
  }
  function s(u) {
    const { internal: f } = n18.getState();
    for (const h of f.hovered.values()) if (!u.length || !u.find((d) => d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
      const p = h.eventObject.__r3f, g = p == null ? void 0 : p.handlers;
      if (f.hovered.delete(Yp(h)), p != null && p.eventCount) {
        const v = { ...h, intersections: u };
        g.onPointerOut == null || g.onPointerOut(v), g.onPointerLeave == null || g.onPointerLeave(v);
      }
    }
  }
  function o(u, f) {
    for (let h = 0; h < f.length; h++) {
      const d = f[h].__r3f;
      d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(u);
    }
  }
  function a(u) {
    switch (u) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: h } = n18.getState();
          "pointerId" in f && h.capturedMap.has(f.pointerId) && requestAnimationFrame(() => {
            h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId), s([]));
          });
        };
    }
    return function(h) {
      const { onPointerMissed: d, internal: p } = n18.getState();
      p.lastEvent.current = h;
      const g = u === "onPointerMove", v = u === "onClick" || u === "onContextMenu" || u === "onDoubleClick", S = i(h, g ? t : void 0), m = v ? e(h) : 0;
      u === "onPointerDown" && (p.initialClick = [h.offsetX, h.offsetY], p.initialHits = S.map((T) => T.eventObject)), v && !S.length && m <= 2 && (o(h, p.interaction), d && d(h)), g && s(S);
      function E(T) {
        const C = T.eventObject, L = C.__r3f, b = L == null ? void 0 : L.handlers;
        if (L != null && L.eventCount) if (g) {
          if (b.onPointerOver || b.onPointerEnter || b.onPointerOut || b.onPointerLeave) {
            const I = Yp(T), U = p.hovered.get(I);
            U ? U.stopped && T.stopPropagation() : (p.hovered.set(I, T), b.onPointerOver == null || b.onPointerOver(T), b.onPointerEnter == null || b.onPointerEnter(T));
          }
          b.onPointerMove == null || b.onPointerMove(T);
        } else {
          const I = b[u];
          I ? (!v || p.initialHits.includes(C)) && (o(h, p.interaction.filter((U) => !p.initialHits.includes(U))), I(T)) : v && p.initialHits.includes(C) && o(h, p.interaction.filter((U) => !p.initialHits.includes(U)));
        }
      }
      r(S, h, m, E);
    };
  }
  return { handlePointer: a };
}
const vb = (n18) => !!(n18 != null && n18.render), yb = be.createContext(null), o5 = (n18, e) => {
  const t = Y4((a, u) => {
    const f = new k(), h = new k(), d = new k();
    function p(m = u().camera, E = h, T = u().size) {
      const { width: C, height: L, top: b, left: I } = T, U = C / L;
      E.isVector3 ? d.copy(E) : d.set(...E);
      const B = m.getWorldPosition(f).distanceTo(d);
      if (fb(m)) return { width: C / m.zoom, height: L / m.zoom, top: b, left: I, factor: 1, distance: B, aspect: U };
      {
        const R = m.fov * Math.PI / 180, D = 2 * Math.tan(R / 2) * B, j = D * (C / L);
        return { width: j, height: D, top: b, left: I, factor: C / j, distance: B, aspect: U };
      }
    }
    let g;
    const v = (m) => a((E) => ({ performance: { ...E.performance, current: m } })), M = new me();
    return { set: a, get: u, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: true, connected: false }, xr: null, scene: null, invalidate: (m = 1) => n18(u(), m), advance: (m, E) => e(m, E, u()), legacy: false, linear: false, flat: false, controls: null, clock: new d1(), pointer: M, mouse: M, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: 0.5, max: 1, debounce: 200, regress: () => {
      const m = u();
      g && clearTimeout(g), m.performance.current !== m.performance.min && v(m.performance.min), g = setTimeout(() => v(u().performance.max), m.performance.debounce);
    } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: false }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: (m) => a((E) => ({ ...E, events: { ...E.events, ...m } })), setSize: (m, E, T, C, L) => {
      const b = u().camera, I = { width: m, height: E, top: C || 0, left: L || 0, updateStyle: T };
      a((U) => ({ size: I, viewport: { ...U.viewport, ...p(b, h, I) } }));
    }, setDpr: (m) => a((E) => {
      const T = mb(m);
      return { viewport: { ...E.viewport, dpr: T, initialDpr: E.viewport.initialDpr || T } };
    }), setFrameloop: (m = "always") => {
      const E = u().clock;
      E.stop(), E.elapsedTime = 0, m !== "never" && (E.start(), E.elapsedTime = 0), a(() => ({ frameloop: m }));
    }, previousRoot: void 0, internal: { active: false, priority: 0, frames: 0, lastEvent: be.createRef(), interaction: [], hovered: /* @__PURE__ */ new Map(), subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: /* @__PURE__ */ new Map(), subscribe: (m, E, T) => {
      const C = u().internal;
      return C.priority = C.priority + (E > 0 ? 1 : 0), C.subscribers.push({ ref: m, priority: E, store: T }), C.subscribers = C.subscribers.sort((L, b) => L.priority - b.priority), () => {
        const L = u().internal;
        L != null && L.subscribers && (L.priority = L.priority - (E > 0 ? 1 : 0), L.subscribers = L.subscribers.filter((b) => b.ref !== m));
      };
    } } };
  }), i = t.getState();
  let r = i.size, s = i.viewport.dpr, o = i.camera;
  return t.subscribe(() => {
    const { camera: a, size: u, viewport: f, gl: h, set: d } = t.getState();
    if (u.width !== r.width || u.height !== r.height || f.dpr !== s) {
      var p;
      r = u, s = f.dpr, n5(a, u), h.setPixelRatio(f.dpr);
      const g = (p = u.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
      h.setSize(u.width, u.height, g);
    }
    a !== o && (o = a, d((g) => ({ viewport: { ...g.viewport, ...g.viewport.getCurrentViewport(a) } })));
  }), t.subscribe((a) => n18(a)), t;
};
let qp, a5 = /* @__PURE__ */ new Set(), l5 = /* @__PURE__ */ new Set(), u5 = /* @__PURE__ */ new Set();
function vv(n18, e) {
  if (n18.size) for (const { callback: t } of n18.values()) t(e);
}
function of(n18, e) {
  switch (n18) {
    case "before":
      return vv(a5, e);
    case "after":
      return vv(l5, e);
    case "tail":
      return vv(u5, e);
  }
}
let yv, xv;
function Sv(n18, e, t) {
  let i = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n18 == "number" && (i = n18 - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n18), yv = e.internal.subscribers, qp = 0; qp < yv.length; qp++) xv = yv[qp], xv.ref.current(xv.store.getState(), i, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function c5(n18) {
  let e = false, t = false, i, r, s;
  function o(f) {
    r = requestAnimationFrame(o), e = true, i = 0, of("before", f), t = true;
    for (const d of n18.values()) {
      var h;
      s = d.store.getState(), s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((h = s.gl.xr) != null && h.isPresenting) && (i += Sv(f, s));
    }
    if (t = false, of("after", f), i === 0) return of("tail", f), e = false, cancelAnimationFrame(r);
  }
  function a(f, h = 1) {
    var d;
    if (!f) return n18.forEach((p) => a(p.store.getState(), h));
    (d = f.gl.xr) != null && d.isPresenting || !f.internal.active || f.frameloop === "never" || (h > 1 ? f.internal.frames = Math.min(60, f.internal.frames + h) : t ? f.internal.frames = 2 : f.internal.frames = 1, e || (e = true, requestAnimationFrame(o)));
  }
  function u(f, h = true, d, p) {
    if (h && of("before", f), d) Sv(f, d, p);
    else for (const g of n18.values()) Sv(f, g.store.getState());
    h && of("after", f);
  }
  return { loop: o, invalidate: a, advance: u };
}
function xb() {
  const n18 = be.useContext(yb);
  if (!n18) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n18;
}
function f5(n18 = (t) => t, e) {
  return xb()(n18, e);
}
function Sb(n18, e = 0) {
  const t = xb(), i = t.getState().internal.subscribe, r = hb(n18);
  return Vh(() => i(r, e, t), [e, i, t]), null;
}
const tc = /* @__PURE__ */ new Map(), { invalidate: sA, advance: oA } = c5(tc), { reconciler: Jm, applyProps: lu } = K4(tc, i5), uu = { objects: "shallow", strict: false }, h5 = (n18, e) => {
  const t = typeof n18 == "function" ? n18(e) : n18;
  return vb(t) ? t : new ZS({ powerPreference: "high-performance", canvas: e, antialias: true, alpha: true, ...n18 });
};
function d5(n18, e) {
  const t = typeof HTMLCanvasElement < "u" && n18 instanceof HTMLCanvasElement;
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
    return { width: i, height: r, top: s, left: o, updateStyle: a };
  } else if (typeof HTMLCanvasElement < "u" && n18 instanceof HTMLCanvasElement && n18.parentElement) {
    const { width: i, height: r, top: s, left: o } = n18.parentElement.getBoundingClientRect();
    return { width: i, height: r, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n18 instanceof OffscreenCanvas) return { width: n18.width, height: n18.height, top: 0, left: 0, updateStyle: t };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function p5(n18) {
  const e = tc.get(n18), t = e == null ? void 0 : e.fiber, i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error, s = i || o5(sA, oA), o = t || Jm.createContainer(s, bu.ConcurrentRoot, null, false, null, "", r, null);
  e || tc.set(n18, { fiber: o, store: s });
  let a, u = false, f;
  return { configure(h = {}) {
    let { gl: d, size: p, scene: g, events: v, onCreated: M, shadows: S = false, linear: m = false, flat: E = false, legacy: T = false, orthographic: C = false, frameloop: L = "always", dpr: b = [1, 2], performance: I, raycaster: U, camera: B, onPointerMissed: R } = h, D = s.getState(), j = D.gl;
    D.gl || D.set({ gl: j = h5(d, n18) });
    let te = D.raycaster;
    te || D.set({ raycaster: te = new rb() });
    const { params: X, ...Q } = U || {};
    if (Jt.equ(Q, te, uu) || lu(te, { ...Q }), Jt.equ(X, te.params, uu) || lu(te, { params: { ...te.params, ...X } }), !D.camera || D.camera === f && !Jt.equ(f, B, uu)) {
      f = B;
      const Y = B instanceof Dh, $ = Y ? B : C ? new Oh(0, 0, 0, 0, 0.1, 1e3) : new Xn(75, 0, 0.1, 1e3);
      Y || ($.position.z = 5, B && (lu($, B), ("aspect" in B || "left" in B || "right" in B || "bottom" in B || "top" in B) && ($.manual = true, $.updateProjectionMatrix())), !D.camera && !(B != null && B.rotation) && $.lookAt(0, 0, 0)), D.set({ camera: $ }), te.camera = $;
    }
    if (!D.scene) {
      let Y;
      g != null && g.isScene ? Y = g : (Y = new JS(), g && lu(Y, g)), D.set({ scene: fu(Y) });
    }
    if (!D.xr) {
      var J;
      const Y = (Ee, ne) => {
        const he = s.getState();
        he.frameloop !== "never" && oA(Ee, true, he, ne);
      }, $ = () => {
        const Ee = s.getState();
        Ee.gl.xr.enabled = Ee.gl.xr.isPresenting, Ee.gl.xr.setAnimationLoop(Ee.gl.xr.isPresenting ? Y : null), Ee.gl.xr.isPresenting || sA(Ee);
      }, ae = { connect() {
        const Ee = s.getState().gl;
        Ee.xr.addEventListener("sessionstart", $), Ee.xr.addEventListener("sessionend", $);
      }, disconnect() {
        const Ee = s.getState().gl;
        Ee.xr.removeEventListener("sessionstart", $), Ee.xr.removeEventListener("sessionend", $);
      } };
      typeof ((J = j.xr) == null ? void 0 : J.addEventListener) == "function" && ae.connect(), D.set({ xr: ae });
    }
    if (j.shadowMap) {
      const Y = j.shadowMap.enabled, $ = j.shadowMap.type;
      if (j.shadowMap.enabled = !!S, Jt.boo(S)) j.shadowMap.type = Tf;
      else if (Jt.str(S)) {
        var ce;
        const ae = { basic: JR, percentage: Mg, soft: Tf, variance: Yr };
        j.shadowMap.type = (ce = ae[S]) != null ? ce : Tf;
      } else Jt.obj(S) && Object.assign(j.shadowMap, S);
      (Y !== j.shadowMap.enabled || $ !== j.shadowMap.type) && (j.shadowMap.needsUpdate = true);
    }
    const V = cb();
    V && ("enabled" in V ? V.enabled = !T : "legacyMode" in V && (V.legacyMode = T)), u || lu(j, { outputEncoding: m ? 3e3 : 3001, toneMapping: E ? ws : PS }), D.legacy !== T && D.set(() => ({ legacy: T })), D.linear !== m && D.set(() => ({ linear: m })), D.flat !== E && D.set(() => ({ flat: E })), d && !Jt.fun(d) && !vb(d) && !Jt.equ(d, j, uu) && lu(j, d), v && !D.events.handlers && D.set({ events: v(s) });
    const q = d5(n18, p);
    return Jt.equ(q, D.size, uu) || D.setSize(q.width, q.height, q.updateStyle, q.top, q.left), b && D.viewport.dpr !== mb(b) && D.setDpr(b), D.frameloop !== L && D.setFrameloop(L), D.onPointerMissed || D.set({ onPointerMissed: R }), I && !Jt.equ(I, D.performance, uu) && D.set((Y) => ({ performance: { ...Y.performance, ...I } })), a = M, u = true, this;
  }, render(h) {
    return u || this.configure(), Jm.updateContainer(Tt.jsx(m5, { store: s, children: h, onCreated: a, rootElement: n18 }), o, null, () => {
    }), s;
  }, unmount() {
    Mb(n18);
  } };
}
function m5({ store: n18, children: e, onCreated: t, rootElement: i }) {
  return Vh(() => {
    const r = n18.getState();
    r.set((s) => ({ internal: { ...s.internal, active: true } })), t && t(r), n18.getState().events.connected || r.events.connect == null || r.events.connect(i);
  }, []), Tt.jsx(yb.Provider, { value: n18, children: e });
}
function Mb(n18, e) {
  const t = tc.get(n18), i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = false), Jm.updateContainer(null, i, null, () => {
      r && setTimeout(() => {
        try {
          var s, o, a, u;
          r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (u = r.gl) != null && u.xr && r.xr.disconnect(), t5(r), tc.delete(n18);
        } catch {
        }
      }, 500);
    });
  }
}
Jm.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: be.version });
const Mv = { onClick: ["click", false], onContextMenu: ["contextmenu", false], onDoubleClick: ["dblclick", false], onWheel: ["wheel", true], onPointerDown: ["pointerdown", true], onPointerUp: ["pointerup", true], onPointerLeave: ["pointerleave", true], onPointerMove: ["pointermove", true], onPointerCancel: ["pointercancel", true], onLostPointerCapture: ["lostpointercapture", true] };
function g5(n18) {
  const { handlePointer: e } = s5(n18);
  return { priority: 1, enabled: true, compute(t, i, r) {
    i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera);
  }, connected: void 0, handlers: Object.keys(Mv).reduce((t, i) => ({ ...t, [i]: e(i) }), {}), update: () => {
    var t;
    const { events: i, internal: r } = n18.getState();
    (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current);
  }, connect: (t) => {
    var i;
    const { set: r, events: s } = n18.getState();
    s.disconnect == null || s.disconnect(), r((o) => ({ events: { ...o.events, connected: t } })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
      const [u, f] = Mv[o];
      t.addEventListener(u, a, { passive: f });
    });
  }, disconnect: () => {
    const { set: t, events: i } = n18.getState();
    if (i.connected) {
      var r;
      Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
        if (i && i.connected instanceof HTMLElement) {
          const [a] = Mv[s];
          i.connected.removeEventListener(a, o);
        }
      }), t((s) => ({ events: { ...s.events, connected: void 0 } }));
    }
  } };
}
function aA(n18, e) {
  let t;
  return (...i) => {
    window.clearTimeout(t), t = window.setTimeout(() => n18(...i), e);
  };
}
function _5({ debounce: n18, scroll: e, polyfill: t, offsetSize: i } = { debounce: 0, scroll: false, offsetSize: false }) {
  const r = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!r) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [s, o] = be.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), a = be.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: s, orientationHandler: null }), u = n18 ? typeof n18 == "number" ? n18 : n18.scroll : null, f = n18 ? typeof n18 == "number" ? n18 : n18.resize : null, h = be.useRef(false);
  be.useEffect(() => (h.current = true, () => void (h.current = false)));
  const [d, p, g] = be.useMemo(() => {
    const m = () => {
      if (!a.current.element) return;
      const { left: E, top: T, width: C, height: L, bottom: b, right: I, x: U, y: B } = a.current.element.getBoundingClientRect(), R = { left: E, top: T, width: C, height: L, bottom: b, right: I, x: U, y: B };
      a.current.element instanceof HTMLElement && i && (R.height = a.current.element.offsetHeight, R.width = a.current.element.offsetWidth), Object.freeze(R), h.current && !S5(a.current.lastBounds, R) && o(a.current.lastBounds = R);
    };
    return [m, f ? aA(m, f) : m, u ? aA(m, u) : m];
  }, [o, i, u, f]);
  function v() {
    a.current.scrollContainers && (a.current.scrollContainers.forEach((m) => m.removeEventListener("scroll", g, true)), a.current.scrollContainers = null), a.current.resizeObserver && (a.current.resizeObserver.disconnect(), a.current.resizeObserver = null), a.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", a.current.orientationHandler));
  }
  function M() {
    a.current.element && (a.current.resizeObserver = new r(g), a.current.resizeObserver.observe(a.current.element), e && a.current.scrollContainers && a.current.scrollContainers.forEach((m) => m.addEventListener("scroll", g, { capture: true, passive: true })), a.current.orientationHandler = () => {
      g();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", a.current.orientationHandler));
  }
  const S = (m) => {
    !m || m === a.current.element || (v(), a.current.element = m, a.current.scrollContainers = wb(m), M());
  };
  return y5(g, !!e), v5(p), be.useEffect(() => {
    v(), M();
  }, [e, g, p]), be.useEffect(() => v, []), [S, s, d];
}
function v5(n18) {
  be.useEffect(() => {
    const e = n18;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n18]);
}
function y5(n18, e) {
  be.useEffect(() => {
    if (e) {
      const t = n18;
      return window.addEventListener("scroll", t, { capture: true, passive: true }), () => void window.removeEventListener("scroll", t, true);
    }
  }, [n18, e]);
}
function wb(n18) {
  const e = [];
  if (!n18 || n18 === document.body) return e;
  const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n18);
  return [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n18), [...e, ...wb(n18.parentElement)];
}
const x5 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], S5 = (n18, e) => x5.every((t) => n18[t] === e[t]);
var M5 = Object.defineProperty, w5 = Object.defineProperties, E5 = Object.getOwnPropertyDescriptors, lA = Object.getOwnPropertySymbols, T5 = Object.prototype.hasOwnProperty, A5 = Object.prototype.propertyIsEnumerable, uA = (n18, e, t) => e in n18 ? M5(n18, e, { enumerable: true, configurable: true, writable: true, value: t }) : n18[e] = t, cA = (n18, e) => {
  for (var t in e || (e = {})) T5.call(e, t) && uA(n18, t, e[t]);
  if (lA) for (var t of lA(e)) A5.call(e, t) && uA(n18, t, e[t]);
  return n18;
}, C5 = (n18, e) => w5(n18, E5(e)), fA, hA;
typeof window < "u" && ((fA = window.document) != null && fA.createElement || ((hA = window.navigator) == null ? void 0 : hA.product) === "ReactNative") ? be.useLayoutEffect : be.useEffect;
function Eb(n18, e, t) {
  if (!n18) return;
  if (t(n18) === true) return n18;
  let i = n18.child;
  for (; i; ) {
    const r = Eb(i, e, t);
    if (r) return r;
    i = i.sibling;
  }
}
function Tb(n18) {
  try {
    return Object.defineProperties(n18, { _currentRenderer: { get() {
      return null;
    }, set() {
    } }, _currentRenderer2: { get() {
      return null;
    }, set() {
    } } });
  } catch {
    return n18;
  }
}
const dA = console.error;
console.error = function() {
  const n18 = [...arguments].join("");
  if ((n18 == null ? void 0 : n18.startsWith("Warning:")) && n18.includes("useContext")) {
    console.error = dA;
    return;
  }
  return dA.apply(this, arguments);
};
const v1 = Tb(be.createContext(null));
class Ab extends be.Component {
  render() {
    return be.createElement(v1.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function R5() {
  const n18 = be.useContext(v1);
  if (n18 === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = be.useId();
  return be.useMemo(() => {
    for (const i of [n18, n18 == null ? void 0 : n18.alternate]) {
      if (!i) continue;
      const r = Eb(i, false, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return true;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n18, e]);
}
function P5() {
  const n18 = R5(), [e] = be.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = n18;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      r && r !== v1 && !e.has(r) && e.set(r, be.useContext(Tb(r)));
    }
    t = t.return;
  }
  return e;
}
function b5() {
  const n18 = P5();
  return be.useMemo(() => Array.from(n18.keys()).reduce((e, t) => (i) => be.createElement(e, null, be.createElement(t.Provider, C5(cA({}, i), { value: n18.get(t) }))), (e) => be.createElement(Ab, cA({}, e))), [n18]);
}
const L5 = be.forwardRef(function({ children: e, fallback: t, resize: i, style: r, gl: s, events: o = g5, eventSource: a, eventPrefix: u, shadows: f, linear: h, flat: d, legacy: p, orthographic: g, frameloop: v, dpr: M, performance: S, raycaster: m, camera: E, scene: T, onPointerMissed: C, onCreated: L, ...b }, I) {
  be.useMemo(() => J4(G4), []);
  const U = b5(), [B, R] = _5({ scroll: true, debounce: { scroll: 50, resize: 0 }, ...i }), D = be.useRef(null), j = be.useRef(null);
  be.useImperativeHandle(I, () => D.current);
  const te = hb(C), [X, Q] = be.useState(false), [J, ce] = be.useState(false);
  if (X) throw X;
  if (J) throw J;
  const V = be.useRef(null);
  Vh(() => {
    const Y = D.current;
    R.width > 0 && R.height > 0 && Y && (V.current || (V.current = p5(Y)), V.current.configure({ gl: s, events: o, shadows: f, linear: h, flat: d, legacy: p, orthographic: g, frameloop: v, dpr: M, performance: S, raycaster: m, camera: E, scene: T, size: R, onPointerMissed: (...$) => te.current == null ? void 0 : te.current(...$), onCreated: ($) => {
      $.events.connect == null || $.events.connect(a ? Q4(a) ? a.current : a : j.current), u && $.setEvents({ compute: (ae, Ee) => {
        const ne = ae[u + "X"], he = ae[u + "Y"];
        Ee.pointer.set(ne / Ee.size.width * 2 - 1, -(he / Ee.size.height) * 2 + 1), Ee.raycaster.setFromCamera(Ee.pointer, Ee.camera);
      } }), L == null ? void 0 : L($);
    } }), V.current.render(Tt.jsx(U, { children: Tt.jsx(db, { set: ce, children: Tt.jsx(be.Suspense, { fallback: Tt.jsx($4, { set: Q }), children: e ?? null }) }) })));
  }), be.useEffect(() => {
    const Y = D.current;
    if (Y) return () => Mb(Y);
  }, []);
  const q = a ? "none" : "auto";
  return Tt.jsx("div", { ref: j, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: q, ...r }, ...b, children: Tt.jsx("div", { ref: B, style: { width: "100%", height: "100%" }, children: Tt.jsx("canvas", { ref: D, style: { display: "block" }, children: t }) }) });
}), I5 = be.forwardRef(function(e, t) {
  return Tt.jsx(Ab, { children: Tt.jsx(L5, { ...e, ref: t }) });
});
function vx() {
  return vx = Object.assign ? Object.assign.bind() : function(n18) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) ({}).hasOwnProperty.call(t, i) && (n18[i] = t[i]);
    }
    return n18;
  }, vx.apply(null, arguments);
}
function D5(n18, e) {
  const t = n18 + "Geometry";
  return be.forwardRef(({ args: i, children: r, ...s }, o) => {
    const a = be.useRef(null);
    return be.useImperativeHandle(o, () => a.current), be.useLayoutEffect(() => void (e == null ? void 0 : e(a.current))), be.createElement("mesh", vx({ ref: a }, s), be.createElement(t, { attach: "geometry", args: i }), r);
  });
}
const N5 = D5("icosahedron"), U5 = {}, pA = (n18) => {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (h, d) => {
    const p = typeof h == "function" ? h(e) : h;
    if (!Object.is(p, e)) {
      const g = e;
      e = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, r = () => e, u = { setState: i, getState: r, getInitialState: () => f, subscribe: (h) => (t.add(h), () => t.delete(h)), destroy: () => {
    (U5 ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), t.clear();
  } }, f = e = n18(i, r, u);
  return u;
}, O5 = (n18) => n18 ? pA(n18) : pA;
var Cb = { exports: {} }, Rb = {}, Pb = { exports: {} }, bb = {};
/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var nc = be;
function F5(n18, e) {
  return n18 === e && (n18 !== 0 || 1 / n18 === 1 / e) || n18 !== n18 && e !== e;
}
var k5 = typeof Object.is == "function" ? Object.is : F5, z5 = nc.useState, B5 = nc.useEffect, V5 = nc.useLayoutEffect, H5 = nc.useDebugValue;
function G5(n18, e) {
  var t = e(), i = z5({ inst: { value: t, getSnapshot: e } }), r = i[0].inst, s = i[1];
  return V5(function() {
    r.value = t, r.getSnapshot = e, wv(r) && s({ inst: r });
  }, [n18, t, e]), B5(function() {
    return wv(r) && s({ inst: r }), n18(function() {
      wv(r) && s({ inst: r });
    });
  }, [n18]), H5(t), t;
}
function wv(n18) {
  var e = n18.getSnapshot;
  n18 = n18.value;
  try {
    var t = e();
    return !k5(n18, t);
  } catch {
    return true;
  }
}
function W5(n18, e) {
  return e();
}
var X5 = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? W5 : G5;
bb.useSyncExternalStore = nc.useSyncExternalStore !== void 0 ? nc.useSyncExternalStore : X5;
Pb.exports = bb;
var Y5 = Pb.exports;
/**
* @license React
* use-sync-external-store-shim/with-selector.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Zg = be, q5 = Y5;
function j5(n18, e) {
  return n18 === e && (n18 !== 0 || 1 / n18 === 1 / e) || n18 !== n18 && e !== e;
}
var Z5 = typeof Object.is == "function" ? Object.is : j5, J5 = q5.useSyncExternalStore, K5 = Zg.useRef, Q5 = Zg.useEffect, $5 = Zg.useMemo, eV = Zg.useDebugValue;
Rb.useSyncExternalStoreWithSelector = function(n18, e, t, i, r) {
  var s = K5(null);
  if (s.current === null) {
    var o = { hasValue: false, value: null };
    s.current = o;
  } else o = s.current;
  s = $5(function() {
    function u(g) {
      if (!f) {
        if (f = true, h = g, g = i(g), r !== void 0 && o.hasValue) {
          var v = o.value;
          if (r(v, g)) return d = v;
        }
        return d = g;
      }
      if (v = d, Z5(h, g)) return v;
      var M = i(g);
      return r !== void 0 && r(v, M) ? (h = g, v) : (h = g, d = M);
    }
    var f = false, h, d, p = t === void 0 ? null : t;
    return [function() {
      return u(e());
    }, p === null ? void 0 : function() {
      return u(p());
    }];
  }, [e, t, i, r]);
  var a = J5(n18, s[0], s[1]);
  return Q5(function() {
    o.hasValue = true, o.value = a;
  }, [a]), eV(a), a;
};
Cb.exports = Rb;
var tV = Cb.exports;
const nV = Nx(tV), Lb = {}, { useDebugValue: iV } = O3, { useSyncExternalStoreWithSelector: rV } = nV;
let mA = false;
const sV = (n18) => n18;
function oV(n18, e = sV, t) {
  (Lb ? "production" : void 0) !== "production" && t && !mA && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), mA = true);
  const i = rV(n18.subscribe, n18.getState, n18.getServerState || n18.getInitialState, e, t);
  return iV(i), i;
}
const gA = (n18) => {
  (Lb ? "production" : void 0) !== "production" && typeof n18 != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
  const e = typeof n18 == "function" ? O5(n18) : n18, t = (i, r) => oV(e, i, r);
  return Object.assign(t, e), t;
}, aV = (n18) => n18 ? gA(n18) : gA;
function Ws(n18) {
  if (n18 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n18;
}
function Ib(n18, e) {
  n18.prototype = Object.create(e.prototype), n18.prototype.constructor = n18, n18.__proto__ = e;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var hr = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, ic = { duration: 0.5, overwrite: false, delay: 0 }, y1, ei, en, As = 1e8, pi = 1 / As, yx = Math.PI * 2, lV = yx / 4, uV = 0, Db = Math.sqrt, cV = Math.cos, fV = Math.sin, qn = function(e) {
  return typeof e == "string";
}, gn = function(e) {
  return typeof e == "function";
}, ao = function(e) {
  return typeof e == "number";
}, x1 = function(e) {
  return typeof e > "u";
}, Ps = function(e) {
  return typeof e == "object";
}, Wi = function(e) {
  return e !== false;
}, S1 = function() {
  return typeof window < "u";
}, jp = function(e) {
  return gn(e) || qn(e);
}, Nb = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, gi = Array.isArray, xx = /(?:-?\.?\d|\.)+/gi, Ub = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Lu = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Ev = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Ob = /[+-]=-?[.\d]+/, Fb = /[^,'"\[\]\s]+/gi, hV = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, on, ps, Sx, M1, pr = {}, Km = {}, kb, zb = function(e) {
  return (Km = rc(e, pr)) && ji;
}, w1 = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, vh = function(e, t) {
  return !t && console.warn(e);
}, Bb = function(e, t) {
  return e && (pr[e] = t) && Km && (Km[e] = t) || pr;
}, yh = function() {
  return 0;
}, dV = { suppressEvents: true, isStart: true, kill: false }, gm = { suppressEvents: true, kill: false }, pV = { suppressEvents: true }, E1 = {}, Qo = [], Mx = {}, Vb, rr = {}, Tv = {}, _A = 30, _m = [], T1 = "", A1 = function(e) {
  var t = e[0], i, r;
  if (Ps(t) || gn(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
    for (r = _m.length; r-- && !_m[r].targetTest(t); ) ;
    i = _m[r];
  }
  for (r = e.length; r--; ) e[r] && (e[r]._gsap || (e[r]._gsap = new fL(e[r], i))) || e.splice(r, 1);
  return e;
}, rl = function(e) {
  return e._gsap || A1(Ur(e))[0]._gsap;
}, Hb = function(e, t, i) {
  return (i = e[t]) && gn(i) ? e[t]() : x1(i) && e.getAttribute && e.getAttribute(t) || i;
}, Xi = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, Sn = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, Pn = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Bu = function(e, t) {
  var i = t.charAt(0), r = parseFloat(t.substr(2));
  return e = parseFloat(e), i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r;
}, mV = function(e, t) {
  for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; ) ;
  return r < i;
}, Qm = function() {
  var e = Qo.length, t = Qo.slice(0), i, r;
  for (Mx = {}, Qo.length = 0, i = 0; i < e; i++) r = t[i], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], true)._lazy = 0);
}, Gb = function(e, t, i, r) {
  Qo.length && !ei && Qm(), e.render(t, i, ei && t < 0 && (e._initted || e._startAt)), Qo.length && !ei && Qm();
}, Wb = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(Fb).length < 2 ? t : qn(e) ? e.trim() : e;
}, Xb = function(e) {
  return e;
}, mr = function(e, t) {
  for (var i in t) i in e || (e[i] = t[i]);
  return e;
}, gV = function(e) {
  return function(t, i) {
    for (var r in i) r in t || r === "duration" && e || r === "ease" || (t[r] = i[r]);
  };
}, rc = function(e, t) {
  for (var i in t) e[i] = t[i];
  return e;
}, vA = function n(e, t) {
  for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = Ps(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
  return e;
}, $m = function(e, t) {
  var i = {}, r;
  for (r in e) r in t || (i[r] = e[r]);
  return i;
}, bf = function(e) {
  var t = e.parent || on, i = e.keyframes ? gV(gi(e.keyframes)) : mr;
  if (Wi(e.inherit)) for (; t; ) i(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, _V = function(e, t) {
  for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; ) ;
  return i < 0;
}, Yb = function(e, t, i, r, s) {
  var o = e[r], a;
  if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
  return o ? (t._next = o._next, o._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = o, t.parent = t._dp = e, t;
}, Jg = function(e, t, i, r) {
  i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
  var s = t._prev, o = t._next;
  s ? s._next = o : e[i] === t && (e[i] = o), o ? o._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null;
}, ra = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, sl = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0)) for (var i = e; i; ) i._dirty = 1, i = i.parent;
  return e;
}, vV = function(e) {
  for (var t = e.parent; t && t.parent; ) t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, wx = function(e, t, i, r) {
  return e._startAt && (ei ? e._startAt.revert(gm) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, true, r));
}, yV = function n3(e) {
  return !e || e._ts && n3(e.parent);
}, yA = function(e) {
  return e._repeat ? sc(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, sc = function(e, t) {
  var i = Math.floor(e = Pn(e / t));
  return e && i === e ? i - 1 : i;
}, eg = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, Kg = function(e) {
  return e._end = Pn(e._start + (e._tDur / Math.abs(e._ts || e._rts || pi) || 0));
}, Qg = function(e, t) {
  var i = e._dp;
  return i && i.smoothChildTiming && e._ts && (e._start = Pn(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Kg(e), i._dirty || sl(i, e)), e;
}, qb = function(e, t) {
  var i;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = eg(e.rawTime(), t), (!t._dur || Hh(0, t.totalDuration(), i) - t._tTime > pi) && t.render(i, true)), sl(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration()) for (i = e; i._dp; ) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
    e._zTime = -1e-8;
  }
}, _s = function(e, t, i, r) {
  return t.parent && ra(t), t._start = Pn((ao(i) ? i : i || e !== on ? br(e, i, t) : e._time) + t._delay), t._end = Pn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), Yb(e, t, "_first", "_last", e._sort ? "_start" : 0), Ex(t) || (e._recent = t), r || qb(e, t), e._ts < 0 && Qg(e, e._tTime), e;
}, jb = function(e, t) {
  return (pr.ScrollTrigger || w1("scrollTrigger", t)) && pr.ScrollTrigger.create(t, e);
}, Zb = function(e, t, i, r, s) {
  if (R1(e, t, s), !e._initted) return 1;
  if (!i && e._pt && !ei && (e._dur && e.vars.lazy !== false || !e._dur && e.vars.lazy) && Vb !== ar.frame) return Qo.push(e), e._lazy = [s, r], 1;
}, xV = function n6(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n6(t));
}, Ex = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, SV = function(e, t, i, r) {
  var s = e.ratio, o = t < 0 || !t && (!e._start && xV(e) && !(!e._initted && Ex(e)) || (e._ts < 0 || e._dp._ts < 0) && !Ex(e)) ? 0 : 1, a = e._rDelay, u = 0, f, h, d;
  if (a && e._repeat && (u = Hh(0, e._tDur, t), h = sc(u, a), e._yoyo && h & 1 && (o = 1 - o), h !== sc(e._tTime, a) && (s = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== s || ei || r || e._zTime === pi || !t && e._zTime) {
    if (!e._initted && Zb(e, t, r, i, u)) return;
    for (d = e._zTime, e._zTime = t || (i ? pi : 0), i || (i = t && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = u, f = e._pt; f; ) f.r(o, f.d), f = f._next;
    t < 0 && wx(e, t, i, true), e._onUpdate && !i && ur(e, "onUpdate"), u && e._repeat && !i && e.parent && ur(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && ra(e, 1), !i && !ei && (ur(e, o ? "onComplete" : "onReverseComplete", true), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, MV = function(e, t, i) {
  var r;
  if (i > t) for (r = e._first; r && r._start <= i; ) {
    if (r.data === "isPause" && r._start > t) return r;
    r = r._next;
  }
  else for (r = e._last; r && r._start >= i; ) {
    if (r.data === "isPause" && r._start < t) return r;
    r = r._prev;
  }
}, oc = function(e, t, i, r) {
  var s = e._repeat, o = Pn(t) || 0, a = e._tTime / e._tDur;
  return a && !r && (e._time *= o / e._dur), e._dur = o, e._tDur = s ? s < 0 ? 1e10 : Pn(o * (s + 1) + e._rDelay * s) : o, a > 0 && !r && Qg(e, e._tTime = e._tDur * a), e.parent && Kg(e), i || sl(e.parent, e), e;
}, xA = function(e) {
  return e instanceof Ci ? sl(e) : oc(e, e._dur);
}, wV = { _start: 0, endTime: yh, totalDuration: yh }, br = function n7(e, t, i) {
  var r = e.labels, s = e._recent || wV, o = e.duration() >= As ? s.endTime(false) : e._dur, a, u, f;
  return qn(t) && (isNaN(t) || t in r) ? (u = t.charAt(0), f = t.substr(-1) === "%", a = t.indexOf("="), u === "<" || u === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (u === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (f ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o), r[t]) : (u = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), f && i && (u = u / 100 * (gi(i) ? i[0] : i).totalDuration()), a > 1 ? n7(e, t.substr(0, a - 1), i) + u : o + u)) : t == null ? o : +t;
}, Lf = function(e, t, i) {
  var r = ao(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, u;
  if (r && (o.duration = t[1]), o.parent = i, e) {
    for (a = o, u = i; u && !("immediateRender" in a); ) a = u.vars.defaults || {}, u = Wi(u.vars.inherit) && u.parent;
    o.immediateRender = Wi(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1];
  }
  return new Rn(t[0], o, t[s + 1]);
}, da = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, Hh = function(e, t, i) {
  return i < e ? e : i > t ? t : i;
}, di = function(e, t) {
  return !qn(e) || !(t = hV.exec(e)) ? "" : t[1];
}, EV = function(e, t, i) {
  return da(i, function(r) {
    return Hh(e, t, r);
  });
}, Tx = [].slice, Jb = function(e, t) {
  return e && Ps(e) && "length" in e && (!t && !e.length || e.length - 1 in e && Ps(e[0])) && !e.nodeType && e !== ps;
}, TV = function(e, t, i) {
  return i === void 0 && (i = []), e.forEach(function(r) {
    var s;
    return qn(r) && !t || Jb(r, 1) ? (s = i).push.apply(s, Ur(r)) : i.push(r);
  }) || i;
}, Ur = function(e, t, i) {
  return en && !t && en.selector ? en.selector(e) : qn(e) && !i && (Sx || !ac()) ? Tx.call((t || M1).querySelectorAll(e), 0) : gi(e) ? TV(e, i) : Jb(e) ? Tx.call(e, 0) : e ? [e] : [];
}, Ax = function(e) {
  return e = Ur(e)[0] || vh("Invalid scope") || {}, function(t) {
    var i = e.current || e.nativeElement || e;
    return Ur(t, i.querySelectorAll ? i : i === e ? vh("Invalid scope") || M1.createElement("div") : e);
  };
}, Kb = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, Qb = function(e) {
  if (gn(e)) return e;
  var t = Ps(e) ? e : { each: e }, i = ol(t.ease), r = t.from || 0, s = parseFloat(t.base) || 0, o = {}, a = r > 0 && r < 1, u = isNaN(r) || a, f = t.axis, h = r, d = r;
  return qn(r) ? h = d = { center: 0.5, edges: 0.5, end: 1 }[r] || 0 : !a && u && (h = r[0], d = r[1]), function(p, g, v) {
    var M = (v || t).length, S = o[M], m, E, T, C, L, b, I, U, B;
    if (!S) {
      if (B = t.grid === "auto" ? 0 : (t.grid || [1, As])[1], !B) {
        for (I = -1e8; I < (I = v[B++].getBoundingClientRect().left) && B < M; ) ;
        B < M && B--;
      }
      for (S = o[M] = [], m = u ? Math.min(B, M) * h - 0.5 : r % B, E = B === As ? 0 : u ? M * d / B - 0.5 : r / B | 0, I = 0, U = As, b = 0; b < M; b++) T = b % B - m, C = E - (b / B | 0), S[b] = L = f ? Math.abs(f === "y" ? C : T) : Db(T * T + C * C), L > I && (I = L), L < U && (U = L);
      r === "random" && Kb(S), S.max = I - U, S.min = U, S.v = M = (parseFloat(t.amount) || parseFloat(t.each) * (B > M ? M - 1 : f ? f === "y" ? M / B : B : Math.max(B, M / B)) || 0) * (r === "edges" ? -1 : 1), S.b = M < 0 ? s - M : s, S.u = di(t.amount || t.each) || 0, i = i && M < 0 ? lL(i) : i;
    }
    return M = (S[p] - S.min) / S.max || 0, Pn(S.b + (i ? i(M) : M) * S.v) + S.u;
  };
}, Cx = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(i) {
    var r = Pn(Math.round(parseFloat(i) / e) * e * t);
    return (r - r % 1) / t + (ao(i) ? 0 : di(i));
  };
}, $b = function(e, t) {
  var i = gi(e), r, s;
  return !i && Ps(e) && (r = i = e.radius || As, e.values ? (e = Ur(e.values), (s = !ao(e[0])) && (r *= r)) : e = Cx(e.increment)), da(t, i ? gn(e) ? function(o) {
    return s = e(o), Math.abs(s - o) <= r ? s : o;
  } : function(o) {
    for (var a = parseFloat(s ? o.x : o), u = parseFloat(s ? o.y : 0), f = As, h = 0, d = e.length, p, g; d--; ) s ? (p = e[d].x - a, g = e[d].y - u, p = p * p + g * g) : p = Math.abs(e[d] - a), p < f && (f = p, h = d);
    return h = !r || f <= r ? e[h] : o, s || h === o || ao(o) ? h : h + di(o);
  } : Cx(e));
}, eL = function(e, t, i, r) {
  return da(gi(e) ? !t : i === true ? !!(i = 0) : !r, function() {
    return gi(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) * i * r) / r;
  });
}, AV = function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
  return function(r) {
    return t.reduce(function(s, o) {
      return o(s);
    }, r);
  };
}, CV = function(e, t) {
  return function(i) {
    return e(parseFloat(i)) + (t || di(i));
  };
}, RV = function(e, t, i) {
  return nL(e, t, 0, 1, i);
}, tL = function(e, t, i) {
  return da(i, function(r) {
    return e[~~t(r)];
  });
}, PV = function n8(e, t, i) {
  var r = t - e;
  return gi(e) ? tL(e, n8(0, e.length), t) : da(i, function(s) {
    return (r + (s - e) % r) % r + e;
  });
}, bV = function n9(e, t, i) {
  var r = t - e, s = r * 2;
  return gi(e) ? tL(e, n9(0, e.length - 1), t) : da(i, function(o) {
    return o = (s + (o - e) % s) % s || 0, e + (o > r ? s - o : o);
  });
}, xh = function(e) {
  for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t)); ) o = e.indexOf(")", r), a = e.charAt(r + 7) === "[", s = e.substr(r + 7, o - r - 7).match(a ? Fb : xx), i += e.substr(t, r - t) + eL(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5), t = o + 1;
  return i + e.substr(t, e.length - t);
}, nL = function(e, t, i, r, s) {
  var o = t - e, a = r - i;
  return da(s, function(u) {
    return i + ((u - e) / o * a || 0);
  });
}, LV = function n10(e, t, i, r) {
  var s = isNaN(e + t) ? 0 : function(g) {
    return (1 - g) * e + g * t;
  };
  if (!s) {
    var o = qn(e), a = {}, u, f, h, d, p;
    if (i === true && (r = 1) && (i = null), o) e = { p: e }, t = { p: t };
    else if (gi(e) && !gi(t)) {
      for (h = [], d = e.length, p = d - 2, f = 1; f < d; f++) h.push(n10(e[f - 1], e[f]));
      d--, s = function(v) {
        v *= d;
        var M = Math.min(p, ~~v);
        return h[M](v - M);
      }, i = t;
    } else r || (e = rc(gi(e) ? [] : {}, e));
    if (!h) {
      for (u in t) C1.call(a, e, u, "get", t[u]);
      s = function(v) {
        return L1(v, a) || (o ? e.p : e);
      };
    }
  }
  return da(i, s);
}, SA = function(e, t, i) {
  var r = e.labels, s = As, o, a, u;
  for (o in r) a = r[o] - t, a < 0 == !!i && a && s > (a = Math.abs(a)) && (u = o, s = a);
  return u;
}, ur = function(e, t, i) {
  var r = e.vars, s = r[t], o = en, a = e._ctx, u, f, h;
  if (s) return u = r[t + "Params"], f = r.callbackScope || e, i && Qo.length && Qm(), a && (en = a), h = u ? s.apply(f, u) : s.call(f), en = o, h;
}, pf = function(e) {
  return ra(e), e.scrollTrigger && e.scrollTrigger.kill(!!ei), e.progress() < 1 && ur(e, "onInterrupt"), e;
}, Iu, iL = [], rL = function(e) {
  if (e) if (e = !e.name && e.default || e, S1() || e.headless) {
    var t = e.name, i = gn(e), r = t && !i && e.init ? function() {
      this._props = [];
    } : e, s = { init: yh, render: L1, add: C1, kill: qV, modifier: YV, rawVars: 0 }, o = { targetTest: 0, get: 0, getSetter: b1, aliases: {}, register: 0 };
    if (ac(), e !== r) {
      if (rr[t]) return;
      mr(r, mr($m(e, s), o)), rc(r.prototype, rc(s, $m(e, o))), rr[r.prop = t] = r, e.targetTest && (_m.push(r), E1[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
    }
    Bb(t, r), e.register && e.register(ji, r, Yi);
  } else iL.push(e);
}, Xt = 255, mf = { aqua: [0, Xt, Xt], lime: [0, Xt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, Xt], navy: [0, 0, 128], white: [Xt, Xt, Xt], olive: [128, 128, 0], yellow: [Xt, Xt, 0], orange: [Xt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [Xt, 0, 0], pink: [Xt, 192, 203], cyan: [0, Xt, Xt], transparent: [Xt, Xt, Xt, 0] }, Av = function(e, t, i) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < 0.5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Xt + 0.5 | 0;
}, sL = function(e, t, i) {
  var r = e ? ao(e) ? [e >> 16, e >> 8 & Xt, e & Xt] : 0 : mf.black, s, o, a, u, f, h, d, p, g, v;
  if (!r) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), mf[e]) r = mf[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (s = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & Xt, r & Xt, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & Xt, e & Xt];
    } else if (e.substr(0, 3) === "hsl") {
      if (r = v = e.match(xx), !t) u = +r[0] % 360 / 360, f = +r[1] / 100, h = +r[2] / 100, o = h <= 0.5 ? h * (f + 1) : h + f - h * f, s = h * 2 - o, r.length > 3 && (r[3] *= 1), r[0] = Av(u + 1 / 3, s, o), r[1] = Av(u, s, o), r[2] = Av(u - 1 / 3, s, o);
      else if (~e.indexOf("=")) return r = e.match(Ub), i && r.length < 4 && (r[3] = 1), r;
    } else r = e.match(xx) || mf.transparent;
    r = r.map(Number);
  }
  return t && !v && (s = r[0] / Xt, o = r[1] / Xt, a = r[2] / Xt, d = Math.max(s, o, a), p = Math.min(s, o, a), h = (d + p) / 2, d === p ? u = f = 0 : (g = d - p, f = h > 0.5 ? g / (2 - d - p) : g / (d + p), u = d === s ? (o - a) / g + (o < a ? 6 : 0) : d === o ? (a - s) / g + 2 : (s - o) / g + 4, u *= 60), r[0] = ~~(u + 0.5), r[1] = ~~(f * 100 + 0.5), r[2] = ~~(h * 100 + 0.5)), i && r.length < 4 && (r[3] = 1), r;
}, oL = function(e) {
  var t = [], i = [], r = -1;
  return e.split($o).forEach(function(s) {
    var o = s.match(Lu) || [];
    t.push.apply(t, o), i.push(r += o.length + 1);
  }), t.c = i, t;
}, MA = function(e, t, i) {
  var r = "", s = (e + r).match($o), o = t ? "hsla(" : "rgba(", a = 0, u, f, h, d;
  if (!s) return e;
  if (s = s.map(function(p) {
    return (p = sL(p, t, 1)) && o + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")";
  }), i && (h = oL(e), u = i.c, u.join(r) !== h.c.join(r))) for (f = e.replace($o, "1").split(Lu), d = f.length - 1; a < d; a++) r += f[a] + (~u.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (h.length ? h : s.length ? s : i).shift());
  if (!f) for (f = e.split($o), d = f.length - 1; a < d; a++) r += f[a] + s[a];
  return r + f[d];
}, $o = function() {
  var n18 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in mf) n18 += "|" + e + "\\b";
  return new RegExp(n18 + ")", "gi");
}(), IV = /hsl[a]?\(/, aL = function(e) {
  var t = e.join(" "), i;
  if ($o.lastIndex = 0, $o.test(t)) return i = IV.test(t), e[1] = MA(e[1], i), e[0] = MA(e[0], i, oL(e[1])), true;
}, Sh, ar = function() {
  var n18 = Date.now, e = 500, t = 33, i = n18(), r = i, s = 1e3 / 240, o = s, a = [], u, f, h, d, p, g, v = function M(S) {
    var m = n18() - r, E = S === true, T, C, L, b;
    if ((m > e || m < 0) && (i += m - t), r += m, L = r - i, T = L - o, (T > 0 || E) && (b = ++d.frame, p = L - d.time * 1e3, d.time = L = L / 1e3, o += T + (T >= s ? 4 : s - T), C = 1), E || (u = f(M)), C) for (g = 0; g < a.length; g++) a[g](L, p, b, S);
  };
  return d = { time: 0, frame: 0, tick: function() {
    v(true);
  }, deltaRatio: function(S) {
    return p / (1e3 / (S || 60));
  }, wake: function() {
    kb && (!Sx && S1() && (ps = Sx = window, M1 = ps.document || {}, pr.gsap = ji, (ps.gsapVersions || (ps.gsapVersions = [])).push(ji.version), zb(Km || ps.GreenSockGlobals || !ps.gsap && ps || {}), iL.forEach(rL)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, u && d.sleep(), f = h || function(S) {
      return setTimeout(S, o - d.time * 1e3 + 1 | 0);
    }, Sh = 1, v(2));
  }, sleep: function() {
    (h ? cancelAnimationFrame : clearTimeout)(u), Sh = 0, f = yh;
  }, lagSmoothing: function(S, m) {
    e = S || 1 / 0, t = Math.min(m || 33, e);
  }, fps: function(S) {
    s = 1e3 / (S || 240), o = d.time * 1e3 + s;
  }, add: function(S, m, E) {
    var T = m ? function(C, L, b, I) {
      S(C, L, b, I), d.remove(T);
    } : S;
    return d.remove(S), a[E ? "unshift" : "push"](T), ac(), T;
  }, remove: function(S, m) {
    ~(m = a.indexOf(S)) && a.splice(m, 1) && g >= m && g--;
  }, _listeners: a }, d;
}(), ac = function() {
  return !Sh && ar.wake();
}, At = {}, DV = /^[\d.\-M][\d.\-,\s]/, NV = /["']/g, UV = function(e) {
  for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, o = i.length, a, u, f; s < o; s++) u = i[s], a = s !== o - 1 ? u.lastIndexOf(",") : u.length, f = u.substr(0, a), t[r] = isNaN(f) ? f.replace(NV, "").trim() : +f, r = u.substr(a + 1).trim();
  return t;
}, OV = function(e) {
  var t = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", t);
  return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i);
}, FV = function(e) {
  var t = (e + "").split("("), i = At[t[0]];
  return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [UV(t[1])] : OV(e).split(",").map(Wb)) : At._CE && DV.test(e) ? At._CE("", e) : i;
}, lL = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, uL = function n11(e, t) {
  for (var i = e._first, r; i; ) i instanceof Ci ? n11(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n11(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next;
}, ol = function(e, t) {
  return e && (gn(e) ? e : At[e] || FV(e)) || t;
}, wl = function(e, t, i, r) {
  i === void 0 && (i = function(u) {
    return 1 - t(1 - u);
  }), r === void 0 && (r = function(u) {
    return u < 0.5 ? t(u * 2) / 2 : 1 - t((1 - u) * 2) / 2;
  });
  var s = { easeIn: t, easeOut: i, easeInOut: r }, o;
  return Xi(e, function(a) {
    At[a] = pr[a] = s, At[o = a.toLowerCase()] = i;
    for (var u in s) At[o + (u === "easeIn" ? ".in" : u === "easeOut" ? ".out" : ".inOut")] = At[a + "." + u] = s[u];
  }), s;
}, cL = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, Cv = function n12(e, t, i) {
  var r = t >= 1 ? t : 1, s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = s / yx * (Math.asin(1 / r) || 0), a = function(h) {
    return h === 1 ? 1 : r * Math.pow(2, -10 * h) * fV((h - o) * s) + 1;
  }, u = e === "out" ? a : e === "in" ? function(f) {
    return 1 - a(1 - f);
  } : cL(a);
  return s = yx / s, u.config = function(f, h) {
    return n12(e, f, h);
  }, u;
}, Rv = function n13(e, t) {
  t === void 0 && (t = 1.70158);
  var i = function(o) {
    return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
  }, r = e === "out" ? i : e === "in" ? function(s) {
    return 1 - i(1 - s);
  } : cL(i);
  return r.config = function(s) {
    return n13(e, s);
  }, r;
};
Xi("Linear,Quad,Cubic,Quart,Quint,Strong", function(n18, e) {
  var t = e < 5 ? e + 1 : e;
  wl(n18 + ",Power" + (t - 1), e ? function(i) {
    return Math.pow(i, t);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, t);
  }, function(i) {
    return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
  });
});
At.Linear.easeNone = At.none = At.Linear.easeIn;
wl("Elastic", Cv("in"), Cv("out"), Cv());
(function(n18, e) {
  var t = 1 / e, i = 2 * t, r = 2.5 * t, s = function(a) {
    return a < t ? n18 * a * a : a < i ? n18 * Math.pow(a - 1.5 / e, 2) + 0.75 : a < r ? n18 * (a -= 2.25 / e) * a + 0.9375 : n18 * Math.pow(a - 2.625 / e, 2) + 0.984375;
  };
  wl("Bounce", function(o) {
    return 1 - s(1 - o);
  }, s);
})(7.5625, 2.75);
wl("Expo", function(n18) {
  return Math.pow(2, 10 * (n18 - 1)) * n18 + n18 * n18 * n18 * n18 * n18 * n18 * (1 - n18);
});
wl("Circ", function(n18) {
  return -(Db(1 - n18 * n18) - 1);
});
wl("Sine", function(n18) {
  return n18 === 1 ? 1 : -cV(n18 * lV) + 1;
});
wl("Back", Rv("in"), Rv("out"), Rv());
At.SteppedEase = At.steps = pr.SteppedEase = { config: function(e, t) {
  e === void 0 && (e = 1);
  var i = 1 / e, r = e + (t ? 0 : 1), s = t ? 1 : 0, o = 1 - pi;
  return function(a) {
    return ((r * Hh(0, o, a) | 0) + s) * i;
  };
} };
ic.ease = At["quad.out"];
Xi("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n18) {
  return T1 += n18 + "," + n18 + "Params,";
});
var fL = function(e, t) {
  this.id = uV++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Hb, this.set = t ? t.getSetter : b1;
}, Mh = function() {
  function n18(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, oc(this, +t.duration, 1, 1), this.data = t.data, en && (this._ctx = en, en.data.push(this)), Sh || ar.wake();
  }
  var e = n18.prototype;
  return e.delay = function(i) {
    return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay;
  }, e.duration = function(i) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(i) {
    return arguments.length ? (this._dirty = 0, oc(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(i, r) {
    if (ac(), !arguments.length) return this._tTime;
    var s = this._dp;
    if (s && s.smoothChildTiming && this._ts) {
      for (Qg(this, i), !s._dp || s.parent || qb(s, this); s && s.parent; ) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, true), s = s.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && _s(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === pi || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), Gb(this, i, r)), this;
  }, e.time = function(i, r) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + yA(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time;
  }, e.totalProgress = function(i, r) {
    return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(i, r) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + yA(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(i, r) {
    var s = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? sc(this._tTime, s) + 1 : 1;
  }, e.timeScale = function(i, r) {
    if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === i) return this;
    var s = this.parent && this._ts ? eg(this.parent._time, this) : this._tTime;
    return this._rts = +i || 0, this._ts = this._ps || i === -1e-8 ? 0 : this._rts, this.totalTime(Hh(-Math.abs(this._delay), this._tDur, s), r !== false), Kg(this), vV(this);
  }, e.paused = function(i) {
    return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (ac(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== pi && (this._tTime -= pi)))), this) : this._ps;
  }, e.startTime = function(i) {
    if (arguments.length) {
      this._start = i;
      var r = this.parent || this._dp;
      return r && (r._sort || !this.parent) && _s(r, this, i - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(i) {
    return this._start + (Wi(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(i) {
    var r = this.parent || this._dp;
    return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? eg(r.rawTime(i), this) : this._tTime : this._tTime;
  }, e.revert = function(i) {
    i === void 0 && (i = pV);
    var r = ei;
    return ei = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-0.01, i.suppressEvents)), this.data !== "nested" && i.kill !== false && this.kill(), ei = r, this;
  }, e.globalTime = function(i) {
    for (var r = this, s = arguments.length ? i : r.rawTime(); r; ) s = r._start + s / (Math.abs(r._ts) || 1), r = r._dp;
    return !this.parent && this._sat ? this._sat.globalTime(i) : s;
  }, e.repeat = function(i) {
    return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, xA(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(i) {
    if (arguments.length) {
      var r = this._time;
      return this._rDelay = i, xA(this), r ? this.time(r) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(i) {
    return arguments.length ? (this._yoyo = i, this) : this._yoyo;
  }, e.seek = function(i, r) {
    return this.totalTime(br(this, i), Wi(r));
  }, e.restart = function(i, r) {
    return this.play().totalTime(i ? -this._delay : 0, Wi(r)), this._dur || (this._zTime = -1e-8), this;
  }, e.play = function(i, r) {
    return i != null && this.seek(i, r), this.reversed(false).paused(false);
  }, e.reverse = function(i, r) {
    return i != null && this.seek(i || this.totalDuration(), r), this.reversed(true).paused(false);
  }, e.pause = function(i, r) {
    return i != null && this.seek(i, r), this.paused(true);
  }, e.resume = function() {
    return this.paused(false);
  }, e.reversed = function(i) {
    return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var i = this.parent || this._dp, r = this._start, s;
    return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(true)) >= r && s < this.endTime(true) - pi);
  }, e.eventCallback = function(i, r, s) {
    var o = this.vars;
    return arguments.length > 1 ? (r ? (o[i] = r, s && (o[i + "Params"] = s), i === "onUpdate" && (this._onUpdate = r)) : delete o[i], this) : o[i];
  }, e.then = function(i) {
    var r = this;
    return new Promise(function(s) {
      var o = gn(i) ? i : Xb, a = function() {
        var f = r.then;
        r.then = null, gn(o) && (o = o(r)) && (o.then || o === r) && (r.then = f), s(o), r.then = f;
      };
      r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a;
    });
  }, e.kill = function() {
    pf(this);
  }, n18;
}();
mr(Mh.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: false, parent: null, _initted: false, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: false, _rts: 1 });
var Ci = function(n18) {
  Ib(e, n18);
  function e(i, r) {
    var s;
    return i === void 0 && (i = {}), s = n18.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = Wi(i.sortChildren), on && _s(i.parent || on, Ws(s), r), i.reversed && s.reverse(), i.paused && s.paused(true), i.scrollTrigger && jb(Ws(s), i.scrollTrigger), s;
  }
  var t = e.prototype;
  return t.to = function(r, s, o) {
    return Lf(0, arguments, this), this;
  }, t.from = function(r, s, o) {
    return Lf(1, arguments, this), this;
  }, t.fromTo = function(r, s, o, a) {
    return Lf(2, arguments, this), this;
  }, t.set = function(r, s, o) {
    return s.duration = 0, s.parent = this, bf(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Rn(r, s, br(this, o), 1), this;
  }, t.call = function(r, s, o) {
    return _s(this, Rn.delayedCall(0, r, s), o);
  }, t.staggerTo = function(r, s, o, a, u, f, h) {
    return o.duration = s, o.stagger = o.stagger || a, o.onComplete = f, o.onCompleteParams = h, o.parent = this, new Rn(r, o, br(this, u)), this;
  }, t.staggerFrom = function(r, s, o, a, u, f, h) {
    return o.runBackwards = 1, bf(o).immediateRender = Wi(o.immediateRender), this.staggerTo(r, s, o, a, u, f, h);
  }, t.staggerFromTo = function(r, s, o, a, u, f, h, d) {
    return a.startAt = o, bf(a).immediateRender = Wi(a.immediateRender), this.staggerTo(r, s, a, u, f, h, d);
  }, t.render = function(r, s, o) {
    var a = this._time, u = this._dirty ? this.totalDuration() : this._tDur, f = this._dur, h = r <= 0 ? 0 : Pn(r), d = this._zTime < 0 != r < 0 && (this._initted || !f), p, g, v, M, S, m, E, T, C, L, b, I;
    if (this !== on && h > u && r >= 0 && (h = u), h !== this._tTime || o || d) {
      if (a !== this._time && f && (h += this._time - a, r += this._time - a), p = h, C = this._start, T = this._ts, m = !T, d && (f || (a = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) {
        if (b = this._yoyo, S = f + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(S * 100 + r, s, o);
        if (p = Pn(h % S), h === u ? (M = this._repeat, p = f) : (L = Pn(h / S), M = ~~L, M && M === L && (p = f, M--), p > f && (p = f)), L = sc(this._tTime, S), !a && this._tTime && L !== M && this._tTime - L * S - this._dur <= 0 && (L = M), b && M & 1 && (p = f - p, I = 1), M !== L && !this._lock) {
          var U = b && L & 1, B = U === (b && M & 1);
          if (M < L && (U = !U), a = U ? 0 : h % f ? f : h, this._lock = 1, this.render(a || (I ? 0 : Pn(M * S)), s, !f)._lock = 0, this._tTime = h, !s && this.parent && ur(this, "onRepeat"), this.vars.repeatRefresh && !I && (this.invalidate()._lock = 1), a && a !== this._time || m !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
          if (f = this._dur, u = this._tDur, B && (this._lock = 2, a = U ? f : -1e-4, this.render(a, true), this.vars.repeatRefresh && !I && this.invalidate()), this._lock = 0, !this._ts && !m) return this;
          uL(this, I);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (E = MV(this, Pn(a), Pn(p)), E && (h -= p - (p = E._start))), this._tTime = h, this._time = p, this._act = !T, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, a = 0), !a && p && !s && !M && (ur(this, "onStart"), this._tTime !== h)) return this;
      if (p >= a && r >= 0) for (g = this._first; g; ) {
        if (v = g._next, (g._act || p >= g._start) && g._ts && E !== g) {
          if (g.parent !== this) return this.render(r, s, o);
          if (g.render(g._ts > 0 ? (p - g._start) * g._ts : (g._dirty ? g.totalDuration() : g._tDur) + (p - g._start) * g._ts, s, o), p !== this._time || !this._ts && !m) {
            E = 0, v && (h += this._zTime = -1e-8);
            break;
          }
        }
        g = v;
      }
      else {
        g = this._last;
        for (var R = r < 0 ? r : p; g; ) {
          if (v = g._prev, (g._act || R <= g._end) && g._ts && E !== g) {
            if (g.parent !== this) return this.render(r, s, o);
            if (g.render(g._ts > 0 ? (R - g._start) * g._ts : (g._dirty ? g.totalDuration() : g._tDur) + (R - g._start) * g._ts, s, o || ei && (g._initted || g._startAt)), p !== this._time || !this._ts && !m) {
              E = 0, v && (h += this._zTime = R ? -1e-8 : pi);
              break;
            }
          }
          g = v;
        }
      }
      if (E && !s && (this.pause(), E.render(p >= a ? 0 : -1e-8)._zTime = p >= a ? 1 : -1, this._ts)) return this._start = C, Kg(this), this.render(r, s, o);
      this._onUpdate && !s && ur(this, "onUpdate", true), (h === u && this._tTime >= this.totalDuration() || !h && a) && (C === this._start || Math.abs(T) !== Math.abs(this._ts)) && (this._lock || ((r || !f) && (h === u && this._ts > 0 || !h && this._ts < 0) && ra(this, 1), !s && !(r < 0 && !a) && (h || a || !u) && (ur(this, h === u && r >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(h < u && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(r, s) {
    var o = this;
    if (ao(s) || (s = br(this, s, r)), !(r instanceof Mh)) {
      if (gi(r)) return r.forEach(function(a) {
        return o.add(a, s);
      }), this;
      if (qn(r)) return this.addLabel(r, s);
      if (gn(r)) r = Rn.delayedCall(0, r);
      else return this;
    }
    return this !== r ? _s(this, r, s) : this;
  }, t.getChildren = function(r, s, o, a) {
    r === void 0 && (r = true), s === void 0 && (s = true), o === void 0 && (o = true), a === void 0 && (a = -1e8);
    for (var u = [], f = this._first; f; ) f._start >= a && (f instanceof Rn ? s && u.push(f) : (o && u.push(f), r && u.push.apply(u, f.getChildren(true, s, o)))), f = f._next;
    return u;
  }, t.getById = function(r) {
    for (var s = this.getChildren(1, 1, 1), o = s.length; o--; ) if (s[o].vars.id === r) return s[o];
  }, t.remove = function(r) {
    return qn(r) ? this.removeLabel(r) : gn(r) ? this.killTweensOf(r) : (r.parent === this && Jg(this, r), r === this._recent && (this._recent = this._last), sl(this));
  }, t.totalTime = function(r, s) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Pn(ar.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), n18.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(r, s) {
    return this.labels[r] = br(this, s), this;
  }, t.removeLabel = function(r) {
    return delete this.labels[r], this;
  }, t.addPause = function(r, s, o) {
    var a = Rn.delayedCall(0, s || yh, o);
    return a.data = "isPause", this._hasPause = 1, _s(this, a, br(this, r));
  }, t.removePause = function(r) {
    var s = this._first;
    for (r = br(this, r); s; ) s._start === r && s.data === "isPause" && ra(s), s = s._next;
  }, t.killTweensOf = function(r, s, o) {
    for (var a = this.getTweensOf(r, o), u = a.length; u--; ) ko !== a[u] && a[u].kill(r, s);
    return this;
  }, t.getTweensOf = function(r, s) {
    for (var o = [], a = Ur(r), u = this._first, f = ao(s), h; u; ) u instanceof Rn ? mV(u._targets, a) && (f ? (!ko || u._initted && u._ts) && u.globalTime(0) <= s && u.globalTime(u.totalDuration()) > s : !s || u.isActive()) && o.push(u) : (h = u.getTweensOf(a, s)).length && o.push.apply(o, h), u = u._next;
    return o;
  }, t.tweenTo = function(r, s) {
    s = s || {};
    var o = this, a = br(o, r), u = s, f = u.startAt, h = u.onStart, d = u.onStartParams, p = u.immediateRender, g, v = Rn.to(o, mr({ ease: s.ease || "none", lazy: false, immediateRender: false, time: a, overwrite: "auto", duration: s.duration || Math.abs((a - (f && "time" in f ? f.time : o._time)) / o.timeScale()) || pi, onStart: function() {
      if (o.pause(), !g) {
        var S = s.duration || Math.abs((a - (f && "time" in f ? f.time : o._time)) / o.timeScale());
        v._dur !== S && oc(v, S, 0, 1).render(v._time, true, true), g = 1;
      }
      h && h.apply(v, d || []);
    } }, s));
    return p ? v.render(0) : v;
  }, t.tweenFromTo = function(r, s, o) {
    return this.tweenTo(s, mr({ startAt: { time: br(this, r) } }, o));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(r) {
    return r === void 0 && (r = this._time), SA(this, br(this, r));
  }, t.previousLabel = function(r) {
    return r === void 0 && (r = this._time), SA(this, br(this, r), 1);
  }, t.currentLabel = function(r) {
    return arguments.length ? this.seek(r, true) : this.previousLabel(this._time + pi);
  }, t.shiftChildren = function(r, s, o) {
    o === void 0 && (o = 0);
    for (var a = this._first, u = this.labels, f; a; ) a._start >= o && (a._start += r, a._end += r), a = a._next;
    if (s) for (f in u) u[f] >= o && (u[f] += r);
    return sl(this);
  }, t.invalidate = function(r) {
    var s = this._first;
    for (this._lock = 0; s; ) s.invalidate(r), s = s._next;
    return n18.prototype.invalidate.call(this, r);
  }, t.clear = function(r) {
    r === void 0 && (r = true);
    for (var s = this._first, o; s; ) o = s._next, this.remove(s), s = o;
    return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), sl(this);
  }, t.totalDuration = function(r) {
    var s = 0, o = this, a = o._last, u = As, f, h, d;
    if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
    if (o._dirty) {
      for (d = o.parent; a; ) f = a._prev, a._dirty && a.totalDuration(), h = a._start, h > u && o._sort && a._ts && !o._lock ? (o._lock = 1, _s(o, a, h - a._delay, 1)._lock = 0) : u = h, h < 0 && a._ts && (s -= h, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += h / o._ts, o._time -= h, o._tTime -= h), o.shiftChildren(-h, false, -1 / 0), u = 0), a._end > s && a._ts && (s = a._end), a = f;
      oc(o, o === on && o._time > s ? o._time : s, 1, 1), o._dirty = 0;
    }
    return o._tDur;
  }, e.updateRoot = function(r) {
    if (on._ts && (Gb(on, eg(r, on)), Vb = ar.frame), ar.frame >= _A) {
      _A += hr.autoSleep || 120;
      var s = on._first;
      if ((!s || !s._ts) && hr.autoSleep && ar._listeners.length < 2) {
        for (; s && !s._ts; ) s = s._next;
        s || ar.sleep();
      }
    }
  }, e;
}(Mh);
mr(Ci.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var kV = function(e, t, i, r, s, o, a) {
  var u = new Yi(this._pt, e, t, 0, 1, _L, null, s), f = 0, h = 0, d, p, g, v, M, S, m, E;
  for (u.b = i, u.e = r, i += "", r += "", (m = ~r.indexOf("random(")) && (r = xh(r)), o && (E = [i, r], o(E, e, t), i = E[0], r = E[1]), p = i.match(Ev) || []; d = Ev.exec(r); ) v = d[0], M = r.substring(f, d.index), g ? g = (g + 1) % 5 : M.substr(-5) === "rgba(" && (g = 1), v !== p[h++] && (S = parseFloat(p[h - 1]) || 0, u._pt = { _next: u._pt, p: M || h === 1 ? M : ",", s: S, c: v.charAt(1) === "=" ? Bu(S, v) - S : parseFloat(v) - S, m: g && g < 4 ? Math.round : 0 }, f = Ev.lastIndex);
  return u.c = f < r.length ? r.substring(f, r.length) : "", u.fp = a, (Ob.test(r) || m) && (u.e = 0), this._pt = u, u;
}, C1 = function(e, t, i, r, s, o, a, u, f, h) {
  gn(r) && (r = r(s || 0, e, o));
  var d = e[t], p = i !== "get" ? i : gn(d) ? f ? e[t.indexOf("set") || !gn(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](f) : e[t]() : d, g = gn(d) ? f ? GV : mL : P1, v;
  if (qn(r) && (~r.indexOf("random(") && (r = xh(r)), r.charAt(1) === "=" && (v = Bu(p, r) + (di(p) || 0), (v || v === 0) && (r = v))), !h || p !== r || Rx) return !isNaN(p * r) && r !== "" ? (v = new Yi(this._pt, e, t, +p || 0, r - (p || 0), typeof d == "boolean" ? XV : gL, 0, g), f && (v.fp = f), a && v.modifier(a, this, e), this._pt = v) : (!d && !(t in e) && w1(t, r), kV.call(this, e, t, p, r, g, u || hr.stringFilter, f));
}, zV = function(e, t, i, r, s) {
  if (gn(e) && (e = If(e, s, t, i, r)), !Ps(e) || e.style && e.nodeType || gi(e) || Nb(e)) return qn(e) ? If(e, s, t, i, r) : e;
  var o = {}, a;
  for (a in e) o[a] = If(e[a], s, t, i, r);
  return o;
}, hL = function(e, t, i, r, s, o) {
  var a, u, f, h;
  if (rr[e] && (a = new rr[e]()).init(s, a.rawVars ? t[e] : zV(t[e], r, s, o, i), i, r, o) !== false && (i._pt = u = new Yi(i._pt, s, e, 0, 1, a.render, a, 0, a.priority), i !== Iu)) for (f = i._ptLookup[i._targets.indexOf(s)], h = a._props.length; h--; ) f[a._props[h]] = u;
  return a;
}, ko, Rx, R1 = function n14(e, t, i) {
  var r = e.vars, s = r.ease, o = r.startAt, a = r.immediateRender, u = r.lazy, f = r.onUpdate, h = r.runBackwards, d = r.yoyoEase, p = r.keyframes, g = r.autoRevert, v = e._dur, M = e._startAt, S = e._targets, m = e.parent, E = m && m.data === "nested" ? m.vars.targets : S, T = e._overwrite === "auto" && !y1, C = e.timeline, L, b, I, U, B, R, D, j, te, X, Q, J, ce;
  if (C && (!p || !s) && (s = "none"), e._ease = ol(s, ic.ease), e._yEase = d ? lL(ol(d === true ? s : d, ic.ease)) : 0, d && e._yoyo && !e._repeat && (d = e._yEase, e._yEase = e._ease, e._ease = d), e._from = !C && !!r.runBackwards, !C || p && !r.stagger) {
    if (j = S[0] ? rl(S[0]).harness : 0, J = j && r[j.prop], L = $m(r, E1), M && (M._zTime < 0 && M.progress(1), t < 0 && h && a && !g ? M.render(-1, true) : M.revert(h && v ? gm : dV), M._lazy = 0), o) {
      if (ra(e._startAt = Rn.set(S, mr({ data: "isStart", overwrite: false, parent: m, immediateRender: true, lazy: !M && Wi(u), startAt: null, delay: 0, onUpdate: f && function() {
        return ur(e, "onUpdate");
      }, stagger: 0 }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ei || !a && !g) && e._startAt.revert(gm), a && v && t <= 0 && i <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (h && v && !M) {
      if (t && (a = false), I = mr({ overwrite: false, data: "isFromStart", lazy: a && !M && Wi(u), immediateRender: a, stagger: 0, parent: m }, L), J && (I[j.prop] = J), ra(e._startAt = Rn.set(S, I)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (ei ? e._startAt.revert(gm) : e._startAt.render(-1, true)), e._zTime = t, !a) n14(e._startAt, pi, pi);
      else if (!t) return;
    }
    for (e._pt = e._ptCache = 0, u = v && Wi(u) || u && !v, b = 0; b < S.length; b++) {
      if (B = S[b], D = B._gsap || A1(S)[b]._gsap, e._ptLookup[b] = X = {}, Mx[D.id] && Qo.length && Qm(), Q = E === S ? b : E.indexOf(B), j && (te = new j()).init(B, J || L, e, Q, E) !== false && (e._pt = U = new Yi(e._pt, B, te.name, 0, 1, te.render, te, 0, te.priority), te._props.forEach(function(V) {
        X[V] = U;
      }), te.priority && (R = 1)), !j || J) for (I in L) rr[I] && (te = hL(I, L, e, Q, B, E)) ? te.priority && (R = 1) : X[I] = U = C1.call(e, B, I, "get", L[I], Q, E, 0, r.stringFilter);
      e._op && e._op[b] && e.kill(B, e._op[b]), T && e._pt && (ko = e, on.killTweensOf(B, X, e.globalTime(t)), ce = !e.parent, ko = 0), e._pt && u && (Mx[D.id] = 1);
    }
    R && vL(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = f, e._initted = (!e._op || e._pt) && !ce, p && t <= 0 && C.render(As, true, true);
}, BV = function(e, t, i, r, s, o, a, u) {
  var f = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, d, p, g;
  if (!f) for (f = e._ptCache[t] = [], p = e._ptLookup, g = e._targets.length; g--; ) {
    if (h = p[g][t], h && h.d && h.d._pt) for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
    if (!h) return Rx = 1, e.vars[t] = "+=0", R1(e, a), Rx = 0, u ? vh(t + " not eligible for reset") : 1;
    f.push(h);
  }
  for (g = f.length; g--; ) d = f[g], h = d._pt || d, h.s = (r || r === 0) && !s ? r : h.s + (r || 0) + o * h.c, h.c = i - h.s, d.e && (d.e = Sn(i) + di(d.e)), d.b && (d.b = h.s + di(d.b));
}, VV = function(e, t) {
  var i = e[0] ? rl(e[0]).harness : 0, r = i && i.aliases, s, o, a, u;
  if (!r) return t;
  s = rc({}, t);
  for (o in r) if (o in s) for (u = r[o].split(","), a = u.length; a--; ) s[u[a]] = s[o];
  return s;
}, HV = function(e, t, i, r) {
  var s = t.ease || r || "power1.inOut", o, a;
  if (gi(t)) a = i[e] || (i[e] = []), t.forEach(function(u, f) {
    return a.push({ t: f / (t.length - 1) * 100, v: u, e: s });
  });
  else for (o in t) a = i[o] || (i[o] = []), o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s });
}, If = function(e, t, i, r, s) {
  return gn(e) ? e.call(t, i, r, s) : qn(e) && ~e.indexOf("random(") ? xh(e) : e;
}, dL = T1 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", pL = {};
Xi(dL + ",id,stagger,delay,duration,paused,scrollTrigger", function(n18) {
  return pL[n18] = 1;
});
var Rn = function(n18) {
  Ib(e, n18);
  function e(i, r, s, o) {
    var a;
    typeof r == "number" && (s.duration = r, r = s, s = null), a = n18.call(this, o ? r : bf(r)) || this;
    var u = a.vars, f = u.duration, h = u.delay, d = u.immediateRender, p = u.stagger, g = u.overwrite, v = u.keyframes, M = u.defaults, S = u.scrollTrigger, m = u.yoyoEase, E = r.parent || on, T = (gi(i) || Nb(i) ? ao(i[0]) : "length" in r) ? [i] : Ur(i), C, L, b, I, U, B, R, D;
    if (a._targets = T.length ? A1(T) : vh("GSAP target " + i + " not found. https://gsap.com", !hr.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = g, v || p || jp(f) || jp(h)) {
      if (r = a.vars, C = a.timeline = new Ci({ data: "nested", defaults: M || {}, targets: E && E.data === "nested" ? E.vars.targets : T }), C.kill(), C.parent = C._dp = Ws(a), C._start = 0, p || jp(f) || jp(h)) {
        if (I = T.length, R = p && Qb(p), Ps(p)) for (U in p) ~dL.indexOf(U) && (D || (D = {}), D[U] = p[U]);
        for (L = 0; L < I; L++) b = $m(r, pL), b.stagger = 0, m && (b.yoyoEase = m), D && rc(b, D), B = T[L], b.duration = +If(f, Ws(a), L, B, T), b.delay = (+If(h, Ws(a), L, B, T) || 0) - a._delay, !p && I === 1 && b.delay && (a._delay = h = b.delay, a._start += h, b.delay = 0), C.to(B, b, R ? R(L, B, T) : 0), C._ease = At.none;
        C.duration() ? f = h = 0 : a.timeline = 0;
      } else if (v) {
        bf(mr(C.vars.defaults, { ease: "none" })), C._ease = ol(v.ease || r.ease || "none");
        var j = 0, te, X, Q;
        if (gi(v)) v.forEach(function(J) {
          return C.to(T, J, ">");
        }), C.duration();
        else {
          b = {};
          for (U in v) U === "ease" || U === "easeEach" || HV(U, v[U], b, v.easeEach);
          for (U in b) for (te = b[U].sort(function(J, ce) {
            return J.t - ce.t;
          }), j = 0, L = 0; L < te.length; L++) X = te[L], Q = { ease: X.e, duration: (X.t - (L ? te[L - 1].t : 0)) / 100 * f }, Q[U] = X.v, C.to(T, Q, j), j += Q.duration;
          C.duration() < f && C.to({}, { duration: f - C.duration() });
        }
      }
      f || a.duration(f = C.duration());
    } else a.timeline = 0;
    return g === true && !y1 && (ko = Ws(a), on.killTweensOf(T), ko = 0), _s(E, Ws(a), s), r.reversed && a.reverse(), r.paused && a.paused(true), (d || !f && !v && a._start === Pn(E._time) && Wi(d) && yV(Ws(a)) && E.data !== "nested") && (a._tTime = -1e-8, a.render(Math.max(0, -h) || 0)), S && jb(Ws(a), S), a;
  }
  var t = e.prototype;
  return t.render = function(r, s, o) {
    var a = this._time, u = this._tDur, f = this._dur, h = r < 0, d = r > u - pi && !h ? u : r < pi ? 0 : r, p, g, v, M, S, m, E, T, C;
    if (!f) SV(this, r, s, o);
    else if (d !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h || this._lazy) {
      if (p = d, T = this.timeline, this._repeat) {
        if (M = f + this._rDelay, this._repeat < -1 && h) return this.totalTime(M * 100 + r, s, o);
        if (p = Pn(d % M), d === u ? (v = this._repeat, p = f) : (S = Pn(d / M), v = ~~S, v && v === S ? (p = f, v--) : p > f && (p = f)), m = this._yoyo && v & 1, m && (C = this._yEase, p = f - p), S = sc(this._tTime, M), p === a && !o && this._initted && v === S) return this._tTime = d, this;
        v !== S && (T && this._yEase && uL(T, m), this.vars.repeatRefresh && !m && !this._lock && p !== M && this._initted && (this._lock = o = 1, this.render(Pn(M * v), true).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (Zb(this, h ? r : p, o, s, d)) return this._tTime = 0, this;
        if (a !== this._time && !(o && this.vars.repeatRefresh && v !== S)) return this;
        if (f !== this._dur) return this.render(r, s, o);
      }
      if (this._tTime = d, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = E = (C || this._ease)(p / f), this._from && (this.ratio = E = 1 - E), p && !a && !s && !v && (ur(this, "onStart"), this._tTime !== d)) return this;
      for (g = this._pt; g; ) g.r(E, g.d), g = g._next;
      T && T.render(r < 0 ? r : T._dur * T._ease(p / this._dur), s, o) || this._startAt && (this._zTime = r), this._onUpdate && !s && (h && wx(this, r, s, o), ur(this, "onUpdate")), this._repeat && v !== S && this.vars.onRepeat && !s && this.parent && ur(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (h && !this._onUpdate && wx(this, r, true, true), (r || !f) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && ra(this, 1), !s && !(h && !a) && (d || a || m) && (ur(this, d === u ? "onComplete" : "onReverseComplete", true), this._prom && !(d < u && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(r) {
    return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), n18.prototype.invalidate.call(this, r);
  }, t.resetTo = function(r, s, o, a, u) {
    Sh || ar.wake(), this._ts || this.play();
    var f = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || R1(this, f), h = this._ease(f / this._dur), BV(this, r, s, o, a, h, f, u) ? this.resetTo(r, s, o, a, 1) : (Qg(this, 0), this.parent || Yb(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(r, s) {
    if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? pf(this) : this.scrollTrigger && this.scrollTrigger.kill(!!ei), this;
    if (this.timeline) {
      var o = this.timeline.totalDuration();
      return this.timeline.killTweensOf(r, s, ko && ko.vars.overwrite !== true)._first || pf(this), this.parent && o !== this.timeline.totalDuration() && oc(this, this._dur * this.timeline._tDur / o, 0, 1), this;
    }
    var a = this._targets, u = r ? Ur(r) : a, f = this._ptLookup, h = this._pt, d, p, g, v, M, S, m;
    if ((!s || s === "all") && _V(a, u)) return s === "all" && (this._pt = 0), pf(this);
    for (d = this._op = this._op || [], s !== "all" && (qn(s) && (M = {}, Xi(s, function(E) {
      return M[E] = 1;
    }), s = M), s = VV(a, s)), m = a.length; m--; ) if (~u.indexOf(a[m])) {
      p = f[m], s === "all" ? (d[m] = s, v = p, g = {}) : (g = d[m] = d[m] || {}, v = s);
      for (M in v) S = p && p[M], S && ((!("kill" in S.d) || S.d.kill(M) === true) && Jg(this, S, "_pt"), delete p[M]), g !== "all" && (g[M] = 1);
    }
    return this._initted && !this._pt && h && pf(this), this;
  }, e.to = function(r, s) {
    return new e(r, s, arguments[2]);
  }, e.from = function(r, s) {
    return Lf(1, arguments);
  }, e.delayedCall = function(r, s, o, a) {
    return new e(s, 0, { immediateRender: false, lazy: false, overwrite: false, delay: r, onComplete: s, onReverseComplete: s, onCompleteParams: o, onReverseCompleteParams: o, callbackScope: a });
  }, e.fromTo = function(r, s, o) {
    return Lf(2, arguments);
  }, e.set = function(r, s) {
    return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s);
  }, e.killTweensOf = function(r, s, o) {
    return on.killTweensOf(r, s, o);
  }, e;
}(Mh);
mr(Rn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Xi("staggerTo,staggerFrom,staggerFromTo", function(n18) {
  Rn[n18] = function() {
    var e = new Ci(), t = Tx.call(arguments, 0);
    return t.splice(n18 === "staggerFromTo" ? 5 : 4, 0, 0), e[n18].apply(e, t);
  };
});
var P1 = function(e, t, i) {
  return e[t] = i;
}, mL = function(e, t, i) {
  return e[t](i);
}, GV = function(e, t, i, r) {
  return e[t](r.fp, i);
}, WV = function(e, t, i) {
  return e.setAttribute(t, i);
}, b1 = function(e, t) {
  return gn(e[t]) ? mL : x1(e[t]) && e.setAttribute ? WV : P1;
}, gL = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, XV = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, _L = function(e, t) {
  var i = t._pt, r = "";
  if (!e && t.b) r = t.b;
  else if (e === 1 && t.e) r = t.e;
  else {
    for (; i; ) r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r, i = i._next;
    r += t.c;
  }
  t.set(t.t, t.p, r, t);
}, L1 = function(e, t) {
  for (var i = t._pt; i; ) i.r(e, i.d), i = i._next;
}, YV = function(e, t, i, r) {
  for (var s = this._pt, o; s; ) o = s._next, s.p === r && s.modifier(e, t, i), s = o;
}, qV = function(e) {
  for (var t = this._pt, i, r; t; ) r = t._next, t.p === e && !t.op || t.op === e ? Jg(this, t, "_pt") : t.dep || (i = 1), t = r;
  return !i;
}, jV = function(e, t, i, r) {
  r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
}, vL = function(e) {
  for (var t = e._pt, i, r, s, o; t; ) {
    for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
    (t._prev = r ? r._prev : o) ? t._prev._next = t : s = t, (t._next = r) ? r._prev = t : o = t, t = i;
  }
  e._pt = s;
}, Yi = function() {
  function n18(t, i, r, s, o, a, u, f, h) {
    this.t = i, this.s = s, this.c = o, this.p = r, this.r = a || gL, this.d = u || this, this.set = f || P1, this.pr = h || 0, this._next = t, t && (t._prev = this);
  }
  var e = n18.prototype;
  return e.modifier = function(i, r, s) {
    this.mSet = this.mSet || this.set, this.set = jV, this.m = i, this.mt = s, this.tween = r;
  }, n18;
}();
Xi(T1 + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n18) {
  return E1[n18] = 1;
});
pr.TweenMax = pr.TweenLite = Rn;
pr.TimelineLite = pr.TimelineMax = Ci;
on = new Ci({ sortChildren: false, defaults: ic, autoRemoveChildren: true, id: "root", smoothChildTiming: true });
hr.stringFilter = aL;
var al = [], vm = {}, ZV = [], wA = 0, JV = 0, Pv = function(e) {
  return (vm[e] || ZV).map(function(t) {
    return t();
  });
}, Px = function() {
  var e = Date.now(), t = [];
  e - wA > 2 && (Pv("matchMediaInit"), al.forEach(function(i) {
    var r = i.queries, s = i.conditions, o, a, u, f;
    for (a in r) o = ps.matchMedia(r[a]).matches, o && (u = 1), o !== s[a] && (s[a] = o, f = 1);
    f && (i.revert(), u && t.push(i));
  }), Pv("matchMediaRevert"), t.forEach(function(i) {
    return i.onMatch(i, function(r) {
      return i.add(null, r);
    });
  }), wA = e, Pv("matchMedia"));
}, yL = function() {
  function n18(t, i) {
    this.selector = i && Ax(i), this.data = [], this._r = [], this.isReverted = false, this.id = JV++, t && this.add(t);
  }
  var e = n18.prototype;
  return e.add = function(i, r, s) {
    gn(i) && (s = r, r = i, i = gn);
    var o = this, a = function() {
      var f = en, h = o.selector, d;
      return f && f !== o && f.data.push(o), s && (o.selector = Ax(s)), en = o, d = r.apply(o, arguments), gn(d) && o._r.push(d), en = f, o.selector = h, o.isReverted = false, d;
    };
    return o.last = a, i === gn ? a(o, function(u) {
      return o.add(null, u);
    }) : i ? o[i] = a : a;
  }, e.ignore = function(i) {
    var r = en;
    en = null, i(this), en = r;
  }, e.getTweens = function() {
    var i = [];
    return this.data.forEach(function(r) {
      return r instanceof n18 ? i.push.apply(i, r.getTweens()) : r instanceof Rn && !(r.parent && r.parent.data === "nested") && i.push(r);
    }), i;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(i, r) {
    var s = this;
    if (i ? function() {
      for (var a = s.getTweens(), u = s.data.length, f; u--; ) f = s.data[u], f.data === "isFlip" && (f.revert(), f.getChildren(true, true, false).forEach(function(h) {
        return a.splice(a.indexOf(h), 1);
      }));
      for (a.map(function(h) {
        return { g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0, t: h };
      }).sort(function(h, d) {
        return d.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(i);
      }), u = s.data.length; u--; ) f = s.data[u], f instanceof Ci ? f.data !== "nested" && (f.scrollTrigger && f.scrollTrigger.revert(), f.kill()) : !(f instanceof Rn) && f.revert && f.revert(i);
      s._r.forEach(function(h) {
        return h(i, s);
      }), s.isReverted = true;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), r) for (var o = al.length; o--; ) al[o].id === this.id && al.splice(o, 1);
  }, e.revert = function(i) {
    this.kill(i || {});
  }, n18;
}(), KV = function() {
  function n18(t) {
    this.contexts = [], this.scope = t, en && en.data.push(this);
  }
  var e = n18.prototype;
  return e.add = function(i, r, s) {
    Ps(i) || (i = { matches: i });
    var o = new yL(0, s || this.scope), a = o.conditions = {}, u, f, h;
    en && !o.selector && (o.selector = en.selector), this.contexts.push(o), r = o.add("onMatch", r), o.queries = i;
    for (f in i) f === "all" ? h = 1 : (u = ps.matchMedia(i[f]), u && (al.indexOf(o) < 0 && al.push(o), (a[f] = u.matches) && (h = 1), u.addListener ? u.addListener(Px) : u.addEventListener("change", Px)));
    return h && r(o, function(d) {
      return o.add(null, d);
    }), this;
  }, e.revert = function(i) {
    this.kill(i || {});
  }, e.kill = function(i) {
    this.contexts.forEach(function(r) {
      return r.kill(i, true);
    });
  }, n18;
}(), tg = { registerPlugin: function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
  t.forEach(function(r) {
    return rL(r);
  });
}, timeline: function(e) {
  return new Ci(e);
}, getTweensOf: function(e, t) {
  return on.getTweensOf(e, t);
}, getProperty: function(e, t, i, r) {
  qn(e) && (e = Ur(e)[0]);
  var s = rl(e || {}).get, o = i ? Xb : Wb;
  return i === "native" && (i = ""), e && (t ? o((rr[t] && rr[t].get || s)(e, t, i, r)) : function(a, u, f) {
    return o((rr[a] && rr[a].get || s)(e, a, u, f));
  });
}, quickSetter: function(e, t, i) {
  if (e = Ur(e), e.length > 1) {
    var r = e.map(function(h) {
      return ji.quickSetter(h, t, i);
    }), s = r.length;
    return function(h) {
      for (var d = s; d--; ) r[d](h);
    };
  }
  e = e[0] || {};
  var o = rr[t], a = rl(e), u = a.harness && (a.harness.aliases || {})[t] || t, f = o ? function(h) {
    var d = new o();
    Iu._pt = 0, d.init(e, i ? h + i : h, Iu, 0, [e]), d.render(1, d), Iu._pt && L1(1, Iu);
  } : a.set(e, u);
  return o ? f : function(h) {
    return f(e, u, i ? h + i : h, a, 1);
  };
}, quickTo: function(e, t, i) {
  var r, s = ji.to(e, mr((r = {}, r[t] = "+=0.1", r.paused = true, r.stagger = 0, r), i || {})), o = function(u, f, h) {
    return s.resetTo(t, u, f, h);
  };
  return o.tween = s, o;
}, isTweening: function(e) {
  return on.getTweensOf(e, true).length > 0;
}, defaults: function(e) {
  return e && e.ease && (e.ease = ol(e.ease, ic.ease)), vA(ic, e || {});
}, config: function(e) {
  return vA(hr, e || {});
}, registerEffect: function(e) {
  var t = e.name, i = e.effect, r = e.plugins, s = e.defaults, o = e.extendTimeline;
  (r || "").split(",").forEach(function(a) {
    return a && !rr[a] && !pr[a] && vh(t + " effect requires " + a + " plugin.");
  }), Tv[t] = function(a, u, f) {
    return i(Ur(a), mr(u || {}, s), f);
  }, o && (Ci.prototype[t] = function(a, u, f) {
    return this.add(Tv[t](a, Ps(u) ? u : (f = u) && {}, this), f);
  });
}, registerEase: function(e, t) {
  At[e] = ol(t);
}, parseEase: function(e, t) {
  return arguments.length ? ol(e, t) : At;
}, getById: function(e) {
  return on.getById(e);
}, exportRoot: function(e, t) {
  e === void 0 && (e = {});
  var i = new Ci(e), r, s;
  for (i.smoothChildTiming = Wi(e.smoothChildTiming), on.remove(i), i._dp = 0, i._time = i._tTime = on._time, r = on._first; r; ) s = r._next, (t || !(!r._dur && r instanceof Rn && r.vars.onComplete === r._targets[0])) && _s(i, r, r._start - r._delay), r = s;
  return _s(on, i, 0), i;
}, context: function(e, t) {
  return e ? new yL(e, t) : en;
}, matchMedia: function(e) {
  return new KV(e);
}, matchMediaRefresh: function() {
  return al.forEach(function(e) {
    var t = e.conditions, i, r;
    for (r in t) t[r] && (t[r] = false, i = 1);
    i && e.revert();
  }) || Px();
}, addEventListener: function(e, t) {
  var i = vm[e] || (vm[e] = []);
  ~i.indexOf(t) || i.push(t);
}, removeEventListener: function(e, t) {
  var i = vm[e], r = i && i.indexOf(t);
  r >= 0 && i.splice(r, 1);
}, utils: { wrap: PV, wrapYoyo: bV, distribute: Qb, random: eL, snap: $b, normalize: RV, getUnit: di, clamp: EV, splitColor: sL, toArray: Ur, selector: Ax, mapRange: nL, pipe: AV, unitize: CV, interpolate: LV, shuffle: Kb }, install: zb, effects: Tv, ticker: ar, updateRoot: Ci.updateRoot, plugins: rr, globalTimeline: on, core: { PropTween: Yi, globals: Bb, Tween: Rn, Timeline: Ci, Animation: Mh, getCache: rl, _removeLinkedListItem: Jg, reverting: function() {
  return ei;
}, context: function(e) {
  return e && en && (en.data.push(e), e._ctx = en), en;
}, suppressOverwrites: function(e) {
  return y1 = e;
} } };
Xi("to,from,fromTo,delayedCall,set,killTweensOf", function(n18) {
  return tg[n18] = Rn[n18];
});
ar.add(Ci.updateRoot);
Iu = tg.to({}, { duration: 0 });
var QV = function(e, t) {
  for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; ) i = i._next;
  return i;
}, $V = function(e, t) {
  var i = e._targets, r, s, o;
  for (r in t) for (s = i.length; s--; ) o = e._ptLookup[s][r], o && (o = o.d) && (o._pt && (o = QV(o, r)), o && o.modifier && o.modifier(t[r], e, i[s], r));
}, bv = function(e, t) {
  return { name: e, rawVars: 1, init: function(r, s, o) {
    o._onInit = function(a) {
      var u, f;
      if (qn(s) && (u = {}, Xi(s, function(h) {
        return u[h] = 1;
      }), s = u), t) {
        u = {};
        for (f in s) u[f] = t(s[f]);
        s = u;
      }
      $V(a, s);
    };
  } };
}, ji = tg.registerPlugin({ name: "attr", init: function(e, t, i, r, s) {
  var o, a, u;
  this.tween = i;
  for (o in t) u = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (u || 0) + "", t[o], r, s, 0, 0, o), a.op = o, a.b = u, this._props.push(o);
}, render: function(e, t) {
  for (var i = t._pt; i; ) ei ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next;
} }, { name: "endArray", init: function(e, t) {
  for (var i = t.length; i--; ) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
} }, bv("roundProps", Cx), bv("modifiers"), bv("snap", $b)) || tg;
Rn.version = Ci.version = ji.version = "3.12.7";
kb = 1;
S1() && ac();
At.Power0;
At.Power1;
At.Power2;
At.Power3;
At.Power4;
At.Linear;
At.Quad;
At.Cubic;
At.Quart;
At.Quint;
At.Strong;
At.Elastic;
At.Back;
At.SteppedEase;
At.Bounce;
At.Sine;
At.Expo;
At.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var EA, zo, Vu, I1, Za, TA, D1, eH = function() {
  return typeof window < "u";
}, lo = {}, za = 180 / Math.PI, Hu = Math.PI / 180, cu = Math.atan2, AA = 1e8, N1 = /([A-Z])/g, tH = /(left|right|width|margin|padding|x)/i, nH = /[\s,\(]\S/, xs = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, bx = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, iH = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, rH = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, sH = function(e, t) {
  var i = t.s + t.c * e;
  t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
}, xL = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, SL = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, oH = function(e, t, i) {
  return e.style[t] = i;
}, aH = function(e, t, i) {
  return e.style.setProperty(t, i);
}, lH = function(e, t, i) {
  return e._gsap[t] = i;
}, uH = function(e, t, i) {
  return e._gsap.scaleX = e._gsap.scaleY = i;
}, cH = function(e, t, i, r, s) {
  var o = e._gsap;
  o.scaleX = o.scaleY = i, o.renderTransform(s, o);
}, fH = function(e, t, i, r, s) {
  var o = e._gsap;
  o[t] = i, o.renderTransform(s, o);
}, ln = "transform", qi = ln + "Origin", hH = function n15(e, t) {
  var i = this, r = this.target, s = r.style, o = r._gsap;
  if (e in lo && s) {
    if (this.tfm = this.tfm || {}, e !== "transform") e = xs[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
      return i.tfm[a] = Ys(r, a);
    }) : this.tfm[e] = o.x ? o[e] : Ys(r, e), e === qi && (this.tfm.zOrigin = o.zOrigin);
    else return xs.transform.split(",").forEach(function(a) {
      return n15.call(i, a, t);
    });
    if (this.props.indexOf(ln) >= 0) return;
    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(qi, t, "")), e = ln;
  }
  (s || t) && this.props.push(e, t, s[e]);
}, ML = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, dH = function() {
  var e = this.props, t = this.target, i = t.style, r = t._gsap, s, o;
  for (s = 0; s < e.length; s += 3) e[s + 1] ? e[s + 1] === 2 ? t[e[s]](e[s + 2]) : t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(N1, "-$1").toLowerCase());
  if (this.tfm) {
    for (o in this.tfm) r[o] = this.tfm[o];
    r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = D1(), (!s || !s.isStart) && !i[ln] && (ML(i), r.zOrigin && i[qi] && (i[qi] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1);
  }
}, wL = function(e, t) {
  var i = { target: e, props: [], revert: dH, save: hH };
  return e._gsap || ji.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(r) {
    return i.save(r);
  }), i;
}, EL, Lx = function(e, t) {
  var i = zo.createElementNS ? zo.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : zo.createElement(e);
  return i && i.style ? i : zo.createElement(e);
}, Cs = function n16(e, t, i) {
  var r = getComputedStyle(e);
  return r[t] || r.getPropertyValue(t.replace(N1, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n16(e, lc(t) || t, 1) || "";
}, CA = "O,Moz,ms,Ms,Webkit".split(","), lc = function(e, t, i) {
  var r = t || Za, s = r.style, o = 5;
  if (e in s && !i) return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(CA[o] + e in s); ) ;
  return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? CA[o] : "") + e;
}, Ix = function() {
  eH() && window.document && (EA = window, zo = EA.document, Vu = zo.documentElement, Za = Lx("div") || { style: {} }, Lx("div"), ln = lc(ln), qi = ln + "Origin", Za.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", EL = !!lc("perspective"), D1 = ji.core.reverting, I1 = 1);
}, RA = function(e) {
  var t = e.ownerSVGElement, i = Lx("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = e.cloneNode(true), s;
  r.style.display = "block", i.appendChild(r), Vu.appendChild(i);
  try {
    s = r.getBBox();
  } catch {
  }
  return i.removeChild(r), Vu.removeChild(i), s;
}, PA = function(e, t) {
  for (var i = t.length; i--; ) if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
}, TL = function(e) {
  var t, i;
  try {
    t = e.getBBox();
  } catch {
    t = RA(e), i = 1;
  }
  return t && (t.width || t.height) || i || (t = RA(e)), t && !t.width && !t.x && !t.y ? { x: +PA(e, ["x", "cx", "x1"]) || 0, y: +PA(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t;
}, AL = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && TL(e));
}, gl = function(e, t) {
  if (t) {
    var i = e.style, r;
    t in lo && t !== qi && (t = ln), i.removeProperty ? (r = t.substr(0, 2), (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(r === "--" ? t : t.replace(N1, "-$1").toLowerCase())) : i.removeAttribute(t);
  }
}, Bo = function(e, t, i, r, s, o) {
  var a = new Yi(e._pt, t, i, 0, 1, o ? SL : xL);
  return e._pt = a, a.b = r, a.e = s, e._props.push(i), a;
}, bA = { deg: 1, rad: 1, turn: 1 }, pH = { grid: 1, flex: 1 }, sa = function n17(e, t, i, r) {
  var s = parseFloat(i) || 0, o = (i + "").trim().substr((s + "").length) || "px", a = Za.style, u = tH.test(t), f = e.tagName.toLowerCase() === "svg", h = (f ? "client" : "offset") + (u ? "Width" : "Height"), d = 100, p = r === "px", g = r === "%", v, M, S, m;
  if (r === o || !s || bA[r] || bA[o]) return s;
  if (o !== "px" && !p && (s = n17(e, t, i, "px")), m = e.getCTM && AL(e), (g || o === "%") && (lo[t] || ~t.indexOf("adius"))) return v = m ? e.getBBox()[u ? "width" : "height"] : e[h], Sn(g ? s / v * d : s / 100 * v);
  if (a[u ? "width" : "height"] = d + (p ? o : r), M = r !== "rem" && ~t.indexOf("adius") || r === "em" && e.appendChild && !f ? e : e.parentNode, m && (M = (e.ownerSVGElement || {}).parentNode), (!M || M === zo || !M.appendChild) && (M = zo.body), S = M._gsap, S && g && S.width && u && S.time === ar.time && !S.uncache) return Sn(s / S.width * d);
  if (g && (t === "height" || t === "width")) {
    var E = e.style[t];
    e.style[t] = d + r, v = e[h], E ? e.style[t] = E : gl(e, t);
  } else (g || o === "%") && !pH[Cs(M, "display")] && (a.position = Cs(e, "position")), M === e && (a.position = "static"), M.appendChild(Za), v = Za[h], M.removeChild(Za), a.position = "absolute";
  return u && g && (S = rl(M), S.time = ar.time, S.width = M[h]), Sn(p ? v * s / d : v && s ? d / v * s : 0);
}, Ys = function(e, t, i, r) {
  var s;
  return I1 || Ix(), t in xs && t !== "transform" && (t = xs[t], ~t.indexOf(",") && (t = t.split(",")[0])), lo[t] && t !== "transform" ? (s = Eh(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : ig(Cs(e, qi)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = ng[t] && ng[t](e, t, i) || Cs(e, t) || Hb(e, t) || (t === "opacity" ? 1 : 0))), i && !~(s + "").trim().indexOf(" ") ? sa(e, t, s, i) + i : s;
}, mH = function(e, t, i, r) {
  if (!i || i === "none") {
    var s = lc(t, e, 1), o = s && Cs(e, s, 1);
    o && o !== i ? (t = s, i = o) : t === "borderColor" && (i = Cs(e, "borderTopColor"));
  }
  var a = new Yi(this._pt, e.style, t, 0, 1, _L), u = 0, f = 0, h, d, p, g, v, M, S, m, E, T, C, L;
  if (a.b = i, a.e = r, i += "", r += "", r === "auto" && (M = e.style[t], e.style[t] = r, r = Cs(e, t) || r, M ? e.style[t] = M : gl(e, t)), h = [i, r], aL(h), i = h[0], r = h[1], p = i.match(Lu) || [], L = r.match(Lu) || [], L.length) {
    for (; d = Lu.exec(r); ) S = d[0], E = r.substring(u, d.index), v ? v = (v + 1) % 5 : (E.substr(-5) === "rgba(" || E.substr(-5) === "hsla(") && (v = 1), S !== (M = p[f++] || "") && (g = parseFloat(M) || 0, C = M.substr((g + "").length), S.charAt(1) === "=" && (S = Bu(g, S) + C), m = parseFloat(S), T = S.substr((m + "").length), u = Lu.lastIndex - T.length, T || (T = T || hr.units[t] || C, u === r.length && (r += T, a.e += T)), C !== T && (g = sa(e, t, M, T) || 0), a._pt = { _next: a._pt, p: E || f === 1 ? E : ",", s: g, c: m - g, m: v && v < 4 || t === "zIndex" ? Math.round : 0 });
    a.c = u < r.length ? r.substring(u, r.length) : "";
  } else a.r = t === "display" && r === "none" ? SL : xL;
  return Ob.test(r) && (a.e = 0), this._pt = a, a;
}, LA = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, gH = function(e) {
  var t = e.split(" "), i = t[0], r = t[1] || "50%";
  return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i, i = r, r = e), t[0] = LA[i] || i, t[1] = LA[r] || r, t.join(" ");
}, _H = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var i = t.t, r = i.style, s = t.u, o = i._gsap, a, u, f;
    if (s === "all" || s === true) r.cssText = "", u = 1;
    else for (s = s.split(","), f = s.length; --f > -1; ) a = s[f], lo[a] && (u = 1, a = a === "transformOrigin" ? qi : ln), gl(i, a);
    u && (gl(i, ln), o && (o.svg && i.removeAttribute("transform"), r.scale = r.rotate = r.translate = "none", Eh(i, 1), o.uncache = 1, ML(r)));
  }
}, ng = { clearProps: function(e, t, i, r, s) {
  if (s.data !== "isFromStart") {
    var o = e._pt = new Yi(e._pt, t, i, 0, 0, _H);
    return o.u = r, o.pr = -10, o.tween = s, e._props.push(i), 1;
  }
} }, wh = [1, 0, 0, 1, 0, 0], CL = {}, RL = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, IA = function(e) {
  var t = Cs(e, ln);
  return RL(t) ? wh : t.substr(7).match(Ub).map(Sn);
}, U1 = function(e, t) {
  var i = e._gsap || rl(e), r = e.style, s = IA(e), o, a, u, f;
  return i.svg && e.getAttribute("transform") ? (u = e.transform.baseVal.consolidate().matrix, s = [u.a, u.b, u.c, u.d, u.e, u.f], s.join(",") === "1,0,0,1,0,0" ? wh : s) : (s === wh && !e.offsetParent && e !== Vu && !i.svg && (u = r.display, r.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (f = 1, a = e.nextElementSibling, Vu.appendChild(e)), s = IA(e), u ? r.display = u : gl(e, "display"), f && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Vu.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
}, Dx = function(e, t, i, r, s, o) {
  var a = e._gsap, u = s || U1(e, true), f = a.xOrigin || 0, h = a.yOrigin || 0, d = a.xOffset || 0, p = a.yOffset || 0, g = u[0], v = u[1], M = u[2], S = u[3], m = u[4], E = u[5], T = t.split(" "), C = parseFloat(T[0]) || 0, L = parseFloat(T[1]) || 0, b, I, U, B;
  i ? u !== wh && (I = g * S - v * M) && (U = C * (S / I) + L * (-M / I) + (M * E - S * m) / I, B = C * (-v / I) + L * (g / I) - (g * E - v * m) / I, C = U, L = B) : (b = TL(e), C = b.x + (~T[0].indexOf("%") ? C / 100 * b.width : C), L = b.y + (~(T[1] || T[0]).indexOf("%") ? L / 100 * b.height : L)), r || r !== false && a.smooth ? (m = C - f, E = L - h, a.xOffset = d + (m * g + E * M) - m, a.yOffset = p + (m * v + E * S) - E) : a.xOffset = a.yOffset = 0, a.xOrigin = C, a.yOrigin = L, a.smooth = !!r, a.origin = t, a.originIsAbsolute = !!i, e.style[qi] = "0px 0px", o && (Bo(o, a, "xOrigin", f, C), Bo(o, a, "yOrigin", h, L), Bo(o, a, "xOffset", d, a.xOffset), Bo(o, a, "yOffset", p, a.yOffset)), e.setAttribute("data-svg-origin", C + " " + L);
}, Eh = function(e, t) {
  var i = e._gsap || new fL(e);
  if ("x" in i && !t && !i.uncache) return i;
  var r = e.style, s = i.scaleX < 0, o = "px", a = "deg", u = getComputedStyle(e), f = Cs(e, qi) || "0", h, d, p, g, v, M, S, m, E, T, C, L, b, I, U, B, R, D, j, te, X, Q, J, ce, V, q, Y, $, ae, Ee, ne, he;
  return h = d = p = M = S = m = E = T = C = 0, g = v = 1, i.svg = !!(e.getCTM && AL(e)), u.translate && ((u.translate !== "none" || u.scale !== "none" || u.rotate !== "none") && (r[ln] = (u.translate !== "none" ? "translate3d(" + (u.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (u.rotate !== "none" ? "rotate(" + u.rotate + ") " : "") + (u.scale !== "none" ? "scale(" + u.scale.split(" ").join(",") + ") " : "") + (u[ln] !== "none" ? u[ln] : "")), r.scale = r.rotate = r.translate = "none"), I = U1(e, i.svg), i.svg && (i.uncache ? (V = e.getBBox(), f = i.xOrigin - V.x + "px " + (i.yOrigin - V.y) + "px", ce = "") : ce = !t && e.getAttribute("data-svg-origin"), Dx(e, ce || f, !!ce || i.originIsAbsolute, i.smooth !== false, I)), L = i.xOrigin || 0, b = i.yOrigin || 0, I !== wh && (D = I[0], j = I[1], te = I[2], X = I[3], h = Q = I[4], d = J = I[5], I.length === 6 ? (g = Math.sqrt(D * D + j * j), v = Math.sqrt(X * X + te * te), M = D || j ? cu(j, D) * za : 0, E = te || X ? cu(te, X) * za + M : 0, E && (v *= Math.abs(Math.cos(E * Hu))), i.svg && (h -= L - (L * D + b * te), d -= b - (L * j + b * X))) : (he = I[6], Ee = I[7], Y = I[8], $ = I[9], ae = I[10], ne = I[11], h = I[12], d = I[13], p = I[14], U = cu(he, ae), S = U * za, U && (B = Math.cos(-U), R = Math.sin(-U), ce = Q * B + Y * R, V = J * B + $ * R, q = he * B + ae * R, Y = Q * -R + Y * B, $ = J * -R + $ * B, ae = he * -R + ae * B, ne = Ee * -R + ne * B, Q = ce, J = V, he = q), U = cu(-te, ae), m = U * za, U && (B = Math.cos(-U), R = Math.sin(-U), ce = D * B - Y * R, V = j * B - $ * R, q = te * B - ae * R, ne = X * R + ne * B, D = ce, j = V, te = q), U = cu(j, D), M = U * za, U && (B = Math.cos(U), R = Math.sin(U), ce = D * B + j * R, V = Q * B + J * R, j = j * B - D * R, J = J * B - Q * R, D = ce, Q = V), S && Math.abs(S) + Math.abs(M) > 359.9 && (S = M = 0, m = 180 - m), g = Sn(Math.sqrt(D * D + j * j + te * te)), v = Sn(Math.sqrt(J * J + he * he)), U = cu(Q, J), E = Math.abs(U) > 2e-4 ? U * za : 0, C = ne ? 1 / (ne < 0 ? -ne : ne) : 0), i.svg && (ce = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !RL(Cs(e, ln)), ce && e.setAttribute("transform", ce))), Math.abs(E) > 90 && Math.abs(E) < 270 && (s ? (g *= -1, E += M <= 0 ? 180 : -180, M += M <= 0 ? 180 : -180) : (v *= -1, E += E <= 0 ? 180 : -180)), t = t || i.uncache, i.x = h - ((i.xPercent = h && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o, i.y = d - ((i.yPercent = d && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o, i.z = p + o, i.scaleX = Sn(g), i.scaleY = Sn(v), i.rotation = Sn(M) + a, i.rotationX = Sn(S) + a, i.rotationY = Sn(m) + a, i.skewX = E + a, i.skewY = T + a, i.transformPerspective = C + o, (i.zOrigin = parseFloat(f.split(" ")[2]) || !t && i.zOrigin || 0) && (r[qi] = ig(f)), i.xOffset = i.yOffset = 0, i.force3D = hr.force3D, i.renderTransform = i.svg ? yH : EL ? PL : vH, i.uncache = 0, i;
}, ig = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, Lv = function(e, t, i) {
  var r = di(t);
  return Sn(parseFloat(t) + parseFloat(sa(e, "x", i + "px", r))) + r;
}, vH = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, PL(e, t);
}, Da = "0deg", af = "0px", Na = ") ", PL = function(e, t) {
  var i = t || this, r = i.xPercent, s = i.yPercent, o = i.x, a = i.y, u = i.z, f = i.rotation, h = i.rotationY, d = i.rotationX, p = i.skewX, g = i.skewY, v = i.scaleX, M = i.scaleY, S = i.transformPerspective, m = i.force3D, E = i.target, T = i.zOrigin, C = "", L = m === "auto" && e && e !== 1 || m === true;
  if (T && (d !== Da || h !== Da)) {
    var b = parseFloat(h) * Hu, I = Math.sin(b), U = Math.cos(b), B;
    b = parseFloat(d) * Hu, B = Math.cos(b), o = Lv(E, o, I * B * -T), a = Lv(E, a, -Math.sin(b) * -T), u = Lv(E, u, U * B * -T + T);
  }
  S !== af && (C += "perspective(" + S + Na), (r || s) && (C += "translate(" + r + "%, " + s + "%) "), (L || o !== af || a !== af || u !== af) && (C += u !== af || L ? "translate3d(" + o + ", " + a + ", " + u + ") " : "translate(" + o + ", " + a + Na), f !== Da && (C += "rotate(" + f + Na), h !== Da && (C += "rotateY(" + h + Na), d !== Da && (C += "rotateX(" + d + Na), (p !== Da || g !== Da) && (C += "skew(" + p + ", " + g + Na), (v !== 1 || M !== 1) && (C += "scale(" + v + ", " + M + Na), E.style[ln] = C || "translate(0, 0)";
}, yH = function(e, t) {
  var i = t || this, r = i.xPercent, s = i.yPercent, o = i.x, a = i.y, u = i.rotation, f = i.skewX, h = i.skewY, d = i.scaleX, p = i.scaleY, g = i.target, v = i.xOrigin, M = i.yOrigin, S = i.xOffset, m = i.yOffset, E = i.forceCSS, T = parseFloat(o), C = parseFloat(a), L, b, I, U, B;
  u = parseFloat(u), f = parseFloat(f), h = parseFloat(h), h && (h = parseFloat(h), f += h, u += h), u || f ? (u *= Hu, f *= Hu, L = Math.cos(u) * d, b = Math.sin(u) * d, I = Math.sin(u - f) * -p, U = Math.cos(u - f) * p, f && (h *= Hu, B = Math.tan(f - h), B = Math.sqrt(1 + B * B), I *= B, U *= B, h && (B = Math.tan(h), B = Math.sqrt(1 + B * B), L *= B, b *= B)), L = Sn(L), b = Sn(b), I = Sn(I), U = Sn(U)) : (L = d, U = p, b = I = 0), (T && !~(o + "").indexOf("px") || C && !~(a + "").indexOf("px")) && (T = sa(g, "x", o, "px"), C = sa(g, "y", a, "px")), (v || M || S || m) && (T = Sn(T + v - (v * L + M * I) + S), C = Sn(C + M - (v * b + M * U) + m)), (r || s) && (B = g.getBBox(), T = Sn(T + r / 100 * B.width), C = Sn(C + s / 100 * B.height)), B = "matrix(" + L + "," + b + "," + I + "," + U + "," + T + "," + C + ")", g.setAttribute("transform", B), E && (g.style[ln] = B);
}, xH = function(e, t, i, r, s) {
  var o = 360, a = qn(s), u = parseFloat(s) * (a && ~s.indexOf("rad") ? za : 1), f = u - r, h = r + f + "deg", d, p;
  return a && (d = s.split("_")[1], d === "short" && (f %= o, f !== f % (o / 2) && (f += f < 0 ? o : -360)), d === "cw" && f < 0 ? f = (f + o * AA) % o - ~~(f / o) * o : d === "ccw" && f > 0 && (f = (f - o * AA) % o - ~~(f / o) * o)), e._pt = p = new Yi(e._pt, t, i, r, f, iH), p.e = h, p.u = "deg", e._props.push(i), p;
}, DA = function(e, t) {
  for (var i in t) e[i] = t[i];
  return e;
}, SH = function(e, t, i) {
  var r = DA({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, u, f, h, d, p, g, v;
  r.svg ? (f = i.getAttribute("transform"), i.setAttribute("transform", ""), o[ln] = t, a = Eh(i, 1), gl(i, ln), i.setAttribute("transform", f)) : (f = getComputedStyle(i)[ln], o[ln] = t, a = Eh(i, 1), o[ln] = f);
  for (u in lo) f = r[u], h = a[u], f !== h && s.indexOf(u) < 0 && (g = di(f), v = di(h), d = g !== v ? sa(i, u, f, v) : parseFloat(f), p = parseFloat(h), e._pt = new Yi(e._pt, a, u, d, p - d, bx), e._pt.u = v || 0, e._props.push(u));
  DA(a, r);
};
Xi("padding,margin,Width,Radius", function(n18, e) {
  var t = "Top", i = "Right", r = "Bottom", s = "Left", o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function(a) {
    return e < 2 ? n18 + a : "border" + a + n18;
  });
  ng[e > 1 ? "border" + n18 : n18] = function(a, u, f, h, d) {
    var p, g;
    if (arguments.length < 4) return p = o.map(function(v) {
      return Ys(a, v, f);
    }), g = p.join(" "), g.split(p[0]).length === 5 ? p[0] : g;
    p = (h + "").split(" "), g = {}, o.forEach(function(v, M) {
      return g[v] = p[M] = p[M] || p[(M - 1) / 2 | 0];
    }), a.init(u, g, d);
  };
});
var bL = { name: "css", register: Ix, targetTest: function(e) {
  return e.style && e.nodeType;
}, init: function(e, t, i, r, s) {
  var o = this._props, a = e.style, u = i.vars.startAt, f, h, d, p, g, v, M, S, m, E, T, C, L, b, I, U;
  I1 || Ix(), this.styles = this.styles || wL(e), U = this.styles.props, this.tween = i;
  for (M in t) if (M !== "autoRound" && (h = t[M], !(rr[M] && hL(M, t, i, r, e, s)))) {
    if (g = typeof h, v = ng[M], g === "function" && (h = h.call(i, r, e, s), g = typeof h), g === "string" && ~h.indexOf("random(") && (h = xh(h)), v) v(this, e, M, h, i) && (I = 1);
    else if (M.substr(0, 2) === "--") f = (getComputedStyle(e).getPropertyValue(M) + "").trim(), h += "", $o.lastIndex = 0, $o.test(f) || (S = di(f), m = di(h)), m ? S !== m && (f = sa(e, M, f, m) + m) : S && (h += S), this.add(a, "setProperty", f, h, r, s, 0, 0, M), o.push(M), U.push(M, 0, a[M]);
    else if (g !== "undefined") {
      if (u && M in u ? (f = typeof u[M] == "function" ? u[M].call(i, r, e, s) : u[M], qn(f) && ~f.indexOf("random(") && (f = xh(f)), di(f + "") || f === "auto" || (f += hr.units[M] || di(Ys(e, M)) || ""), (f + "").charAt(1) === "=" && (f = Ys(e, M))) : f = Ys(e, M), p = parseFloat(f), E = g === "string" && h.charAt(1) === "=" && h.substr(0, 2), E && (h = h.substr(2)), d = parseFloat(h), M in xs && (M === "autoAlpha" && (p === 1 && Ys(e, "visibility") === "hidden" && d && (p = 0), U.push("visibility", 0, a.visibility), Bo(this, a, "visibility", p ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), M !== "scale" && M !== "transform" && (M = xs[M], ~M.indexOf(",") && (M = M.split(",")[0]))), T = M in lo, T) {
        if (this.styles.save(M), C || (L = e._gsap, L.renderTransform && !t.parseTransform || Eh(e, t.parseTransform), b = t.smoothOrigin !== false && L.smooth, C = this._pt = new Yi(this._pt, a, ln, 0, 1, L.renderTransform, L, 0, -1), C.dep = 1), M === "scale") this._pt = new Yi(this._pt, L, "scaleY", L.scaleY, (E ? Bu(L.scaleY, E + d) : d) - L.scaleY || 0, bx), this._pt.u = 0, o.push("scaleY", M), M += "X";
        else if (M === "transformOrigin") {
          U.push(qi, 0, a[qi]), h = gH(h), L.svg ? Dx(e, h, 0, b, 0, this) : (m = parseFloat(h.split(" ")[2]) || 0, m !== L.zOrigin && Bo(this, L, "zOrigin", L.zOrigin, m), Bo(this, a, M, ig(f), ig(h)));
          continue;
        } else if (M === "svgOrigin") {
          Dx(e, h, 1, b, 0, this);
          continue;
        } else if (M in CL) {
          xH(this, L, M, p, E ? Bu(p, E + h) : h);
          continue;
        } else if (M === "smoothOrigin") {
          Bo(this, L, "smooth", L.smooth, h);
          continue;
        } else if (M === "force3D") {
          L[M] = h;
          continue;
        } else if (M === "transform") {
          SH(this, h, e);
          continue;
        }
      } else M in a || (M = lc(M) || M);
      if (T || (d || d === 0) && (p || p === 0) && !nH.test(h) && M in a) S = (f + "").substr((p + "").length), d || (d = 0), m = di(h) || (M in hr.units ? hr.units[M] : S), S !== m && (p = sa(e, M, f, m)), this._pt = new Yi(this._pt, T ? L : a, M, p, (E ? Bu(p, E + d) : d) - p, !T && (m === "px" || M === "zIndex") && t.autoRound !== false ? sH : bx), this._pt.u = m || 0, S !== m && m !== "%" && (this._pt.b = f, this._pt.r = rH);
      else if (M in a) mH.call(this, e, M, f, E ? E + h : h);
      else if (M in e) this.add(e, M, f || e[M], E ? E + h : h, r, s);
      else if (M !== "parseTransform") {
        w1(M, h);
        continue;
      }
      T || (M in a ? U.push(M, 0, a[M]) : typeof e[M] == "function" ? U.push(M, 2, e[M]()) : U.push(M, 1, f || e[M])), o.push(M);
    }
  }
  I && vL(this);
}, render: function(e, t) {
  if (t.tween._time || !D1()) for (var i = t._pt; i; ) i.r(e, i.d), i = i._next;
  else t.styles.revert();
}, get: Ys, aliases: xs, getSetter: function(e, t, i) {
  var r = xs[t];
  return r && r.indexOf(",") < 0 && (t = r), t in lo && t !== qi && (e._gsap.x || Ys(e, "x")) ? i && TA === i ? t === "scale" ? uH : lH : (TA = i || {}) && (t === "scale" ? cH : fH) : e.style && !x1(e.style[t]) ? oH : ~t.indexOf("-") ? aH : b1(e, t);
}, core: { _removeProperty: gl, _getMatrix: U1 } };
ji.utils.checkPrefix = lc;
ji.core.getStyleSaver = wL;
(function(n18, e, t, i) {
  var r = Xi(n18 + "," + e + "," + t, function(s) {
    lo[s] = 1;
  });
  Xi(e, function(s) {
    hr.units[s] = "deg", CL[s] = 1;
  }), xs[r[13]] = n18 + "," + e, Xi(i, function(s) {
    var o = s.split(":");
    xs[o[1]] = r[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Xi("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n18) {
  hr.units[n18] = "px";
});
ji.registerPlugin(bL);
var rg = ji.registerPlugin(bL) || ji;
rg.core.Tween;
const lf = (n18) => n18 * (Math.PI / 180);
function Zp(n18, e = 100, t = [0, 0, 0], i = [90, 0, 0]) {
  return [e * Math.cos(lf(n18[0] - i[0])) * Math.cos(lf(n18[2] - i[2])), e * Math.sin(lf(n18[0] - i[0])) * Math.cos(lf(n18[2] - i[2])), e * Math.sin(lf(n18[2] - i[2]))].map((o, a) => o + t[a]);
}
function NA(n18, e = [x, y, z]) {
  return n18.map((t, i) => e[i] != null ? e[i] - (t - e[i]) : t);
}
function UA(n18, e, t, i) {
  return i < 0.5 ? n18.map((r, s) => ox.lerp(n18[s], e[s], i * 2)) : e.map((r, s) => ox.lerp(e[s], t[s], (i - 0.5) * 2));
}
function MH({ u: n18, r: e, res: t = { x: 36, y: 18 }, width: i = 360, height: r = 180, arrowFactor: s = 0.1 }) {
  const o = be.useRef(), a = be.useMemo(() => (t.x + 1) * (t.y + 1) * 4, [t]), u = be.useMemo(() => {
    const f = new Float32Array(a * 2 * 3);
    return new _t().setAttribute("position", new Ot(f, 3));
  }, [a]);
  return Sb(() => {
    if (!o.current) return;
    const f = o.current.geometry.attributes.position.array;
    let h = 0;
    const d = i / t.x, p = r / t.y, g = i / 2, v = r / 2;
    for (let M = 0; M <= t.x; M++) {
      const S = -g + M * d;
      for (let m = 0; m <= t.y; m++) {
        const E = -v + m * p, T = [];
        if (!(M == 0 && M == t.x && m == 0 && m == t.y)) {
          T.push([S, 0, E + p / 2]), T.push([S + d / 2, 0, E]), T.push([S, 0, E - p / 2]), T.push([S - d / 2, 0, E]);
          for (const C of T) {
            const L = [S, 0, E], b = C, I = Zp(L, e, [0, e, 0]), U = Zp(b, e, [0, e, 0]), B = NA(Zp(L, e, [0, e, 0]), [null, 0, null]), R = NA(Zp(b, e, [0, e, 0]), [null, 0, null]), D = UA(I, L.map((te) => te * 2), B, n18), j = UA(U.map((te, X) => I[X] + (te - I[X]) * s), b.map((te) => te * 2), R, n18);
            f.set(D, h), h += 3, f.set(j, h), h += 3;
          }
        }
      }
    }
    o.current.geometry.attributes.position.needsUpdate = true;
  }), Tt.jsx("lineSegments", { ref: o, geometry: u, children: Tt.jsx("lineBasicMaterial", { attach: "material", color: "gray" }) });
}
function wH({ u: n18, r: e, offset: t = 0.1 }) {
  return Tt.jsx(Tt.Fragment, { children: Tt.jsx(N5, { args: [e - t, 100], scale: 1, position: [0, e, 0], "material-transparent": true, "material-opacity": 1 - n18 * 2, "material-color": "black" }) });
}
let Gu = aV((n18, e) => ({ scale: "xl", cameraSettings: [], cameraLock: false, setScale: (t) => {
  const i = e().cameraOptions[t];
  console.log(i), n18({ scale: t, cameraSettings: i });
}, cameraOptions: { xl: { fov: 100, rot: false, zoom: false, pan: false, position: [0, 0, 100] }, m: { fov: 50, rot: false, zoom: false, pan: true, position: [0, 0, 100] }, xs: { fov: 100, rot: true, zoom: false, pan: false, position: [0, 0, 150] } } }));
function EH() {
  const n18 = Gu((i) => i.scale), [e, t] = be.useState(0);
  return be.useEffect(() => {
    const i = n18 === "xl" ? 0 : n18 === "m" ? 0.5 : 1;
    rg.to({ u: e }, { u: i, duration: 2, ease: "power3.out", onUpdate: function() {
      t(this.targets()[0].u);
    }, onStart: () => {
      Gu.setState({ cameraLock: true });
    }, onComplete: () => {
      Gu.setState({ cameraLock: false });
    } });
  }, [n18]), Tt.jsxs(Tt.Fragment, { children: [Tt.jsx(MH, { u: e, r: 100 }), Tt.jsx(wH, { u: e, r: 100 }), Tt.jsx("ambientLight", {}), Tt.jsx("pointLight", { position: [10, 10, 10] })] });
}
function TH() {
  const { camera: n18 } = f5(), e = Gu((o) => o.cameraSettings), t = Gu((o) => o.cameraLock), i = be.useRef({ x: 0, y: 0 }), r = be.useRef({ x: 0, y: 0 }), s = be.useRef({ x: 0, y: 0 });
  return be.useEffect(() => {
    n18.position.set(0, 0, 100), n18.lookAt(0, 0, 0);
  }, [n18]), be.useEffect(() => {
    e.fov !== void 0 && (rg.to(n18.position, { duration: 1, x: 0, y: 0, z: 100, onUpdate: () => {
      n18.lookAt(0, 0, 0);
    } }), rg.to(n18, { duration: 1, fov: e.fov, onUpdate: () => {
      n18.updateProjectionMatrix();
    } }));
  }, [e]), be.useEffect(() => {
    const o = (a) => {
      const { innerWidth: u, innerHeight: f } = window;
      s.current.x = (a.clientX / u - 0.5) * 2, s.current.y = (a.clientY / f - 0.5) * 2;
    };
    return window.addEventListener("mousemove", o), () => window.removeEventListener("mousemove", o);
  }, []), Sb(() => {
    if (!t) {
      if (e.rot) {
        const u = s.current.y * 0.2, f = s.current.x * 0.5;
        i.current.x += (u - i.current.x) * 0.05, i.current.y += (f - i.current.y) * 0.05, n18.rotation.x = -i.current.x, n18.rotation.y = -i.current.y;
      }
      if (e.pan) {
        const u = s.current.x * 100, f = s.current.y * 100;
        r.current.x += (u - r.current.x) * 0.02, r.current.y += (f - r.current.y) * 0.02, n18.position.set(r.current.x, -r.current.y, n18.position.z);
      }
    }
  }), null;
}
function AH() {
  return Tt.jsx(Tt.Fragment, { children: Tt.jsx(I5, { camera: { near: 0.01, far: 1e3 }, children: Tt.jsxs("group", { rotation: [-Math.PI / 2, 0, 0], children: [Tt.jsx(EH, {}), Tt.jsx(TH, {})] }) }) });
}
const CH = Iv.createRoot(document.querySelector("#root")), ym = Gu.getState().setScale;
RH();
CH.render(Tt.jsxs(Tt.Fragment, { children: [Tt.jsxs("div", { style: { position: "absolute", top: 20, left: 20, zIndex: 1 }, children: [Tt.jsx("button", { onClick: () => ym("xl"), children: "Sphere" }), Tt.jsx("button", { onClick: () => ym("m"), children: "Flat Grid" }), Tt.jsx("button", { onClick: () => ym("xs"), children: "Inverted Sphere" })] }), Tt.jsx(AH, {})] }));
async function RH() {
  ym("m");
}
