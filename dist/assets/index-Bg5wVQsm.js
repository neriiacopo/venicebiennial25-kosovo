function zO(n24, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i) if (r !== "default" && !(r in n24)) {
        const s = Object.getOwnPropertyDescriptor(i, r);
        s && Object.defineProperty(n24, r, s.get ? s : { enumerable: true, get: () => i[r] });
      }
    }
  }
  return Object.freeze(Object.defineProperty(n24, Symbol.toStringTag, { value: "Module" }));
}
(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r) if (s.type === "childList") for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: true, subtree: true });
  function t(r) {
    const s = {};
    return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s;
  }
  function i(r) {
    if (r.ep) return;
    r.ep = true;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function JS(n24) {
  return n24 && n24.__esModule && Object.prototype.hasOwnProperty.call(n24, "default") ? n24.default : n24;
}
function za(n24) {
  if (n24.__esModule) return n24;
  var e = n24.default;
  if (typeof e == "function") {
    var t = function i() {
      return this instanceof i ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(n24).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n24, i);
    Object.defineProperty(t, i, r.get ? r : { enumerable: true, get: function() {
      return n24[i];
    } });
  }), t;
}
var rR = { exports: {} }, A0 = {}, sR = { exports: {} }, At = {};
/**
* @license React
* react.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var bd = Symbol.for("react.element"), BO = Symbol.for("react.portal"), VO = Symbol.for("react.fragment"), HO = Symbol.for("react.strict_mode"), GO = Symbol.for("react.profiler"), WO = Symbol.for("react.provider"), XO = Symbol.for("react.context"), jO = Symbol.for("react.forward_ref"), $O = Symbol.for("react.suspense"), YO = Symbol.for("react.memo"), qO = Symbol.for("react.lazy"), nA = Symbol.iterator;
function KO(n24) {
  return n24 === null || typeof n24 != "object" ? null : (n24 = nA && n24[nA] || n24["@@iterator"], typeof n24 == "function" ? n24 : null);
}
var oR = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, aR = Object.assign, lR = {};
function ef(n24, e, t) {
  this.props = n24, this.context = e, this.refs = lR, this.updater = t || oR;
}
ef.prototype.isReactComponent = {};
ef.prototype.setState = function(n24, e) {
  if (typeof n24 != "object" && typeof n24 != "function" && n24 != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, n24, e, "setState");
};
ef.prototype.forceUpdate = function(n24) {
  this.updater.enqueueForceUpdate(this, n24, "forceUpdate");
};
function uR() {
}
uR.prototype = ef.prototype;
function QS(n24, e, t) {
  this.props = n24, this.context = e, this.refs = lR, this.updater = t || oR;
}
var eM = QS.prototype = new uR();
eM.constructor = QS;
aR(eM, ef.prototype);
eM.isPureReactComponent = true;
var iA = Array.isArray, cR = Object.prototype.hasOwnProperty, tM = { current: null }, fR = { key: true, ref: true, __self: true, __source: true };
function hR(n24, e, t) {
  var i, r = {}, s = null, o = null;
  if (e != null) for (i in e.ref !== void 0 && (o = e.ref), e.key !== void 0 && (s = "" + e.key), e) cR.call(e, i) && !fR.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), f = 0; f < a; f++) l[f] = arguments[f + 2];
    r.children = l;
  }
  if (n24 && n24.defaultProps) for (i in a = n24.defaultProps, a) r[i] === void 0 && (r[i] = a[i]);
  return { $$typeof: bd, type: n24, key: s, ref: o, props: r, _owner: tM.current };
}
function ZO(n24, e) {
  return { $$typeof: bd, type: n24.type, key: e, ref: n24.ref, props: n24.props, _owner: n24._owner };
}
function nM(n24) {
  return typeof n24 == "object" && n24 !== null && n24.$$typeof === bd;
}
function JO(n24) {
  var e = { "=": "=0", ":": "=2" };
  return "$" + n24.replace(/[=:]/g, function(t) {
    return e[t];
  });
}
var rA = /\/+/g;
function uy(n24, e) {
  return typeof n24 == "object" && n24 !== null && n24.key != null ? JO("" + n24.key) : e.toString(36);
}
function lg(n24, e, t, i, r) {
  var s = typeof n24;
  (s === "undefined" || s === "boolean") && (n24 = null);
  var o = false;
  if (n24 === null) o = true;
  else switch (s) {
    case "string":
    case "number":
      o = true;
      break;
    case "object":
      switch (n24.$$typeof) {
        case bd:
        case BO:
          o = true;
      }
  }
  if (o) return o = n24, r = r(o), n24 = i === "" ? "." + uy(o, 0) : i, iA(r) ? (t = "", n24 != null && (t = n24.replace(rA, "$&/") + "/"), lg(r, e, t, "", function(f) {
    return f;
  })) : r != null && (nM(r) && (r = ZO(r, t + (!r.key || o && o.key === r.key ? "" : ("" + r.key).replace(rA, "$&/") + "/") + n24)), e.push(r)), 1;
  if (o = 0, i = i === "" ? "." : i + ":", iA(n24)) for (var a = 0; a < n24.length; a++) {
    s = n24[a];
    var l = i + uy(s, a);
    o += lg(s, e, t, l, r);
  }
  else if (l = KO(n24), typeof l == "function") for (n24 = l.call(n24), a = 0; !(s = n24.next()).done; ) s = s.value, l = i + uy(s, a++), o += lg(s, e, t, l, r);
  else if (s === "object") throw e = String(n24), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(n24).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
  return o;
}
function $p(n24, e, t) {
  if (n24 == null) return n24;
  var i = [], r = 0;
  return lg(n24, i, "", "", function(s) {
    return e.call(t, s, r++);
  }), i;
}
function QO(n24) {
  if (n24._status === -1) {
    var e = n24._result;
    e = e(), e.then(function(t) {
      (n24._status === 0 || n24._status === -1) && (n24._status = 1, n24._result = t);
    }, function(t) {
      (n24._status === 0 || n24._status === -1) && (n24._status = 2, n24._result = t);
    }), n24._status === -1 && (n24._status = 0, n24._result = e);
  }
  if (n24._status === 1) return n24._result.default;
  throw n24._result;
}
var ji = { current: null }, ug = { transition: null }, eU = { ReactCurrentDispatcher: ji, ReactCurrentBatchConfig: ug, ReactCurrentOwner: tM };
function dR() {
  throw Error("act(...) is not supported in production builds of React.");
}
At.Children = { map: $p, forEach: function(n24, e, t) {
  $p(n24, function() {
    e.apply(this, arguments);
  }, t);
}, count: function(n24) {
  var e = 0;
  return $p(n24, function() {
    e++;
  }), e;
}, toArray: function(n24) {
  return $p(n24, function(e) {
    return e;
  }) || [];
}, only: function(n24) {
  if (!nM(n24)) throw Error("React.Children.only expected to receive a single React element child.");
  return n24;
} };
At.Component = ef;
At.Fragment = VO;
At.Profiler = GO;
At.PureComponent = QS;
At.StrictMode = HO;
At.Suspense = $O;
At.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = eU;
At.act = dR;
At.cloneElement = function(n24, e, t) {
  if (n24 == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + n24 + ".");
  var i = aR({}, n24.props), r = n24.key, s = n24.ref, o = n24._owner;
  if (e != null) {
    if (e.ref !== void 0 && (s = e.ref, o = tM.current), e.key !== void 0 && (r = "" + e.key), n24.type && n24.type.defaultProps) var a = n24.type.defaultProps;
    for (l in e) cR.call(e, l) && !fR.hasOwnProperty(l) && (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var f = 0; f < l; f++) a[f] = arguments[f + 2];
    i.children = a;
  }
  return { $$typeof: bd, type: n24.type, key: r, ref: s, props: i, _owner: o };
};
At.createContext = function(n24) {
  return n24 = { $$typeof: XO, _currentValue: n24, _currentValue2: n24, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, n24.Provider = { $$typeof: WO, _context: n24 }, n24.Consumer = n24;
};
At.createElement = hR;
At.createFactory = function(n24) {
  var e = hR.bind(null, n24);
  return e.type = n24, e;
};
At.createRef = function() {
  return { current: null };
};
At.forwardRef = function(n24) {
  return { $$typeof: jO, render: n24 };
};
At.isValidElement = nM;
At.lazy = function(n24) {
  return { $$typeof: qO, _payload: { _status: -1, _result: n24 }, _init: QO };
};
At.memo = function(n24, e) {
  return { $$typeof: YO, type: n24, compare: e === void 0 ? null : e };
};
At.startTransition = function(n24) {
  var e = ug.transition;
  ug.transition = {};
  try {
    n24();
  } finally {
    ug.transition = e;
  }
};
At.unstable_act = dR;
At.useCallback = function(n24, e) {
  return ji.current.useCallback(n24, e);
};
At.useContext = function(n24) {
  return ji.current.useContext(n24);
};
At.useDebugValue = function() {
};
At.useDeferredValue = function(n24) {
  return ji.current.useDeferredValue(n24);
};
At.useEffect = function(n24, e) {
  return ji.current.useEffect(n24, e);
};
At.useId = function() {
  return ji.current.useId();
};
At.useImperativeHandle = function(n24, e, t) {
  return ji.current.useImperativeHandle(n24, e, t);
};
At.useInsertionEffect = function(n24, e) {
  return ji.current.useInsertionEffect(n24, e);
};
At.useLayoutEffect = function(n24, e) {
  return ji.current.useLayoutEffect(n24, e);
};
At.useMemo = function(n24, e) {
  return ji.current.useMemo(n24, e);
};
At.useReducer = function(n24, e, t) {
  return ji.current.useReducer(n24, e, t);
};
At.useRef = function(n24) {
  return ji.current.useRef(n24);
};
At.useState = function(n24) {
  return ji.current.useState(n24);
};
At.useSyncExternalStore = function(n24, e, t) {
  return ji.current.useSyncExternalStore(n24, e, t);
};
At.useTransition = function() {
  return ji.current.useTransition();
};
At.version = "18.3.1";
sR.exports = At;
var ne = sR.exports;
const Ml = JS(ne), sA = zO({ __proto__: null, default: Ml }, [ne]);
/**
* @license React
* react-jsx-runtime.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var tU = ne, nU = Symbol.for("react.element"), iU = Symbol.for("react.fragment"), rU = Object.prototype.hasOwnProperty, sU = tU.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, oU = { key: true, ref: true, __self: true, __source: true };
function pR(n24, e, t) {
  var i, r = {}, s = null, o = null;
  t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
  for (i in e) rU.call(e, i) && !oU.hasOwnProperty(i) && (r[i] = e[i]);
  if (n24 && n24.defaultProps) for (i in e = n24.defaultProps, e) r[i] === void 0 && (r[i] = e[i]);
  return { $$typeof: nU, type: n24, key: s, ref: o, props: r, _owner: sU.current };
}
A0.Fragment = iU;
A0.jsx = pR;
A0.jsxs = pR;
rR.exports = A0;
var Be = rR.exports, Bx = {}, mR = { exports: {} }, Dr = {}, gR = { exports: {} }, _R = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(n24) {
  function e(B, Y) {
    var $ = B.length;
    B.push(Y);
    e: for (; 0 < $; ) {
      var ee = $ - 1 >>> 1, ue = B[ee];
      if (0 < r(ue, Y)) B[ee] = Y, B[$] = ue, $ = ee;
      else break e;
    }
  }
  function t(B) {
    return B.length === 0 ? null : B[0];
  }
  function i(B) {
    if (B.length === 0) return null;
    var Y = B[0], $ = B.pop();
    if ($ !== Y) {
      B[0] = $;
      e: for (var ee = 0, ue = B.length, Ae = ue >>> 1; ee < Ae; ) {
        var te = 2 * (ee + 1) - 1, de = B[te], Ee = te + 1, Ie = B[Ee];
        if (0 > r(de, $)) Ee < ue && 0 > r(Ie, de) ? (B[ee] = Ie, B[Ee] = $, ee = Ee) : (B[ee] = de, B[te] = $, ee = te);
        else if (Ee < ue && 0 > r(Ie, $)) B[ee] = Ie, B[Ee] = $, ee = Ee;
        else break e;
      }
    }
    return Y;
  }
  function r(B, Y) {
    var $ = B.sortIndex - Y.sortIndex;
    return $ !== 0 ? $ : B.id - Y.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n24.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    n24.unstable_now = function() {
      return o.now() - a;
    };
  }
  var l = [], f = [], h = 1, d = null, p = 3, g = false, v = false, S = false, M = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function E(B) {
    for (var Y = t(f); Y !== null; ) {
      if (Y.callback === null) i(f);
      else if (Y.startTime <= B) i(f), Y.sortIndex = Y.expirationTime, e(l, Y);
      else break;
      Y = t(f);
    }
  }
  function A(B) {
    if (S = false, E(B), !v) if (t(l) !== null) v = true, q(P);
    else {
      var Y = t(f);
      Y !== null && ae(A, Y.startTime - B);
    }
  }
  function P(B, Y) {
    v = false, S && (S = false, m(D), D = -1), g = true;
    var $ = p;
    try {
      for (E(Y), d = t(l); d !== null && (!(d.expirationTime > Y) || B && !N()); ) {
        var ee = d.callback;
        if (typeof ee == "function") {
          d.callback = null, p = d.priorityLevel;
          var ue = ee(d.expirationTime <= Y);
          Y = n24.unstable_now(), typeof ue == "function" ? d.callback = ue : d === t(l) && i(l), E(Y);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var Ae = true;
      else {
        var te = t(f);
        te !== null && ae(A, te.startTime - Y), Ae = false;
      }
      return Ae;
    } finally {
      d = null, p = $, g = false;
    }
  }
  var R = false, L = null, D = -1, F = 5, C = -1;
  function N() {
    return !(n24.unstable_now() - C < F);
  }
  function j() {
    if (L !== null) {
      var B = n24.unstable_now();
      C = B;
      var Y = true;
      try {
        Y = L(true, B);
      } finally {
        Y ? Z() : (R = false, L = null);
      }
    } else R = false;
  }
  var Z;
  if (typeof w == "function") Z = function() {
    w(j);
  };
  else if (typeof MessageChannel < "u") {
    var G = new MessageChannel(), J = G.port2;
    G.port1.onmessage = j, Z = function() {
      J.postMessage(null);
    };
  } else Z = function() {
    M(j, 0);
  };
  function q(B) {
    L = B, R || (R = true, Z());
  }
  function ae(B, Y) {
    D = M(function() {
      B(n24.unstable_now());
    }, Y);
  }
  n24.unstable_IdlePriority = 5, n24.unstable_ImmediatePriority = 1, n24.unstable_LowPriority = 4, n24.unstable_NormalPriority = 3, n24.unstable_Profiling = null, n24.unstable_UserBlockingPriority = 2, n24.unstable_cancelCallback = function(B) {
    B.callback = null;
  }, n24.unstable_continueExecution = function() {
    v || g || (v = true, q(P));
  }, n24.unstable_forceFrameRate = function(B) {
    0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < B ? Math.floor(1e3 / B) : 5;
  }, n24.unstable_getCurrentPriorityLevel = function() {
    return p;
  }, n24.unstable_getFirstCallbackNode = function() {
    return t(l);
  }, n24.unstable_next = function(B) {
    switch (p) {
      case 1:
      case 2:
      case 3:
        var Y = 3;
        break;
      default:
        Y = p;
    }
    var $ = p;
    p = Y;
    try {
      return B();
    } finally {
      p = $;
    }
  }, n24.unstable_pauseExecution = function() {
  }, n24.unstable_requestPaint = function() {
  }, n24.unstable_runWithPriority = function(B, Y) {
    switch (B) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        B = 3;
    }
    var $ = p;
    p = B;
    try {
      return Y();
    } finally {
      p = $;
    }
  }, n24.unstable_scheduleCallback = function(B, Y, $) {
    var ee = n24.unstable_now();
    switch (typeof $ == "object" && $ !== null ? ($ = $.delay, $ = typeof $ == "number" && 0 < $ ? ee + $ : ee) : $ = ee, B) {
      case 1:
        var ue = -1;
        break;
      case 2:
        ue = 250;
        break;
      case 5:
        ue = 1073741823;
        break;
      case 4:
        ue = 1e4;
        break;
      default:
        ue = 5e3;
    }
    return ue = $ + ue, B = { id: h++, callback: Y, priorityLevel: B, startTime: $, expirationTime: ue, sortIndex: -1 }, $ > ee ? (B.sortIndex = $, e(f, B), t(l) === null && B === t(f) && (S ? (m(D), D = -1) : S = true, ae(A, $ - ee))) : (B.sortIndex = ue, e(l, B), v || g || (v = true, q(P))), B;
  }, n24.unstable_shouldYield = N, n24.unstable_wrapCallback = function(B) {
    var Y = p;
    return function() {
      var $ = p;
      p = Y;
      try {
        return B.apply(this, arguments);
      } finally {
        p = $;
      }
    };
  };
})(_R);
gR.exports = _R;
var aU = gR.exports;
/**
* @license React
* react-dom.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var lU = ne, Lr = aU;
function Me(n24) {
  for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n24, t = 1; t < arguments.length; t++) e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified React error #" + n24 + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var vR = /* @__PURE__ */ new Set(), Lh = {};
function eu(n24, e) {
  Dc(n24, e), Dc(n24 + "Capture", e);
}
function Dc(n24, e) {
  for (Lh[n24] = e, n24 = 0; n24 < e.length; n24++) vR.add(e[n24]);
}
var Io = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Vx = Object.prototype.hasOwnProperty, uU = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, oA = {}, aA = {};
function cU(n24) {
  return Vx.call(aA, n24) ? true : Vx.call(oA, n24) ? false : uU.test(n24) ? aA[n24] = true : (oA[n24] = true, false);
}
function fU(n24, e, t, i) {
  if (t !== null && t.type === 0) return false;
  switch (typeof e) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      return i ? false : t !== null ? !t.acceptsBooleans : (n24 = n24.toLowerCase().slice(0, 5), n24 !== "data-" && n24 !== "aria-");
    default:
      return false;
  }
}
function hU(n24, e, t, i) {
  if (e === null || typeof e > "u" || fU(n24, e, t, i)) return true;
  if (i) return false;
  if (t !== null) switch (t.type) {
    case 3:
      return !e;
    case 4:
      return e === false;
    case 5:
      return isNaN(e);
    case 6:
      return isNaN(e) || 1 > e;
  }
  return false;
}
function $i(n24, e, t, i, r, s, o) {
  this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = i, this.attributeNamespace = r, this.mustUseProperty = t, this.propertyName = n24, this.type = e, this.sanitizeURL = s, this.removeEmptyString = o;
}
var pi = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(n24) {
  pi[n24] = new $i(n24, 0, false, n24, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(n24) {
  var e = n24[0];
  pi[e] = new $i(e, 1, false, n24[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(n24) {
  pi[n24] = new $i(n24, 2, false, n24.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(n24) {
  pi[n24] = new $i(n24, 2, false, n24, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(n24) {
  pi[n24] = new $i(n24, 3, false, n24.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(n24) {
  pi[n24] = new $i(n24, 3, true, n24, null, false, false);
});
["capture", "download"].forEach(function(n24) {
  pi[n24] = new $i(n24, 4, false, n24, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(n24) {
  pi[n24] = new $i(n24, 6, false, n24, null, false, false);
});
["rowSpan", "start"].forEach(function(n24) {
  pi[n24] = new $i(n24, 5, false, n24.toLowerCase(), null, false, false);
});
var iM = /[\-:]([a-z])/g;
function rM(n24) {
  return n24[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(n24) {
  var e = n24.replace(iM, rM);
  pi[e] = new $i(e, 1, false, n24, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(n24) {
  var e = n24.replace(iM, rM);
  pi[e] = new $i(e, 1, false, n24, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(n24) {
  var e = n24.replace(iM, rM);
  pi[e] = new $i(e, 1, false, n24, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(n24) {
  pi[n24] = new $i(n24, 1, false, n24.toLowerCase(), null, false, false);
});
pi.xlinkHref = new $i("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(n24) {
  pi[n24] = new $i(n24, 1, false, n24.toLowerCase(), null, true, true);
});
function sM(n24, e, t, i) {
  var r = pi.hasOwnProperty(e) ? pi[e] : null;
  (r !== null ? r.type !== 0 : i || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (hU(e, t, r, i) && (t = null), i || r === null ? cU(e) && (t === null ? n24.removeAttribute(e) : n24.setAttribute(e, "" + t)) : r.mustUseProperty ? n24[r.propertyName] = t === null ? r.type === 3 ? false : "" : t : (e = r.attributeName, i = r.attributeNamespace, t === null ? n24.removeAttribute(e) : (r = r.type, t = r === 3 || r === 4 && t === true ? "" : "" + t, i ? n24.setAttributeNS(i, e, t) : n24.setAttribute(e, t))));
}
var Ho = lU.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Yp = Symbol.for("react.element"), nc = Symbol.for("react.portal"), ic = Symbol.for("react.fragment"), oM = Symbol.for("react.strict_mode"), Hx = Symbol.for("react.profiler"), yR = Symbol.for("react.provider"), xR = Symbol.for("react.context"), aM = Symbol.for("react.forward_ref"), Gx = Symbol.for("react.suspense"), Wx = Symbol.for("react.suspense_list"), lM = Symbol.for("react.memo"), la = Symbol.for("react.lazy"), SR = Symbol.for("react.offscreen"), lA = Symbol.iterator;
function Df(n24) {
  return n24 === null || typeof n24 != "object" ? null : (n24 = lA && n24[lA] || n24["@@iterator"], typeof n24 == "function" ? n24 : null);
}
var gn = Object.assign, cy;
function sh(n24) {
  if (cy === void 0) try {
    throw Error();
  } catch (t) {
    var e = t.stack.trim().match(/\n( *(at )?)/);
    cy = e && e[1] || "";
  }
  return `
` + cy + n24;
}
var fy = false;
function hy(n24, e) {
  if (!n24 || fy) return "";
  fy = true;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e) if (e = function() {
      throw Error();
    }, Object.defineProperty(e.prototype, "props", { set: function() {
      throw Error();
    } }), typeof Reflect == "object" && Reflect.construct) {
      try {
        Reflect.construct(e, []);
      } catch (f) {
        var i = f;
      }
      Reflect.construct(n24, [], e);
    } else {
      try {
        e.call();
      } catch (f) {
        i = f;
      }
      n24.call(e.prototype);
    }
    else {
      try {
        throw Error();
      } catch (f) {
        i = f;
      }
      n24();
    }
  } catch (f) {
    if (f && i && typeof f.stack == "string") {
      for (var r = f.stack.split(`
`), s = i.stack.split(`
`), o = r.length - 1, a = s.length - 1; 1 <= o && 0 <= a && r[o] !== s[a]; ) a--;
      for (; 1 <= o && 0 <= a; o--, a--) if (r[o] !== s[a]) {
        if (o !== 1 || a !== 1) do
          if (o--, a--, 0 > a || r[o] !== s[a]) {
            var l = `
` + r[o].replace(" at new ", " at ");
            return n24.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", n24.displayName)), l;
          }
        while (1 <= o && 0 <= a);
        break;
      }
    }
  } finally {
    fy = false, Error.prepareStackTrace = t;
  }
  return (n24 = n24 ? n24.displayName || n24.name : "") ? sh(n24) : "";
}
function dU(n24) {
  switch (n24.tag) {
    case 5:
      return sh(n24.type);
    case 16:
      return sh("Lazy");
    case 13:
      return sh("Suspense");
    case 19:
      return sh("SuspenseList");
    case 0:
    case 2:
    case 15:
      return n24 = hy(n24.type, false), n24;
    case 11:
      return n24 = hy(n24.type.render, false), n24;
    case 1:
      return n24 = hy(n24.type, true), n24;
    default:
      return "";
  }
}
function Xx(n24) {
  if (n24 == null) return null;
  if (typeof n24 == "function") return n24.displayName || n24.name || null;
  if (typeof n24 == "string") return n24;
  switch (n24) {
    case ic:
      return "Fragment";
    case nc:
      return "Portal";
    case Hx:
      return "Profiler";
    case oM:
      return "StrictMode";
    case Gx:
      return "Suspense";
    case Wx:
      return "SuspenseList";
  }
  if (typeof n24 == "object") switch (n24.$$typeof) {
    case xR:
      return (n24.displayName || "Context") + ".Consumer";
    case yR:
      return (n24._context.displayName || "Context") + ".Provider";
    case aM:
      var e = n24.render;
      return n24 = n24.displayName, n24 || (n24 = e.displayName || e.name || "", n24 = n24 !== "" ? "ForwardRef(" + n24 + ")" : "ForwardRef"), n24;
    case lM:
      return e = n24.displayName || null, e !== null ? e : Xx(n24.type) || "Memo";
    case la:
      e = n24._payload, n24 = n24._init;
      try {
        return Xx(n24(e));
      } catch {
      }
  }
  return null;
}
function pU(n24) {
  var e = n24.type;
  switch (n24.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return n24 = e.render, n24 = n24.displayName || n24.name || "", e.displayName || (n24 !== "" ? "ForwardRef(" + n24 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Xx(e);
    case 8:
      return e === oM ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Na(n24) {
  switch (typeof n24) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n24;
    case "object":
      return n24;
    default:
      return "";
  }
}
function MR(n24) {
  var e = n24.type;
  return (n24 = n24.nodeName) && n24.toLowerCase() === "input" && (e === "checkbox" || e === "radio");
}
function mU(n24) {
  var e = MR(n24) ? "checked" : "value", t = Object.getOwnPropertyDescriptor(n24.constructor.prototype, e), i = "" + n24[e];
  if (!n24.hasOwnProperty(e) && typeof t < "u" && typeof t.get == "function" && typeof t.set == "function") {
    var r = t.get, s = t.set;
    return Object.defineProperty(n24, e, { configurable: true, get: function() {
      return r.call(this);
    }, set: function(o) {
      i = "" + o, s.call(this, o);
    } }), Object.defineProperty(n24, e, { enumerable: t.enumerable }), { getValue: function() {
      return i;
    }, setValue: function(o) {
      i = "" + o;
    }, stopTracking: function() {
      n24._valueTracker = null, delete n24[e];
    } };
  }
}
function qp(n24) {
  n24._valueTracker || (n24._valueTracker = mU(n24));
}
function wR(n24) {
  if (!n24) return false;
  var e = n24._valueTracker;
  if (!e) return true;
  var t = e.getValue(), i = "";
  return n24 && (i = MR(n24) ? n24.checked ? "true" : "false" : n24.value), n24 = i, n24 !== t ? (e.setValue(n24), true) : false;
}
function Ug(n24) {
  if (n24 = n24 || (typeof document < "u" ? document : void 0), typeof n24 > "u") return null;
  try {
    return n24.activeElement || n24.body;
  } catch {
    return n24.body;
  }
}
function jx(n24, e) {
  var t = e.checked;
  return gn({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: t ?? n24._wrapperState.initialChecked });
}
function uA(n24, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue, i = e.checked != null ? e.checked : e.defaultChecked;
  t = Na(e.value != null ? e.value : t), n24._wrapperState = { initialChecked: i, initialValue: t, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null };
}
function ER(n24, e) {
  e = e.checked, e != null && sM(n24, "checked", e, false);
}
function $x(n24, e) {
  ER(n24, e);
  var t = Na(e.value), i = e.type;
  if (t != null) i === "number" ? (t === 0 && n24.value === "" || n24.value != t) && (n24.value = "" + t) : n24.value !== "" + t && (n24.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n24.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value") ? Yx(n24, e.type, t) : e.hasOwnProperty("defaultValue") && Yx(n24, e.type, Na(e.defaultValue)), e.checked == null && e.defaultChecked != null && (n24.defaultChecked = !!e.defaultChecked);
}
function cA(n24, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (!(i !== "submit" && i !== "reset" || e.value !== void 0 && e.value !== null)) return;
    e = "" + n24._wrapperState.initialValue, t || e === n24.value || (n24.value = e), n24.defaultValue = e;
  }
  t = n24.name, t !== "" && (n24.name = ""), n24.defaultChecked = !!n24._wrapperState.initialChecked, t !== "" && (n24.name = t);
}
function Yx(n24, e, t) {
  (e !== "number" || Ug(n24.ownerDocument) !== n24) && (t == null ? n24.defaultValue = "" + n24._wrapperState.initialValue : n24.defaultValue !== "" + t && (n24.defaultValue = "" + t));
}
var oh = Array.isArray;
function Mc(n24, e, t, i) {
  if (n24 = n24.options, e) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = true;
    for (t = 0; t < n24.length; t++) r = e.hasOwnProperty("$" + n24[t].value), n24[t].selected !== r && (n24[t].selected = r), r && i && (n24[t].defaultSelected = true);
  } else {
    for (t = "" + Na(t), e = null, r = 0; r < n24.length; r++) {
      if (n24[r].value === t) {
        n24[r].selected = true, i && (n24[r].defaultSelected = true);
        return;
      }
      e !== null || n24[r].disabled || (e = n24[r]);
    }
    e !== null && (e.selected = true);
  }
}
function qx(n24, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(Me(91));
  return gn({}, e, { value: void 0, defaultValue: void 0, children: "" + n24._wrapperState.initialValue });
}
function fA(n24, e) {
  var t = e.value;
  if (t == null) {
    if (t = e.children, e = e.defaultValue, t != null) {
      if (e != null) throw Error(Me(92));
      if (oh(t)) {
        if (1 < t.length) throw Error(Me(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), t = e;
  }
  n24._wrapperState = { initialValue: Na(t) };
}
function TR(n24, e) {
  var t = Na(e.value), i = Na(e.defaultValue);
  t != null && (t = "" + t, t !== n24.value && (n24.value = t), e.defaultValue == null && n24.defaultValue !== t && (n24.defaultValue = t)), i != null && (n24.defaultValue = "" + i);
}
function hA(n24) {
  var e = n24.textContent;
  e === n24._wrapperState.initialValue && e !== "" && e !== null && (n24.value = e);
}
function AR(n24) {
  switch (n24) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function Kx(n24, e) {
  return n24 == null || n24 === "http://www.w3.org/1999/xhtml" ? AR(e) : n24 === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : n24;
}
var Kp, bR = function(n24) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, t, i, r) {
    MSApp.execUnsafeLocalFunction(function() {
      return n24(e, t, i, r);
    });
  } : n24;
}(function(n24, e) {
  if (n24.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n24) n24.innerHTML = e;
  else {
    for (Kp = Kp || document.createElement("div"), Kp.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = Kp.firstChild; n24.firstChild; ) n24.removeChild(n24.firstChild);
    for (; e.firstChild; ) n24.appendChild(e.firstChild);
  }
});
function Ih(n24, e) {
  if (e) {
    var t = n24.firstChild;
    if (t && t === n24.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n24.textContent = e;
}
var dh = { animationIterationCount: true, aspectRatio: true, borderImageOutset: true, borderImageSlice: true, borderImageWidth: true, boxFlex: true, boxFlexGroup: true, boxOrdinalGroup: true, columnCount: true, columns: true, flex: true, flexGrow: true, flexPositive: true, flexShrink: true, flexNegative: true, flexOrder: true, gridArea: true, gridRow: true, gridRowEnd: true, gridRowSpan: true, gridRowStart: true, gridColumn: true, gridColumnEnd: true, gridColumnSpan: true, gridColumnStart: true, fontWeight: true, lineClamp: true, lineHeight: true, opacity: true, order: true, orphans: true, tabSize: true, widows: true, zIndex: true, zoom: true, fillOpacity: true, floodOpacity: true, stopOpacity: true, strokeDasharray: true, strokeDashoffset: true, strokeMiterlimit: true, strokeOpacity: true, strokeWidth: true }, gU = ["Webkit", "ms", "Moz", "O"];
Object.keys(dh).forEach(function(n24) {
  gU.forEach(function(e) {
    e = e + n24.charAt(0).toUpperCase() + n24.substring(1), dh[e] = dh[n24];
  });
});
function CR(n24, e, t) {
  return e == null || typeof e == "boolean" || e === "" ? "" : t || typeof e != "number" || e === 0 || dh.hasOwnProperty(n24) && dh[n24] ? ("" + e).trim() : e + "px";
}
function RR(n24, e) {
  n24 = n24.style;
  for (var t in e) if (e.hasOwnProperty(t)) {
    var i = t.indexOf("--") === 0, r = CR(t, e[t], i);
    t === "float" && (t = "cssFloat"), i ? n24.setProperty(t, r) : n24[t] = r;
  }
}
var _U = gn({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function Zx(n24, e) {
  if (e) {
    if (_U[n24] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(Me(137, n24));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(Me(60));
      if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(Me(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(Me(62));
  }
}
function Jx(n24, e) {
  if (n24.indexOf("-") === -1) return typeof e.is == "string";
  switch (n24) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var Qx = null;
function uM(n24) {
  return n24 = n24.target || n24.srcElement || window, n24.correspondingUseElement && (n24 = n24.correspondingUseElement), n24.nodeType === 3 ? n24.parentNode : n24;
}
var e1 = null, wc = null, Ec = null;
function dA(n24) {
  if (n24 = Pd(n24)) {
    if (typeof e1 != "function") throw Error(Me(280));
    var e = n24.stateNode;
    e && (e = L0(e), e1(n24.stateNode, n24.type, e));
  }
}
function PR(n24) {
  wc ? Ec ? Ec.push(n24) : Ec = [n24] : wc = n24;
}
function LR() {
  if (wc) {
    var n24 = wc, e = Ec;
    if (Ec = wc = null, dA(n24), e) for (n24 = 0; n24 < e.length; n24++) dA(e[n24]);
  }
}
function IR(n24, e) {
  return n24(e);
}
function NR() {
}
var dy = false;
function DR(n24, e, t) {
  if (dy) return n24(e, t);
  dy = true;
  try {
    return IR(n24, e, t);
  } finally {
    dy = false, (wc !== null || Ec !== null) && (NR(), LR());
  }
}
function Nh(n24, e) {
  var t = n24.stateNode;
  if (t === null) return null;
  var i = L0(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) || (n24 = n24.type, i = !(n24 === "button" || n24 === "input" || n24 === "select" || n24 === "textarea")), n24 = !i;
      break e;
    default:
      n24 = false;
  }
  if (n24) return null;
  if (t && typeof t != "function") throw Error(Me(231, e, typeof t));
  return t;
}
var t1 = false;
if (Io) try {
  var Of = {};
  Object.defineProperty(Of, "passive", { get: function() {
    t1 = true;
  } }), window.addEventListener("test", Of, Of), window.removeEventListener("test", Of, Of);
} catch {
  t1 = false;
}
function vU(n24, e, t, i, r, s, o, a, l) {
  var f = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, f);
  } catch (h) {
    this.onError(h);
  }
}
var ph = false, kg = null, Fg = false, n1 = null, yU = { onError: function(n24) {
  ph = true, kg = n24;
} };
function xU(n24, e, t, i, r, s, o, a, l) {
  ph = false, kg = null, vU.apply(yU, arguments);
}
function SU(n24, e, t, i, r, s, o, a, l) {
  if (xU.apply(this, arguments), ph) {
    if (ph) {
      var f = kg;
      ph = false, kg = null;
    } else throw Error(Me(198));
    Fg || (Fg = true, n1 = f);
  }
}
function tu(n24) {
  var e = n24, t = n24;
  if (n24.alternate) for (; e.return; ) e = e.return;
  else {
    n24 = e;
    do
      e = n24, e.flags & 4098 && (t = e.return), n24 = e.return;
    while (n24);
  }
  return e.tag === 3 ? t : null;
}
function OR(n24) {
  if (n24.tag === 13) {
    var e = n24.memoizedState;
    if (e === null && (n24 = n24.alternate, n24 !== null && (e = n24.memoizedState)), e !== null) return e.dehydrated;
  }
  return null;
}
function pA(n24) {
  if (tu(n24) !== n24) throw Error(Me(188));
}
function MU(n24) {
  var e = n24.alternate;
  if (!e) {
    if (e = tu(n24), e === null) throw Error(Me(188));
    return e !== n24 ? null : n24;
  }
  for (var t = n24, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (i = r.return, i !== null) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return pA(r), n24;
        if (s === i) return pA(r), e;
        s = s.sibling;
      }
      throw Error(Me(188));
    }
    if (t.return !== i.return) t = r, i = s;
    else {
      for (var o = false, a = r.child; a; ) {
        if (a === t) {
          o = true, t = r, i = s;
          break;
        }
        if (a === i) {
          o = true, i = r, t = s;
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            o = true, t = s, i = r;
            break;
          }
          if (a === i) {
            o = true, i = s, t = r;
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(Me(189));
      }
    }
    if (t.alternate !== i) throw Error(Me(190));
  }
  if (t.tag !== 3) throw Error(Me(188));
  return t.stateNode.current === t ? n24 : e;
}
function UR(n24) {
  return n24 = MU(n24), n24 !== null ? kR(n24) : null;
}
function kR(n24) {
  if (n24.tag === 5 || n24.tag === 6) return n24;
  for (n24 = n24.child; n24 !== null; ) {
    var e = kR(n24);
    if (e !== null) return e;
    n24 = n24.sibling;
  }
  return null;
}
var FR = Lr.unstable_scheduleCallback, mA = Lr.unstable_cancelCallback, wU = Lr.unstable_shouldYield, EU = Lr.unstable_requestPaint, Ln = Lr.unstable_now, TU = Lr.unstable_getCurrentPriorityLevel, cM = Lr.unstable_ImmediatePriority, zR = Lr.unstable_UserBlockingPriority, zg = Lr.unstable_NormalPriority, AU = Lr.unstable_LowPriority, BR = Lr.unstable_IdlePriority, b0 = null, Ks = null;
function bU(n24) {
  if (Ks && typeof Ks.onCommitFiberRoot == "function") try {
    Ks.onCommitFiberRoot(b0, n24, void 0, (n24.current.flags & 128) === 128);
  } catch {
  }
}
var Ms = Math.clz32 ? Math.clz32 : PU, CU = Math.log, RU = Math.LN2;
function PU(n24) {
  return n24 >>>= 0, n24 === 0 ? 32 : 31 - (CU(n24) / RU | 0) | 0;
}
var Zp = 64, Jp = 4194304;
function ah(n24) {
  switch (n24 & -n24) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n24 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n24 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n24;
  }
}
function Bg(n24, e) {
  var t = n24.pendingLanes;
  if (t === 0) return 0;
  var i = 0, r = n24.suspendedLanes, s = n24.pingedLanes, o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? i = ah(a) : (s &= o, s !== 0 && (i = ah(s)));
  } else o = t & ~r, o !== 0 ? i = ah(o) : s !== 0 && (i = ah(s));
  if (i === 0) return 0;
  if (e !== 0 && e !== i && !(e & r) && (r = i & -i, s = e & -e, r >= s || r === 16 && (s & 4194240) !== 0)) return e;
  if (i & 4 && (i |= t & 16), e = n24.entangledLanes, e !== 0) for (n24 = n24.entanglements, e &= i; 0 < e; ) t = 31 - Ms(e), r = 1 << t, i |= n24[t], e &= ~r;
  return i;
}
function LU(n24, e) {
  switch (n24) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function IU(n24, e) {
  for (var t = n24.suspendedLanes, i = n24.pingedLanes, r = n24.expirationTimes, s = n24.pendingLanes; 0 < s; ) {
    var o = 31 - Ms(s), a = 1 << o, l = r[o];
    l === -1 ? (!(a & t) || a & i) && (r[o] = LU(a, e)) : l <= e && (n24.expiredLanes |= a), s &= ~a;
  }
}
function i1(n24) {
  return n24 = n24.pendingLanes & -1073741825, n24 !== 0 ? n24 : n24 & 1073741824 ? 1073741824 : 0;
}
function VR() {
  var n24 = Zp;
  return Zp <<= 1, !(Zp & 4194240) && (Zp = 64), n24;
}
function py(n24) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n24);
  return e;
}
function Cd(n24, e, t) {
  n24.pendingLanes |= e, e !== 536870912 && (n24.suspendedLanes = 0, n24.pingedLanes = 0), n24 = n24.eventTimes, e = 31 - Ms(e), n24[e] = t;
}
function NU(n24, e) {
  var t = n24.pendingLanes & ~e;
  n24.pendingLanes = e, n24.suspendedLanes = 0, n24.pingedLanes = 0, n24.expiredLanes &= e, n24.mutableReadLanes &= e, n24.entangledLanes &= e, e = n24.entanglements;
  var i = n24.eventTimes;
  for (n24 = n24.expirationTimes; 0 < t; ) {
    var r = 31 - Ms(t), s = 1 << r;
    e[r] = 0, i[r] = -1, n24[r] = -1, t &= ~s;
  }
}
function fM(n24, e) {
  var t = n24.entangledLanes |= e;
  for (n24 = n24.entanglements; t; ) {
    var i = 31 - Ms(t), r = 1 << i;
    r & e | n24[i] & e && (n24[i] |= e), t &= ~r;
  }
}
var Wt = 0;
function HR(n24) {
  return n24 &= -n24, 1 < n24 ? 4 < n24 ? n24 & 268435455 ? 16 : 536870912 : 4 : 1;
}
var GR, hM, WR, XR, jR, r1 = false, Qp = [], xa = null, Sa = null, Ma = null, Dh = /* @__PURE__ */ new Map(), Oh = /* @__PURE__ */ new Map(), fa = [], DU = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function gA(n24, e) {
  switch (n24) {
    case "focusin":
    case "focusout":
      xa = null;
      break;
    case "dragenter":
    case "dragleave":
      Sa = null;
      break;
    case "mouseover":
    case "mouseout":
      Ma = null;
      break;
    case "pointerover":
    case "pointerout":
      Dh.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Oh.delete(e.pointerId);
  }
}
function Uf(n24, e, t, i, r, s) {
  return n24 === null || n24.nativeEvent !== s ? (n24 = { blockedOn: e, domEventName: t, eventSystemFlags: i, nativeEvent: s, targetContainers: [r] }, e !== null && (e = Pd(e), e !== null && hM(e)), n24) : (n24.eventSystemFlags |= i, e = n24.targetContainers, r !== null && e.indexOf(r) === -1 && e.push(r), n24);
}
function OU(n24, e, t, i, r) {
  switch (e) {
    case "focusin":
      return xa = Uf(xa, n24, e, t, i, r), true;
    case "dragenter":
      return Sa = Uf(Sa, n24, e, t, i, r), true;
    case "mouseover":
      return Ma = Uf(Ma, n24, e, t, i, r), true;
    case "pointerover":
      var s = r.pointerId;
      return Dh.set(s, Uf(Dh.get(s) || null, n24, e, t, i, r)), true;
    case "gotpointercapture":
      return s = r.pointerId, Oh.set(s, Uf(Oh.get(s) || null, n24, e, t, i, r)), true;
  }
  return false;
}
function $R(n24) {
  var e = wl(n24.target);
  if (e !== null) {
    var t = tu(e);
    if (t !== null) {
      if (e = t.tag, e === 13) {
        if (e = OR(t), e !== null) {
          n24.blockedOn = e, jR(n24.priority, function() {
            WR(t);
          });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n24.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n24.blockedOn = null;
}
function cg(n24) {
  if (n24.blockedOn !== null) return false;
  for (var e = n24.targetContainers; 0 < e.length; ) {
    var t = s1(n24.domEventName, n24.eventSystemFlags, e[0], n24.nativeEvent);
    if (t === null) {
      t = n24.nativeEvent;
      var i = new t.constructor(t.type, t);
      Qx = i, t.target.dispatchEvent(i), Qx = null;
    } else return e = Pd(t), e !== null && hM(e), n24.blockedOn = t, false;
    e.shift();
  }
  return true;
}
function _A(n24, e, t) {
  cg(n24) && t.delete(e);
}
function UU() {
  r1 = false, xa !== null && cg(xa) && (xa = null), Sa !== null && cg(Sa) && (Sa = null), Ma !== null && cg(Ma) && (Ma = null), Dh.forEach(_A), Oh.forEach(_A);
}
function kf(n24, e) {
  n24.blockedOn === e && (n24.blockedOn = null, r1 || (r1 = true, Lr.unstable_scheduleCallback(Lr.unstable_NormalPriority, UU)));
}
function Uh(n24) {
  function e(r) {
    return kf(r, n24);
  }
  if (0 < Qp.length) {
    kf(Qp[0], n24);
    for (var t = 1; t < Qp.length; t++) {
      var i = Qp[t];
      i.blockedOn === n24 && (i.blockedOn = null);
    }
  }
  for (xa !== null && kf(xa, n24), Sa !== null && kf(Sa, n24), Ma !== null && kf(Ma, n24), Dh.forEach(e), Oh.forEach(e), t = 0; t < fa.length; t++) i = fa[t], i.blockedOn === n24 && (i.blockedOn = null);
  for (; 0 < fa.length && (t = fa[0], t.blockedOn === null); ) $R(t), t.blockedOn === null && fa.shift();
}
var Tc = Ho.ReactCurrentBatchConfig, Vg = true;
function kU(n24, e, t, i) {
  var r = Wt, s = Tc.transition;
  Tc.transition = null;
  try {
    Wt = 1, dM(n24, e, t, i);
  } finally {
    Wt = r, Tc.transition = s;
  }
}
function FU(n24, e, t, i) {
  var r = Wt, s = Tc.transition;
  Tc.transition = null;
  try {
    Wt = 4, dM(n24, e, t, i);
  } finally {
    Wt = r, Tc.transition = s;
  }
}
function dM(n24, e, t, i) {
  if (Vg) {
    var r = s1(n24, e, t, i);
    if (r === null) Ey(n24, e, i, Hg, t), gA(n24, i);
    else if (OU(r, n24, e, t, i)) i.stopPropagation();
    else if (gA(n24, i), e & 4 && -1 < DU.indexOf(n24)) {
      for (; r !== null; ) {
        var s = Pd(r);
        if (s !== null && GR(s), s = s1(n24, e, t, i), s === null && Ey(n24, e, i, Hg, t), s === r) break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else Ey(n24, e, i, null, t);
  }
}
var Hg = null;
function s1(n24, e, t, i) {
  if (Hg = null, n24 = uM(i), n24 = wl(n24), n24 !== null) if (e = tu(n24), e === null) n24 = null;
  else if (t = e.tag, t === 13) {
    if (n24 = OR(e), n24 !== null) return n24;
    n24 = null;
  } else if (t === 3) {
    if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null;
    n24 = null;
  } else e !== n24 && (n24 = null);
  return Hg = n24, null;
}
function YR(n24) {
  switch (n24) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (TU()) {
        case cM:
          return 1;
        case zR:
          return 4;
        case zg:
        case AU:
          return 16;
        case BR:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var ma = null, pM = null, fg = null;
function qR() {
  if (fg) return fg;
  var n24, e = pM, t = e.length, i, r = "value" in ma ? ma.value : ma.textContent, s = r.length;
  for (n24 = 0; n24 < t && e[n24] === r[n24]; n24++) ;
  var o = t - n24;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++) ;
  return fg = r.slice(n24, 1 < i ? 1 - i : void 0);
}
function hg(n24) {
  var e = n24.keyCode;
  return "charCode" in n24 ? (n24 = n24.charCode, n24 === 0 && e === 13 && (n24 = 13)) : n24 = e, n24 === 10 && (n24 = 13), 32 <= n24 || n24 === 13 ? n24 : 0;
}
function em() {
  return true;
}
function vA() {
  return false;
}
function Or(n24) {
  function e(t, i, r, s, o) {
    this._reactName = t, this._targetInst = r, this.type = i, this.nativeEvent = s, this.target = o, this.currentTarget = null;
    for (var a in n24) n24.hasOwnProperty(a) && (t = n24[a], this[a] = t ? t(s) : s[a]);
    return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === false) ? em : vA, this.isPropagationStopped = vA, this;
  }
  return gn(e.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var t = this.nativeEvent;
    t && (t.preventDefault ? t.preventDefault() : typeof t.returnValue != "unknown" && (t.returnValue = false), this.isDefaultPrevented = em);
  }, stopPropagation: function() {
    var t = this.nativeEvent;
    t && (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != "unknown" && (t.cancelBubble = true), this.isPropagationStopped = em);
  }, persist: function() {
  }, isPersistent: em }), e;
}
var tf = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(n24) {
  return n24.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, mM = Or(tf), Rd = gn({}, tf, { view: 0, detail: 0 }), zU = Or(Rd), my, gy, Ff, C0 = gn({}, Rd, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: gM, button: 0, buttons: 0, relatedTarget: function(n24) {
  return n24.relatedTarget === void 0 ? n24.fromElement === n24.srcElement ? n24.toElement : n24.fromElement : n24.relatedTarget;
}, movementX: function(n24) {
  return "movementX" in n24 ? n24.movementX : (n24 !== Ff && (Ff && n24.type === "mousemove" ? (my = n24.screenX - Ff.screenX, gy = n24.screenY - Ff.screenY) : gy = my = 0, Ff = n24), my);
}, movementY: function(n24) {
  return "movementY" in n24 ? n24.movementY : gy;
} }), yA = Or(C0), BU = gn({}, C0, { dataTransfer: 0 }), VU = Or(BU), HU = gn({}, Rd, { relatedTarget: 0 }), _y = Or(HU), GU = gn({}, tf, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), WU = Or(GU), XU = gn({}, tf, { clipboardData: function(n24) {
  return "clipboardData" in n24 ? n24.clipboardData : window.clipboardData;
} }), jU = Or(XU), $U = gn({}, tf, { data: 0 }), xA = Or($U), YU = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, qU = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, KU = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function ZU(n24) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n24) : (n24 = KU[n24]) ? !!e[n24] : false;
}
function gM() {
  return ZU;
}
var JU = gn({}, Rd, { key: function(n24) {
  if (n24.key) {
    var e = YU[n24.key] || n24.key;
    if (e !== "Unidentified") return e;
  }
  return n24.type === "keypress" ? (n24 = hg(n24), n24 === 13 ? "Enter" : String.fromCharCode(n24)) : n24.type === "keydown" || n24.type === "keyup" ? qU[n24.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: gM, charCode: function(n24) {
  return n24.type === "keypress" ? hg(n24) : 0;
}, keyCode: function(n24) {
  return n24.type === "keydown" || n24.type === "keyup" ? n24.keyCode : 0;
}, which: function(n24) {
  return n24.type === "keypress" ? hg(n24) : n24.type === "keydown" || n24.type === "keyup" ? n24.keyCode : 0;
} }), QU = Or(JU), ek = gn({}, C0, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), SA = Or(ek), tk = gn({}, Rd, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: gM }), nk = Or(tk), ik = gn({}, tf, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), rk = Or(ik), sk = gn({}, C0, { deltaX: function(n24) {
  return "deltaX" in n24 ? n24.deltaX : "wheelDeltaX" in n24 ? -n24.wheelDeltaX : 0;
}, deltaY: function(n24) {
  return "deltaY" in n24 ? n24.deltaY : "wheelDeltaY" in n24 ? -n24.wheelDeltaY : "wheelDelta" in n24 ? -n24.wheelDelta : 0;
}, deltaZ: 0, deltaMode: 0 }), ok = Or(sk), ak = [9, 13, 27, 32], _M = Io && "CompositionEvent" in window, mh = null;
Io && "documentMode" in document && (mh = document.documentMode);
var lk = Io && "TextEvent" in window && !mh, KR = Io && (!_M || mh && 8 < mh && 11 >= mh), MA = " ", wA = false;
function ZR(n24, e) {
  switch (n24) {
    case "keyup":
      return ak.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function JR(n24) {
  return n24 = n24.detail, typeof n24 == "object" && "data" in n24 ? n24.data : null;
}
var rc = false;
function uk(n24, e) {
  switch (n24) {
    case "compositionend":
      return JR(e);
    case "keypress":
      return e.which !== 32 ? null : (wA = true, MA);
    case "textInput":
      return n24 = e.data, n24 === MA && wA ? null : n24;
    default:
      return null;
  }
}
function ck(n24, e) {
  if (rc) return n24 === "compositionend" || !_M && ZR(n24, e) ? (n24 = qR(), fg = pM = ma = null, rc = false, n24) : null;
  switch (n24) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return KR && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var fk = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function EA(n24) {
  var e = n24 && n24.nodeName && n24.nodeName.toLowerCase();
  return e === "input" ? !!fk[n24.type] : e === "textarea";
}
function QR(n24, e, t, i) {
  PR(i), e = Gg(e, "onChange"), 0 < e.length && (t = new mM("onChange", "change", null, t, i), n24.push({ event: t, listeners: e }));
}
var gh = null, kh = null;
function hk(n24) {
  cP(n24, 0);
}
function R0(n24) {
  var e = ac(n24);
  if (wR(e)) return n24;
}
function dk(n24, e) {
  if (n24 === "change") return e;
}
var eP = false;
if (Io) {
  var vy;
  if (Io) {
    var yy = "oninput" in document;
    if (!yy) {
      var TA = document.createElement("div");
      TA.setAttribute("oninput", "return;"), yy = typeof TA.oninput == "function";
    }
    vy = yy;
  } else vy = false;
  eP = vy && (!document.documentMode || 9 < document.documentMode);
}
function AA() {
  gh && (gh.detachEvent("onpropertychange", tP), kh = gh = null);
}
function tP(n24) {
  if (n24.propertyName === "value" && R0(kh)) {
    var e = [];
    QR(e, kh, n24, uM(n24)), DR(hk, e);
  }
}
function pk(n24, e, t) {
  n24 === "focusin" ? (AA(), gh = e, kh = t, gh.attachEvent("onpropertychange", tP)) : n24 === "focusout" && AA();
}
function mk(n24) {
  if (n24 === "selectionchange" || n24 === "keyup" || n24 === "keydown") return R0(kh);
}
function gk(n24, e) {
  if (n24 === "click") return R0(e);
}
function _k(n24, e) {
  if (n24 === "input" || n24 === "change") return R0(e);
}
function vk(n24, e) {
  return n24 === e && (n24 !== 0 || 1 / n24 === 1 / e) || n24 !== n24 && e !== e;
}
var Ts = typeof Object.is == "function" ? Object.is : vk;
function Fh(n24, e) {
  if (Ts(n24, e)) return true;
  if (typeof n24 != "object" || n24 === null || typeof e != "object" || e === null) return false;
  var t = Object.keys(n24), i = Object.keys(e);
  if (t.length !== i.length) return false;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Vx.call(e, r) || !Ts(n24[r], e[r])) return false;
  }
  return true;
}
function bA(n24) {
  for (; n24 && n24.firstChild; ) n24 = n24.firstChild;
  return n24;
}
function CA(n24, e) {
  var t = bA(n24);
  n24 = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (i = n24 + t.textContent.length, n24 <= e && i >= e) return { node: t, offset: e - n24 };
      n24 = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = bA(t);
  }
}
function nP(n24, e) {
  return n24 && e ? n24 === e ? true : n24 && n24.nodeType === 3 ? false : e && e.nodeType === 3 ? nP(n24, e.parentNode) : "contains" in n24 ? n24.contains(e) : n24.compareDocumentPosition ? !!(n24.compareDocumentPosition(e) & 16) : false : false;
}
function iP() {
  for (var n24 = window, e = Ug(); e instanceof n24.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = false;
    }
    if (t) n24 = e.contentWindow;
    else break;
    e = Ug(n24.document);
  }
  return e;
}
function vM(n24) {
  var e = n24 && n24.nodeName && n24.nodeName.toLowerCase();
  return e && (e === "input" && (n24.type === "text" || n24.type === "search" || n24.type === "tel" || n24.type === "url" || n24.type === "password") || e === "textarea" || n24.contentEditable === "true");
}
function yk(n24) {
  var e = iP(), t = n24.focusedElem, i = n24.selectionRange;
  if (e !== t && t && t.ownerDocument && nP(t.ownerDocument.documentElement, t)) {
    if (i !== null && vM(t)) {
      if (e = i.start, n24 = i.end, n24 === void 0 && (n24 = e), "selectionStart" in t) t.selectionStart = e, t.selectionEnd = Math.min(n24, t.value.length);
      else if (n24 = (e = t.ownerDocument || document) && e.defaultView || window, n24.getSelection) {
        n24 = n24.getSelection();
        var r = t.textContent.length, s = Math.min(i.start, r);
        i = i.end === void 0 ? s : Math.min(i.end, r), !n24.extend && s > i && (r = i, i = s, s = r), r = CA(t, s);
        var o = CA(t, i);
        r && o && (n24.rangeCount !== 1 || n24.anchorNode !== r.node || n24.anchorOffset !== r.offset || n24.focusNode !== o.node || n24.focusOffset !== o.offset) && (e = e.createRange(), e.setStart(r.node, r.offset), n24.removeAllRanges(), s > i ? (n24.addRange(e), n24.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset), n24.addRange(e)));
      }
    }
    for (e = [], n24 = t; n24 = n24.parentNode; ) n24.nodeType === 1 && e.push({ element: n24, left: n24.scrollLeft, top: n24.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++) n24 = e[t], n24.element.scrollLeft = n24.left, n24.element.scrollTop = n24.top;
  }
}
var xk = Io && "documentMode" in document && 11 >= document.documentMode, sc = null, o1 = null, _h = null, a1 = false;
function RA(n24, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  a1 || sc == null || sc !== Ug(i) || (i = sc, "selectionStart" in i && vM(i) ? i = { start: i.selectionStart, end: i.selectionEnd } : (i = (i.ownerDocument && i.ownerDocument.defaultView || window).getSelection(), i = { anchorNode: i.anchorNode, anchorOffset: i.anchorOffset, focusNode: i.focusNode, focusOffset: i.focusOffset }), _h && Fh(_h, i) || (_h = i, i = Gg(o1, "onSelect"), 0 < i.length && (e = new mM("onSelect", "select", null, e, t), n24.push({ event: e, listeners: i }), e.target = sc)));
}
function tm(n24, e) {
  var t = {};
  return t[n24.toLowerCase()] = e.toLowerCase(), t["Webkit" + n24] = "webkit" + e, t["Moz" + n24] = "moz" + e, t;
}
var oc = { animationend: tm("Animation", "AnimationEnd"), animationiteration: tm("Animation", "AnimationIteration"), animationstart: tm("Animation", "AnimationStart"), transitionend: tm("Transition", "TransitionEnd") }, xy = {}, rP = {};
Io && (rP = document.createElement("div").style, "AnimationEvent" in window || (delete oc.animationend.animation, delete oc.animationiteration.animation, delete oc.animationstart.animation), "TransitionEvent" in window || delete oc.transitionend.transition);
function P0(n24) {
  if (xy[n24]) return xy[n24];
  if (!oc[n24]) return n24;
  var e = oc[n24], t;
  for (t in e) if (e.hasOwnProperty(t) && t in rP) return xy[n24] = e[t];
  return n24;
}
var sP = P0("animationend"), oP = P0("animationiteration"), aP = P0("animationstart"), lP = P0("transitionend"), uP = /* @__PURE__ */ new Map(), PA = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Ba(n24, e) {
  uP.set(n24, e), eu(e, [n24]);
}
for (var Sy = 0; Sy < PA.length; Sy++) {
  var My = PA[Sy], Sk = My.toLowerCase(), Mk = My[0].toUpperCase() + My.slice(1);
  Ba(Sk, "on" + Mk);
}
Ba(sP, "onAnimationEnd");
Ba(oP, "onAnimationIteration");
Ba(aP, "onAnimationStart");
Ba("dblclick", "onDoubleClick");
Ba("focusin", "onFocus");
Ba("focusout", "onBlur");
Ba(lP, "onTransitionEnd");
Dc("onMouseEnter", ["mouseout", "mouseover"]);
Dc("onMouseLeave", ["mouseout", "mouseover"]);
Dc("onPointerEnter", ["pointerout", "pointerover"]);
Dc("onPointerLeave", ["pointerout", "pointerover"]);
eu("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
eu("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
eu("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
eu("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
eu("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
eu("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lh = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), wk = new Set("cancel close invalid load scroll toggle".split(" ").concat(lh));
function LA(n24, e, t) {
  var i = n24.type || "unknown-event";
  n24.currentTarget = t, SU(i, e, void 0, n24), n24.currentTarget = null;
}
function cP(n24, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n24.length; t++) {
    var i = n24[t], r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e) for (var o = i.length - 1; 0 <= o; o--) {
        var a = i[o], l = a.instance, f = a.currentTarget;
        if (a = a.listener, l !== s && r.isPropagationStopped()) break e;
        LA(r, a, f), s = l;
      }
      else for (o = 0; o < i.length; o++) {
        if (a = i[o], l = a.instance, f = a.currentTarget, a = a.listener, l !== s && r.isPropagationStopped()) break e;
        LA(r, a, f), s = l;
      }
    }
  }
  if (Fg) throw n24 = n1, Fg = false, n1 = null, n24;
}
function en(n24, e) {
  var t = e[h1];
  t === void 0 && (t = e[h1] = /* @__PURE__ */ new Set());
  var i = n24 + "__bubble";
  t.has(i) || (fP(e, n24, 2, false), t.add(i));
}
function wy(n24, e, t) {
  var i = 0;
  e && (i |= 4), fP(t, n24, i, e);
}
var nm = "_reactListening" + Math.random().toString(36).slice(2);
function zh(n24) {
  if (!n24[nm]) {
    n24[nm] = true, vR.forEach(function(t) {
      t !== "selectionchange" && (wk.has(t) || wy(t, false, n24), wy(t, true, n24));
    });
    var e = n24.nodeType === 9 ? n24 : n24.ownerDocument;
    e === null || e[nm] || (e[nm] = true, wy("selectionchange", false, e));
  }
}
function fP(n24, e, t, i) {
  switch (YR(e)) {
    case 1:
      var r = kU;
      break;
    case 4:
      r = FU;
      break;
    default:
      r = dM;
  }
  t = r.bind(null, e, t, n24), r = void 0, !t1 || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (r = true), i ? r !== void 0 ? n24.addEventListener(e, t, { capture: true, passive: r }) : n24.addEventListener(e, t, true) : r !== void 0 ? n24.addEventListener(e, t, { passive: r }) : n24.addEventListener(e, t, false);
}
function Ey(n24, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null) e: for (; ; ) {
    if (i === null) return;
    var o = i.tag;
    if (o === 3 || o === 4) {
      var a = i.stateNode.containerInfo;
      if (a === r || a.nodeType === 8 && a.parentNode === r) break;
      if (o === 4) for (o = i.return; o !== null; ) {
        var l = o.tag;
        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo, l === r || l.nodeType === 8 && l.parentNode === r)) return;
        o = o.return;
      }
      for (; a !== null; ) {
        if (o = wl(a), o === null) return;
        if (l = o.tag, l === 5 || l === 6) {
          i = s = o;
          continue e;
        }
        a = a.parentNode;
      }
    }
    i = i.return;
  }
  DR(function() {
    var f = s, h = uM(t), d = [];
    e: {
      var p = uP.get(n24);
      if (p !== void 0) {
        var g = mM, v = n24;
        switch (n24) {
          case "keypress":
            if (hg(t) === 0) break e;
          case "keydown":
          case "keyup":
            g = QU;
            break;
          case "focusin":
            v = "focus", g = _y;
            break;
          case "focusout":
            v = "blur", g = _y;
            break;
          case "beforeblur":
          case "afterblur":
            g = _y;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            g = yA;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            g = VU;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            g = nk;
            break;
          case sP:
          case oP:
          case aP:
            g = WU;
            break;
          case lP:
            g = rk;
            break;
          case "scroll":
            g = zU;
            break;
          case "wheel":
            g = ok;
            break;
          case "copy":
          case "cut":
          case "paste":
            g = jU;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            g = SA;
        }
        var S = (e & 4) !== 0, M = !S && n24 === "scroll", m = S ? p !== null ? p + "Capture" : null : p;
        S = [];
        for (var w = f, E; w !== null; ) {
          E = w;
          var A = E.stateNode;
          if (E.tag === 5 && A !== null && (E = A, m !== null && (A = Nh(w, m), A != null && S.push(Bh(w, A, E)))), M) break;
          w = w.return;
        }
        0 < S.length && (p = new g(p, v, null, t, h), d.push({ event: p, listeners: S }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (p = n24 === "mouseover" || n24 === "pointerover", g = n24 === "mouseout" || n24 === "pointerout", p && t !== Qx && (v = t.relatedTarget || t.fromElement) && (wl(v) || v[No])) break e;
        if ((g || p) && (p = h.window === h ? h : (p = h.ownerDocument) ? p.defaultView || p.parentWindow : window, g ? (v = t.relatedTarget || t.toElement, g = f, v = v ? wl(v) : null, v !== null && (M = tu(v), v !== M || v.tag !== 5 && v.tag !== 6) && (v = null)) : (g = null, v = f), g !== v)) {
          if (S = yA, A = "onMouseLeave", m = "onMouseEnter", w = "mouse", (n24 === "pointerout" || n24 === "pointerover") && (S = SA, A = "onPointerLeave", m = "onPointerEnter", w = "pointer"), M = g == null ? p : ac(g), E = v == null ? p : ac(v), p = new S(A, w + "leave", g, t, h), p.target = M, p.relatedTarget = E, A = null, wl(h) === f && (S = new S(m, w + "enter", v, t, h), S.target = E, S.relatedTarget = M, A = S), M = A, g && v) t: {
            for (S = g, m = v, w = 0, E = S; E; E = Eu(E)) w++;
            for (E = 0, A = m; A; A = Eu(A)) E++;
            for (; 0 < w - E; ) S = Eu(S), w--;
            for (; 0 < E - w; ) m = Eu(m), E--;
            for (; w--; ) {
              if (S === m || m !== null && S === m.alternate) break t;
              S = Eu(S), m = Eu(m);
            }
            S = null;
          }
          else S = null;
          g !== null && IA(d, p, g, S, false), v !== null && M !== null && IA(d, M, v, S, true);
        }
      }
      e: {
        if (p = f ? ac(f) : window, g = p.nodeName && p.nodeName.toLowerCase(), g === "select" || g === "input" && p.type === "file") var P = dk;
        else if (EA(p)) if (eP) P = _k;
        else {
          P = mk;
          var R = pk;
        }
        else (g = p.nodeName) && g.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (P = gk);
        if (P && (P = P(n24, f))) {
          QR(d, P, t, h);
          break e;
        }
        R && R(n24, p, f), n24 === "focusout" && (R = p._wrapperState) && R.controlled && p.type === "number" && Yx(p, "number", p.value);
      }
      switch (R = f ? ac(f) : window, n24) {
        case "focusin":
          (EA(R) || R.contentEditable === "true") && (sc = R, o1 = f, _h = null);
          break;
        case "focusout":
          _h = o1 = sc = null;
          break;
        case "mousedown":
          a1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          a1 = false, RA(d, t, h);
          break;
        case "selectionchange":
          if (xk) break;
        case "keydown":
        case "keyup":
          RA(d, t, h);
      }
      var L;
      if (_M) e: {
        switch (n24) {
          case "compositionstart":
            var D = "onCompositionStart";
            break e;
          case "compositionend":
            D = "onCompositionEnd";
            break e;
          case "compositionupdate":
            D = "onCompositionUpdate";
            break e;
        }
        D = void 0;
      }
      else rc ? ZR(n24, t) && (D = "onCompositionEnd") : n24 === "keydown" && t.keyCode === 229 && (D = "onCompositionStart");
      D && (KR && t.locale !== "ko" && (rc || D !== "onCompositionStart" ? D === "onCompositionEnd" && rc && (L = qR()) : (ma = h, pM = "value" in ma ? ma.value : ma.textContent, rc = true)), R = Gg(f, D), 0 < R.length && (D = new xA(D, n24, null, t, h), d.push({ event: D, listeners: R }), L ? D.data = L : (L = JR(t), L !== null && (D.data = L)))), (L = lk ? uk(n24, t) : ck(n24, t)) && (f = Gg(f, "onBeforeInput"), 0 < f.length && (h = new xA("onBeforeInput", "beforeinput", null, t, h), d.push({ event: h, listeners: f }), h.data = L));
    }
    cP(d, e);
  });
}
function Bh(n24, e, t) {
  return { instance: n24, listener: e, currentTarget: t };
}
function Gg(n24, e) {
  for (var t = e + "Capture", i = []; n24 !== null; ) {
    var r = n24, s = r.stateNode;
    r.tag === 5 && s !== null && (r = s, s = Nh(n24, t), s != null && i.unshift(Bh(n24, s, r)), s = Nh(n24, e), s != null && i.push(Bh(n24, s, r))), n24 = n24.return;
  }
  return i;
}
function Eu(n24) {
  if (n24 === null) return null;
  do
    n24 = n24.return;
  while (n24 && n24.tag !== 5);
  return n24 || null;
}
function IA(n24, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t, l = a.alternate, f = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 && f !== null && (a = f, r ? (l = Nh(t, s), l != null && o.unshift(Bh(t, l, a))) : r || (l = Nh(t, s), l != null && o.push(Bh(t, l, a)))), t = t.return;
  }
  o.length !== 0 && n24.push({ event: e, listeners: o });
}
var Ek = /\r\n?/g, Tk = /\u0000|\uFFFD/g;
function NA(n24) {
  return (typeof n24 == "string" ? n24 : "" + n24).replace(Ek, `
`).replace(Tk, "");
}
function im(n24, e, t) {
  if (e = NA(e), NA(n24) !== e && t) throw Error(Me(425));
}
function Wg() {
}
var l1 = null, u1 = null;
function c1(n24, e) {
  return n24 === "textarea" || n24 === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null;
}
var f1 = typeof setTimeout == "function" ? setTimeout : void 0, Ak = typeof clearTimeout == "function" ? clearTimeout : void 0, DA = typeof Promise == "function" ? Promise : void 0, bk = typeof queueMicrotask == "function" ? queueMicrotask : typeof DA < "u" ? function(n24) {
  return DA.resolve(null).then(n24).catch(Ck);
} : f1;
function Ck(n24) {
  setTimeout(function() {
    throw n24;
  });
}
function Ty(n24, e) {
  var t = e, i = 0;
  do {
    var r = t.nextSibling;
    if (n24.removeChild(t), r && r.nodeType === 8) if (t = r.data, t === "/$") {
      if (i === 0) {
        n24.removeChild(r), Uh(e);
        return;
      }
      i--;
    } else t !== "$" && t !== "$?" && t !== "$!" || i++;
    t = r;
  } while (t);
  Uh(e);
}
function wa(n24) {
  for (; n24 != null; n24 = n24.nextSibling) {
    var e = n24.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (e = n24.data, e === "$" || e === "$!" || e === "$?") break;
      if (e === "/$") return null;
    }
  }
  return n24;
}
function OA(n24) {
  n24 = n24.previousSibling;
  for (var e = 0; n24; ) {
    if (n24.nodeType === 8) {
      var t = n24.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n24;
        e--;
      } else t === "/$" && e++;
    }
    n24 = n24.previousSibling;
  }
  return null;
}
var nf = Math.random().toString(36).slice(2), Ws = "__reactFiber$" + nf, Vh = "__reactProps$" + nf, No = "__reactContainer$" + nf, h1 = "__reactEvents$" + nf, Rk = "__reactListeners$" + nf, Pk = "__reactHandles$" + nf;
function wl(n24) {
  var e = n24[Ws];
  if (e) return e;
  for (var t = n24.parentNode; t; ) {
    if (e = t[No] || t[Ws]) {
      if (t = e.alternate, e.child !== null || t !== null && t.child !== null) for (n24 = OA(n24); n24 !== null; ) {
        if (t = n24[Ws]) return t;
        n24 = OA(n24);
      }
      return e;
    }
    n24 = t, t = n24.parentNode;
  }
  return null;
}
function Pd(n24) {
  return n24 = n24[Ws] || n24[No], !n24 || n24.tag !== 5 && n24.tag !== 6 && n24.tag !== 13 && n24.tag !== 3 ? null : n24;
}
function ac(n24) {
  if (n24.tag === 5 || n24.tag === 6) return n24.stateNode;
  throw Error(Me(33));
}
function L0(n24) {
  return n24[Vh] || null;
}
var d1 = [], lc = -1;
function Va(n24) {
  return { current: n24 };
}
function nn(n24) {
  0 > lc || (n24.current = d1[lc], d1[lc] = null, lc--);
}
function Jt(n24, e) {
  lc++, d1[lc] = n24.current, n24.current = e;
}
var Da = {}, Li = Va(Da), tr = Va(false), Wl = Da;
function Oc(n24, e) {
  var t = n24.type.contextTypes;
  if (!t) return Da;
  var i = n24.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e) return i.__reactInternalMemoizedMaskedChildContext;
  var r = {}, s;
  for (s in t) r[s] = e[s];
  return i && (n24 = n24.stateNode, n24.__reactInternalMemoizedUnmaskedChildContext = e, n24.__reactInternalMemoizedMaskedChildContext = r), r;
}
function nr(n24) {
  return n24 = n24.childContextTypes, n24 != null;
}
function Xg() {
  nn(tr), nn(Li);
}
function UA(n24, e, t) {
  if (Li.current !== Da) throw Error(Me(168));
  Jt(Li, e), Jt(tr, t);
}
function hP(n24, e, t) {
  var i = n24.stateNode;
  if (e = e.childContextTypes, typeof i.getChildContext != "function") return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(Me(108, pU(n24) || "Unknown", r));
  return gn({}, t, i);
}
function jg(n24) {
  return n24 = (n24 = n24.stateNode) && n24.__reactInternalMemoizedMergedChildContext || Da, Wl = Li.current, Jt(Li, n24), Jt(tr, tr.current), true;
}
function kA(n24, e, t) {
  var i = n24.stateNode;
  if (!i) throw Error(Me(169));
  t ? (n24 = hP(n24, e, Wl), i.__reactInternalMemoizedMergedChildContext = n24, nn(tr), nn(Li), Jt(Li, n24)) : nn(tr), Jt(tr, t);
}
var wo = null, I0 = false, Ay = false;
function dP(n24) {
  wo === null ? wo = [n24] : wo.push(n24);
}
function Lk(n24) {
  I0 = true, dP(n24);
}
function Ha() {
  if (!Ay && wo !== null) {
    Ay = true;
    var n24 = 0, e = Wt;
    try {
      var t = wo;
      for (Wt = 1; n24 < t.length; n24++) {
        var i = t[n24];
        do
          i = i(true);
        while (i !== null);
      }
      wo = null, I0 = false;
    } catch (r) {
      throw wo !== null && (wo = wo.slice(n24 + 1)), FR(cM, Ha), r;
    } finally {
      Wt = e, Ay = false;
    }
  }
  return null;
}
var uc = [], cc = 0, $g = null, Yg = 0, Qr = [], es = 0, Xl = null, Ao = 1, bo = "";
function ml(n24, e) {
  uc[cc++] = Yg, uc[cc++] = $g, $g = n24, Yg = e;
}
function pP(n24, e, t) {
  Qr[es++] = Ao, Qr[es++] = bo, Qr[es++] = Xl, Xl = n24;
  var i = Ao;
  n24 = bo;
  var r = 32 - Ms(i) - 1;
  i &= ~(1 << r), t += 1;
  var s = 32 - Ms(e) + r;
  if (30 < s) {
    var o = r - r % 5;
    s = (i & (1 << o) - 1).toString(32), i >>= o, r -= o, Ao = 1 << 32 - Ms(e) + r | t << r | i, bo = s + n24;
  } else Ao = 1 << s | t << r | i, bo = n24;
}
function yM(n24) {
  n24.return !== null && (ml(n24, 1), pP(n24, 1, 0));
}
function xM(n24) {
  for (; n24 === $g; ) $g = uc[--cc], uc[cc] = null, Yg = uc[--cc], uc[cc] = null;
  for (; n24 === Xl; ) Xl = Qr[--es], Qr[es] = null, bo = Qr[--es], Qr[es] = null, Ao = Qr[--es], Qr[es] = null;
}
var br = null, Tr = null, on = false, xs = null;
function mP(n24, e) {
  var t = is(5, null, null, 0);
  t.elementType = "DELETED", t.stateNode = e, t.return = n24, e = n24.deletions, e === null ? (n24.deletions = [t], n24.flags |= 16) : e.push(t);
}
function FA(n24, e) {
  switch (n24.tag) {
    case 5:
      var t = n24.type;
      return e = e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (n24.stateNode = e, br = n24, Tr = wa(e.firstChild), true) : false;
    case 6:
      return e = n24.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (n24.stateNode = e, br = n24, Tr = null, true) : false;
    case 13:
      return e = e.nodeType !== 8 ? null : e, e !== null ? (t = Xl !== null ? { id: Ao, overflow: bo } : null, n24.memoizedState = { dehydrated: e, treeContext: t, retryLane: 1073741824 }, t = is(18, null, null, 0), t.stateNode = e, t.return = n24, n24.child = t, br = n24, Tr = null, true) : false;
    default:
      return false;
  }
}
function p1(n24) {
  return (n24.mode & 1) !== 0 && (n24.flags & 128) === 0;
}
function m1(n24) {
  if (on) {
    var e = Tr;
    if (e) {
      var t = e;
      if (!FA(n24, e)) {
        if (p1(n24)) throw Error(Me(418));
        e = wa(t.nextSibling);
        var i = br;
        e && FA(n24, e) ? mP(i, t) : (n24.flags = n24.flags & -4097 | 2, on = false, br = n24);
      }
    } else {
      if (p1(n24)) throw Error(Me(418));
      n24.flags = n24.flags & -4097 | 2, on = false, br = n24;
    }
  }
}
function zA(n24) {
  for (n24 = n24.return; n24 !== null && n24.tag !== 5 && n24.tag !== 3 && n24.tag !== 13; ) n24 = n24.return;
  br = n24;
}
function rm(n24) {
  if (n24 !== br) return false;
  if (!on) return zA(n24), on = true, false;
  var e;
  if ((e = n24.tag !== 3) && !(e = n24.tag !== 5) && (e = n24.type, e = e !== "head" && e !== "body" && !c1(n24.type, n24.memoizedProps)), e && (e = Tr)) {
    if (p1(n24)) throw gP(), Error(Me(418));
    for (; e; ) mP(n24, e), e = wa(e.nextSibling);
  }
  if (zA(n24), n24.tag === 13) {
    if (n24 = n24.memoizedState, n24 = n24 !== null ? n24.dehydrated : null, !n24) throw Error(Me(317));
    e: {
      for (n24 = n24.nextSibling, e = 0; n24; ) {
        if (n24.nodeType === 8) {
          var t = n24.data;
          if (t === "/$") {
            if (e === 0) {
              Tr = wa(n24.nextSibling);
              break e;
            }
            e--;
          } else t !== "$" && t !== "$!" && t !== "$?" || e++;
        }
        n24 = n24.nextSibling;
      }
      Tr = null;
    }
  } else Tr = br ? wa(n24.stateNode.nextSibling) : null;
  return true;
}
function gP() {
  for (var n24 = Tr; n24; ) n24 = wa(n24.nextSibling);
}
function Uc() {
  Tr = br = null, on = false;
}
function SM(n24) {
  xs === null ? xs = [n24] : xs.push(n24);
}
var Ik = Ho.ReactCurrentBatchConfig;
function zf(n24, e, t) {
  if (n24 = t.ref, n24 !== null && typeof n24 != "function" && typeof n24 != "object") {
    if (t._owner) {
      if (t = t._owner, t) {
        if (t.tag !== 1) throw Error(Me(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(Me(147, n24));
      var r = i, s = "" + n24;
      return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function(o) {
        var a = r.refs;
        o === null ? delete a[s] : a[s] = o;
      }, e._stringRef = s, e);
    }
    if (typeof n24 != "string") throw Error(Me(284));
    if (!t._owner) throw Error(Me(290, n24));
  }
  return n24;
}
function sm(n24, e) {
  throw n24 = Object.prototype.toString.call(e), Error(Me(31, n24 === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : n24));
}
function BA(n24) {
  var e = n24._init;
  return e(n24._payload);
}
function _P(n24) {
  function e(m, w) {
    if (n24) {
      var E = m.deletions;
      E === null ? (m.deletions = [w], m.flags |= 16) : E.push(w);
    }
  }
  function t(m, w) {
    if (!n24) return null;
    for (; w !== null; ) e(m, w), w = w.sibling;
    return null;
  }
  function i(m, w) {
    for (m = /* @__PURE__ */ new Map(); w !== null; ) w.key !== null ? m.set(w.key, w) : m.set(w.index, w), w = w.sibling;
    return m;
  }
  function r(m, w) {
    return m = ba(m, w), m.index = 0, m.sibling = null, m;
  }
  function s(m, w, E) {
    return m.index = E, n24 ? (E = m.alternate, E !== null ? (E = E.index, E < w ? (m.flags |= 2, w) : E) : (m.flags |= 2, w)) : (m.flags |= 1048576, w);
  }
  function o(m) {
    return n24 && m.alternate === null && (m.flags |= 2), m;
  }
  function a(m, w, E, A) {
    return w === null || w.tag !== 6 ? (w = Ny(E, m.mode, A), w.return = m, w) : (w = r(w, E), w.return = m, w);
  }
  function l(m, w, E, A) {
    var P = E.type;
    return P === ic ? h(m, w, E.props.children, A, E.key) : w !== null && (w.elementType === P || typeof P == "object" && P !== null && P.$$typeof === la && BA(P) === w.type) ? (A = r(w, E.props), A.ref = zf(m, w, E), A.return = m, A) : (A = yg(E.type, E.key, E.props, null, m.mode, A), A.ref = zf(m, w, E), A.return = m, A);
  }
  function f(m, w, E, A) {
    return w === null || w.tag !== 4 || w.stateNode.containerInfo !== E.containerInfo || w.stateNode.implementation !== E.implementation ? (w = Dy(E, m.mode, A), w.return = m, w) : (w = r(w, E.children || []), w.return = m, w);
  }
  function h(m, w, E, A, P) {
    return w === null || w.tag !== 7 ? (w = Nl(E, m.mode, A, P), w.return = m, w) : (w = r(w, E), w.return = m, w);
  }
  function d(m, w, E) {
    if (typeof w == "string" && w !== "" || typeof w == "number") return w = Ny("" + w, m.mode, E), w.return = m, w;
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Yp:
          return E = yg(w.type, w.key, w.props, null, m.mode, E), E.ref = zf(m, null, w), E.return = m, E;
        case nc:
          return w = Dy(w, m.mode, E), w.return = m, w;
        case la:
          var A = w._init;
          return d(m, A(w._payload), E);
      }
      if (oh(w) || Df(w)) return w = Nl(w, m.mode, E, null), w.return = m, w;
      sm(m, w);
    }
    return null;
  }
  function p(m, w, E, A) {
    var P = w !== null ? w.key : null;
    if (typeof E == "string" && E !== "" || typeof E == "number") return P !== null ? null : a(m, w, "" + E, A);
    if (typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case Yp:
          return E.key === P ? l(m, w, E, A) : null;
        case nc:
          return E.key === P ? f(m, w, E, A) : null;
        case la:
          return P = E._init, p(m, w, P(E._payload), A);
      }
      if (oh(E) || Df(E)) return P !== null ? null : h(m, w, E, A, null);
      sm(m, E);
    }
    return null;
  }
  function g(m, w, E, A, P) {
    if (typeof A == "string" && A !== "" || typeof A == "number") return m = m.get(E) || null, a(w, m, "" + A, P);
    if (typeof A == "object" && A !== null) {
      switch (A.$$typeof) {
        case Yp:
          return m = m.get(A.key === null ? E : A.key) || null, l(w, m, A, P);
        case nc:
          return m = m.get(A.key === null ? E : A.key) || null, f(w, m, A, P);
        case la:
          var R = A._init;
          return g(m, w, E, R(A._payload), P);
      }
      if (oh(A) || Df(A)) return m = m.get(E) || null, h(w, m, A, P, null);
      sm(w, A);
    }
    return null;
  }
  function v(m, w, E, A) {
    for (var P = null, R = null, L = w, D = w = 0, F = null; L !== null && D < E.length; D++) {
      L.index > D ? (F = L, L = null) : F = L.sibling;
      var C = p(m, L, E[D], A);
      if (C === null) {
        L === null && (L = F);
        break;
      }
      n24 && L && C.alternate === null && e(m, L), w = s(C, w, D), R === null ? P = C : R.sibling = C, R = C, L = F;
    }
    if (D === E.length) return t(m, L), on && ml(m, D), P;
    if (L === null) {
      for (; D < E.length; D++) L = d(m, E[D], A), L !== null && (w = s(L, w, D), R === null ? P = L : R.sibling = L, R = L);
      return on && ml(m, D), P;
    }
    for (L = i(m, L); D < E.length; D++) F = g(L, m, D, E[D], A), F !== null && (n24 && F.alternate !== null && L.delete(F.key === null ? D : F.key), w = s(F, w, D), R === null ? P = F : R.sibling = F, R = F);
    return n24 && L.forEach(function(N) {
      return e(m, N);
    }), on && ml(m, D), P;
  }
  function S(m, w, E, A) {
    var P = Df(E);
    if (typeof P != "function") throw Error(Me(150));
    if (E = P.call(E), E == null) throw Error(Me(151));
    for (var R = P = null, L = w, D = w = 0, F = null, C = E.next(); L !== null && !C.done; D++, C = E.next()) {
      L.index > D ? (F = L, L = null) : F = L.sibling;
      var N = p(m, L, C.value, A);
      if (N === null) {
        L === null && (L = F);
        break;
      }
      n24 && L && N.alternate === null && e(m, L), w = s(N, w, D), R === null ? P = N : R.sibling = N, R = N, L = F;
    }
    if (C.done) return t(m, L), on && ml(m, D), P;
    if (L === null) {
      for (; !C.done; D++, C = E.next()) C = d(m, C.value, A), C !== null && (w = s(C, w, D), R === null ? P = C : R.sibling = C, R = C);
      return on && ml(m, D), P;
    }
    for (L = i(m, L); !C.done; D++, C = E.next()) C = g(L, m, D, C.value, A), C !== null && (n24 && C.alternate !== null && L.delete(C.key === null ? D : C.key), w = s(C, w, D), R === null ? P = C : R.sibling = C, R = C);
    return n24 && L.forEach(function(j) {
      return e(m, j);
    }), on && ml(m, D), P;
  }
  function M(m, w, E, A) {
    if (typeof E == "object" && E !== null && E.type === ic && E.key === null && (E = E.props.children), typeof E == "object" && E !== null) {
      switch (E.$$typeof) {
        case Yp:
          e: {
            for (var P = E.key, R = w; R !== null; ) {
              if (R.key === P) {
                if (P = E.type, P === ic) {
                  if (R.tag === 7) {
                    t(m, R.sibling), w = r(R, E.props.children), w.return = m, m = w;
                    break e;
                  }
                } else if (R.elementType === P || typeof P == "object" && P !== null && P.$$typeof === la && BA(P) === R.type) {
                  t(m, R.sibling), w = r(R, E.props), w.ref = zf(m, R, E), w.return = m, m = w;
                  break e;
                }
                t(m, R);
                break;
              } else e(m, R);
              R = R.sibling;
            }
            E.type === ic ? (w = Nl(E.props.children, m.mode, A, E.key), w.return = m, m = w) : (A = yg(E.type, E.key, E.props, null, m.mode, A), A.ref = zf(m, w, E), A.return = m, m = A);
          }
          return o(m);
        case nc:
          e: {
            for (R = E.key; w !== null; ) {
              if (w.key === R) if (w.tag === 4 && w.stateNode.containerInfo === E.containerInfo && w.stateNode.implementation === E.implementation) {
                t(m, w.sibling), w = r(w, E.children || []), w.return = m, m = w;
                break e;
              } else {
                t(m, w);
                break;
              }
              else e(m, w);
              w = w.sibling;
            }
            w = Dy(E, m.mode, A), w.return = m, m = w;
          }
          return o(m);
        case la:
          return R = E._init, M(m, w, R(E._payload), A);
      }
      if (oh(E)) return v(m, w, E, A);
      if (Df(E)) return S(m, w, E, A);
      sm(m, E);
    }
    return typeof E == "string" && E !== "" || typeof E == "number" ? (E = "" + E, w !== null && w.tag === 6 ? (t(m, w.sibling), w = r(w, E), w.return = m, m = w) : (t(m, w), w = Ny(E, m.mode, A), w.return = m, m = w), o(m)) : t(m, w);
  }
  return M;
}
var kc = _P(true), vP = _P(false), qg = Va(null), Kg = null, fc = null, MM = null;
function wM() {
  MM = fc = Kg = null;
}
function EM(n24) {
  var e = qg.current;
  nn(qg), n24._currentValue = e;
}
function g1(n24, e, t) {
  for (; n24 !== null; ) {
    var i = n24.alternate;
    if ((n24.childLanes & e) !== e ? (n24.childLanes |= e, i !== null && (i.childLanes |= e)) : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e), n24 === t) break;
    n24 = n24.return;
  }
}
function Ac(n24, e) {
  Kg = n24, MM = fc = null, n24 = n24.dependencies, n24 !== null && n24.firstContext !== null && (n24.lanes & e && (er = true), n24.firstContext = null);
}
function os(n24) {
  var e = n24._currentValue;
  if (MM !== n24) if (n24 = { context: n24, memoizedValue: e, next: null }, fc === null) {
    if (Kg === null) throw Error(Me(308));
    fc = n24, Kg.dependencies = { lanes: 0, firstContext: n24 };
  } else fc = fc.next = n24;
  return e;
}
var El = null;
function TM(n24) {
  El === null ? El = [n24] : El.push(n24);
}
function yP(n24, e, t, i) {
  var r = e.interleaved;
  return r === null ? (t.next = t, TM(e)) : (t.next = r.next, r.next = t), e.interleaved = t, Do(n24, i);
}
function Do(n24, e) {
  n24.lanes |= e;
  var t = n24.alternate;
  for (t !== null && (t.lanes |= e), t = n24, n24 = n24.return; n24 !== null; ) n24.childLanes |= e, t = n24.alternate, t !== null && (t.childLanes |= e), t = n24, n24 = n24.return;
  return t.tag === 3 ? t.stateNode : null;
}
var ua = false;
function AM(n24) {
  n24.updateQueue = { baseState: n24.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function xP(n24, e) {
  n24 = n24.updateQueue, e.updateQueue === n24 && (e.updateQueue = { baseState: n24.baseState, firstBaseUpdate: n24.firstBaseUpdate, lastBaseUpdate: n24.lastBaseUpdate, shared: n24.shared, effects: n24.effects });
}
function Po(n24, e) {
  return { eventTime: n24, lane: e, tag: 0, payload: null, callback: null, next: null };
}
function Ea(n24, e, t) {
  var i = n24.updateQueue;
  if (i === null) return null;
  if (i = i.shared, Pt & 2) {
    var r = i.pending;
    return r === null ? e.next = e : (e.next = r.next, r.next = e), i.pending = e, Do(n24, t);
  }
  return r = i.interleaved, r === null ? (e.next = e, TM(i)) : (e.next = r.next, r.next = e), i.interleaved = e, Do(n24, t);
}
function dg(n24, e, t) {
  if (e = e.updateQueue, e !== null && (e = e.shared, (t & 4194240) !== 0)) {
    var i = e.lanes;
    i &= n24.pendingLanes, t |= i, e.lanes = t, fM(n24, t);
  }
}
function VA(n24, e) {
  var t = n24.updateQueue, i = n24.alternate;
  if (i !== null && (i = i.updateQueue, t === i)) {
    var r = null, s = null;
    if (t = t.firstBaseUpdate, t !== null) {
      do {
        var o = { eventTime: t.eventTime, lane: t.lane, tag: t.tag, payload: t.payload, callback: t.callback, next: null };
        s === null ? r = s = o : s = s.next = o, t = t.next;
      } while (t !== null);
      s === null ? r = s = e : s = s.next = e;
    } else r = s = e;
    t = { baseState: i.baseState, firstBaseUpdate: r, lastBaseUpdate: s, shared: i.shared, effects: i.effects }, n24.updateQueue = t;
    return;
  }
  n24 = t.lastBaseUpdate, n24 === null ? t.firstBaseUpdate = e : n24.next = e, t.lastBaseUpdate = e;
}
function Zg(n24, e, t, i) {
  var r = n24.updateQueue;
  ua = false;
  var s = r.firstBaseUpdate, o = r.lastBaseUpdate, a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a, f = l.next;
    l.next = null, o === null ? s = f : o.next = f, o = l;
    var h = n24.alternate;
    h !== null && (h = h.updateQueue, a = h.lastBaseUpdate, a !== o && (a === null ? h.firstBaseUpdate = f : a.next = f, h.lastBaseUpdate = l));
  }
  if (s !== null) {
    var d = r.baseState;
    o = 0, h = f = l = null, a = s;
    do {
      var p = a.lane, g = a.eventTime;
      if ((i & p) === p) {
        h !== null && (h = h.next = { eventTime: g, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null });
        e: {
          var v = n24, S = a;
          switch (p = e, g = t, S.tag) {
            case 1:
              if (v = S.payload, typeof v == "function") {
                d = v.call(g, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = v.flags & -65537 | 128;
            case 0:
              if (v = S.payload, p = typeof v == "function" ? v.call(g, d, p) : v, p == null) break e;
              d = gn({}, d, p);
              break e;
            case 2:
              ua = true;
          }
        }
        a.callback !== null && a.lane !== 0 && (n24.flags |= 64, p = r.effects, p === null ? r.effects = [a] : p.push(a));
      } else g = { eventTime: g, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, h === null ? (f = h = g, l = d) : h = h.next = g, o |= p;
      if (a = a.next, a === null) {
        if (a = r.shared.pending, a === null) break;
        p = a, a = p.next, p.next = null, r.lastBaseUpdate = p, r.shared.pending = null;
      }
    } while (true);
    if (h === null && (l = d), r.baseState = l, r.firstBaseUpdate = f, r.lastBaseUpdate = h, e = r.shared.interleaved, e !== null) {
      r = e;
      do
        o |= r.lane, r = r.next;
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    $l |= o, n24.lanes = o, n24.memoizedState = d;
  }
}
function HA(n24, e, t) {
  if (n24 = e.effects, e.effects = null, n24 !== null) for (e = 0; e < n24.length; e++) {
    var i = n24[e], r = i.callback;
    if (r !== null) {
      if (i.callback = null, i = t, typeof r != "function") throw Error(Me(191, r));
      r.call(i);
    }
  }
}
var Ld = {}, Zs = Va(Ld), Hh = Va(Ld), Gh = Va(Ld);
function Tl(n24) {
  if (n24 === Ld) throw Error(Me(174));
  return n24;
}
function bM(n24, e) {
  switch (Jt(Gh, e), Jt(Hh, n24), Jt(Zs, Ld), n24 = e.nodeType, n24) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : Kx(null, "");
      break;
    default:
      n24 = n24 === 8 ? e.parentNode : e, e = n24.namespaceURI || null, n24 = n24.tagName, e = Kx(e, n24);
  }
  nn(Zs), Jt(Zs, e);
}
function Fc() {
  nn(Zs), nn(Hh), nn(Gh);
}
function SP(n24) {
  Tl(Gh.current);
  var e = Tl(Zs.current), t = Kx(e, n24.type);
  e !== t && (Jt(Hh, n24), Jt(Zs, t));
}
function CM(n24) {
  Hh.current === n24 && (nn(Zs), nn(Hh));
}
var cn = Va(0);
function Jg(n24) {
  for (var e = n24; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (t !== null && (t = t.dehydrated, t === null || t.data === "$?" || t.data === "$!")) return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      e.child.return = e, e = e.child;
      continue;
    }
    if (e === n24) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n24) return null;
      e = e.return;
    }
    e.sibling.return = e.return, e = e.sibling;
  }
  return null;
}
var by = [];
function RM() {
  for (var n24 = 0; n24 < by.length; n24++) by[n24]._workInProgressVersionPrimary = null;
  by.length = 0;
}
var pg = Ho.ReactCurrentDispatcher, Cy = Ho.ReactCurrentBatchConfig, jl = 0, mn = null, Wn = null, ti = null, Qg = false, vh = false, Wh = 0, Nk = 0;
function yi() {
  throw Error(Me(321));
}
function PM(n24, e) {
  if (e === null) return false;
  for (var t = 0; t < e.length && t < n24.length; t++) if (!Ts(n24[t], e[t])) return false;
  return true;
}
function LM(n24, e, t, i, r, s) {
  if (jl = s, mn = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, pg.current = n24 === null || n24.memoizedState === null ? kk : Fk, n24 = t(i, r), vh) {
    s = 0;
    do {
      if (vh = false, Wh = 0, 25 <= s) throw Error(Me(301));
      s += 1, ti = Wn = null, e.updateQueue = null, pg.current = zk, n24 = t(i, r);
    } while (vh);
  }
  if (pg.current = e0, e = Wn !== null && Wn.next !== null, jl = 0, ti = Wn = mn = null, Qg = false, e) throw Error(Me(300));
  return n24;
}
function IM() {
  var n24 = Wh !== 0;
  return Wh = 0, n24;
}
function Bs() {
  var n24 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return ti === null ? mn.memoizedState = ti = n24 : ti = ti.next = n24, ti;
}
function as() {
  if (Wn === null) {
    var n24 = mn.alternate;
    n24 = n24 !== null ? n24.memoizedState : null;
  } else n24 = Wn.next;
  var e = ti === null ? mn.memoizedState : ti.next;
  if (e !== null) ti = e, Wn = n24;
  else {
    if (n24 === null) throw Error(Me(310));
    Wn = n24, n24 = { memoizedState: Wn.memoizedState, baseState: Wn.baseState, baseQueue: Wn.baseQueue, queue: Wn.queue, next: null }, ti === null ? mn.memoizedState = ti = n24 : ti = ti.next = n24;
  }
  return ti;
}
function Xh(n24, e) {
  return typeof e == "function" ? e(n24) : e;
}
function Ry(n24) {
  var e = as(), t = e.queue;
  if (t === null) throw Error(Me(311));
  t.lastRenderedReducer = n24;
  var i = Wn, r = i.baseQueue, s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      r.next = s.next, s.next = o;
    }
    i.baseQueue = r = s, t.pending = null;
  }
  if (r !== null) {
    s = r.next, i = i.baseState;
    var a = o = null, l = null, f = s;
    do {
      var h = f.lane;
      if ((jl & h) === h) l !== null && (l = l.next = { lane: 0, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null }), i = f.hasEagerState ? f.eagerState : n24(i, f.action);
      else {
        var d = { lane: h, action: f.action, hasEagerState: f.hasEagerState, eagerState: f.eagerState, next: null };
        l === null ? (a = l = d, o = i) : l = l.next = d, mn.lanes |= h, $l |= h;
      }
      f = f.next;
    } while (f !== null && f !== s);
    l === null ? o = i : l.next = a, Ts(i, e.memoizedState) || (er = true), e.memoizedState = i, e.baseState = o, e.baseQueue = l, t.lastRenderedState = i;
  }
  if (n24 = t.interleaved, n24 !== null) {
    r = n24;
    do
      s = r.lane, mn.lanes |= s, $l |= s, r = r.next;
    while (r !== n24);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Py(n24) {
  var e = as(), t = e.queue;
  if (t === null) throw Error(Me(311));
  t.lastRenderedReducer = n24;
  var i = t.dispatch, r = t.pending, s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = r = r.next;
    do
      s = n24(s, o.action), o = o.next;
    while (o !== r);
    Ts(s, e.memoizedState) || (er = true), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), t.lastRenderedState = s;
  }
  return [s, i];
}
function MP() {
}
function wP(n24, e) {
  var t = mn, i = as(), r = e(), s = !Ts(i.memoizedState, r);
  if (s && (i.memoizedState = r, er = true), i = i.queue, NM(AP.bind(null, t, i, n24), [n24]), i.getSnapshot !== e || s || ti !== null && ti.memoizedState.tag & 1) {
    if (t.flags |= 2048, jh(9, TP.bind(null, t, i, r, e), void 0, null), ii === null) throw Error(Me(349));
    jl & 30 || EP(t, e, r);
  }
  return r;
}
function EP(n24, e, t) {
  n24.flags |= 16384, n24 = { getSnapshot: e, value: t }, e = mn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, mn.updateQueue = e, e.stores = [n24]) : (t = e.stores, t === null ? e.stores = [n24] : t.push(n24));
}
function TP(n24, e, t, i) {
  e.value = t, e.getSnapshot = i, bP(e) && CP(n24);
}
function AP(n24, e, t) {
  return t(function() {
    bP(e) && CP(n24);
  });
}
function bP(n24) {
  var e = n24.getSnapshot;
  n24 = n24.value;
  try {
    var t = e();
    return !Ts(n24, t);
  } catch {
    return true;
  }
}
function CP(n24) {
  var e = Do(n24, 1);
  e !== null && ws(e, n24, 1, -1);
}
function GA(n24) {
  var e = Bs();
  return typeof n24 == "function" && (n24 = n24()), e.memoizedState = e.baseState = n24, n24 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Xh, lastRenderedState: n24 }, e.queue = n24, n24 = n24.dispatch = Uk.bind(null, mn, n24), [e.memoizedState, n24];
}
function jh(n24, e, t, i) {
  return n24 = { tag: n24, create: e, destroy: t, deps: i, next: null }, e = mn.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, mn.updateQueue = e, e.lastEffect = n24.next = n24) : (t = e.lastEffect, t === null ? e.lastEffect = n24.next = n24 : (i = t.next, t.next = n24, n24.next = i, e.lastEffect = n24)), n24;
}
function RP() {
  return as().memoizedState;
}
function mg(n24, e, t, i) {
  var r = Bs();
  mn.flags |= n24, r.memoizedState = jh(1 | e, t, void 0, i === void 0 ? null : i);
}
function N0(n24, e, t, i) {
  var r = as();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Wn !== null) {
    var o = Wn.memoizedState;
    if (s = o.destroy, i !== null && PM(i, o.deps)) {
      r.memoizedState = jh(e, t, s, i);
      return;
    }
  }
  mn.flags |= n24, r.memoizedState = jh(1 | e, t, s, i);
}
function WA(n24, e) {
  return mg(8390656, 8, n24, e);
}
function NM(n24, e) {
  return N0(2048, 8, n24, e);
}
function PP(n24, e) {
  return N0(4, 2, n24, e);
}
function LP(n24, e) {
  return N0(4, 4, n24, e);
}
function IP(n24, e) {
  if (typeof e == "function") return n24 = n24(), e(n24), function() {
    e(null);
  };
  if (e != null) return n24 = n24(), e.current = n24, function() {
    e.current = null;
  };
}
function NP(n24, e, t) {
  return t = t != null ? t.concat([n24]) : null, N0(4, 4, IP.bind(null, e, n24), t);
}
function DM() {
}
function DP(n24, e) {
  var t = as();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && PM(e, i[1]) ? i[0] : (t.memoizedState = [n24, e], n24);
}
function OP(n24, e) {
  var t = as();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && PM(e, i[1]) ? i[0] : (n24 = n24(), t.memoizedState = [n24, e], n24);
}
function UP(n24, e, t) {
  return jl & 21 ? (Ts(t, e) || (t = VR(), mn.lanes |= t, $l |= t, n24.baseState = true), e) : (n24.baseState && (n24.baseState = false, er = true), n24.memoizedState = t);
}
function Dk(n24, e) {
  var t = Wt;
  Wt = t !== 0 && 4 > t ? t : 4, n24(true);
  var i = Cy.transition;
  Cy.transition = {};
  try {
    n24(false), e();
  } finally {
    Wt = t, Cy.transition = i;
  }
}
function kP() {
  return as().memoizedState;
}
function Ok(n24, e, t) {
  var i = Aa(n24);
  if (t = { lane: i, action: t, hasEagerState: false, eagerState: null, next: null }, FP(n24)) zP(e, t);
  else if (t = yP(n24, e, t, i), t !== null) {
    var r = Hi();
    ws(t, n24, i, r), BP(t, e, i);
  }
}
function Uk(n24, e, t) {
  var i = Aa(n24), r = { lane: i, action: t, hasEagerState: false, eagerState: null, next: null };
  if (FP(n24)) zP(e, r);
  else {
    var s = n24.alternate;
    if (n24.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try {
      var o = e.lastRenderedState, a = s(o, t);
      if (r.hasEagerState = true, r.eagerState = a, Ts(a, o)) {
        var l = e.interleaved;
        l === null ? (r.next = r, TM(e)) : (r.next = l.next, l.next = r), e.interleaved = r;
        return;
      }
    } catch {
    } finally {
    }
    t = yP(n24, e, r, i), t !== null && (r = Hi(), ws(t, n24, i, r), BP(t, e, i));
  }
}
function FP(n24) {
  var e = n24.alternate;
  return n24 === mn || e !== null && e === mn;
}
function zP(n24, e) {
  vh = Qg = true;
  var t = n24.pending;
  t === null ? e.next = e : (e.next = t.next, t.next = e), n24.pending = e;
}
function BP(n24, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    i &= n24.pendingLanes, t |= i, e.lanes = t, fM(n24, t);
  }
}
var e0 = { readContext: os, useCallback: yi, useContext: yi, useEffect: yi, useImperativeHandle: yi, useInsertionEffect: yi, useLayoutEffect: yi, useMemo: yi, useReducer: yi, useRef: yi, useState: yi, useDebugValue: yi, useDeferredValue: yi, useTransition: yi, useMutableSource: yi, useSyncExternalStore: yi, useId: yi, unstable_isNewReconciler: false }, kk = { readContext: os, useCallback: function(n24, e) {
  return Bs().memoizedState = [n24, e === void 0 ? null : e], n24;
}, useContext: os, useEffect: WA, useImperativeHandle: function(n24, e, t) {
  return t = t != null ? t.concat([n24]) : null, mg(4194308, 4, IP.bind(null, e, n24), t);
}, useLayoutEffect: function(n24, e) {
  return mg(4194308, 4, n24, e);
}, useInsertionEffect: function(n24, e) {
  return mg(4, 2, n24, e);
}, useMemo: function(n24, e) {
  var t = Bs();
  return e = e === void 0 ? null : e, n24 = n24(), t.memoizedState = [n24, e], n24;
}, useReducer: function(n24, e, t) {
  var i = Bs();
  return e = t !== void 0 ? t(e) : e, i.memoizedState = i.baseState = e, n24 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: n24, lastRenderedState: e }, i.queue = n24, n24 = n24.dispatch = Ok.bind(null, mn, n24), [i.memoizedState, n24];
}, useRef: function(n24) {
  var e = Bs();
  return n24 = { current: n24 }, e.memoizedState = n24;
}, useState: GA, useDebugValue: DM, useDeferredValue: function(n24) {
  return Bs().memoizedState = n24;
}, useTransition: function() {
  var n24 = GA(false), e = n24[0];
  return n24 = Dk.bind(null, n24[1]), Bs().memoizedState = n24, [e, n24];
}, useMutableSource: function() {
}, useSyncExternalStore: function(n24, e, t) {
  var i = mn, r = Bs();
  if (on) {
    if (t === void 0) throw Error(Me(407));
    t = t();
  } else {
    if (t = e(), ii === null) throw Error(Me(349));
    jl & 30 || EP(i, e, t);
  }
  r.memoizedState = t;
  var s = { value: t, getSnapshot: e };
  return r.queue = s, WA(AP.bind(null, i, s, n24), [n24]), i.flags |= 2048, jh(9, TP.bind(null, i, s, t, e), void 0, null), t;
}, useId: function() {
  var n24 = Bs(), e = ii.identifierPrefix;
  if (on) {
    var t = bo, i = Ao;
    t = (i & ~(1 << 32 - Ms(i) - 1)).toString(32) + t, e = ":" + e + "R" + t, t = Wh++, 0 < t && (e += "H" + t.toString(32)), e += ":";
  } else t = Nk++, e = ":" + e + "r" + t.toString(32) + ":";
  return n24.memoizedState = e;
}, unstable_isNewReconciler: false }, Fk = { readContext: os, useCallback: DP, useContext: os, useEffect: NM, useImperativeHandle: NP, useInsertionEffect: PP, useLayoutEffect: LP, useMemo: OP, useReducer: Ry, useRef: RP, useState: function() {
  return Ry(Xh);
}, useDebugValue: DM, useDeferredValue: function(n24) {
  var e = as();
  return UP(e, Wn.memoizedState, n24);
}, useTransition: function() {
  var n24 = Ry(Xh)[0], e = as().memoizedState;
  return [n24, e];
}, useMutableSource: MP, useSyncExternalStore: wP, useId: kP, unstable_isNewReconciler: false }, zk = { readContext: os, useCallback: DP, useContext: os, useEffect: NM, useImperativeHandle: NP, useInsertionEffect: PP, useLayoutEffect: LP, useMemo: OP, useReducer: Py, useRef: RP, useState: function() {
  return Py(Xh);
}, useDebugValue: DM, useDeferredValue: function(n24) {
  var e = as();
  return Wn === null ? e.memoizedState = n24 : UP(e, Wn.memoizedState, n24);
}, useTransition: function() {
  var n24 = Py(Xh)[0], e = as().memoizedState;
  return [n24, e];
}, useMutableSource: MP, useSyncExternalStore: wP, useId: kP, unstable_isNewReconciler: false };
function _s(n24, e) {
  if (n24 && n24.defaultProps) {
    e = gn({}, e), n24 = n24.defaultProps;
    for (var t in n24) e[t] === void 0 && (e[t] = n24[t]);
    return e;
  }
  return e;
}
function _1(n24, e, t, i) {
  e = n24.memoizedState, t = t(i, e), t = t == null ? e : gn({}, e, t), n24.memoizedState = t, n24.lanes === 0 && (n24.updateQueue.baseState = t);
}
var D0 = { isMounted: function(n24) {
  return (n24 = n24._reactInternals) ? tu(n24) === n24 : false;
}, enqueueSetState: function(n24, e, t) {
  n24 = n24._reactInternals;
  var i = Hi(), r = Aa(n24), s = Po(i, r);
  s.payload = e, t != null && (s.callback = t), e = Ea(n24, s, r), e !== null && (ws(e, n24, r, i), dg(e, n24, r));
}, enqueueReplaceState: function(n24, e, t) {
  n24 = n24._reactInternals;
  var i = Hi(), r = Aa(n24), s = Po(i, r);
  s.tag = 1, s.payload = e, t != null && (s.callback = t), e = Ea(n24, s, r), e !== null && (ws(e, n24, r, i), dg(e, n24, r));
}, enqueueForceUpdate: function(n24, e) {
  n24 = n24._reactInternals;
  var t = Hi(), i = Aa(n24), r = Po(t, i);
  r.tag = 2, e != null && (r.callback = e), e = Ea(n24, r, i), e !== null && (ws(e, n24, i, t), dg(e, n24, i));
} };
function XA(n24, e, t, i, r, s, o) {
  return n24 = n24.stateNode, typeof n24.shouldComponentUpdate == "function" ? n24.shouldComponentUpdate(i, s, o) : e.prototype && e.prototype.isPureReactComponent ? !Fh(t, i) || !Fh(r, s) : true;
}
function VP(n24, e, t) {
  var i = false, r = Da, s = e.contextType;
  return typeof s == "object" && s !== null ? s = os(s) : (r = nr(e) ? Wl : Li.current, i = e.contextTypes, s = (i = i != null) ? Oc(n24, r) : Da), e = new e(t, s), n24.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = D0, n24.stateNode = e, e._reactInternals = n24, i && (n24 = n24.stateNode, n24.__reactInternalMemoizedUnmaskedChildContext = r, n24.__reactInternalMemoizedMaskedChildContext = s), e;
}
function jA(n24, e, t, i) {
  n24 = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(t, i), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(t, i), e.state !== n24 && D0.enqueueReplaceState(e, e.state, null);
}
function v1(n24, e, t, i) {
  var r = n24.stateNode;
  r.props = t, r.state = n24.memoizedState, r.refs = {}, AM(n24);
  var s = e.contextType;
  typeof s == "object" && s !== null ? r.context = os(s) : (s = nr(e) ? Wl : Li.current, r.context = Oc(n24, s)), r.state = n24.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (_1(n24, e, s, t), r.state = n24.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof r.getSnapshotBeforeUpdate == "function" || typeof r.UNSAFE_componentWillMount != "function" && typeof r.componentWillMount != "function" || (e = r.state, typeof r.componentWillMount == "function" && r.componentWillMount(), typeof r.UNSAFE_componentWillMount == "function" && r.UNSAFE_componentWillMount(), e !== r.state && D0.enqueueReplaceState(r, r.state, null), Zg(n24, t, r, i), r.state = n24.memoizedState), typeof r.componentDidMount == "function" && (n24.flags |= 4194308);
}
function zc(n24, e) {
  try {
    var t = "", i = e;
    do
      t += dU(i), i = i.return;
    while (i);
    var r = t;
  } catch (s) {
    r = `
Error generating stack: ` + s.message + `
` + s.stack;
  }
  return { value: n24, source: e, stack: r, digest: null };
}
function Ly(n24, e, t) {
  return { value: n24, source: null, stack: t ?? null, digest: e ?? null };
}
function y1(n24, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function() {
      throw t;
    });
  }
}
var Bk = typeof WeakMap == "function" ? WeakMap : Map;
function HP(n24, e, t) {
  t = Po(-1, t), t.tag = 3, t.payload = { element: null };
  var i = e.value;
  return t.callback = function() {
    n0 || (n0 = true, R1 = i), y1(n24, e);
  }, t;
}
function GP(n24, e, t) {
  t = Po(-1, t), t.tag = 3;
  var i = n24.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    t.payload = function() {
      return i(r);
    }, t.callback = function() {
      y1(n24, e);
    };
  }
  var s = n24.stateNode;
  return s !== null && typeof s.componentDidCatch == "function" && (t.callback = function() {
    y1(n24, e), typeof i != "function" && (Ta === null ? Ta = /* @__PURE__ */ new Set([this]) : Ta.add(this));
    var o = e.stack;
    this.componentDidCatch(e.value, { componentStack: o !== null ? o : "" });
  }), t;
}
function $A(n24, e, t) {
  var i = n24.pingCache;
  if (i === null) {
    i = n24.pingCache = new Bk();
    var r = /* @__PURE__ */ new Set();
    i.set(e, r);
  } else r = i.get(e), r === void 0 && (r = /* @__PURE__ */ new Set(), i.set(e, r));
  r.has(t) || (r.add(t), n24 = eF.bind(null, n24, e, t), e.then(n24, n24));
}
function YA(n24) {
  do {
    var e;
    if ((e = n24.tag === 13) && (e = n24.memoizedState, e = e !== null ? e.dehydrated !== null : true), e) return n24;
    n24 = n24.return;
  } while (n24 !== null);
  return null;
}
function qA(n24, e, t, i, r) {
  return n24.mode & 1 ? (n24.flags |= 65536, n24.lanes = r, n24) : (n24 === e ? n24.flags |= 65536 : (n24.flags |= 128, t.flags |= 131072, t.flags &= -52805, t.tag === 1 && (t.alternate === null ? t.tag = 17 : (e = Po(-1, 1), e.tag = 2, Ea(t, e, 1))), t.lanes |= 1), n24);
}
var Vk = Ho.ReactCurrentOwner, er = false;
function Fi(n24, e, t, i) {
  e.child = n24 === null ? vP(e, null, t, i) : kc(e, n24.child, t, i);
}
function KA(n24, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return Ac(e, r), i = LM(n24, e, t, i, s, r), t = IM(), n24 !== null && !er ? (e.updateQueue = n24.updateQueue, e.flags &= -2053, n24.lanes &= ~r, Oo(n24, e, r)) : (on && t && yM(e), e.flags |= 1, Fi(n24, e, i, r), e.child);
}
function ZA(n24, e, t, i, r) {
  if (n24 === null) {
    var s = t.type;
    return typeof s == "function" && !HM(s) && s.defaultProps === void 0 && t.compare === null && t.defaultProps === void 0 ? (e.tag = 15, e.type = s, WP(n24, e, s, i, r)) : (n24 = yg(t.type, null, i, e, e.mode, r), n24.ref = e.ref, n24.return = e, e.child = n24);
  }
  if (s = n24.child, !(n24.lanes & r)) {
    var o = s.memoizedProps;
    if (t = t.compare, t = t !== null ? t : Fh, t(o, i) && n24.ref === e.ref) return Oo(n24, e, r);
  }
  return e.flags |= 1, n24 = ba(s, i), n24.ref = e.ref, n24.return = e, e.child = n24;
}
function WP(n24, e, t, i, r) {
  if (n24 !== null) {
    var s = n24.memoizedProps;
    if (Fh(s, i) && n24.ref === e.ref) if (er = false, e.pendingProps = i = s, (n24.lanes & r) !== 0) n24.flags & 131072 && (er = true);
    else return e.lanes = n24.lanes, Oo(n24, e, r);
  }
  return x1(n24, e, t, i, r);
}
function XP(n24, e, t) {
  var i = e.pendingProps, r = i.children, s = n24 !== null ? n24.memoizedState : null;
  if (i.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Jt(dc, yr), yr |= t;
  else {
    if (!(t & 1073741824)) return n24 = s !== null ? s.baseLanes | t : t, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: n24, cachePool: null, transitions: null }, e.updateQueue = null, Jt(dc, yr), yr |= n24, null;
    e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, i = s !== null ? s.baseLanes : t, Jt(dc, yr), yr |= i;
  }
  else s !== null ? (i = s.baseLanes | t, e.memoizedState = null) : i = t, Jt(dc, yr), yr |= i;
  return Fi(n24, e, r, t), e.child;
}
function jP(n24, e) {
  var t = e.ref;
  (n24 === null && t !== null || n24 !== null && n24.ref !== t) && (e.flags |= 512, e.flags |= 2097152);
}
function x1(n24, e, t, i, r) {
  var s = nr(t) ? Wl : Li.current;
  return s = Oc(e, s), Ac(e, r), t = LM(n24, e, t, i, s, r), i = IM(), n24 !== null && !er ? (e.updateQueue = n24.updateQueue, e.flags &= -2053, n24.lanes &= ~r, Oo(n24, e, r)) : (on && i && yM(e), e.flags |= 1, Fi(n24, e, t, r), e.child);
}
function JA(n24, e, t, i, r) {
  if (nr(t)) {
    var s = true;
    jg(e);
  } else s = false;
  if (Ac(e, r), e.stateNode === null) gg(n24, e), VP(e, t, i), v1(e, t, i, r), i = true;
  else if (n24 === null) {
    var o = e.stateNode, a = e.memoizedProps;
    o.props = a;
    var l = o.context, f = t.contextType;
    typeof f == "object" && f !== null ? f = os(f) : (f = nr(t) ? Wl : Li.current, f = Oc(e, f));
    var h = t.getDerivedStateFromProps, d = typeof h == "function" || typeof o.getSnapshotBeforeUpdate == "function";
    d || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== i || l !== f) && jA(e, o, i, f), ua = false;
    var p = e.memoizedState;
    o.state = p, Zg(e, i, o, r), l = e.memoizedState, a !== i || p !== l || tr.current || ua ? (typeof h == "function" && (_1(e, t, h, i), l = e.memoizedState), (a = ua || XA(e, t, a, i, p, l, f)) ? (d || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(), typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()), typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = i, e.memoizedState = l), o.props = i, o.state = l, o.context = f, i = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308), i = false);
  } else {
    o = e.stateNode, xP(n24, e), a = e.memoizedProps, f = e.type === e.elementType ? a : _s(e.type, a), o.props = f, d = e.pendingProps, p = o.context, l = t.contextType, typeof l == "object" && l !== null ? l = os(l) : (l = nr(t) ? Wl : Li.current, l = Oc(e, l));
    var g = t.getDerivedStateFromProps;
    (h = typeof g == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== d || p !== l) && jA(e, o, i, l), ua = false, p = e.memoizedState, o.state = p, Zg(e, i, o, r);
    var v = e.memoizedState;
    a !== d || p !== v || tr.current || ua ? (typeof g == "function" && (_1(e, t, g, i), v = e.memoizedState), (f = ua || XA(e, t, f, i, p, v, l) || false) ? (h || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(i, v, l), typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(i, v, l)), typeof o.componentDidUpdate == "function" && (e.flags |= 4), typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === n24.memoizedProps && p === n24.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n24.memoizedProps && p === n24.memoizedState || (e.flags |= 1024), e.memoizedProps = i, e.memoizedState = v), o.props = i, o.state = v, o.context = l, i = f) : (typeof o.componentDidUpdate != "function" || a === n24.memoizedProps && p === n24.memoizedState || (e.flags |= 4), typeof o.getSnapshotBeforeUpdate != "function" || a === n24.memoizedProps && p === n24.memoizedState || (e.flags |= 1024), i = false);
  }
  return S1(n24, e, t, i, s, r);
}
function S1(n24, e, t, i, r, s) {
  jP(n24, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && kA(e, t, false), Oo(n24, e, s);
  i = e.stateNode, Vk.current = e;
  var a = o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return e.flags |= 1, n24 !== null && o ? (e.child = kc(e, n24.child, null, s), e.child = kc(e, null, a, s)) : Fi(n24, e, a, s), e.memoizedState = i.state, r && kA(e, t, true), e.child;
}
function $P(n24) {
  var e = n24.stateNode;
  e.pendingContext ? UA(n24, e.pendingContext, e.pendingContext !== e.context) : e.context && UA(n24, e.context, false), bM(n24, e.containerInfo);
}
function QA(n24, e, t, i, r) {
  return Uc(), SM(r), e.flags |= 256, Fi(n24, e, t, i), e.child;
}
var M1 = { dehydrated: null, treeContext: null, retryLane: 0 };
function w1(n24) {
  return { baseLanes: n24, cachePool: null, transitions: null };
}
function YP(n24, e, t) {
  var i = e.pendingProps, r = cn.current, s = false, o = (e.flags & 128) !== 0, a;
  if ((a = o) || (a = n24 !== null && n24.memoizedState === null ? false : (r & 2) !== 0), a ? (s = true, e.flags &= -129) : (n24 === null || n24.memoizedState !== null) && (r |= 1), Jt(cn, r & 1), n24 === null) return m1(e), n24 = e.memoizedState, n24 !== null && (n24 = n24.dehydrated, n24 !== null) ? (e.mode & 1 ? n24.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (o = i.children, n24 = i.fallback, s ? (i = e.mode, s = e.child, o = { mode: "hidden", children: o }, !(i & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = o) : s = k0(o, i, 0, null), n24 = Nl(n24, i, t, null), s.return = e, n24.return = e, s.sibling = n24, e.child = s, e.child.memoizedState = w1(t), e.memoizedState = M1, n24) : OM(e, o));
  if (r = n24.memoizedState, r !== null && (a = r.dehydrated, a !== null)) return Hk(n24, e, o, i, a, r, t);
  if (s) {
    s = i.fallback, o = e.mode, r = n24.child, a = r.sibling;
    var l = { mode: "hidden", children: i.children };
    return !(o & 1) && e.child !== r ? (i = e.child, i.childLanes = 0, i.pendingProps = l, e.deletions = null) : (i = ba(r, l), i.subtreeFlags = r.subtreeFlags & 14680064), a !== null ? s = ba(a, s) : (s = Nl(s, o, t, null), s.flags |= 2), s.return = e, i.return = e, i.sibling = s, e.child = i, i = s, s = e.child, o = n24.child.memoizedState, o = o === null ? w1(t) : { baseLanes: o.baseLanes | t, cachePool: null, transitions: o.transitions }, s.memoizedState = o, s.childLanes = n24.childLanes & ~t, e.memoizedState = M1, i;
  }
  return s = n24.child, n24 = s.sibling, i = ba(s, { mode: "visible", children: i.children }), !(e.mode & 1) && (i.lanes = t), i.return = e, i.sibling = null, n24 !== null && (t = e.deletions, t === null ? (e.deletions = [n24], e.flags |= 16) : t.push(n24)), e.child = i, e.memoizedState = null, i;
}
function OM(n24, e) {
  return e = k0({ mode: "visible", children: e }, n24.mode, 0, null), e.return = n24, n24.child = e;
}
function om(n24, e, t, i) {
  return i !== null && SM(i), kc(e, n24.child, null, t), n24 = OM(e, e.pendingProps.children), n24.flags |= 2, e.memoizedState = null, n24;
}
function Hk(n24, e, t, i, r, s, o) {
  if (t) return e.flags & 256 ? (e.flags &= -257, i = Ly(Error(Me(422))), om(n24, e, o, i)) : e.memoizedState !== null ? (e.child = n24.child, e.flags |= 128, null) : (s = i.fallback, r = e.mode, i = k0({ mode: "visible", children: i.children }, r, 0, null), s = Nl(s, r, o, null), s.flags |= 2, i.return = e, s.return = e, i.sibling = s, e.child = i, e.mode & 1 && kc(e, n24.child, null, o), e.child.memoizedState = w1(o), e.memoizedState = M1, s);
  if (!(e.mode & 1)) return om(n24, e, o, null);
  if (r.data === "$!") {
    if (i = r.nextSibling && r.nextSibling.dataset, i) var a = i.dgst;
    return i = a, s = Error(Me(419)), i = Ly(s, i, void 0), om(n24, e, o, i);
  }
  if (a = (o & n24.childLanes) !== 0, er || a) {
    if (i = ii, i !== null) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      r = r & (i.suspendedLanes | o) ? 0 : r, r !== 0 && r !== s.retryLane && (s.retryLane = r, Do(n24, r), ws(i, n24, r, -1));
    }
    return VM(), i = Ly(Error(Me(421))), om(n24, e, o, i);
  }
  return r.data === "$?" ? (e.flags |= 128, e.child = n24.child, e = tF.bind(null, n24), r._reactRetry = e, null) : (n24 = s.treeContext, Tr = wa(r.nextSibling), br = e, on = true, xs = null, n24 !== null && (Qr[es++] = Ao, Qr[es++] = bo, Qr[es++] = Xl, Ao = n24.id, bo = n24.overflow, Xl = e), e = OM(e, i.children), e.flags |= 4096, e);
}
function eb(n24, e, t) {
  n24.lanes |= e;
  var i = n24.alternate;
  i !== null && (i.lanes |= e), g1(n24.return, e, t);
}
function Iy(n24, e, t, i, r) {
  var s = n24.memoizedState;
  s === null ? n24.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: i, tail: t, tailMode: r } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = i, s.tail = t, s.tailMode = r);
}
function qP(n24, e, t) {
  var i = e.pendingProps, r = i.revealOrder, s = i.tail;
  if (Fi(n24, e, i.children, t), i = cn.current, i & 2) i = i & 1 | 2, e.flags |= 128;
  else {
    if (n24 !== null && n24.flags & 128) e: for (n24 = e.child; n24 !== null; ) {
      if (n24.tag === 13) n24.memoizedState !== null && eb(n24, t, e);
      else if (n24.tag === 19) eb(n24, t, e);
      else if (n24.child !== null) {
        n24.child.return = n24, n24 = n24.child;
        continue;
      }
      if (n24 === e) break e;
      for (; n24.sibling === null; ) {
        if (n24.return === null || n24.return === e) break e;
        n24 = n24.return;
      }
      n24.sibling.return = n24.return, n24 = n24.sibling;
    }
    i &= 1;
  }
  if (Jt(cn, i), !(e.mode & 1)) e.memoizedState = null;
  else switch (r) {
    case "forwards":
      for (t = e.child, r = null; t !== null; ) n24 = t.alternate, n24 !== null && Jg(n24) === null && (r = t), t = t.sibling;
      t = r, t === null ? (r = e.child, e.child = null) : (r = t.sibling, t.sibling = null), Iy(e, false, r, t, s);
      break;
    case "backwards":
      for (t = null, r = e.child, e.child = null; r !== null; ) {
        if (n24 = r.alternate, n24 !== null && Jg(n24) === null) {
          e.child = r;
          break;
        }
        n24 = r.sibling, r.sibling = t, t = r, r = n24;
      }
      Iy(e, true, t, null, s);
      break;
    case "together":
      Iy(e, false, null, null, void 0);
      break;
    default:
      e.memoizedState = null;
  }
  return e.child;
}
function gg(n24, e) {
  !(e.mode & 1) && n24 !== null && (n24.alternate = null, e.alternate = null, e.flags |= 2);
}
function Oo(n24, e, t) {
  if (n24 !== null && (e.dependencies = n24.dependencies), $l |= e.lanes, !(t & e.childLanes)) return null;
  if (n24 !== null && e.child !== n24.child) throw Error(Me(153));
  if (e.child !== null) {
    for (n24 = e.child, t = ba(n24, n24.pendingProps), e.child = t, t.return = e; n24.sibling !== null; ) n24 = n24.sibling, t = t.sibling = ba(n24, n24.pendingProps), t.return = e;
    t.sibling = null;
  }
  return e.child;
}
function Gk(n24, e, t) {
  switch (e.tag) {
    case 3:
      $P(e), Uc();
      break;
    case 5:
      SP(e);
      break;
    case 1:
      nr(e.type) && jg(e);
      break;
    case 4:
      bM(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context, r = e.memoizedProps.value;
      Jt(qg, i._currentValue), i._currentValue = r;
      break;
    case 13:
      if (i = e.memoizedState, i !== null) return i.dehydrated !== null ? (Jt(cn, cn.current & 1), e.flags |= 128, null) : t & e.child.childLanes ? YP(n24, e, t) : (Jt(cn, cn.current & 1), n24 = Oo(n24, e, t), n24 !== null ? n24.sibling : null);
      Jt(cn, cn.current & 1);
      break;
    case 19:
      if (i = (t & e.childLanes) !== 0, n24.flags & 128) {
        if (i) return qP(n24, e, t);
        e.flags |= 128;
      }
      if (r = e.memoizedState, r !== null && (r.rendering = null, r.tail = null, r.lastEffect = null), Jt(cn, cn.current), i) break;
      return null;
    case 22:
    case 23:
      return e.lanes = 0, XP(n24, e, t);
  }
  return Oo(n24, e, t);
}
var KP, E1, ZP, JP;
KP = function(n24, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n24.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      t.child.return = t, t = t.child;
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    t.sibling.return = t.return, t = t.sibling;
  }
};
E1 = function() {
};
ZP = function(n24, e, t, i) {
  var r = n24.memoizedProps;
  if (r !== i) {
    n24 = e.stateNode, Tl(Zs.current);
    var s = null;
    switch (t) {
      case "input":
        r = jx(n24, r), i = jx(n24, i), s = [];
        break;
      case "select":
        r = gn({}, r, { value: void 0 }), i = gn({}, i, { value: void 0 }), s = [];
        break;
      case "textarea":
        r = qx(n24, r), i = qx(n24, i), s = [];
        break;
      default:
        typeof r.onClick != "function" && typeof i.onClick == "function" && (n24.onclick = Wg);
    }
    Zx(t, i);
    var o;
    t = null;
    for (f in r) if (!i.hasOwnProperty(f) && r.hasOwnProperty(f) && r[f] != null) if (f === "style") {
      var a = r[f];
      for (o in a) a.hasOwnProperty(o) && (t || (t = {}), t[o] = "");
    } else f !== "dangerouslySetInnerHTML" && f !== "children" && f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (Lh.hasOwnProperty(f) ? s || (s = []) : (s = s || []).push(f, null));
    for (f in i) {
      var l = i[f];
      if (a = r == null ? void 0 : r[f], i.hasOwnProperty(f) && l !== a && (l != null || a != null)) if (f === "style") if (a) {
        for (o in a) !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (t || (t = {}), t[o] = "");
        for (o in l) l.hasOwnProperty(o) && a[o] !== l[o] && (t || (t = {}), t[o] = l[o]);
      } else t || (s || (s = []), s.push(f, t)), t = l;
      else f === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (s = s || []).push(f, l)) : f === "children" ? typeof l != "string" && typeof l != "number" || (s = s || []).push(f, "" + l) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && (Lh.hasOwnProperty(f) ? (l != null && f === "onScroll" && en("scroll", n24), s || a === l || (s = [])) : (s = s || []).push(f, l));
    }
    t && (s = s || []).push("style", t);
    var f = s;
    (e.updateQueue = f) && (e.flags |= 4);
  }
};
JP = function(n24, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Bf(n24, e) {
  if (!on) switch (n24.tailMode) {
    case "hidden":
      e = n24.tail;
      for (var t = null; e !== null; ) e.alternate !== null && (t = e), e = e.sibling;
      t === null ? n24.tail = null : t.sibling = null;
      break;
    case "collapsed":
      t = n24.tail;
      for (var i = null; t !== null; ) t.alternate !== null && (i = t), t = t.sibling;
      i === null ? e || n24.tail === null ? n24.tail = null : n24.tail.sibling = null : i.sibling = null;
  }
}
function xi(n24) {
  var e = n24.alternate !== null && n24.alternate.child === n24.child, t = 0, i = 0;
  if (e) for (var r = n24.child; r !== null; ) t |= r.lanes | r.childLanes, i |= r.subtreeFlags & 14680064, i |= r.flags & 14680064, r.return = n24, r = r.sibling;
  else for (r = n24.child; r !== null; ) t |= r.lanes | r.childLanes, i |= r.subtreeFlags, i |= r.flags, r.return = n24, r = r.sibling;
  return n24.subtreeFlags |= i, n24.childLanes = t, e;
}
function Wk(n24, e, t) {
  var i = e.pendingProps;
  switch (xM(e), e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return xi(e), null;
    case 1:
      return nr(e.type) && Xg(), xi(e), null;
    case 3:
      return i = e.stateNode, Fc(), nn(tr), nn(Li), RM(), i.pendingContext && (i.context = i.pendingContext, i.pendingContext = null), (n24 === null || n24.child === null) && (rm(e) ? e.flags |= 4 : n24 === null || n24.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, xs !== null && (I1(xs), xs = null))), E1(n24, e), xi(e), null;
    case 5:
      CM(e);
      var r = Tl(Gh.current);
      if (t = e.type, n24 !== null && e.stateNode != null) ZP(n24, e, t, i, r), n24.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152);
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(Me(166));
          return xi(e), null;
        }
        if (n24 = Tl(Zs.current), rm(e)) {
          i = e.stateNode, t = e.type;
          var s = e.memoizedProps;
          switch (i[Ws] = e, i[Vh] = s, n24 = (e.mode & 1) !== 0, t) {
            case "dialog":
              en("cancel", i), en("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              en("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < lh.length; r++) en(lh[r], i);
              break;
            case "source":
              en("error", i);
              break;
            case "img":
            case "image":
            case "link":
              en("error", i), en("load", i);
              break;
            case "details":
              en("toggle", i);
              break;
            case "input":
              uA(i, s), en("invalid", i);
              break;
            case "select":
              i._wrapperState = { wasMultiple: !!s.multiple }, en("invalid", i);
              break;
            case "textarea":
              fA(i, s), en("invalid", i);
          }
          Zx(t, s), r = null;
          for (var o in s) if (s.hasOwnProperty(o)) {
            var a = s[o];
            o === "children" ? typeof a == "string" ? i.textContent !== a && (s.suppressHydrationWarning !== true && im(i.textContent, a, n24), r = ["children", a]) : typeof a == "number" && i.textContent !== "" + a && (s.suppressHydrationWarning !== true && im(i.textContent, a, n24), r = ["children", "" + a]) : Lh.hasOwnProperty(o) && a != null && o === "onScroll" && en("scroll", i);
          }
          switch (t) {
            case "input":
              qp(i), cA(i, s, true);
              break;
            case "textarea":
              qp(i), hA(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Wg);
          }
          i = r, e.updateQueue = i, i !== null && (e.flags |= 4);
        } else {
          o = r.nodeType === 9 ? r : r.ownerDocument, n24 === "http://www.w3.org/1999/xhtml" && (n24 = AR(t)), n24 === "http://www.w3.org/1999/xhtml" ? t === "script" ? (n24 = o.createElement("div"), n24.innerHTML = "<script><\/script>", n24 = n24.removeChild(n24.firstChild)) : typeof i.is == "string" ? n24 = o.createElement(t, { is: i.is }) : (n24 = o.createElement(t), t === "select" && (o = n24, i.multiple ? o.multiple = true : i.size && (o.size = i.size))) : n24 = o.createElementNS(n24, t), n24[Ws] = e, n24[Vh] = i, KP(n24, e, false, false), e.stateNode = n24;
          e: {
            switch (o = Jx(t, i), t) {
              case "dialog":
                en("cancel", n24), en("close", n24), r = i;
                break;
              case "iframe":
              case "object":
              case "embed":
                en("load", n24), r = i;
                break;
              case "video":
              case "audio":
                for (r = 0; r < lh.length; r++) en(lh[r], n24);
                r = i;
                break;
              case "source":
                en("error", n24), r = i;
                break;
              case "img":
              case "image":
              case "link":
                en("error", n24), en("load", n24), r = i;
                break;
              case "details":
                en("toggle", n24), r = i;
                break;
              case "input":
                uA(n24, i), r = jx(n24, i), en("invalid", n24);
                break;
              case "option":
                r = i;
                break;
              case "select":
                n24._wrapperState = { wasMultiple: !!i.multiple }, r = gn({}, i, { value: void 0 }), en("invalid", n24);
                break;
              case "textarea":
                fA(n24, i), r = qx(n24, i), en("invalid", n24);
                break;
              default:
                r = i;
            }
            Zx(t, r), a = r;
            for (s in a) if (a.hasOwnProperty(s)) {
              var l = a[s];
              s === "style" ? RR(n24, l) : s === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && bR(n24, l)) : s === "children" ? typeof l == "string" ? (t !== "textarea" || l !== "") && Ih(n24, l) : typeof l == "number" && Ih(n24, "" + l) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (Lh.hasOwnProperty(s) ? l != null && s === "onScroll" && en("scroll", n24) : l != null && sM(n24, s, l, o));
            }
            switch (t) {
              case "input":
                qp(n24), cA(n24, i, false);
                break;
              case "textarea":
                qp(n24), hA(n24);
                break;
              case "option":
                i.value != null && n24.setAttribute("value", "" + Na(i.value));
                break;
              case "select":
                n24.multiple = !!i.multiple, s = i.value, s != null ? Mc(n24, !!i.multiple, s, false) : i.defaultValue != null && Mc(n24, !!i.multiple, i.defaultValue, true);
                break;
              default:
                typeof r.onClick == "function" && (n24.onclick = Wg);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = true;
                break e;
              default:
                i = false;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && (e.flags |= 512, e.flags |= 2097152);
      }
      return xi(e), null;
    case 6:
      if (n24 && e.stateNode != null) JP(n24, e, n24.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(Me(166));
        if (t = Tl(Gh.current), Tl(Zs.current), rm(e)) {
          if (i = e.stateNode, t = e.memoizedProps, i[Ws] = e, (s = i.nodeValue !== t) && (n24 = br, n24 !== null)) switch (n24.tag) {
            case 3:
              im(i.nodeValue, t, (n24.mode & 1) !== 0);
              break;
            case 5:
              n24.memoizedProps.suppressHydrationWarning !== true && im(i.nodeValue, t, (n24.mode & 1) !== 0);
          }
          s && (e.flags |= 4);
        } else i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i), i[Ws] = e, e.stateNode = i;
      }
      return xi(e), null;
    case 13:
      if (nn(cn), i = e.memoizedState, n24 === null || n24.memoizedState !== null && n24.memoizedState.dehydrated !== null) {
        if (on && Tr !== null && e.mode & 1 && !(e.flags & 128)) gP(), Uc(), e.flags |= 98560, s = false;
        else if (s = rm(e), i !== null && i.dehydrated !== null) {
          if (n24 === null) {
            if (!s) throw Error(Me(318));
            if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(Me(317));
            s[Ws] = e;
          } else Uc(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4;
          xi(e), s = false;
        } else xs !== null && (I1(xs), xs = null), s = true;
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128 ? (e.lanes = t, e) : (i = i !== null, i !== (n24 !== null && n24.memoizedState !== null) && i && (e.child.flags |= 8192, e.mode & 1 && (n24 === null || cn.current & 1 ? jn === 0 && (jn = 3) : VM())), e.updateQueue !== null && (e.flags |= 4), xi(e), null);
    case 4:
      return Fc(), E1(n24, e), n24 === null && zh(e.stateNode.containerInfo), xi(e), null;
    case 10:
      return EM(e.type._context), xi(e), null;
    case 17:
      return nr(e.type) && Xg(), xi(e), null;
    case 19:
      if (nn(cn), s = e.memoizedState, s === null) return xi(e), null;
      if (i = (e.flags & 128) !== 0, o = s.rendering, o === null) if (i) Bf(s, false);
      else {
        if (jn !== 0 || n24 !== null && n24.flags & 128) for (n24 = e.child; n24 !== null; ) {
          if (o = Jg(n24), o !== null) {
            for (e.flags |= 128, Bf(s, false), i = o.updateQueue, i !== null && (e.updateQueue = i, e.flags |= 4), e.subtreeFlags = 0, i = t, t = e.child; t !== null; ) s = t, n24 = i, s.flags &= 14680066, o = s.alternate, o === null ? (s.childLanes = 0, s.lanes = n24, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = o.childLanes, s.lanes = o.lanes, s.child = o.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = o.memoizedProps, s.memoizedState = o.memoizedState, s.updateQueue = o.updateQueue, s.type = o.type, n24 = o.dependencies, s.dependencies = n24 === null ? null : { lanes: n24.lanes, firstContext: n24.firstContext }), t = t.sibling;
            return Jt(cn, cn.current & 1 | 2), e.child;
          }
          n24 = n24.sibling;
        }
        s.tail !== null && Ln() > Bc && (e.flags |= 128, i = true, Bf(s, false), e.lanes = 4194304);
      }
      else {
        if (!i) if (n24 = Jg(o), n24 !== null) {
          if (e.flags |= 128, i = true, t = n24.updateQueue, t !== null && (e.updateQueue = t, e.flags |= 4), Bf(s, true), s.tail === null && s.tailMode === "hidden" && !o.alternate && !on) return xi(e), null;
        } else 2 * Ln() - s.renderingStartTime > Bc && t !== 1073741824 && (e.flags |= 128, i = true, Bf(s, false), e.lanes = 4194304);
        s.isBackwards ? (o.sibling = e.child, e.child = o) : (t = s.last, t !== null ? t.sibling = o : e.child = o, s.last = o);
      }
      return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = Ln(), e.sibling = null, t = cn.current, Jt(cn, i ? t & 1 | 2 : t & 1), e) : (xi(e), null);
    case 22:
    case 23:
      return BM(), i = e.memoizedState !== null, n24 !== null && n24.memoizedState !== null !== i && (e.flags |= 8192), i && e.mode & 1 ? yr & 1073741824 && (xi(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : xi(e), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(Me(156, e.tag));
}
function Xk(n24, e) {
  switch (xM(e), e.tag) {
    case 1:
      return nr(e.type) && Xg(), n24 = e.flags, n24 & 65536 ? (e.flags = n24 & -65537 | 128, e) : null;
    case 3:
      return Fc(), nn(tr), nn(Li), RM(), n24 = e.flags, n24 & 65536 && !(n24 & 128) ? (e.flags = n24 & -65537 | 128, e) : null;
    case 5:
      return CM(e), null;
    case 13:
      if (nn(cn), n24 = e.memoizedState, n24 !== null && n24.dehydrated !== null) {
        if (e.alternate === null) throw Error(Me(340));
        Uc();
      }
      return n24 = e.flags, n24 & 65536 ? (e.flags = n24 & -65537 | 128, e) : null;
    case 19:
      return nn(cn), null;
    case 4:
      return Fc(), null;
    case 10:
      return EM(e.type._context), null;
    case 22:
    case 23:
      return BM(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var am = false, Ti = false, jk = typeof WeakSet == "function" ? WeakSet : Set, He = null;
function hc(n24, e) {
  var t = n24.ref;
  if (t !== null) if (typeof t == "function") try {
    t(null);
  } catch (i) {
    Mn(n24, e, i);
  }
  else t.current = null;
}
function T1(n24, e, t) {
  try {
    t();
  } catch (i) {
    Mn(n24, e, i);
  }
}
var tb = false;
function $k(n24, e) {
  if (l1 = Vg, n24 = iP(), vM(n24)) {
    if ("selectionStart" in n24) var t = { start: n24.selectionStart, end: n24.selectionEnd };
    else e: {
      t = (t = n24.ownerDocument) && t.defaultView || window;
      var i = t.getSelection && t.getSelection();
      if (i && i.rangeCount !== 0) {
        t = i.anchorNode;
        var r = i.anchorOffset, s = i.focusNode;
        i = i.focusOffset;
        try {
          t.nodeType, s.nodeType;
        } catch {
          t = null;
          break e;
        }
        var o = 0, a = -1, l = -1, f = 0, h = 0, d = n24, p = null;
        t: for (; ; ) {
          for (var g; d !== t || r !== 0 && d.nodeType !== 3 || (a = o + r), d !== s || i !== 0 && d.nodeType !== 3 || (l = o + i), d.nodeType === 3 && (o += d.nodeValue.length), (g = d.firstChild) !== null; ) p = d, d = g;
          for (; ; ) {
            if (d === n24) break t;
            if (p === t && ++f === r && (a = o), p === s && ++h === i && (l = o), (g = d.nextSibling) !== null) break;
            d = p, p = d.parentNode;
          }
          d = g;
        }
        t = a === -1 || l === -1 ? null : { start: a, end: l };
      } else t = null;
    }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (u1 = { focusedElem: n24, selectionRange: t }, Vg = false, He = e; He !== null; ) if (e = He, n24 = e.child, (e.subtreeFlags & 1028) !== 0 && n24 !== null) n24.return = e, He = n24;
  else for (; He !== null; ) {
    e = He;
    try {
      var v = e.alternate;
      if (e.flags & 1024) switch (e.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (v !== null) {
            var S = v.memoizedProps, M = v.memoizedState, m = e.stateNode, w = m.getSnapshotBeforeUpdate(e.elementType === e.type ? S : _s(e.type, S), M);
            m.__reactInternalSnapshotBeforeUpdate = w;
          }
          break;
        case 3:
          var E = e.stateNode.containerInfo;
          E.nodeType === 1 ? E.textContent = "" : E.nodeType === 9 && E.documentElement && E.removeChild(E.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(Me(163));
      }
    } catch (A) {
      Mn(e, e.return, A);
    }
    if (n24 = e.sibling, n24 !== null) {
      n24.return = e.return, He = n24;
      break;
    }
    He = e.return;
  }
  return v = tb, tb = false, v;
}
function yh(n24, e, t) {
  var i = e.updateQueue;
  if (i = i !== null ? i.lastEffect : null, i !== null) {
    var r = i = i.next;
    do {
      if ((r.tag & n24) === n24) {
        var s = r.destroy;
        r.destroy = void 0, s !== void 0 && T1(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function O0(n24, e) {
  if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) {
    var t = e = e.next;
    do {
      if ((t.tag & n24) === n24) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function A1(n24) {
  var e = n24.ref;
  if (e !== null) {
    var t = n24.stateNode;
    switch (n24.tag) {
      case 5:
        n24 = t;
        break;
      default:
        n24 = t;
    }
    typeof e == "function" ? e(n24) : e.current = n24;
  }
}
function QP(n24) {
  var e = n24.alternate;
  e !== null && (n24.alternate = null, QP(e)), n24.child = null, n24.deletions = null, n24.sibling = null, n24.tag === 5 && (e = n24.stateNode, e !== null && (delete e[Ws], delete e[Vh], delete e[h1], delete e[Rk], delete e[Pk])), n24.stateNode = null, n24.return = null, n24.dependencies = null, n24.memoizedProps = null, n24.memoizedState = null, n24.pendingProps = null, n24.stateNode = null, n24.updateQueue = null;
}
function e3(n24) {
  return n24.tag === 5 || n24.tag === 3 || n24.tag === 4;
}
function nb(n24) {
  e: for (; ; ) {
    for (; n24.sibling === null; ) {
      if (n24.return === null || e3(n24.return)) return null;
      n24 = n24.return;
    }
    for (n24.sibling.return = n24.return, n24 = n24.sibling; n24.tag !== 5 && n24.tag !== 6 && n24.tag !== 18; ) {
      if (n24.flags & 2 || n24.child === null || n24.tag === 4) continue e;
      n24.child.return = n24, n24 = n24.child;
    }
    if (!(n24.flags & 2)) return n24.stateNode;
  }
}
function b1(n24, e, t) {
  var i = n24.tag;
  if (i === 5 || i === 6) n24 = n24.stateNode, e ? t.nodeType === 8 ? t.parentNode.insertBefore(n24, e) : t.insertBefore(n24, e) : (t.nodeType === 8 ? (e = t.parentNode, e.insertBefore(n24, t)) : (e = t, e.appendChild(n24)), t = t._reactRootContainer, t != null || e.onclick !== null || (e.onclick = Wg));
  else if (i !== 4 && (n24 = n24.child, n24 !== null)) for (b1(n24, e, t), n24 = n24.sibling; n24 !== null; ) b1(n24, e, t), n24 = n24.sibling;
}
function C1(n24, e, t) {
  var i = n24.tag;
  if (i === 5 || i === 6) n24 = n24.stateNode, e ? t.insertBefore(n24, e) : t.appendChild(n24);
  else if (i !== 4 && (n24 = n24.child, n24 !== null)) for (C1(n24, e, t), n24 = n24.sibling; n24 !== null; ) C1(n24, e, t), n24 = n24.sibling;
}
var ci = null, ys = false;
function Qo(n24, e, t) {
  for (t = t.child; t !== null; ) t3(n24, e, t), t = t.sibling;
}
function t3(n24, e, t) {
  if (Ks && typeof Ks.onCommitFiberUnmount == "function") try {
    Ks.onCommitFiberUnmount(b0, t);
  } catch {
  }
  switch (t.tag) {
    case 5:
      Ti || hc(t, e);
    case 6:
      var i = ci, r = ys;
      ci = null, Qo(n24, e, t), ci = i, ys = r, ci !== null && (ys ? (n24 = ci, t = t.stateNode, n24.nodeType === 8 ? n24.parentNode.removeChild(t) : n24.removeChild(t)) : ci.removeChild(t.stateNode));
      break;
    case 18:
      ci !== null && (ys ? (n24 = ci, t = t.stateNode, n24.nodeType === 8 ? Ty(n24.parentNode, t) : n24.nodeType === 1 && Ty(n24, t), Uh(n24)) : Ty(ci, t.stateNode));
      break;
    case 4:
      i = ci, r = ys, ci = t.stateNode.containerInfo, ys = true, Qo(n24, e, t), ci = i, ys = r;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!Ti && (i = t.updateQueue, i !== null && (i = i.lastEffect, i !== null))) {
        r = i = i.next;
        do {
          var s = r, o = s.destroy;
          s = s.tag, o !== void 0 && (s & 2 || s & 4) && T1(t, e, o), r = r.next;
        } while (r !== i);
      }
      Qo(n24, e, t);
      break;
    case 1:
      if (!Ti && (hc(t, e), i = t.stateNode, typeof i.componentWillUnmount == "function")) try {
        i.props = t.memoizedProps, i.state = t.memoizedState, i.componentWillUnmount();
      } catch (a) {
        Mn(t, e, a);
      }
      Qo(n24, e, t);
      break;
    case 21:
      Qo(n24, e, t);
      break;
    case 22:
      t.mode & 1 ? (Ti = (i = Ti) || t.memoizedState !== null, Qo(n24, e, t), Ti = i) : Qo(n24, e, t);
      break;
    default:
      Qo(n24, e, t);
  }
}
function ib(n24) {
  var e = n24.updateQueue;
  if (e !== null) {
    n24.updateQueue = null;
    var t = n24.stateNode;
    t === null && (t = n24.stateNode = new jk()), e.forEach(function(i) {
      var r = nF.bind(null, n24, i);
      t.has(i) || (t.add(i), i.then(r, r));
    });
  }
}
function ds(n24, e) {
  var t = e.deletions;
  if (t !== null) for (var i = 0; i < t.length; i++) {
    var r = t[i];
    try {
      var s = n24, o = e, a = o;
      e: for (; a !== null; ) {
        switch (a.tag) {
          case 5:
            ci = a.stateNode, ys = false;
            break e;
          case 3:
            ci = a.stateNode.containerInfo, ys = true;
            break e;
          case 4:
            ci = a.stateNode.containerInfo, ys = true;
            break e;
        }
        a = a.return;
      }
      if (ci === null) throw Error(Me(160));
      t3(s, o, r), ci = null, ys = false;
      var l = r.alternate;
      l !== null && (l.return = null), r.return = null;
    } catch (f) {
      Mn(r, e, f);
    }
  }
  if (e.subtreeFlags & 12854) for (e = e.child; e !== null; ) n3(e, n24), e = e.sibling;
}
function n3(n24, e) {
  var t = n24.alternate, i = n24.flags;
  switch (n24.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (ds(e, n24), zs(n24), i & 4) {
        try {
          yh(3, n24, n24.return), O0(3, n24);
        } catch (S) {
          Mn(n24, n24.return, S);
        }
        try {
          yh(5, n24, n24.return);
        } catch (S) {
          Mn(n24, n24.return, S);
        }
      }
      break;
    case 1:
      ds(e, n24), zs(n24), i & 512 && t !== null && hc(t, t.return);
      break;
    case 5:
      if (ds(e, n24), zs(n24), i & 512 && t !== null && hc(t, t.return), n24.flags & 32) {
        var r = n24.stateNode;
        try {
          Ih(r, "");
        } catch (S) {
          Mn(n24, n24.return, S);
        }
      }
      if (i & 4 && (r = n24.stateNode, r != null)) {
        var s = n24.memoizedProps, o = t !== null ? t.memoizedProps : s, a = n24.type, l = n24.updateQueue;
        if (n24.updateQueue = null, l !== null) try {
          a === "input" && s.type === "radio" && s.name != null && ER(r, s), Jx(a, o);
          var f = Jx(a, s);
          for (o = 0; o < l.length; o += 2) {
            var h = l[o], d = l[o + 1];
            h === "style" ? RR(r, d) : h === "dangerouslySetInnerHTML" ? bR(r, d) : h === "children" ? Ih(r, d) : sM(r, h, d, f);
          }
          switch (a) {
            case "input":
              $x(r, s);
              break;
            case "textarea":
              TR(r, s);
              break;
            case "select":
              var p = r._wrapperState.wasMultiple;
              r._wrapperState.wasMultiple = !!s.multiple;
              var g = s.value;
              g != null ? Mc(r, !!s.multiple, g, false) : p !== !!s.multiple && (s.defaultValue != null ? Mc(r, !!s.multiple, s.defaultValue, true) : Mc(r, !!s.multiple, s.multiple ? [] : "", false));
          }
          r[Vh] = s;
        } catch (S) {
          Mn(n24, n24.return, S);
        }
      }
      break;
    case 6:
      if (ds(e, n24), zs(n24), i & 4) {
        if (n24.stateNode === null) throw Error(Me(162));
        r = n24.stateNode, s = n24.memoizedProps;
        try {
          r.nodeValue = s;
        } catch (S) {
          Mn(n24, n24.return, S);
        }
      }
      break;
    case 3:
      if (ds(e, n24), zs(n24), i & 4 && t !== null && t.memoizedState.isDehydrated) try {
        Uh(e.containerInfo);
      } catch (S) {
        Mn(n24, n24.return, S);
      }
      break;
    case 4:
      ds(e, n24), zs(n24);
      break;
    case 13:
      ds(e, n24), zs(n24), r = n24.child, r.flags & 8192 && (s = r.memoizedState !== null, r.stateNode.isHidden = s, !s || r.alternate !== null && r.alternate.memoizedState !== null || (FM = Ln())), i & 4 && ib(n24);
      break;
    case 22:
      if (h = t !== null && t.memoizedState !== null, n24.mode & 1 ? (Ti = (f = Ti) || h, ds(e, n24), Ti = f) : ds(e, n24), zs(n24), i & 8192) {
        if (f = n24.memoizedState !== null, (n24.stateNode.isHidden = f) && !h && n24.mode & 1) for (He = n24, h = n24.child; h !== null; ) {
          for (d = He = h; He !== null; ) {
            switch (p = He, g = p.child, p.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                yh(4, p, p.return);
                break;
              case 1:
                hc(p, p.return);
                var v = p.stateNode;
                if (typeof v.componentWillUnmount == "function") {
                  i = p, t = p.return;
                  try {
                    e = i, v.props = e.memoizedProps, v.state = e.memoizedState, v.componentWillUnmount();
                  } catch (S) {
                    Mn(i, t, S);
                  }
                }
                break;
              case 5:
                hc(p, p.return);
                break;
              case 22:
                if (p.memoizedState !== null) {
                  sb(d);
                  continue;
                }
            }
            g !== null ? (g.return = p, He = g) : sb(d);
          }
          h = h.sibling;
        }
        e: for (h = null, d = n24; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                r = d.stateNode, f ? (s = r.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (a = d.stateNode, l = d.memoizedProps.style, o = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = CR("display", o));
              } catch (S) {
                Mn(n24, n24.return, S);
              }
            }
          } else if (d.tag === 6) {
            if (h === null) try {
              d.stateNode.nodeValue = f ? "" : d.memoizedProps;
            } catch (S) {
              Mn(n24, n24.return, S);
            }
          } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === n24) && d.child !== null) {
            d.child.return = d, d = d.child;
            continue;
          }
          if (d === n24) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n24) break e;
            h === d && (h = null), d = d.return;
          }
          h === d && (h = null), d.sibling.return = d.return, d = d.sibling;
        }
      }
      break;
    case 19:
      ds(e, n24), zs(n24), i & 4 && ib(n24);
      break;
    case 21:
      break;
    default:
      ds(e, n24), zs(n24);
  }
}
function zs(n24) {
  var e = n24.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n24.return; t !== null; ) {
          if (e3(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(Me(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Ih(r, ""), i.flags &= -33);
          var s = nb(n24);
          C1(n24, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo, a = nb(n24);
          b1(n24, a, o);
          break;
        default:
          throw Error(Me(161));
      }
    } catch (l) {
      Mn(n24, n24.return, l);
    }
    n24.flags &= -3;
  }
  e & 4096 && (n24.flags &= -4097);
}
function Yk(n24, e, t) {
  He = n24, i3(n24);
}
function i3(n24, e, t) {
  for (var i = (n24.mode & 1) !== 0; He !== null; ) {
    var r = He, s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || am;
      if (!o) {
        var a = r.alternate, l = a !== null && a.memoizedState !== null || Ti;
        a = am;
        var f = Ti;
        if (am = o, (Ti = l) && !f) for (He = r; He !== null; ) o = He, l = o.child, o.tag === 22 && o.memoizedState !== null ? ob(r) : l !== null ? (l.return = o, He = l) : ob(r);
        for (; s !== null; ) He = s, i3(s), s = s.sibling;
        He = r, am = a, Ti = f;
      }
      rb(n24);
    } else r.subtreeFlags & 8772 && s !== null ? (s.return = r, He = s) : rb(n24);
  }
}
function rb(n24) {
  for (; He !== null; ) {
    var e = He;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772) switch (e.tag) {
          case 0:
          case 11:
          case 15:
            Ti || O0(5, e);
            break;
          case 1:
            var i = e.stateNode;
            if (e.flags & 4 && !Ti) if (t === null) i.componentDidMount();
            else {
              var r = e.elementType === e.type ? t.memoizedProps : _s(e.type, t.memoizedProps);
              i.componentDidUpdate(r, t.memoizedState, i.__reactInternalSnapshotBeforeUpdate);
            }
            var s = e.updateQueue;
            s !== null && HA(e, s, i);
            break;
          case 3:
            var o = e.updateQueue;
            if (o !== null) {
              if (t = null, e.child !== null) switch (e.child.tag) {
                case 5:
                  t = e.child.stateNode;
                  break;
                case 1:
                  t = e.child.stateNode;
              }
              HA(e, o, t);
            }
            break;
          case 5:
            var a = e.stateNode;
            if (t === null && e.flags & 4) {
              t = a;
              var l = e.memoizedProps;
              switch (e.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  l.autoFocus && t.focus();
                  break;
                case "img":
                  l.src && (t.src = l.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (e.memoizedState === null) {
              var f = e.alternate;
              if (f !== null) {
                var h = f.memoizedState;
                if (h !== null) {
                  var d = h.dehydrated;
                  d !== null && Uh(d);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(Me(163));
        }
        Ti || e.flags & 512 && A1(e);
      } catch (p) {
        Mn(e, e.return, p);
      }
    }
    if (e === n24) {
      He = null;
      break;
    }
    if (t = e.sibling, t !== null) {
      t.return = e.return, He = t;
      break;
    }
    He = e.return;
  }
}
function sb(n24) {
  for (; He !== null; ) {
    var e = He;
    if (e === n24) {
      He = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      t.return = e.return, He = t;
      break;
    }
    He = e.return;
  }
}
function ob(n24) {
  for (; He !== null; ) {
    var e = He;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            O0(4, e);
          } catch (l) {
            Mn(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              Mn(e, r, l);
            }
          }
          var s = e.return;
          try {
            A1(e);
          } catch (l) {
            Mn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            A1(e);
          } catch (l) {
            Mn(e, o, l);
          }
      }
    } catch (l) {
      Mn(e, e.return, l);
    }
    if (e === n24) {
      He = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      a.return = e.return, He = a;
      break;
    }
    He = e.return;
  }
}
var qk = Math.ceil, t0 = Ho.ReactCurrentDispatcher, UM = Ho.ReactCurrentOwner, ss = Ho.ReactCurrentBatchConfig, Pt = 0, ii = null, Vn = null, hi = 0, yr = 0, dc = Va(0), jn = 0, $h = null, $l = 0, U0 = 0, kM = 0, xh = null, Qi = null, FM = 0, Bc = 1 / 0, So = null, n0 = false, R1 = null, Ta = null, lm = false, ga = null, i0 = 0, Sh = 0, P1 = null, _g = -1, vg = 0;
function Hi() {
  return Pt & 6 ? Ln() : _g !== -1 ? _g : _g = Ln();
}
function Aa(n24) {
  return n24.mode & 1 ? Pt & 2 && hi !== 0 ? hi & -hi : Ik.transition !== null ? (vg === 0 && (vg = VR()), vg) : (n24 = Wt, n24 !== 0 || (n24 = window.event, n24 = n24 === void 0 ? 16 : YR(n24.type)), n24) : 1;
}
function ws(n24, e, t, i) {
  if (50 < Sh) throw Sh = 0, P1 = null, Error(Me(185));
  Cd(n24, t, i), (!(Pt & 2) || n24 !== ii) && (n24 === ii && (!(Pt & 2) && (U0 |= t), jn === 4 && ha(n24, hi)), ir(n24, i), t === 1 && Pt === 0 && !(e.mode & 1) && (Bc = Ln() + 500, I0 && Ha()));
}
function ir(n24, e) {
  var t = n24.callbackNode;
  IU(n24, e);
  var i = Bg(n24, n24 === ii ? hi : 0);
  if (i === 0) t !== null && mA(t), n24.callbackNode = null, n24.callbackPriority = 0;
  else if (e = i & -i, n24.callbackPriority !== e) {
    if (t != null && mA(t), e === 1) n24.tag === 0 ? Lk(ab.bind(null, n24)) : dP(ab.bind(null, n24)), bk(function() {
      !(Pt & 6) && Ha();
    }), t = null;
    else {
      switch (HR(i)) {
        case 1:
          t = cM;
          break;
        case 4:
          t = zR;
          break;
        case 16:
          t = zg;
          break;
        case 536870912:
          t = BR;
          break;
        default:
          t = zg;
      }
      t = f3(t, r3.bind(null, n24));
    }
    n24.callbackPriority = e, n24.callbackNode = t;
  }
}
function r3(n24, e) {
  if (_g = -1, vg = 0, Pt & 6) throw Error(Me(327));
  var t = n24.callbackNode;
  if (bc() && n24.callbackNode !== t) return null;
  var i = Bg(n24, n24 === ii ? hi : 0);
  if (i === 0) return null;
  if (i & 30 || i & n24.expiredLanes || e) e = r0(n24, i);
  else {
    e = i;
    var r = Pt;
    Pt |= 2;
    var s = o3();
    (ii !== n24 || hi !== e) && (So = null, Bc = Ln() + 500, Il(n24, e));
    do
      try {
        Jk();
        break;
      } catch (a) {
        s3(n24, a);
      }
    while (true);
    wM(), t0.current = s, Pt = r, Vn !== null ? e = 0 : (ii = null, hi = 0, e = jn);
  }
  if (e !== 0) {
    if (e === 2 && (r = i1(n24), r !== 0 && (i = r, e = L1(n24, r))), e === 1) throw t = $h, Il(n24, 0), ha(n24, i), ir(n24, Ln()), t;
    if (e === 6) ha(n24, i);
    else {
      if (r = n24.current.alternate, !(i & 30) && !Kk(r) && (e = r0(n24, i), e === 2 && (s = i1(n24), s !== 0 && (i = s, e = L1(n24, s))), e === 1)) throw t = $h, Il(n24, 0), ha(n24, i), ir(n24, Ln()), t;
      switch (n24.finishedWork = r, n24.finishedLanes = i, e) {
        case 0:
        case 1:
          throw Error(Me(345));
        case 2:
          gl(n24, Qi, So);
          break;
        case 3:
          if (ha(n24, i), (i & 130023424) === i && (e = FM + 500 - Ln(), 10 < e)) {
            if (Bg(n24, 0) !== 0) break;
            if (r = n24.suspendedLanes, (r & i) !== i) {
              Hi(), n24.pingedLanes |= n24.suspendedLanes & r;
              break;
            }
            n24.timeoutHandle = f1(gl.bind(null, n24, Qi, So), e);
            break;
          }
          gl(n24, Qi, So);
          break;
        case 4:
          if (ha(n24, i), (i & 4194240) === i) break;
          for (e = n24.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - Ms(i);
            s = 1 << o, o = e[o], o > r && (r = o), i &= ~s;
          }
          if (i = r, i = Ln() - i, i = (120 > i ? 120 : 480 > i ? 480 : 1080 > i ? 1080 : 1920 > i ? 1920 : 3e3 > i ? 3e3 : 4320 > i ? 4320 : 1960 * qk(i / 1960)) - i, 10 < i) {
            n24.timeoutHandle = f1(gl.bind(null, n24, Qi, So), i);
            break;
          }
          gl(n24, Qi, So);
          break;
        case 5:
          gl(n24, Qi, So);
          break;
        default:
          throw Error(Me(329));
      }
    }
  }
  return ir(n24, Ln()), n24.callbackNode === t ? r3.bind(null, n24) : null;
}
function L1(n24, e) {
  var t = xh;
  return n24.current.memoizedState.isDehydrated && (Il(n24, e).flags |= 256), n24 = r0(n24, e), n24 !== 2 && (e = Qi, Qi = t, e !== null && I1(e)), n24;
}
function I1(n24) {
  Qi === null ? Qi = n24 : Qi.push.apply(Qi, n24);
}
function Kk(n24) {
  for (var e = n24; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && (t = t.stores, t !== null)) for (var i = 0; i < t.length; i++) {
        var r = t[i], s = r.getSnapshot;
        r = r.value;
        try {
          if (!Ts(s(), r)) return false;
        } catch {
          return false;
        }
      }
    }
    if (t = e.child, e.subtreeFlags & 16384 && t !== null) t.return = e, e = t;
    else {
      if (e === n24) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n24) return true;
        e = e.return;
      }
      e.sibling.return = e.return, e = e.sibling;
    }
  }
  return true;
}
function ha(n24, e) {
  for (e &= ~kM, e &= ~U0, n24.suspendedLanes |= e, n24.pingedLanes &= ~e, n24 = n24.expirationTimes; 0 < e; ) {
    var t = 31 - Ms(e), i = 1 << t;
    n24[t] = -1, e &= ~i;
  }
}
function ab(n24) {
  if (Pt & 6) throw Error(Me(327));
  bc();
  var e = Bg(n24, 0);
  if (!(e & 1)) return ir(n24, Ln()), null;
  var t = r0(n24, e);
  if (n24.tag !== 0 && t === 2) {
    var i = i1(n24);
    i !== 0 && (e = i, t = L1(n24, i));
  }
  if (t === 1) throw t = $h, Il(n24, 0), ha(n24, e), ir(n24, Ln()), t;
  if (t === 6) throw Error(Me(345));
  return n24.finishedWork = n24.current.alternate, n24.finishedLanes = e, gl(n24, Qi, So), ir(n24, Ln()), null;
}
function zM(n24, e) {
  var t = Pt;
  Pt |= 1;
  try {
    return n24(e);
  } finally {
    Pt = t, Pt === 0 && (Bc = Ln() + 500, I0 && Ha());
  }
}
function Yl(n24) {
  ga !== null && ga.tag === 0 && !(Pt & 6) && bc();
  var e = Pt;
  Pt |= 1;
  var t = ss.transition, i = Wt;
  try {
    if (ss.transition = null, Wt = 1, n24) return n24();
  } finally {
    Wt = i, ss.transition = t, Pt = e, !(Pt & 6) && Ha();
  }
}
function BM() {
  yr = dc.current, nn(dc);
}
function Il(n24, e) {
  n24.finishedWork = null, n24.finishedLanes = 0;
  var t = n24.timeoutHandle;
  if (t !== -1 && (n24.timeoutHandle = -1, Ak(t)), Vn !== null) for (t = Vn.return; t !== null; ) {
    var i = t;
    switch (xM(i), i.tag) {
      case 1:
        i = i.type.childContextTypes, i != null && Xg();
        break;
      case 3:
        Fc(), nn(tr), nn(Li), RM();
        break;
      case 5:
        CM(i);
        break;
      case 4:
        Fc();
        break;
      case 13:
        nn(cn);
        break;
      case 19:
        nn(cn);
        break;
      case 10:
        EM(i.type._context);
        break;
      case 22:
      case 23:
        BM();
    }
    t = t.return;
  }
  if (ii = n24, Vn = n24 = ba(n24.current, null), hi = yr = e, jn = 0, $h = null, kM = U0 = $l = 0, Qi = xh = null, El !== null) {
    for (e = 0; e < El.length; e++) if (t = El[e], i = t.interleaved, i !== null) {
      t.interleaved = null;
      var r = i.next, s = t.pending;
      if (s !== null) {
        var o = s.next;
        s.next = r, i.next = o;
      }
      t.pending = i;
    }
    El = null;
  }
  return n24;
}
function s3(n24, e) {
  do {
    var t = Vn;
    try {
      if (wM(), pg.current = e0, Qg) {
        for (var i = mn.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), i = i.next;
        }
        Qg = false;
      }
      if (jl = 0, ti = Wn = mn = null, vh = false, Wh = 0, UM.current = null, t === null || t.return === null) {
        jn = 1, $h = e, Vn = null;
        break;
      }
      e: {
        var s = n24, o = t.return, a = t, l = e;
        if (e = hi, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") {
          var f = l, h = a, d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p ? (h.updateQueue = p.updateQueue, h.memoizedState = p.memoizedState, h.lanes = p.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var g = YA(o);
          if (g !== null) {
            g.flags &= -257, qA(g, o, a, s, e), g.mode & 1 && $A(s, f, e), e = g, l = f;
            var v = e.updateQueue;
            if (v === null) {
              var S = /* @__PURE__ */ new Set();
              S.add(l), e.updateQueue = S;
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              $A(s, f, e), VM();
              break e;
            }
            l = Error(Me(426));
          }
        } else if (on && a.mode & 1) {
          var M = YA(o);
          if (M !== null) {
            !(M.flags & 65536) && (M.flags |= 256), qA(M, o, a, s, e), SM(zc(l, a));
            break e;
          }
        }
        s = l = zc(l, a), jn !== 4 && (jn = 2), xh === null ? xh = [s] : xh.push(s), s = o;
        do {
          switch (s.tag) {
            case 3:
              s.flags |= 65536, e &= -e, s.lanes |= e;
              var m = HP(s, l, e);
              VA(s, m);
              break e;
            case 1:
              a = l;
              var w = s.type, E = s.stateNode;
              if (!(s.flags & 128) && (typeof w.getDerivedStateFromError == "function" || E !== null && typeof E.componentDidCatch == "function" && (Ta === null || !Ta.has(E)))) {
                s.flags |= 65536, e &= -e, s.lanes |= e;
                var A = GP(s, a, e);
                VA(s, A);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      l3(t);
    } catch (P) {
      e = P, Vn === t && t !== null && (Vn = t = t.return);
      continue;
    }
    break;
  } while (true);
}
function o3() {
  var n24 = t0.current;
  return t0.current = e0, n24 === null ? e0 : n24;
}
function VM() {
  (jn === 0 || jn === 3 || jn === 2) && (jn = 4), ii === null || !($l & 268435455) && !(U0 & 268435455) || ha(ii, hi);
}
function r0(n24, e) {
  var t = Pt;
  Pt |= 2;
  var i = o3();
  (ii !== n24 || hi !== e) && (So = null, Il(n24, e));
  do
    try {
      Zk();
      break;
    } catch (r) {
      s3(n24, r);
    }
  while (true);
  if (wM(), Pt = t, t0.current = i, Vn !== null) throw Error(Me(261));
  return ii = null, hi = 0, jn;
}
function Zk() {
  for (; Vn !== null; ) a3(Vn);
}
function Jk() {
  for (; Vn !== null && !wU(); ) a3(Vn);
}
function a3(n24) {
  var e = c3(n24.alternate, n24, yr);
  n24.memoizedProps = n24.pendingProps, e === null ? l3(n24) : Vn = e, UM.current = null;
}
function l3(n24) {
  var e = n24;
  do {
    var t = e.alternate;
    if (n24 = e.return, e.flags & 32768) {
      if (t = Xk(t, e), t !== null) {
        t.flags &= 32767, Vn = t;
        return;
      }
      if (n24 !== null) n24.flags |= 32768, n24.subtreeFlags = 0, n24.deletions = null;
      else {
        jn = 6, Vn = null;
        return;
      }
    } else if (t = Wk(t, e, yr), t !== null) {
      Vn = t;
      return;
    }
    if (e = e.sibling, e !== null) {
      Vn = e;
      return;
    }
    Vn = e = n24;
  } while (e !== null);
  jn === 0 && (jn = 5);
}
function gl(n24, e, t) {
  var i = Wt, r = ss.transition;
  try {
    ss.transition = null, Wt = 1, Qk(n24, e, t, i);
  } finally {
    ss.transition = r, Wt = i;
  }
  return null;
}
function Qk(n24, e, t, i) {
  do
    bc();
  while (ga !== null);
  if (Pt & 6) throw Error(Me(327));
  t = n24.finishedWork;
  var r = n24.finishedLanes;
  if (t === null) return null;
  if (n24.finishedWork = null, n24.finishedLanes = 0, t === n24.current) throw Error(Me(177));
  n24.callbackNode = null, n24.callbackPriority = 0;
  var s = t.lanes | t.childLanes;
  if (NU(n24, s), n24 === ii && (Vn = ii = null, hi = 0), !(t.subtreeFlags & 2064) && !(t.flags & 2064) || lm || (lm = true, f3(zg, function() {
    return bc(), null;
  })), s = (t.flags & 15990) !== 0, t.subtreeFlags & 15990 || s) {
    s = ss.transition, ss.transition = null;
    var o = Wt;
    Wt = 1;
    var a = Pt;
    Pt |= 4, UM.current = null, $k(n24, t), n3(t, n24), yk(u1), Vg = !!l1, u1 = l1 = null, n24.current = t, Yk(t), EU(), Pt = a, Wt = o, ss.transition = s;
  } else n24.current = t;
  if (lm && (lm = false, ga = n24, i0 = r), s = n24.pendingLanes, s === 0 && (Ta = null), bU(t.stateNode), ir(n24, Ln()), e !== null) for (i = n24.onRecoverableError, t = 0; t < e.length; t++) r = e[t], i(r.value, { componentStack: r.stack, digest: r.digest });
  if (n0) throw n0 = false, n24 = R1, R1 = null, n24;
  return i0 & 1 && n24.tag !== 0 && bc(), s = n24.pendingLanes, s & 1 ? n24 === P1 ? Sh++ : (Sh = 0, P1 = n24) : Sh = 0, Ha(), null;
}
function bc() {
  if (ga !== null) {
    var n24 = HR(i0), e = ss.transition, t = Wt;
    try {
      if (ss.transition = null, Wt = 16 > n24 ? 16 : n24, ga === null) var i = false;
      else {
        if (n24 = ga, ga = null, i0 = 0, Pt & 6) throw Error(Me(331));
        var r = Pt;
        for (Pt |= 4, He = n24.current; He !== null; ) {
          var s = He, o = s.child;
          if (He.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var f = a[l];
                for (He = f; He !== null; ) {
                  var h = He;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      yh(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) d.return = h, He = d;
                  else for (; He !== null; ) {
                    h = He;
                    var p = h.sibling, g = h.return;
                    if (QP(h), h === f) {
                      He = null;
                      break;
                    }
                    if (p !== null) {
                      p.return = g, He = p;
                      break;
                    }
                    He = g;
                  }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var S = v.child;
                if (S !== null) {
                  v.child = null;
                  do {
                    var M = S.sibling;
                    S.sibling = null, S = M;
                  } while (S !== null);
                }
              }
              He = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) o.return = s, He = o;
          else e: for (; He !== null; ) {
            if (s = He, s.flags & 2048) switch (s.tag) {
              case 0:
              case 11:
              case 15:
                yh(9, s, s.return);
            }
            var m = s.sibling;
            if (m !== null) {
              m.return = s.return, He = m;
              break e;
            }
            He = s.return;
          }
        }
        var w = n24.current;
        for (He = w; He !== null; ) {
          o = He;
          var E = o.child;
          if (o.subtreeFlags & 2064 && E !== null) E.return = o, He = E;
          else e: for (o = w; He !== null; ) {
            if (a = He, a.flags & 2048) try {
              switch (a.tag) {
                case 0:
                case 11:
                case 15:
                  O0(9, a);
              }
            } catch (P) {
              Mn(a, a.return, P);
            }
            if (a === o) {
              He = null;
              break e;
            }
            var A = a.sibling;
            if (A !== null) {
              A.return = a.return, He = A;
              break e;
            }
            He = a.return;
          }
        }
        if (Pt = r, Ha(), Ks && typeof Ks.onPostCommitFiberRoot == "function") try {
          Ks.onPostCommitFiberRoot(b0, n24);
        } catch {
        }
        i = true;
      }
      return i;
    } finally {
      Wt = t, ss.transition = e;
    }
  }
  return false;
}
function lb(n24, e, t) {
  e = zc(t, e), e = HP(n24, e, 1), n24 = Ea(n24, e, 1), e = Hi(), n24 !== null && (Cd(n24, 1, e), ir(n24, e));
}
function Mn(n24, e, t) {
  if (n24.tag === 3) lb(n24, n24, t);
  else for (; e !== null; ) {
    if (e.tag === 3) {
      lb(e, n24, t);
      break;
    } else if (e.tag === 1) {
      var i = e.stateNode;
      if (typeof e.type.getDerivedStateFromError == "function" || typeof i.componentDidCatch == "function" && (Ta === null || !Ta.has(i))) {
        n24 = zc(t, n24), n24 = GP(e, n24, 1), e = Ea(e, n24, 1), n24 = Hi(), e !== null && (Cd(e, 1, n24), ir(e, n24));
        break;
      }
    }
    e = e.return;
  }
}
function eF(n24, e, t) {
  var i = n24.pingCache;
  i !== null && i.delete(e), e = Hi(), n24.pingedLanes |= n24.suspendedLanes & t, ii === n24 && (hi & t) === t && (jn === 4 || jn === 3 && (hi & 130023424) === hi && 500 > Ln() - FM ? Il(n24, 0) : kM |= t), ir(n24, e);
}
function u3(n24, e) {
  e === 0 && (n24.mode & 1 ? (e = Jp, Jp <<= 1, !(Jp & 130023424) && (Jp = 4194304)) : e = 1);
  var t = Hi();
  n24 = Do(n24, e), n24 !== null && (Cd(n24, e, t), ir(n24, t));
}
function tF(n24) {
  var e = n24.memoizedState, t = 0;
  e !== null && (t = e.retryLane), u3(n24, t);
}
function nF(n24, e) {
  var t = 0;
  switch (n24.tag) {
    case 13:
      var i = n24.stateNode, r = n24.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n24.stateNode;
      break;
    default:
      throw Error(Me(314));
  }
  i !== null && i.delete(e), u3(n24, t);
}
var c3;
c3 = function(n24, e, t) {
  if (n24 !== null) if (n24.memoizedProps !== e.pendingProps || tr.current) er = true;
  else {
    if (!(n24.lanes & t) && !(e.flags & 128)) return er = false, Gk(n24, e, t);
    er = !!(n24.flags & 131072);
  }
  else er = false, on && e.flags & 1048576 && pP(e, Yg, e.index);
  switch (e.lanes = 0, e.tag) {
    case 2:
      var i = e.type;
      gg(n24, e), n24 = e.pendingProps;
      var r = Oc(e, Li.current);
      Ac(e, t), r = LM(null, e, i, n24, r, t);
      var s = IM();
      return e.flags |= 1, typeof r == "object" && r !== null && typeof r.render == "function" && r.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, nr(i) ? (s = true, jg(e)) : s = false, e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null, AM(e), r.updater = D0, e.stateNode = r, r._reactInternals = e, v1(e, i, n24, t), e = S1(null, e, i, true, s, t)) : (e.tag = 0, on && s && yM(e), Fi(null, e, r, t), e = e.child), e;
    case 16:
      i = e.elementType;
      e: {
        switch (gg(n24, e), n24 = e.pendingProps, r = i._init, i = r(i._payload), e.type = i, r = e.tag = rF(i), n24 = _s(i, n24), r) {
          case 0:
            e = x1(null, e, i, n24, t);
            break e;
          case 1:
            e = JA(null, e, i, n24, t);
            break e;
          case 11:
            e = KA(null, e, i, n24, t);
            break e;
          case 14:
            e = ZA(null, e, i, _s(i.type, n24), t);
            break e;
        }
        throw Error(Me(306, i, ""));
      }
      return e;
    case 0:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : _s(i, r), x1(n24, e, i, r, t);
    case 1:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : _s(i, r), JA(n24, e, i, r, t);
    case 3:
      e: {
        if ($P(e), n24 === null) throw Error(Me(387));
        i = e.pendingProps, s = e.memoizedState, r = s.element, xP(n24, e), Zg(e, i, null, t);
        var o = e.memoizedState;
        if (i = o.element, s.isDehydrated) if (s = { element: i, isDehydrated: false, cache: o.cache, pendingSuspenseBoundaries: o.pendingSuspenseBoundaries, transitions: o.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) {
          r = zc(Error(Me(423)), e), e = QA(n24, e, i, t, r);
          break e;
        } else if (i !== r) {
          r = zc(Error(Me(424)), e), e = QA(n24, e, i, t, r);
          break e;
        } else for (Tr = wa(e.stateNode.containerInfo.firstChild), br = e, on = true, xs = null, t = vP(e, null, i, t), e.child = t; t; ) t.flags = t.flags & -3 | 4096, t = t.sibling;
        else {
          if (Uc(), i === r) {
            e = Oo(n24, e, t);
            break e;
          }
          Fi(n24, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return SP(e), n24 === null && m1(e), i = e.type, r = e.pendingProps, s = n24 !== null ? n24.memoizedProps : null, o = r.children, c1(i, r) ? o = null : s !== null && c1(i, s) && (e.flags |= 32), jP(n24, e), Fi(n24, e, o, t), e.child;
    case 6:
      return n24 === null && m1(e), null;
    case 13:
      return YP(n24, e, t);
    case 4:
      return bM(e, e.stateNode.containerInfo), i = e.pendingProps, n24 === null ? e.child = kc(e, null, i, t) : Fi(n24, e, i, t), e.child;
    case 11:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : _s(i, r), KA(n24, e, i, r, t);
    case 7:
      return Fi(n24, e, e.pendingProps, t), e.child;
    case 8:
      return Fi(n24, e, e.pendingProps.children, t), e.child;
    case 12:
      return Fi(n24, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (i = e.type._context, r = e.pendingProps, s = e.memoizedProps, o = r.value, Jt(qg, i._currentValue), i._currentValue = o, s !== null) if (Ts(s.value, o)) {
          if (s.children === r.children && !tr.current) {
            e = Oo(n24, e, t);
            break e;
          }
        } else for (s = e.child, s !== null && (s.return = e); s !== null; ) {
          var a = s.dependencies;
          if (a !== null) {
            o = s.child;
            for (var l = a.firstContext; l !== null; ) {
              if (l.context === i) {
                if (s.tag === 1) {
                  l = Po(-1, t & -t), l.tag = 2;
                  var f = s.updateQueue;
                  if (f !== null) {
                    f = f.shared;
                    var h = f.pending;
                    h === null ? l.next = l : (l.next = h.next, h.next = l), f.pending = l;
                  }
                }
                s.lanes |= t, l = s.alternate, l !== null && (l.lanes |= t), g1(s.return, t, e), a.lanes |= t;
                break;
              }
              l = l.next;
            }
          } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
          else if (s.tag === 18) {
            if (o = s.return, o === null) throw Error(Me(341));
            o.lanes |= t, a = o.alternate, a !== null && (a.lanes |= t), g1(o, t, e), o = s.sibling;
          } else o = s.child;
          if (o !== null) o.return = s;
          else for (o = s; o !== null; ) {
            if (o === e) {
              o = null;
              break;
            }
            if (s = o.sibling, s !== null) {
              s.return = o.return, o = s;
              break;
            }
            o = o.return;
          }
          s = o;
        }
        Fi(n24, e, r.children, t), e = e.child;
      }
      return e;
    case 9:
      return r = e.type, i = e.pendingProps.children, Ac(e, t), r = os(r), i = i(r), e.flags |= 1, Fi(n24, e, i, t), e.child;
    case 14:
      return i = e.type, r = _s(i, e.pendingProps), r = _s(i.type, r), ZA(n24, e, i, r, t);
    case 15:
      return WP(n24, e, e.type, e.pendingProps, t);
    case 17:
      return i = e.type, r = e.pendingProps, r = e.elementType === i ? r : _s(i, r), gg(n24, e), e.tag = 1, nr(i) ? (n24 = true, jg(e)) : n24 = false, Ac(e, t), VP(e, i, r), v1(e, i, r, t), S1(null, e, i, true, n24, t);
    case 19:
      return qP(n24, e, t);
    case 22:
      return XP(n24, e, t);
  }
  throw Error(Me(156, e.tag));
};
function f3(n24, e) {
  return FR(n24, e);
}
function iF(n24, e, t, i) {
  this.tag = n24, this.key = t, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = i, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
function is(n24, e, t, i) {
  return new iF(n24, e, t, i);
}
function HM(n24) {
  return n24 = n24.prototype, !(!n24 || !n24.isReactComponent);
}
function rF(n24) {
  if (typeof n24 == "function") return HM(n24) ? 1 : 0;
  if (n24 != null) {
    if (n24 = n24.$$typeof, n24 === aM) return 11;
    if (n24 === lM) return 14;
  }
  return 2;
}
function ba(n24, e) {
  var t = n24.alternate;
  return t === null ? (t = is(n24.tag, e, n24.key, n24.mode), t.elementType = n24.elementType, t.type = n24.type, t.stateNode = n24.stateNode, t.alternate = n24, n24.alternate = t) : (t.pendingProps = e, t.type = n24.type, t.flags = 0, t.subtreeFlags = 0, t.deletions = null), t.flags = n24.flags & 14680064, t.childLanes = n24.childLanes, t.lanes = n24.lanes, t.child = n24.child, t.memoizedProps = n24.memoizedProps, t.memoizedState = n24.memoizedState, t.updateQueue = n24.updateQueue, e = n24.dependencies, t.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, t.sibling = n24.sibling, t.index = n24.index, t.ref = n24.ref, t;
}
function yg(n24, e, t, i, r, s) {
  var o = 2;
  if (i = n24, typeof n24 == "function") HM(n24) && (o = 1);
  else if (typeof n24 == "string") o = 5;
  else e: switch (n24) {
    case ic:
      return Nl(t.children, r, s, e);
    case oM:
      o = 8, r |= 8;
      break;
    case Hx:
      return n24 = is(12, t, e, r | 2), n24.elementType = Hx, n24.lanes = s, n24;
    case Gx:
      return n24 = is(13, t, e, r), n24.elementType = Gx, n24.lanes = s, n24;
    case Wx:
      return n24 = is(19, t, e, r), n24.elementType = Wx, n24.lanes = s, n24;
    case SR:
      return k0(t, r, s, e);
    default:
      if (typeof n24 == "object" && n24 !== null) switch (n24.$$typeof) {
        case yR:
          o = 10;
          break e;
        case xR:
          o = 9;
          break e;
        case aM:
          o = 11;
          break e;
        case lM:
          o = 14;
          break e;
        case la:
          o = 16, i = null;
          break e;
      }
      throw Error(Me(130, n24 == null ? n24 : typeof n24, ""));
  }
  return e = is(o, t, e, r), e.elementType = n24, e.type = i, e.lanes = s, e;
}
function Nl(n24, e, t, i) {
  return n24 = is(7, n24, i, e), n24.lanes = t, n24;
}
function k0(n24, e, t, i) {
  return n24 = is(22, n24, i, e), n24.elementType = SR, n24.lanes = t, n24.stateNode = { isHidden: false }, n24;
}
function Ny(n24, e, t) {
  return n24 = is(6, n24, null, e), n24.lanes = t, n24;
}
function Dy(n24, e, t) {
  return e = is(4, n24.children !== null ? n24.children : [], n24.key, e), e.lanes = t, e.stateNode = { containerInfo: n24.containerInfo, pendingChildren: null, implementation: n24.implementation }, e;
}
function sF(n24, e, t, i, r) {
  this.tag = e, this.containerInfo = n24, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = py(0), this.expirationTimes = py(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = py(0), this.identifierPrefix = i, this.onRecoverableError = r, this.mutableSourceEagerHydrationData = null;
}
function GM(n24, e, t, i, r, s, o, a, l) {
  return n24 = new sF(n24, e, t, a, l), e === 1 ? (e = 1, s === true && (e |= 8)) : e = 0, s = is(3, null, null, e), n24.current = s, s.stateNode = n24, s.memoizedState = { element: i, isDehydrated: t, cache: null, transitions: null, pendingSuspenseBoundaries: null }, AM(s), n24;
}
function oF(n24, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: nc, key: i == null ? null : "" + i, children: n24, containerInfo: e, implementation: t };
}
function h3(n24) {
  if (!n24) return Da;
  n24 = n24._reactInternals;
  e: {
    if (tu(n24) !== n24 || n24.tag !== 1) throw Error(Me(170));
    var e = n24;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (nr(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(Me(171));
  }
  if (n24.tag === 1) {
    var t = n24.type;
    if (nr(t)) return hP(n24, t, e);
  }
  return e;
}
function d3(n24, e, t, i, r, s, o, a, l) {
  return n24 = GM(t, i, true, n24, r, s, o, a, l), n24.context = h3(null), t = n24.current, i = Hi(), r = Aa(t), s = Po(i, r), s.callback = e ?? null, Ea(t, s, r), n24.current.lanes = r, Cd(n24, r, i), ir(n24, i), n24;
}
function F0(n24, e, t, i) {
  var r = e.current, s = Hi(), o = Aa(r);
  return t = h3(t), e.context === null ? e.context = t : e.pendingContext = t, e = Po(s, o), e.payload = { element: n24 }, i = i === void 0 ? null : i, i !== null && (e.callback = i), n24 = Ea(r, e, o), n24 !== null && (ws(n24, r, o, s), dg(n24, r, o)), o;
}
function s0(n24) {
  if (n24 = n24.current, !n24.child) return null;
  switch (n24.child.tag) {
    case 5:
      return n24.child.stateNode;
    default:
      return n24.child.stateNode;
  }
}
function ub(n24, e) {
  if (n24 = n24.memoizedState, n24 !== null && n24.dehydrated !== null) {
    var t = n24.retryLane;
    n24.retryLane = t !== 0 && t < e ? t : e;
  }
}
function WM(n24, e) {
  ub(n24, e), (n24 = n24.alternate) && ub(n24, e);
}
function aF() {
  return null;
}
var p3 = typeof reportError == "function" ? reportError : function(n24) {
  console.error(n24);
};
function XM(n24) {
  this._internalRoot = n24;
}
z0.prototype.render = XM.prototype.render = function(n24) {
  var e = this._internalRoot;
  if (e === null) throw Error(Me(409));
  F0(n24, e, null, null);
};
z0.prototype.unmount = XM.prototype.unmount = function() {
  var n24 = this._internalRoot;
  if (n24 !== null) {
    this._internalRoot = null;
    var e = n24.containerInfo;
    Yl(function() {
      F0(null, n24, null, null);
    }), e[No] = null;
  }
};
function z0(n24) {
  this._internalRoot = n24;
}
z0.prototype.unstable_scheduleHydration = function(n24) {
  if (n24) {
    var e = XR();
    n24 = { blockedOn: null, target: n24, priority: e };
    for (var t = 0; t < fa.length && e !== 0 && e < fa[t].priority; t++) ;
    fa.splice(t, 0, n24), t === 0 && $R(n24);
  }
};
function jM(n24) {
  return !(!n24 || n24.nodeType !== 1 && n24.nodeType !== 9 && n24.nodeType !== 11);
}
function B0(n24) {
  return !(!n24 || n24.nodeType !== 1 && n24.nodeType !== 9 && n24.nodeType !== 11 && (n24.nodeType !== 8 || n24.nodeValue !== " react-mount-point-unstable "));
}
function cb() {
}
function lF(n24, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function() {
        var f = s0(o);
        s.call(f);
      };
    }
    var o = d3(e, i, n24, 0, null, false, false, "", cb);
    return n24._reactRootContainer = o, n24[No] = o.current, zh(n24.nodeType === 8 ? n24.parentNode : n24), Yl(), o;
  }
  for (; r = n24.lastChild; ) n24.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function() {
      var f = s0(l);
      a.call(f);
    };
  }
  var l = GM(n24, 0, false, null, null, false, false, "", cb);
  return n24._reactRootContainer = l, n24[No] = l.current, zh(n24.nodeType === 8 ? n24.parentNode : n24), Yl(function() {
    F0(e, l, t, i);
  }), l;
}
function V0(n24, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function() {
        var l = s0(o);
        a.call(l);
      };
    }
    F0(e, o, n24, r);
  } else o = lF(t, e, n24, r, i);
  return s0(o);
}
GR = function(n24) {
  switch (n24.tag) {
    case 3:
      var e = n24.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = ah(e.pendingLanes);
        t !== 0 && (fM(e, t | 1), ir(e, Ln()), !(Pt & 6) && (Bc = Ln() + 500, Ha()));
      }
      break;
    case 13:
      Yl(function() {
        var i = Do(n24, 1);
        if (i !== null) {
          var r = Hi();
          ws(i, n24, 1, r);
        }
      }), WM(n24, 1);
  }
};
hM = function(n24) {
  if (n24.tag === 13) {
    var e = Do(n24, 134217728);
    if (e !== null) {
      var t = Hi();
      ws(e, n24, 134217728, t);
    }
    WM(n24, 134217728);
  }
};
WR = function(n24) {
  if (n24.tag === 13) {
    var e = Aa(n24), t = Do(n24, e);
    if (t !== null) {
      var i = Hi();
      ws(t, n24, e, i);
    }
    WM(n24, e);
  }
};
XR = function() {
  return Wt;
};
jR = function(n24, e) {
  var t = Wt;
  try {
    return Wt = n24, e();
  } finally {
    Wt = t;
  }
};
e1 = function(n24, e, t) {
  switch (e) {
    case "input":
      if ($x(n24, t), e = t.name, t.type === "radio" && e != null) {
        for (t = n24; t.parentNode; ) t = t.parentNode;
        for (t = t.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < t.length; e++) {
          var i = t[e];
          if (i !== n24 && i.form === n24.form) {
            var r = L0(i);
            if (!r) throw Error(Me(90));
            wR(i), $x(i, r);
          }
        }
      }
      break;
    case "textarea":
      TR(n24, t);
      break;
    case "select":
      e = t.value, e != null && Mc(n24, !!t.multiple, e, false);
  }
};
IR = zM;
NR = Yl;
var uF = { usingClientEntryPoint: false, Events: [Pd, ac, L0, PR, LR, zM] }, Vf = { findFiberByHostInstance: wl, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, cF = { bundleType: Vf.bundleType, version: Vf.version, rendererPackageName: Vf.rendererPackageName, rendererConfig: Vf.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Ho.ReactCurrentDispatcher, findHostInstanceByFiber: function(n24) {
  return n24 = UR(n24), n24 === null ? null : n24.stateNode;
}, findFiberByHostInstance: Vf.findFiberByHostInstance || aF, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var um = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!um.isDisabled && um.supportsFiber) try {
    b0 = um.inject(cF), Ks = um;
  } catch {
  }
}
Dr.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = uF;
Dr.createPortal = function(n24, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!jM(e)) throw Error(Me(200));
  return oF(n24, e, null, t);
};
Dr.createRoot = function(n24, e) {
  if (!jM(n24)) throw Error(Me(299));
  var t = false, i = "", r = p3;
  return e != null && (e.unstable_strictMode === true && (t = true), e.identifierPrefix !== void 0 && (i = e.identifierPrefix), e.onRecoverableError !== void 0 && (r = e.onRecoverableError)), e = GM(n24, 1, false, null, null, t, false, i, r), n24[No] = e.current, zh(n24.nodeType === 8 ? n24.parentNode : n24), new XM(e);
};
Dr.findDOMNode = function(n24) {
  if (n24 == null) return null;
  if (n24.nodeType === 1) return n24;
  var e = n24._reactInternals;
  if (e === void 0) throw typeof n24.render == "function" ? Error(Me(188)) : (n24 = Object.keys(n24).join(","), Error(Me(268, n24)));
  return n24 = UR(e), n24 = n24 === null ? null : n24.stateNode, n24;
};
Dr.flushSync = function(n24) {
  return Yl(n24);
};
Dr.hydrate = function(n24, e, t) {
  if (!B0(e)) throw Error(Me(200));
  return V0(null, n24, e, true, t);
};
Dr.hydrateRoot = function(n24, e, t) {
  if (!jM(n24)) throw Error(Me(405));
  var i = t != null && t.hydratedSources || null, r = false, s = "", o = p3;
  if (t != null && (t.unstable_strictMode === true && (r = true), t.identifierPrefix !== void 0 && (s = t.identifierPrefix), t.onRecoverableError !== void 0 && (o = t.onRecoverableError)), e = d3(e, null, n24, 1, t ?? null, r, false, s, o), n24[No] = e.current, zh(n24), i) for (n24 = 0; n24 < i.length; n24++) t = i[n24], r = t._getVersion, r = r(t._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [t, r] : e.mutableSourceEagerHydrationData.push(t, r);
  return new z0(e);
};
Dr.render = function(n24, e, t) {
  if (!B0(e)) throw Error(Me(200));
  return V0(null, n24, e, false, t);
};
Dr.unmountComponentAtNode = function(n24) {
  if (!B0(n24)) throw Error(Me(40));
  return n24._reactRootContainer ? (Yl(function() {
    V0(null, null, n24, false, function() {
      n24._reactRootContainer = null, n24[No] = null;
    });
  }), true) : false;
};
Dr.unstable_batchedUpdates = zM;
Dr.unstable_renderSubtreeIntoContainer = function(n24, e, t, i) {
  if (!B0(t)) throw Error(Me(200));
  if (n24 == null || n24._reactInternals === void 0) throw Error(Me(38));
  return V0(n24, e, t, false, i);
};
Dr.version = "18.3.1-next-f1338f8080-20240426";
function m3() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(m3);
  } catch (n24) {
    console.error(n24);
  }
}
m3(), mR.exports = Dr;
var fF = mR.exports, fb = fF;
Bx.createRoot = fb.createRoot, Bx.hydrateRoot = fb.hydrateRoot;
function ql(n24) {
  let e = "https://mui.com/production-error/?code=" + n24;
  for (let t = 1; t < arguments.length; t += 1) e += "&args[]=" + encodeURIComponent(arguments[t]);
  return "Minified MUI error #" + n24 + "; visit " + e + " for the full message.";
}
const hF = Object.freeze(Object.defineProperty({ __proto__: null, default: ql }, Symbol.toStringTag, { value: "Module" })), o0 = "$$material";
function dt() {
  return dt = Object.assign ? Object.assign.bind() : function(n24) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var i in t) ({}).hasOwnProperty.call(t, i) && (n24[i] = t[i]);
    }
    return n24;
  }, dt.apply(null, arguments);
}
function Xi(n24, e) {
  if (n24 == null) return {};
  var t = {};
  for (var i in n24) if ({}.hasOwnProperty.call(n24, i)) {
    if (e.indexOf(i) !== -1) continue;
    t[i] = n24[i];
  }
  return t;
}
function dF(n24) {
  if (n24.sheet) return n24.sheet;
  for (var e = 0; e < document.styleSheets.length; e++) if (document.styleSheets[e].ownerNode === n24) return document.styleSheets[e];
}
function pF(n24) {
  var e = document.createElement("style");
  return e.setAttribute("data-emotion", n24.key), n24.nonce !== void 0 && e.setAttribute("nonce", n24.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
}
var mF = function() {
  function n24(t) {
    var i = this;
    this._insertTag = function(r) {
      var s;
      i.tags.length === 0 ? i.insertionPoint ? s = i.insertionPoint.nextSibling : i.prepend ? s = i.container.firstChild : s = i.before : s = i.tags[i.tags.length - 1].nextSibling, i.container.insertBefore(r, s), i.tags.push(r);
    }, this.isSpeedy = t.speedy === void 0 ? true : t.speedy, this.tags = [], this.ctr = 0, this.nonce = t.nonce, this.key = t.key, this.container = t.container, this.prepend = t.prepend, this.insertionPoint = t.insertionPoint, this.before = null;
  }
  var e = n24.prototype;
  return e.hydrate = function(i) {
    i.forEach(this._insertTag);
  }, e.insert = function(i) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(pF(this));
    var r = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var s = dF(r);
      try {
        s.insertRule(i, s.cssRules.length);
      } catch {
      }
    } else r.appendChild(document.createTextNode(i));
    this.ctr++;
  }, e.flush = function() {
    this.tags.forEach(function(i) {
      var r;
      return (r = i.parentNode) == null ? void 0 : r.removeChild(i);
    }), this.tags = [], this.ctr = 0;
  }, n24;
}(), Ei = "-ms-", a0 = "-moz-", kt = "-webkit-", g3 = "comm", $M = "rule", YM = "decl", gF = "@import", _3 = "@keyframes", _F = "@layer", vF = Math.abs, H0 = String.fromCharCode, yF = Object.assign;
function xF(n24, e) {
  return fi(n24, 0) ^ 45 ? (((e << 2 ^ fi(n24, 0)) << 2 ^ fi(n24, 1)) << 2 ^ fi(n24, 2)) << 2 ^ fi(n24, 3) : 0;
}
function v3(n24) {
  return n24.trim();
}
function SF(n24, e) {
  return (n24 = e.exec(n24)) ? n24[0] : n24;
}
function Ft(n24, e, t) {
  return n24.replace(e, t);
}
function N1(n24, e) {
  return n24.indexOf(e);
}
function fi(n24, e) {
  return n24.charCodeAt(e) | 0;
}
function Yh(n24, e, t) {
  return n24.slice(e, t);
}
function Hs(n24) {
  return n24.length;
}
function qM(n24) {
  return n24.length;
}
function cm(n24, e) {
  return e.push(n24), n24;
}
function MF(n24, e) {
  return n24.map(e).join("");
}
var G0 = 1, Vc = 1, y3 = 0, ur = 0, Bn = 0, rf = "";
function W0(n24, e, t, i, r, s, o) {
  return { value: n24, root: e, parent: t, type: i, props: r, children: s, line: G0, column: Vc, length: o, return: "" };
}
function Hf(n24, e) {
  return yF(W0("", null, null, "", null, null, 0), n24, { length: -n24.length }, e);
}
function wF() {
  return Bn;
}
function EF() {
  return Bn = ur > 0 ? fi(rf, --ur) : 0, Vc--, Bn === 10 && (Vc = 1, G0--), Bn;
}
function Cr() {
  return Bn = ur < y3 ? fi(rf, ur++) : 0, Vc++, Bn === 10 && (Vc = 1, G0++), Bn;
}
function Js() {
  return fi(rf, ur);
}
function xg() {
  return ur;
}
function Id(n24, e) {
  return Yh(rf, n24, e);
}
function qh(n24) {
  switch (n24) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function x3(n24) {
  return G0 = Vc = 1, y3 = Hs(rf = n24), ur = 0, [];
}
function S3(n24) {
  return rf = "", n24;
}
function Sg(n24) {
  return v3(Id(ur - 1, D1(n24 === 91 ? n24 + 2 : n24 === 40 ? n24 + 1 : n24)));
}
function TF(n24) {
  for (; (Bn = Js()) && Bn < 33; ) Cr();
  return qh(n24) > 2 || qh(Bn) > 3 ? "" : " ";
}
function AF(n24, e) {
  for (; --e && Cr() && !(Bn < 48 || Bn > 102 || Bn > 57 && Bn < 65 || Bn > 70 && Bn < 97); ) ;
  return Id(n24, xg() + (e < 6 && Js() == 32 && Cr() == 32));
}
function D1(n24) {
  for (; Cr(); ) switch (Bn) {
    case n24:
      return ur;
    case 34:
    case 39:
      n24 !== 34 && n24 !== 39 && D1(Bn);
      break;
    case 40:
      n24 === 41 && D1(n24);
      break;
    case 92:
      Cr();
      break;
  }
  return ur;
}
function bF(n24, e) {
  for (; Cr() && n24 + Bn !== 57; ) if (n24 + Bn === 84 && Js() === 47) break;
  return "/*" + Id(e, ur - 1) + "*" + H0(n24 === 47 ? n24 : Cr());
}
function CF(n24) {
  for (; !qh(Js()); ) Cr();
  return Id(n24, ur);
}
function RF(n24) {
  return S3(Mg("", null, null, null, [""], n24 = x3(n24), 0, [0], n24));
}
function Mg(n24, e, t, i, r, s, o, a, l) {
  for (var f = 0, h = 0, d = o, p = 0, g = 0, v = 0, S = 1, M = 1, m = 1, w = 0, E = "", A = r, P = s, R = i, L = E; M; ) switch (v = w, w = Cr()) {
    case 40:
      if (v != 108 && fi(L, d - 1) == 58) {
        N1(L += Ft(Sg(w), "&", "&\f"), "&\f") != -1 && (m = -1);
        break;
      }
    case 34:
    case 39:
    case 91:
      L += Sg(w);
      break;
    case 9:
    case 10:
    case 13:
    case 32:
      L += TF(v);
      break;
    case 92:
      L += AF(xg() - 1, 7);
      continue;
    case 47:
      switch (Js()) {
        case 42:
        case 47:
          cm(PF(bF(Cr(), xg()), e, t), l);
          break;
        default:
          L += "/";
      }
      break;
    case 123 * S:
      a[f++] = Hs(L) * m;
    case 125 * S:
    case 59:
    case 0:
      switch (w) {
        case 0:
        case 125:
          M = 0;
        case 59 + h:
          m == -1 && (L = Ft(L, /\f/g, "")), g > 0 && Hs(L) - d && cm(g > 32 ? db(L + ";", i, t, d - 1) : db(Ft(L, " ", "") + ";", i, t, d - 2), l);
          break;
        case 59:
          L += ";";
        default:
          if (cm(R = hb(L, e, t, f, h, r, a, E, A = [], P = [], d), s), w === 123) if (h === 0) Mg(L, e, R, R, A, s, d, a, P);
          else switch (p === 99 && fi(L, 3) === 110 ? 100 : p) {
            case 100:
            case 108:
            case 109:
            case 115:
              Mg(n24, R, R, i && cm(hb(n24, R, R, 0, 0, r, a, E, r, A = [], d), P), r, P, d, a, i ? A : P);
              break;
            default:
              Mg(L, R, R, R, [""], P, 0, a, P);
          }
      }
      f = h = g = 0, S = m = 1, E = L = "", d = o;
      break;
    case 58:
      d = 1 + Hs(L), g = v;
    default:
      if (S < 1) {
        if (w == 123) --S;
        else if (w == 125 && S++ == 0 && EF() == 125) continue;
      }
      switch (L += H0(w), w * S) {
        case 38:
          m = h > 0 ? 1 : (L += "\f", -1);
          break;
        case 44:
          a[f++] = (Hs(L) - 1) * m, m = 1;
          break;
        case 64:
          Js() === 45 && (L += Sg(Cr())), p = Js(), h = d = Hs(E = L += CF(xg())), w++;
          break;
        case 45:
          v === 45 && Hs(L) == 2 && (S = 0);
      }
  }
  return s;
}
function hb(n24, e, t, i, r, s, o, a, l, f, h) {
  for (var d = r - 1, p = r === 0 ? s : [""], g = qM(p), v = 0, S = 0, M = 0; v < i; ++v) for (var m = 0, w = Yh(n24, d + 1, d = vF(S = o[v])), E = n24; m < g; ++m) (E = v3(S > 0 ? p[m] + " " + w : Ft(w, /&\f/g, p[m]))) && (l[M++] = E);
  return W0(n24, e, t, r === 0 ? $M : a, l, f, h);
}
function PF(n24, e, t) {
  return W0(n24, e, t, g3, H0(wF()), Yh(n24, 2, -2), 0);
}
function db(n24, e, t, i) {
  return W0(n24, e, t, YM, Yh(n24, 0, i), Yh(n24, i + 1, -1), i);
}
function Cc(n24, e) {
  for (var t = "", i = qM(n24), r = 0; r < i; r++) t += e(n24[r], r, n24, e) || "";
  return t;
}
function LF(n24, e, t, i) {
  switch (n24.type) {
    case _F:
      if (n24.children.length) break;
    case gF:
    case YM:
      return n24.return = n24.return || n24.value;
    case g3:
      return "";
    case _3:
      return n24.return = n24.value + "{" + Cc(n24.children, i) + "}";
    case $M:
      n24.value = n24.props.join(",");
  }
  return Hs(t = Cc(n24.children, i)) ? n24.return = n24.value + "{" + t + "}" : "";
}
function IF(n24) {
  var e = qM(n24);
  return function(t, i, r, s) {
    for (var o = "", a = 0; a < e; a++) o += n24[a](t, i, r, s) || "";
    return o;
  };
}
function NF(n24) {
  return function(e) {
    e.root || (e = e.return) && n24(e);
  };
}
function M3(n24) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(t) {
    return e[t] === void 0 && (e[t] = n24(t)), e[t];
  };
}
var DF = function(e, t, i) {
  for (var r = 0, s = 0; r = s, s = Js(), r === 38 && s === 12 && (t[i] = 1), !qh(s); ) Cr();
  return Id(e, ur);
}, OF = function(e, t) {
  var i = -1, r = 44;
  do
    switch (qh(r)) {
      case 0:
        r === 38 && Js() === 12 && (t[i] = 1), e[i] += DF(ur - 1, t, i);
        break;
      case 2:
        e[i] += Sg(r);
        break;
      case 4:
        if (r === 44) {
          e[++i] = Js() === 58 ? "&\f" : "", t[i] = e[i].length;
          break;
        }
      default:
        e[i] += H0(r);
    }
  while (r = Cr());
  return e;
}, UF = function(e, t) {
  return S3(OF(x3(e), t));
}, pb = /* @__PURE__ */ new WeakMap(), kF = function(e) {
  if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
    for (var t = e.value, i = e.parent, r = e.column === i.column && e.line === i.line; i.type !== "rule"; ) if (i = i.parent, !i) return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !pb.get(i)) && !r) {
      pb.set(e, true);
      for (var s = [], o = UF(t, s), a = i.props, l = 0, f = 0; l < o.length; l++) for (var h = 0; h < a.length; h++, f++) e.props[f] = s[l] ? o[l].replace(/&\f/g, a[h]) : a[h] + " " + o[l];
    }
  }
}, FF = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    t.charCodeAt(0) === 108 && t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
};
function w3(n24, e) {
  switch (xF(n24, e)) {
    case 5103:
      return kt + "print-" + n24 + n24;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return kt + n24 + n24;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return kt + n24 + a0 + n24 + Ei + n24 + n24;
    case 6828:
    case 4268:
      return kt + n24 + Ei + n24 + n24;
    case 6165:
      return kt + n24 + Ei + "flex-" + n24 + n24;
    case 5187:
      return kt + n24 + Ft(n24, /(\w+).+(:[^]+)/, kt + "box-$1$2" + Ei + "flex-$1$2") + n24;
    case 5443:
      return kt + n24 + Ei + "flex-item-" + Ft(n24, /flex-|-self/, "") + n24;
    case 4675:
      return kt + n24 + Ei + "flex-line-pack" + Ft(n24, /align-content|flex-|-self/, "") + n24;
    case 5548:
      return kt + n24 + Ei + Ft(n24, "shrink", "negative") + n24;
    case 5292:
      return kt + n24 + Ei + Ft(n24, "basis", "preferred-size") + n24;
    case 6060:
      return kt + "box-" + Ft(n24, "-grow", "") + kt + n24 + Ei + Ft(n24, "grow", "positive") + n24;
    case 4554:
      return kt + Ft(n24, /([^-])(transform)/g, "$1" + kt + "$2") + n24;
    case 6187:
      return Ft(Ft(Ft(n24, /(zoom-|grab)/, kt + "$1"), /(image-set)/, kt + "$1"), n24, "") + n24;
    case 5495:
    case 3959:
      return Ft(n24, /(image-set\([^]*)/, kt + "$1$`$1");
    case 4968:
      return Ft(Ft(n24, /(.+:)(flex-)?(.*)/, kt + "box-pack:$3" + Ei + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + kt + n24 + n24;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return Ft(n24, /(.+)-inline(.+)/, kt + "$1$2") + n24;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Hs(n24) - 1 - e > 6) switch (fi(n24, e + 1)) {
        case 109:
          if (fi(n24, e + 4) !== 45) break;
        case 102:
          return Ft(n24, /(.+:)(.+)-([^]+)/, "$1" + kt + "$2-$3$1" + a0 + (fi(n24, e + 3) == 108 ? "$3" : "$2-$3")) + n24;
        case 115:
          return ~N1(n24, "stretch") ? w3(Ft(n24, "stretch", "fill-available"), e) + n24 : n24;
      }
      break;
    case 4949:
      if (fi(n24, e + 1) !== 115) break;
    case 6444:
      switch (fi(n24, Hs(n24) - 3 - (~N1(n24, "!important") && 10))) {
        case 107:
          return Ft(n24, ":", ":" + kt) + n24;
        case 101:
          return Ft(n24, /(.+:)([^;!]+)(;|!.+)?/, "$1" + kt + (fi(n24, 14) === 45 ? "inline-" : "") + "box$3$1" + kt + "$2$3$1" + Ei + "$2box$3") + n24;
      }
      break;
    case 5936:
      switch (fi(n24, e + 11)) {
        case 114:
          return kt + n24 + Ei + Ft(n24, /[svh]\w+-[tblr]{2}/, "tb") + n24;
        case 108:
          return kt + n24 + Ei + Ft(n24, /[svh]\w+-[tblr]{2}/, "tb-rl") + n24;
        case 45:
          return kt + n24 + Ei + Ft(n24, /[svh]\w+-[tblr]{2}/, "lr") + n24;
      }
      return kt + n24 + Ei + n24 + n24;
  }
  return n24;
}
var zF = function(e, t, i, r) {
  if (e.length > -1 && !e.return) switch (e.type) {
    case YM:
      e.return = w3(e.value, e.length);
      break;
    case _3:
      return Cc([Hf(e, { value: Ft(e.value, "@", "@" + kt) })], r);
    case $M:
      if (e.length) return MF(e.props, function(s) {
        switch (SF(s, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return Cc([Hf(e, { props: [Ft(s, /:(read-\w+)/, ":" + a0 + "$1")] })], r);
          case "::placeholder":
            return Cc([Hf(e, { props: [Ft(s, /:(plac\w+)/, ":" + kt + "input-$1")] }), Hf(e, { props: [Ft(s, /:(plac\w+)/, ":" + a0 + "$1")] }), Hf(e, { props: [Ft(s, /:(plac\w+)/, Ei + "input-$1")] })], r);
        }
        return "";
      });
  }
}, BF = [zF], E3 = function(e) {
  var t = e.key;
  if (t === "css") {
    var i = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(i, function(S) {
      var M = S.getAttribute("data-emotion");
      M.indexOf(" ") !== -1 && (document.head.appendChild(S), S.setAttribute("data-s", ""));
    });
  }
  var r = e.stylisPlugins || BF, s = {}, o, a = [];
  o = e.container || document.head, Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + t + ' "]'), function(S) {
    for (var M = S.getAttribute("data-emotion").split(" "), m = 1; m < M.length; m++) s[M[m]] = true;
    a.push(S);
  });
  var l, f = [kF, FF];
  {
    var h, d = [LF, NF(function(S) {
      h.insert(S);
    })], p = IF(f.concat(r, d)), g = function(M) {
      return Cc(RF(M), p);
    };
    l = function(M, m, w, E) {
      h = w, g(M ? M + "{" + m.styles + "}" : m.styles), E && (v.inserted[m.name] = true);
    };
  }
  var v = { key: t, sheet: new mF({ key: t, container: o, nonce: e.nonce, speedy: e.speedy, prepend: e.prepend, insertionPoint: e.insertionPoint }), nonce: e.nonce, inserted: s, registered: {}, insert: l };
  return v.sheet.hydrate(a), v;
}, T3 = { exports: {} }, Xt = {};
/** @license React v16.13.1
* react-is.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var si = typeof Symbol == "function" && Symbol.for, KM = si ? Symbol.for("react.element") : 60103, ZM = si ? Symbol.for("react.portal") : 60106, X0 = si ? Symbol.for("react.fragment") : 60107, j0 = si ? Symbol.for("react.strict_mode") : 60108, $0 = si ? Symbol.for("react.profiler") : 60114, Y0 = si ? Symbol.for("react.provider") : 60109, q0 = si ? Symbol.for("react.context") : 60110, JM = si ? Symbol.for("react.async_mode") : 60111, K0 = si ? Symbol.for("react.concurrent_mode") : 60111, Z0 = si ? Symbol.for("react.forward_ref") : 60112, J0 = si ? Symbol.for("react.suspense") : 60113, VF = si ? Symbol.for("react.suspense_list") : 60120, Q0 = si ? Symbol.for("react.memo") : 60115, e_ = si ? Symbol.for("react.lazy") : 60116, HF = si ? Symbol.for("react.block") : 60121, GF = si ? Symbol.for("react.fundamental") : 60117, WF = si ? Symbol.for("react.responder") : 60118, XF = si ? Symbol.for("react.scope") : 60119;
function Ur(n24) {
  if (typeof n24 == "object" && n24 !== null) {
    var e = n24.$$typeof;
    switch (e) {
      case KM:
        switch (n24 = n24.type, n24) {
          case JM:
          case K0:
          case X0:
          case $0:
          case j0:
          case J0:
            return n24;
          default:
            switch (n24 = n24 && n24.$$typeof, n24) {
              case q0:
              case Z0:
              case e_:
              case Q0:
              case Y0:
                return n24;
              default:
                return e;
            }
        }
      case ZM:
        return e;
    }
  }
}
function A3(n24) {
  return Ur(n24) === K0;
}
Xt.AsyncMode = JM;
Xt.ConcurrentMode = K0;
Xt.ContextConsumer = q0;
Xt.ContextProvider = Y0;
Xt.Element = KM;
Xt.ForwardRef = Z0;
Xt.Fragment = X0;
Xt.Lazy = e_;
Xt.Memo = Q0;
Xt.Portal = ZM;
Xt.Profiler = $0;
Xt.StrictMode = j0;
Xt.Suspense = J0;
Xt.isAsyncMode = function(n24) {
  return A3(n24) || Ur(n24) === JM;
};
Xt.isConcurrentMode = A3;
Xt.isContextConsumer = function(n24) {
  return Ur(n24) === q0;
};
Xt.isContextProvider = function(n24) {
  return Ur(n24) === Y0;
};
Xt.isElement = function(n24) {
  return typeof n24 == "object" && n24 !== null && n24.$$typeof === KM;
};
Xt.isForwardRef = function(n24) {
  return Ur(n24) === Z0;
};
Xt.isFragment = function(n24) {
  return Ur(n24) === X0;
};
Xt.isLazy = function(n24) {
  return Ur(n24) === e_;
};
Xt.isMemo = function(n24) {
  return Ur(n24) === Q0;
};
Xt.isPortal = function(n24) {
  return Ur(n24) === ZM;
};
Xt.isProfiler = function(n24) {
  return Ur(n24) === $0;
};
Xt.isStrictMode = function(n24) {
  return Ur(n24) === j0;
};
Xt.isSuspense = function(n24) {
  return Ur(n24) === J0;
};
Xt.isValidElementType = function(n24) {
  return typeof n24 == "string" || typeof n24 == "function" || n24 === X0 || n24 === K0 || n24 === $0 || n24 === j0 || n24 === J0 || n24 === VF || typeof n24 == "object" && n24 !== null && (n24.$$typeof === e_ || n24.$$typeof === Q0 || n24.$$typeof === Y0 || n24.$$typeof === q0 || n24.$$typeof === Z0 || n24.$$typeof === GF || n24.$$typeof === WF || n24.$$typeof === XF || n24.$$typeof === HF);
};
Xt.typeOf = Ur;
T3.exports = Xt;
var jF = T3.exports, b3 = jF, $F = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, YF = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, C3 = {};
C3[b3.ForwardRef] = $F;
C3[b3.Memo] = YF;
var qF = true;
function R3(n24, e, t) {
  var i = "";
  return t.split(" ").forEach(function(r) {
    n24[r] !== void 0 ? e.push(n24[r] + ";") : r && (i += r + " ");
  }), i;
}
var QM = function(e, t, i) {
  var r = e.key + "-" + t.name;
  (i === false || qF === false) && e.registered[r] === void 0 && (e.registered[r] = t.styles);
}, ew = function(e, t, i) {
  QM(e, t, i);
  var r = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var s = t;
    do
      e.insert(t === s ? "." + r : "", s, e.sheet, true), s = s.next;
    while (s !== void 0);
  }
};
function KF(n24) {
  for (var e = 0, t, i = 0, r = n24.length; r >= 4; ++i, r -= 4) t = n24.charCodeAt(i) & 255 | (n24.charCodeAt(++i) & 255) << 8 | (n24.charCodeAt(++i) & 255) << 16 | (n24.charCodeAt(++i) & 255) << 24, t = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), t ^= t >>> 24, e = (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16) ^ (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      e ^= (n24.charCodeAt(i + 2) & 255) << 16;
    case 2:
      e ^= (n24.charCodeAt(i + 1) & 255) << 8;
    case 1:
      e ^= n24.charCodeAt(i) & 255, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
var ZF = { animationIterationCount: 1, aspectRatio: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, scale: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, JF = /[A-Z]|^ms/g, QF = /_EMO_([^_]+?)_([^]*?)_EMO_/g, P3 = function(e) {
  return e.charCodeAt(1) === 45;
}, mb = function(e) {
  return e != null && typeof e != "boolean";
}, Oy = M3(function(n24) {
  return P3(n24) ? n24 : n24.replace(JF, "-$&").toLowerCase();
}), gb = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string") return t.replace(QF, function(i, r, s) {
        return Gs = { name: r, styles: s, next: Gs }, r;
      });
  }
  return ZF[e] !== 1 && !P3(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
function Kh(n24, e, t) {
  if (t == null) return "";
  var i = t;
  if (i.__emotion_styles !== void 0) return i;
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      var r = t;
      if (r.anim === 1) return Gs = { name: r.name, styles: r.styles, next: Gs }, r.name;
      var s = t;
      if (s.styles !== void 0) {
        var o = s.next;
        if (o !== void 0) for (; o !== void 0; ) Gs = { name: o.name, styles: o.styles, next: Gs }, o = o.next;
        var a = s.styles + ";";
        return a;
      }
      return ez(n24, e, t);
    }
    case "function": {
      if (n24 !== void 0) {
        var l = Gs, f = t(n24);
        return Gs = l, Kh(n24, e, f);
      }
      break;
    }
  }
  var h = t;
  if (e == null) return h;
  var d = e[h];
  return d !== void 0 ? d : h;
}
function ez(n24, e, t) {
  var i = "";
  if (Array.isArray(t)) for (var r = 0; r < t.length; r++) i += Kh(n24, e, t[r]) + ";";
  else for (var s in t) {
    var o = t[s];
    if (typeof o != "object") {
      var a = o;
      e != null && e[a] !== void 0 ? i += s + "{" + e[a] + "}" : mb(a) && (i += Oy(s) + ":" + gb(s, a) + ";");
    } else if (Array.isArray(o) && typeof o[0] == "string" && (e == null || e[o[0]] === void 0)) for (var l = 0; l < o.length; l++) mb(o[l]) && (i += Oy(s) + ":" + gb(s, o[l]) + ";");
    else {
      var f = Kh(n24, e, o);
      switch (s) {
        case "animation":
        case "animationName": {
          i += Oy(s) + ":" + f + ";";
          break;
        }
        default:
          i += s + "{" + f + "}";
      }
    }
  }
  return i;
}
var _b = /label:\s*([^\s;{]+)\s*(;|$)/g, Gs;
function t_(n24, e, t) {
  if (n24.length === 1 && typeof n24[0] == "object" && n24[0] !== null && n24[0].styles !== void 0) return n24[0];
  var i = true, r = "";
  Gs = void 0;
  var s = n24[0];
  if (s == null || s.raw === void 0) i = false, r += Kh(t, e, s);
  else {
    var o = s;
    r += o[0];
  }
  for (var a = 1; a < n24.length; a++) if (r += Kh(t, e, n24[a]), i) {
    var l = s;
    r += l[a];
  }
  _b.lastIndex = 0;
  for (var f = "", h; (h = _b.exec(r)) !== null; ) f += "-" + h[1];
  var d = KF(r) + f;
  return { name: d, styles: r, next: Gs };
}
var tz = function(e) {
  return e();
}, L3 = sA.useInsertionEffect ? sA.useInsertionEffect : false, I3 = L3 || tz, vb = L3 || ne.useLayoutEffect, N3 = ne.createContext(typeof HTMLElement < "u" ? E3({ key: "css" }) : null), nz = N3.Provider, tw = function(e) {
  return ne.forwardRef(function(t, i) {
    var r = ne.useContext(N3);
    return e(t, r, i);
  });
}, sf = ne.createContext({}), nw = {}.hasOwnProperty, O1 = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", iz = function(e, t) {
  var i = {};
  for (var r in t) nw.call(t, r) && (i[r] = t[r]);
  return i[O1] = e, i;
}, rz = function(e) {
  var t = e.cache, i = e.serialized, r = e.isStringTag;
  return QM(t, i, r), I3(function() {
    return ew(t, i, r);
  }), null;
}, sz = tw(function(n24, e, t) {
  var i = n24.css;
  typeof i == "string" && e.registered[i] !== void 0 && (i = e.registered[i]);
  var r = n24[O1], s = [i], o = "";
  typeof n24.className == "string" ? o = R3(e.registered, s, n24.className) : n24.className != null && (o = n24.className + " ");
  var a = t_(s, void 0, ne.useContext(sf));
  o += e.key + "-" + a.name;
  var l = {};
  for (var f in n24) nw.call(n24, f) && f !== "css" && f !== O1 && (l[f] = n24[f]);
  return l.className = o, t && (l.ref = t), ne.createElement(ne.Fragment, null, ne.createElement(rz, { cache: e, serialized: a, isStringTag: typeof r == "string" }), ne.createElement(r, l));
}), oz = sz, Uy = { exports: {} }, yb;
function D3() {
  return yb || (yb = 1, function(n24) {
    function e() {
      return n24.exports = e = Object.assign ? Object.assign.bind() : function(t) {
        for (var i = 1; i < arguments.length; i++) {
          var r = arguments[i];
          for (var s in r) ({}).hasOwnProperty.call(r, s) && (t[s] = r[s]);
        }
        return t;
      }, n24.exports.__esModule = true, n24.exports.default = n24.exports, e.apply(null, arguments);
    }
    n24.exports = e, n24.exports.__esModule = true, n24.exports.default = n24.exports;
  }(Uy)), Uy.exports;
}
D3();
var xb = function(e, t) {
  var i = arguments;
  if (t == null || !nw.call(t, "css")) return ne.createElement.apply(void 0, i);
  var r = i.length, s = new Array(r);
  s[0] = oz, s[1] = iz(e, t);
  for (var o = 2; o < r; o++) s[o] = i[o];
  return ne.createElement.apply(null, s);
};
(function(n24) {
  var e;
  e || (e = n24.JSX || (n24.JSX = {}));
})(xb || (xb = {}));
var az = tw(function(n24, e) {
  var t = n24.styles, i = t_([t], void 0, ne.useContext(sf)), r = ne.useRef();
  return vb(function() {
    var s = e.key + "-global", o = new e.sheet.constructor({ key: s, nonce: e.sheet.nonce, container: e.sheet.container, speedy: e.sheet.isSpeedy }), a = false, l = document.querySelector('style[data-emotion="' + s + " " + i.name + '"]');
    return e.sheet.tags.length && (o.before = e.sheet.tags[0]), l !== null && (a = true, l.setAttribute("data-emotion", s), o.hydrate([l])), r.current = [o, a], function() {
      o.flush();
    };
  }, [e]), vb(function() {
    var s = r.current, o = s[0], a = s[1];
    if (a) {
      s[1] = false;
      return;
    }
    if (i.next !== void 0 && ew(e, i.next, true), o.tags.length) {
      var l = o.tags[o.tags.length - 1].nextElementSibling;
      o.before = l, o.flush();
    }
    e.insert("", i, o, false);
  }, [e, i.name]), null;
});
function O3() {
  for (var n24 = arguments.length, e = new Array(n24), t = 0; t < n24; t++) e[t] = arguments[t];
  return t_(e);
}
function n_() {
  var n24 = O3.apply(void 0, arguments), e = "animation-" + n24.name;
  return { name: e, styles: "@keyframes " + e + "{" + n24.styles + "}", anim: 1, toString: function() {
    return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
  } };
}
var lz = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, uz = M3(function(n24) {
  return lz.test(n24) || n24.charCodeAt(0) === 111 && n24.charCodeAt(1) === 110 && n24.charCodeAt(2) < 91;
}), cz = uz, fz = function(e) {
  return e !== "theme";
}, Sb = function(e) {
  return typeof e == "string" && e.charCodeAt(0) > 96 ? cz : fz;
}, Mb = function(e, t, i) {
  var r;
  if (t) {
    var s = t.shouldForwardProp;
    r = e.__emotion_forwardProp && s ? function(o) {
      return e.__emotion_forwardProp(o) && s(o);
    } : s;
  }
  return typeof r != "function" && i && (r = e.__emotion_forwardProp), r;
}, hz = function(e) {
  var t = e.cache, i = e.serialized, r = e.isStringTag;
  return QM(t, i, r), I3(function() {
    return ew(t, i, r);
  }), null;
}, dz = function n(e, t) {
  var i = e.__emotion_real === e, r = i && e.__emotion_base || e, s, o;
  t !== void 0 && (s = t.label, o = t.target);
  var a = Mb(e, t, i), l = a || Sb(r), f = !l("as");
  return function() {
    var h = arguments, d = i && e.__emotion_styles !== void 0 ? e.__emotion_styles.slice(0) : [];
    if (s !== void 0 && d.push("label:" + s + ";"), h[0] == null || h[0].raw === void 0) d.push.apply(d, h);
    else {
      var p = h[0];
      d.push(p[0]);
      for (var g = h.length, v = 1; v < g; v++) d.push(h[v], p[v]);
    }
    var S = tw(function(M, m, w) {
      var E = f && M.as || r, A = "", P = [], R = M;
      if (M.theme == null) {
        R = {};
        for (var L in M) R[L] = M[L];
        R.theme = ne.useContext(sf);
      }
      typeof M.className == "string" ? A = R3(m.registered, P, M.className) : M.className != null && (A = M.className + " ");
      var D = t_(d.concat(P), m.registered, R);
      A += m.key + "-" + D.name, o !== void 0 && (A += " " + o);
      var F = f && a === void 0 ? Sb(E) : l, C = {};
      for (var N in M) f && N === "as" || F(N) && (C[N] = M[N]);
      return C.className = A, w && (C.ref = w), ne.createElement(ne.Fragment, null, ne.createElement(hz, { cache: m, serialized: D, isStringTag: typeof E == "string" }), ne.createElement(E, C));
    });
    return S.displayName = s !== void 0 ? s : "Styled(" + (typeof r == "string" ? r : r.displayName || r.name || "Component") + ")", S.defaultProps = e.defaultProps, S.__emotion_real = S, S.__emotion_base = r, S.__emotion_styles = d, S.__emotion_forwardProp = a, Object.defineProperty(S, "toString", { value: function() {
      return "." + o;
    } }), S.withComponent = function(M, m) {
      var w = n(M, dt({}, t, m, { shouldForwardProp: Mb(S, m, true) }));
      return w.apply(void 0, d);
    }, S;
  };
}, pz = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], U1 = dz.bind(null);
pz.forEach(function(n24) {
  U1[n24] = U1(n24);
});
let k1;
typeof document == "object" && (k1 = E3({ key: "css", prepend: true }));
function mz(n24) {
  const { injectFirst: e, children: t } = n24;
  return e && k1 ? Be.jsx(nz, { value: k1, children: t }) : t;
}
function gz(n24) {
  return n24 == null || Object.keys(n24).length === 0;
}
function _z(n24) {
  const { styles: e, defaultTheme: t = {} } = n24, i = typeof e == "function" ? (r) => e(gz(r) ? t : r) : e;
  return Be.jsx(az, { styles: i });
}
function U3(n24, e) {
  return U1(n24, e);
}
const vz = (n24, e) => {
  Array.isArray(n24.__emotion_styles) && (n24.__emotion_styles = e(n24.__emotion_styles));
}, yz = Object.freeze(Object.defineProperty({ __proto__: null, GlobalStyles: _z, StyledEngineProvider: mz, ThemeContext: sf, css: O3, default: U3, internal_processStyles: vz, keyframes: n_ }, Symbol.toStringTag, { value: "Module" }));
function da(n24) {
  if (typeof n24 != "object" || n24 === null) return false;
  const e = Object.getPrototypeOf(n24);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n24) && !(Symbol.iterator in n24);
}
function k3(n24) {
  if (ne.isValidElement(n24) || !da(n24)) return n24;
  const e = {};
  return Object.keys(n24).forEach((t) => {
    e[t] = k3(n24[t]);
  }), e;
}
function Qs(n24, e, t = { clone: true }) {
  const i = t.clone ? dt({}, n24) : n24;
  return da(n24) && da(e) && Object.keys(e).forEach((r) => {
    ne.isValidElement(e[r]) ? i[r] = e[r] : da(e[r]) && Object.prototype.hasOwnProperty.call(n24, r) && da(n24[r]) ? i[r] = Qs(n24[r], e[r], t) : t.clone ? i[r] = da(e[r]) ? k3(e[r]) : e[r] : i[r] = e[r];
  }), i;
}
const xz = Object.freeze(Object.defineProperty({ __proto__: null, default: Qs, isPlainObject: da }, Symbol.toStringTag, { value: "Module" })), Sz = ["values", "unit", "step"], Mz = (n24) => {
  const e = Object.keys(n24).map((t) => ({ key: t, val: n24[t] })) || [];
  return e.sort((t, i) => t.val - i.val), e.reduce((t, i) => dt({}, t, { [i.key]: i.val }), {});
};
function F3(n24) {
  const { values: e = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, unit: t = "px", step: i = 5 } = n24, r = Xi(n24, Sz), s = Mz(e), o = Object.keys(s);
  function a(p) {
    return `@media (min-width:${typeof e[p] == "number" ? e[p] : p}${t})`;
  }
  function l(p) {
    return `@media (max-width:${(typeof e[p] == "number" ? e[p] : p) - i / 100}${t})`;
  }
  function f(p, g) {
    const v = o.indexOf(g);
    return `@media (min-width:${typeof e[p] == "number" ? e[p] : p}${t}) and (max-width:${(v !== -1 && typeof e[o[v]] == "number" ? e[o[v]] : g) - i / 100}${t})`;
  }
  function h(p) {
    return o.indexOf(p) + 1 < o.length ? f(p, o[o.indexOf(p) + 1]) : a(p);
  }
  function d(p) {
    const g = o.indexOf(p);
    return g === 0 ? a(o[1]) : g === o.length - 1 ? l(o[g]) : f(p, o[o.indexOf(p) + 1]).replace("@media", "@media not all and");
  }
  return dt({ keys: o, values: s, up: a, down: l, between: f, only: h, not: d, unit: t }, r);
}
const wz = { borderRadius: 4 };
function Mh(n24, e) {
  return e ? Qs(n24, e, { clone: false }) : n24;
}
const iw = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 }, wb = { keys: ["xs", "sm", "md", "lg", "xl"], up: (n24) => `@media (min-width:${iw[n24]}px)` };
function Uo(n24, e, t) {
  const i = n24.theme || {};
  if (Array.isArray(e)) {
    const s = i.breakpoints || wb;
    return e.reduce((o, a, l) => (o[s.up(s.keys[l])] = t(e[l]), o), {});
  }
  if (typeof e == "object") {
    const s = i.breakpoints || wb;
    return Object.keys(e).reduce((o, a) => {
      if (Object.keys(s.values || iw).indexOf(a) !== -1) {
        const l = s.up(a);
        o[l] = t(e[a], a);
      } else {
        const l = a;
        o[l] = e[l];
      }
      return o;
    }, {});
  }
  return t(e);
}
function Ez(n24 = {}) {
  var e;
  return ((e = n24.keys) == null ? void 0 : e.reduce((i, r) => {
    const s = n24.up(r);
    return i[s] = {}, i;
  }, {})) || {};
}
function Tz(n24, e) {
  return n24.reduce((t, i) => {
    const r = t[i];
    return (!r || Object.keys(r).length === 0) && delete t[i], t;
  }, e);
}
function Nd(n24) {
  if (typeof n24 != "string") throw new Error(ql(7));
  return n24.charAt(0).toUpperCase() + n24.slice(1);
}
const Az = Object.freeze(Object.defineProperty({ __proto__: null, default: Nd }, Symbol.toStringTag, { value: "Module" }));
function i_(n24, e, t = true) {
  if (!e || typeof e != "string") return null;
  if (n24 && n24.vars && t) {
    const i = `vars.${e}`.split(".").reduce((r, s) => r && r[s] ? r[s] : null, n24);
    if (i != null) return i;
  }
  return e.split(".").reduce((i, r) => i && i[r] != null ? i[r] : null, n24);
}
function l0(n24, e, t, i = t) {
  let r;
  return typeof n24 == "function" ? r = n24(t) : Array.isArray(n24) ? r = n24[t] || i : r = i_(n24, t) || i, e && (r = e(r, i, n24)), r;
}
function In(n24) {
  const { prop: e, cssProperty: t = n24.prop, themeKey: i, transform: r } = n24, s = (o) => {
    if (o[e] == null) return null;
    const a = o[e], l = o.theme, f = i_(l, i) || {};
    return Uo(o, a, (d) => {
      let p = l0(f, r, d);
      return d === p && typeof d == "string" && (p = l0(f, r, `${e}${d === "default" ? "" : Nd(d)}`, d)), t === false ? p : { [t]: p };
    });
  };
  return s.propTypes = {}, s.filterProps = [e], s;
}
function bz(n24) {
  const e = {};
  return (t) => (e[t] === void 0 && (e[t] = n24(t)), e[t]);
}
const Cz = { m: "margin", p: "padding" }, Rz = { t: "Top", r: "Right", b: "Bottom", l: "Left", x: ["Left", "Right"], y: ["Top", "Bottom"] }, Eb = { marginX: "mx", marginY: "my", paddingX: "px", paddingY: "py" }, Pz = bz((n24) => {
  if (n24.length > 2) if (Eb[n24]) n24 = Eb[n24];
  else return [n24];
  const [e, t] = n24.split(""), i = Cz[e], r = Rz[t] || "";
  return Array.isArray(r) ? r.map((s) => i + s) : [i + r];
}), rw = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"], sw = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...rw, ...sw];
function Dd(n24, e, t, i) {
  var r;
  const s = (r = i_(n24, e, false)) != null ? r : t;
  return typeof s == "number" ? (o) => typeof o == "string" ? o : s * o : Array.isArray(s) ? (o) => typeof o == "string" ? o : s[o] : typeof s == "function" ? s : () => {
  };
}
function z3(n24) {
  return Dd(n24, "spacing", 8);
}
function Od(n24, e) {
  if (typeof e == "string" || e == null) return e;
  const t = Math.abs(e), i = n24(t);
  return e >= 0 ? i : typeof i == "number" ? -i : `-${i}`;
}
function Lz(n24, e) {
  return (t) => n24.reduce((i, r) => (i[r] = Od(e, t), i), {});
}
function Iz(n24, e, t, i) {
  if (e.indexOf(t) === -1) return null;
  const r = Pz(t), s = Lz(r, i), o = n24[t];
  return Uo(n24, o, s);
}
function B3(n24, e) {
  const t = z3(n24.theme);
  return Object.keys(n24).map((i) => Iz(n24, e, i, t)).reduce(Mh, {});
}
function xn(n24) {
  return B3(n24, rw);
}
xn.propTypes = {};
xn.filterProps = rw;
function Sn(n24) {
  return B3(n24, sw);
}
Sn.propTypes = {};
Sn.filterProps = sw;
function Nz(n24 = 8) {
  if (n24.mui) return n24;
  const e = z3({ spacing: n24 }), t = (...i) => (i.length === 0 ? [1] : i).map((s) => {
    const o = e(s);
    return typeof o == "number" ? `${o}px` : o;
  }).join(" ");
  return t.mui = true, t;
}
function r_(...n24) {
  const e = n24.reduce((i, r) => (r.filterProps.forEach((s) => {
    i[s] = r;
  }), i), {}), t = (i) => Object.keys(i).reduce((r, s) => e[s] ? Mh(r, e[s](i)) : r, {});
  return t.propTypes = {}, t.filterProps = n24.reduce((i, r) => i.concat(r.filterProps), []), t;
}
function ts(n24) {
  return typeof n24 != "number" ? n24 : `${n24}px solid`;
}
function us(n24, e) {
  return In({ prop: n24, themeKey: "borders", transform: e });
}
const Dz = us("border", ts), Oz = us("borderTop", ts), Uz = us("borderRight", ts), kz = us("borderBottom", ts), Fz = us("borderLeft", ts), zz = us("borderColor"), Bz = us("borderTopColor"), Vz = us("borderRightColor"), Hz = us("borderBottomColor"), Gz = us("borderLeftColor"), Wz = us("outline", ts), Xz = us("outlineColor"), s_ = (n24) => {
  if (n24.borderRadius !== void 0 && n24.borderRadius !== null) {
    const e = Dd(n24.theme, "shape.borderRadius", 4), t = (i) => ({ borderRadius: Od(e, i) });
    return Uo(n24, n24.borderRadius, t);
  }
  return null;
};
s_.propTypes = {};
s_.filterProps = ["borderRadius"];
r_(Dz, Oz, Uz, kz, Fz, zz, Bz, Vz, Hz, Gz, s_, Wz, Xz);
const o_ = (n24) => {
  if (n24.gap !== void 0 && n24.gap !== null) {
    const e = Dd(n24.theme, "spacing", 8), t = (i) => ({ gap: Od(e, i) });
    return Uo(n24, n24.gap, t);
  }
  return null;
};
o_.propTypes = {};
o_.filterProps = ["gap"];
const a_ = (n24) => {
  if (n24.columnGap !== void 0 && n24.columnGap !== null) {
    const e = Dd(n24.theme, "spacing", 8), t = (i) => ({ columnGap: Od(e, i) });
    return Uo(n24, n24.columnGap, t);
  }
  return null;
};
a_.propTypes = {};
a_.filterProps = ["columnGap"];
const l_ = (n24) => {
  if (n24.rowGap !== void 0 && n24.rowGap !== null) {
    const e = Dd(n24.theme, "spacing", 8), t = (i) => ({ rowGap: Od(e, i) });
    return Uo(n24, n24.rowGap, t);
  }
  return null;
};
l_.propTypes = {};
l_.filterProps = ["rowGap"];
const jz = In({ prop: "gridColumn" }), $z = In({ prop: "gridRow" }), Yz = In({ prop: "gridAutoFlow" }), qz = In({ prop: "gridAutoColumns" }), Kz = In({ prop: "gridAutoRows" }), Zz = In({ prop: "gridTemplateColumns" }), Jz = In({ prop: "gridTemplateRows" }), Qz = In({ prop: "gridTemplateAreas" }), eB = In({ prop: "gridArea" });
r_(o_, a_, l_, jz, $z, Yz, qz, Kz, Zz, Jz, Qz, eB);
function Rc(n24, e) {
  return e === "grey" ? e : n24;
}
const tB = In({ prop: "color", themeKey: "palette", transform: Rc }), nB = In({ prop: "bgcolor", cssProperty: "backgroundColor", themeKey: "palette", transform: Rc }), iB = In({ prop: "backgroundColor", themeKey: "palette", transform: Rc });
r_(tB, nB, iB);
function Sr(n24) {
  return n24 <= 1 && n24 !== 0 ? `${n24 * 100}%` : n24;
}
const rB = In({ prop: "width", transform: Sr }), ow = (n24) => {
  if (n24.maxWidth !== void 0 && n24.maxWidth !== null) {
    const e = (t) => {
      var i, r;
      const s = ((i = n24.theme) == null || (i = i.breakpoints) == null || (i = i.values) == null ? void 0 : i[t]) || iw[t];
      return s ? ((r = n24.theme) == null || (r = r.breakpoints) == null ? void 0 : r.unit) !== "px" ? { maxWidth: `${s}${n24.theme.breakpoints.unit}` } : { maxWidth: s } : { maxWidth: Sr(t) };
    };
    return Uo(n24, n24.maxWidth, e);
  }
  return null;
};
ow.filterProps = ["maxWidth"];
const sB = In({ prop: "minWidth", transform: Sr }), oB = In({ prop: "height", transform: Sr }), aB = In({ prop: "maxHeight", transform: Sr }), lB = In({ prop: "minHeight", transform: Sr });
In({ prop: "size", cssProperty: "width", transform: Sr });
In({ prop: "size", cssProperty: "height", transform: Sr });
const uB = In({ prop: "boxSizing" });
r_(rB, ow, sB, oB, aB, lB, uB);
const Ud = { border: { themeKey: "borders", transform: ts }, borderTop: { themeKey: "borders", transform: ts }, borderRight: { themeKey: "borders", transform: ts }, borderBottom: { themeKey: "borders", transform: ts }, borderLeft: { themeKey: "borders", transform: ts }, borderColor: { themeKey: "palette" }, borderTopColor: { themeKey: "palette" }, borderRightColor: { themeKey: "palette" }, borderBottomColor: { themeKey: "palette" }, borderLeftColor: { themeKey: "palette" }, outline: { themeKey: "borders", transform: ts }, outlineColor: { themeKey: "palette" }, borderRadius: { themeKey: "shape.borderRadius", style: s_ }, color: { themeKey: "palette", transform: Rc }, bgcolor: { themeKey: "palette", cssProperty: "backgroundColor", transform: Rc }, backgroundColor: { themeKey: "palette", transform: Rc }, p: { style: Sn }, pt: { style: Sn }, pr: { style: Sn }, pb: { style: Sn }, pl: { style: Sn }, px: { style: Sn }, py: { style: Sn }, padding: { style: Sn }, paddingTop: { style: Sn }, paddingRight: { style: Sn }, paddingBottom: { style: Sn }, paddingLeft: { style: Sn }, paddingX: { style: Sn }, paddingY: { style: Sn }, paddingInline: { style: Sn }, paddingInlineStart: { style: Sn }, paddingInlineEnd: { style: Sn }, paddingBlock: { style: Sn }, paddingBlockStart: { style: Sn }, paddingBlockEnd: { style: Sn }, m: { style: xn }, mt: { style: xn }, mr: { style: xn }, mb: { style: xn }, ml: { style: xn }, mx: { style: xn }, my: { style: xn }, margin: { style: xn }, marginTop: { style: xn }, marginRight: { style: xn }, marginBottom: { style: xn }, marginLeft: { style: xn }, marginX: { style: xn }, marginY: { style: xn }, marginInline: { style: xn }, marginInlineStart: { style: xn }, marginInlineEnd: { style: xn }, marginBlock: { style: xn }, marginBlockStart: { style: xn }, marginBlockEnd: { style: xn }, displayPrint: { cssProperty: false, transform: (n24) => ({ "@media print": { display: n24 } }) }, display: {}, overflow: {}, textOverflow: {}, visibility: {}, whiteSpace: {}, flexBasis: {}, flexDirection: {}, flexWrap: {}, justifyContent: {}, alignItems: {}, alignContent: {}, order: {}, flex: {}, flexGrow: {}, flexShrink: {}, alignSelf: {}, justifyItems: {}, justifySelf: {}, gap: { style: o_ }, rowGap: { style: l_ }, columnGap: { style: a_ }, gridColumn: {}, gridRow: {}, gridAutoFlow: {}, gridAutoColumns: {}, gridAutoRows: {}, gridTemplateColumns: {}, gridTemplateRows: {}, gridTemplateAreas: {}, gridArea: {}, position: {}, zIndex: { themeKey: "zIndex" }, top: {}, right: {}, bottom: {}, left: {}, boxShadow: { themeKey: "shadows" }, width: { transform: Sr }, maxWidth: { style: ow }, minWidth: { transform: Sr }, height: { transform: Sr }, maxHeight: { transform: Sr }, minHeight: { transform: Sr }, boxSizing: {}, fontFamily: { themeKey: "typography" }, fontSize: { themeKey: "typography" }, fontStyle: { themeKey: "typography" }, fontWeight: { themeKey: "typography" }, letterSpacing: {}, textTransform: {}, lineHeight: {}, textAlign: {}, typography: { cssProperty: false, themeKey: "typography" } };
function cB(...n24) {
  const e = n24.reduce((i, r) => i.concat(Object.keys(r)), []), t = new Set(e);
  return n24.every((i) => t.size === Object.keys(i).length);
}
function fB(n24, e) {
  return typeof n24 == "function" ? n24(e) : n24;
}
function V3() {
  function n24(t, i, r, s) {
    const o = { [t]: i, theme: r }, a = s[t];
    if (!a) return { [t]: i };
    const { cssProperty: l = t, themeKey: f, transform: h, style: d } = a;
    if (i == null) return null;
    if (f === "typography" && i === "inherit") return { [t]: i };
    const p = i_(r, f) || {};
    return d ? d(o) : Uo(o, i, (v) => {
      let S = l0(p, h, v);
      return v === S && typeof v == "string" && (S = l0(p, h, `${t}${v === "default" ? "" : Nd(v)}`, v)), l === false ? S : { [l]: S };
    });
  }
  function e(t) {
    var i;
    const { sx: r, theme: s = {} } = t || {};
    if (!r) return null;
    const o = (i = s.unstable_sxConfig) != null ? i : Ud;
    function a(l) {
      let f = l;
      if (typeof l == "function") f = l(s);
      else if (typeof l != "object") return l;
      if (!f) return null;
      const h = Ez(s.breakpoints), d = Object.keys(h);
      let p = h;
      return Object.keys(f).forEach((g) => {
        const v = fB(f[g], s);
        if (v != null) if (typeof v == "object") if (o[g]) p = Mh(p, n24(g, v, s, o));
        else {
          const S = Uo({ theme: s }, v, (M) => ({ [g]: M }));
          cB(S, v) ? p[g] = e({ sx: v, theme: s }) : p = Mh(p, S);
        }
        else p = Mh(p, n24(g, v, s, o));
      }), Tz(d, p);
    }
    return Array.isArray(r) ? r.map(a) : a(r);
  }
  return e;
}
const kd = V3();
kd.filterProps = ["sx"];
function H3(n24, e) {
  const t = this;
  return t.vars && typeof t.getColorSchemeSelector == "function" ? { [t.getColorSchemeSelector(n24).replace(/(\[[^\]]+\])/, "*:where($1)")]: e } : t.palette.mode === n24 ? e : {};
}
const hB = ["breakpoints", "palette", "spacing", "shape"];
function aw(n24 = {}, ...e) {
  const { breakpoints: t = {}, palette: i = {}, spacing: r, shape: s = {} } = n24, o = Xi(n24, hB), a = F3(t), l = Nz(r);
  let f = Qs({ breakpoints: a, direction: "ltr", components: {}, palette: dt({ mode: "light" }, i), spacing: l, shape: dt({}, wz, s) }, o);
  return f.applyStyles = H3, f = e.reduce((h, d) => Qs(h, d), f), f.unstable_sxConfig = dt({}, Ud, o == null ? void 0 : o.unstable_sxConfig), f.unstable_sx = function(d) {
    return kd({ sx: d, theme: this });
  }, f;
}
const dB = Object.freeze(Object.defineProperty({ __proto__: null, default: aw, private_createBreakpoints: F3, unstable_applyStyles: H3 }, Symbol.toStringTag, { value: "Module" }));
function pB(n24) {
  return Object.keys(n24).length === 0;
}
function G3(n24 = null) {
  const e = ne.useContext(sf);
  return !e || pB(e) ? n24 : e;
}
const mB = aw();
function gB(n24 = mB) {
  return G3(n24);
}
const _B = ["sx"], vB = (n24) => {
  var e, t;
  const i = { systemProps: {}, otherProps: {} }, r = (e = n24 == null || (t = n24.theme) == null ? void 0 : t.unstable_sxConfig) != null ? e : Ud;
  return Object.keys(n24).forEach((s) => {
    r[s] ? i.systemProps[s] = n24[s] : i.otherProps[s] = n24[s];
  }), i;
};
function W3(n24) {
  const { sx: e } = n24, t = Xi(n24, _B), { systemProps: i, otherProps: r } = vB(t);
  let s;
  return Array.isArray(e) ? s = [i, ...e] : typeof e == "function" ? s = (...o) => {
    const a = e(...o);
    return da(a) ? dt({}, i, a) : i;
  } : s = dt({}, i, e), dt({}, r, { sx: s });
}
const yB = Object.freeze(Object.defineProperty({ __proto__: null, default: kd, extendSxProp: W3, unstable_createStyleFunctionSx: V3, unstable_defaultSxConfig: Ud }, Symbol.toStringTag, { value: "Module" })), Tb = (n24) => n24, xB = () => {
  let n24 = Tb;
  return { configure(e) {
    n24 = e;
  }, generate(e) {
    return n24(e);
  }, reset() {
    n24 = Tb;
  } };
}, X3 = xB();
function j3(n24) {
  var e, t, i = "";
  if (typeof n24 == "string" || typeof n24 == "number") i += n24;
  else if (typeof n24 == "object") if (Array.isArray(n24)) {
    var r = n24.length;
    for (e = 0; e < r; e++) n24[e] && (t = j3(n24[e])) && (i && (i += " "), i += t);
  } else for (t in n24) n24[t] && (i && (i += " "), i += t);
  return i;
}
function Zr() {
  for (var n24, e, t = 0, i = "", r = arguments.length; t < r; t++) (n24 = arguments[t]) && (e = j3(n24)) && (i && (i += " "), i += e);
  return i;
}
const SB = ["className", "component"];
function MB(n24 = {}) {
  const { themeId: e, defaultTheme: t, defaultClassName: i = "MuiBox-root", generateClassName: r } = n24, s = U3("div", { shouldForwardProp: (a) => a !== "theme" && a !== "sx" && a !== "as" })(kd);
  return ne.forwardRef(function(l, f) {
    const h = gB(t), d = W3(l), { className: p, component: g = "div" } = d, v = Xi(d, SB);
    return Be.jsx(s, dt({ as: g, ref: f, className: Zr(p, r ? r(i) : i), theme: e && h[e] || h }, v));
  });
}
const wB = { active: "active", checked: "checked", completed: "completed", disabled: "disabled", error: "error", expanded: "expanded", focused: "focused", focusVisible: "focusVisible", open: "open", readOnly: "readOnly", required: "required", selected: "selected" };
function lw(n24, e, t = "Mui") {
  const i = wB[e];
  return i ? `${t}-${i}` : `${X3.generate(n24)}-${e}`;
}
function u_(n24, e, t = "Mui") {
  const i = {};
  return e.forEach((r) => {
    i[r] = lw(n24, r, t);
  }), i;
}
var $3 = { exports: {} }, Kt = {};
/**
* @license React
* react-is.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var uw = Symbol.for("react.transitional.element"), cw = Symbol.for("react.portal"), c_ = Symbol.for("react.fragment"), f_ = Symbol.for("react.strict_mode"), h_ = Symbol.for("react.profiler"), d_ = Symbol.for("react.consumer"), p_ = Symbol.for("react.context"), m_ = Symbol.for("react.forward_ref"), g_ = Symbol.for("react.suspense"), __ = Symbol.for("react.suspense_list"), v_ = Symbol.for("react.memo"), y_ = Symbol.for("react.lazy"), EB = Symbol.for("react.view_transition"), TB = Symbol.for("react.client.reference");
function cs(n24) {
  if (typeof n24 == "object" && n24 !== null) {
    var e = n24.$$typeof;
    switch (e) {
      case uw:
        switch (n24 = n24.type, n24) {
          case c_:
          case h_:
          case f_:
          case g_:
          case __:
          case EB:
            return n24;
          default:
            switch (n24 = n24 && n24.$$typeof, n24) {
              case p_:
              case m_:
              case y_:
              case v_:
                return n24;
              case d_:
                return n24;
              default:
                return e;
            }
        }
      case cw:
        return e;
    }
  }
}
Kt.ContextConsumer = d_;
Kt.ContextProvider = p_;
Kt.Element = uw;
Kt.ForwardRef = m_;
Kt.Fragment = c_;
Kt.Lazy = y_;
Kt.Memo = v_;
Kt.Portal = cw;
Kt.Profiler = h_;
Kt.StrictMode = f_;
Kt.Suspense = g_;
Kt.SuspenseList = __;
Kt.isContextConsumer = function(n24) {
  return cs(n24) === d_;
};
Kt.isContextProvider = function(n24) {
  return cs(n24) === p_;
};
Kt.isElement = function(n24) {
  return typeof n24 == "object" && n24 !== null && n24.$$typeof === uw;
};
Kt.isForwardRef = function(n24) {
  return cs(n24) === m_;
};
Kt.isFragment = function(n24) {
  return cs(n24) === c_;
};
Kt.isLazy = function(n24) {
  return cs(n24) === y_;
};
Kt.isMemo = function(n24) {
  return cs(n24) === v_;
};
Kt.isPortal = function(n24) {
  return cs(n24) === cw;
};
Kt.isProfiler = function(n24) {
  return cs(n24) === h_;
};
Kt.isStrictMode = function(n24) {
  return cs(n24) === f_;
};
Kt.isSuspense = function(n24) {
  return cs(n24) === g_;
};
Kt.isSuspenseList = function(n24) {
  return cs(n24) === __;
};
Kt.isValidElementType = function(n24) {
  return typeof n24 == "string" || typeof n24 == "function" || n24 === c_ || n24 === h_ || n24 === f_ || n24 === g_ || n24 === __ || typeof n24 == "object" && n24 !== null && (n24.$$typeof === y_ || n24.$$typeof === v_ || n24.$$typeof === p_ || n24.$$typeof === d_ || n24.$$typeof === m_ || n24.$$typeof === TB || n24.getModuleId !== void 0);
};
Kt.typeOf = cs;
$3.exports = Kt;
var Ab = $3.exports;
const AB = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;
function Y3(n24) {
  const e = `${n24}`.match(AB);
  return e && e[1] || "";
}
function q3(n24, e = "") {
  return n24.displayName || n24.name || Y3(n24) || e;
}
function bb(n24, e, t) {
  const i = q3(e);
  return n24.displayName || (i !== "" ? `${t}(${i})` : t);
}
function bB(n24) {
  if (n24 != null) {
    if (typeof n24 == "string") return n24;
    if (typeof n24 == "function") return q3(n24, "Component");
    if (typeof n24 == "object") switch (n24.$$typeof) {
      case Ab.ForwardRef:
        return bb(n24, n24.render, "ForwardRef");
      case Ab.Memo:
        return bb(n24, n24.type, "memo");
      default:
        return;
    }
  }
}
const CB = Object.freeze(Object.defineProperty({ __proto__: null, default: bB, getFunctionName: Y3 }, Symbol.toStringTag, { value: "Module" }));
function u0(n24, e) {
  const t = dt({}, e);
  return Object.keys(n24).forEach((i) => {
    if (i.toString().match(/^(components|slots)$/)) t[i] = dt({}, n24[i], t[i]);
    else if (i.toString().match(/^(componentsProps|slotProps)$/)) {
      const r = n24[i] || {}, s = e[i];
      t[i] = {}, !s || !Object.keys(s) ? t[i] = r : !r || !Object.keys(r) ? t[i] = s : (t[i] = dt({}, s), Object.keys(r).forEach((o) => {
        t[i][o] = u0(r[o], s[o]);
      }));
    } else t[i] === void 0 && (t[i] = n24[i]);
  }), t;
}
const RB = typeof window < "u" ? ne.useLayoutEffect : ne.useEffect;
function K3(n24, e = Number.MIN_SAFE_INTEGER, t = Number.MAX_SAFE_INTEGER) {
  return Math.max(e, Math.min(n24, t));
}
const PB = Object.freeze(Object.defineProperty({ __proto__: null, default: K3 }, Symbol.toStringTag, { value: "Module" }));
function LB(n24, e = 0, t = 1) {
  return K3(n24, e, t);
}
function IB(n24) {
  n24 = n24.slice(1);
  const e = new RegExp(`.{1,${n24.length >= 6 ? 2 : 1}}`, "g");
  let t = n24.match(e);
  return t && t[0].length === 1 && (t = t.map((i) => i + i)), t ? `rgb${t.length === 4 ? "a" : ""}(${t.map((i, r) => r < 3 ? parseInt(i, 16) : Math.round(parseInt(i, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function Z3(n24) {
  if (n24.type) return n24;
  if (n24.charAt(0) === "#") return Z3(IB(n24));
  const e = n24.indexOf("("), t = n24.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1) throw new Error(ql(9, n24));
  let i = n24.substring(e + 1, n24.length - 1), r;
  if (t === "color") {
    if (i = i.split(" "), r = i.shift(), i.length === 4 && i[3].charAt(0) === "/" && (i[3] = i[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(r) === -1) throw new Error(ql(10, r));
  } else i = i.split(",");
  return i = i.map((s) => parseFloat(s)), { type: t, values: i, colorSpace: r };
}
function NB(n24) {
  const { type: e, colorSpace: t } = n24;
  let { values: i } = n24;
  return e.indexOf("rgb") !== -1 ? i = i.map((r, s) => s < 3 ? parseInt(r, 10) : r) : e.indexOf("hsl") !== -1 && (i[1] = `${i[1]}%`, i[2] = `${i[2]}%`), e.indexOf("color") !== -1 ? i = `${t} ${i.join(" ")}` : i = `${i.join(", ")}`, `${e}(${i})`;
}
function fm(n24, e) {
  return n24 = Z3(n24), e = LB(e), (n24.type === "rgb" || n24.type === "hsl") && (n24.type += "a"), n24.type === "color" ? n24.values[3] = `/${e}` : n24.values[3] = e, NB(n24);
}
function DB(n24, e) {
  typeof n24 == "function" ? n24(e) : n24 && (n24.current = e);
}
function hm(n24) {
  const e = ne.useRef(n24);
  return RB(() => {
    e.current = n24;
  }), ne.useRef((...t) => (0, e.current)(...t)).current;
}
function Cb(...n24) {
  return ne.useMemo(() => n24.every((e) => e == null) ? null : (e) => {
    n24.forEach((t) => {
      DB(t, e);
    });
  }, n24);
}
const Rb = {};
function OB(n24, e) {
  const t = ne.useRef(Rb);
  return t.current === Rb && (t.current = n24(e)), t;
}
const UB = [];
function kB(n24) {
  ne.useEffect(n24, UB);
}
class x_ {
  constructor() {
    this.currentId = null, this.clear = () => {
      this.currentId !== null && (clearTimeout(this.currentId), this.currentId = null);
    }, this.disposeEffect = () => this.clear;
  }
  static create() {
    return new x_();
  }
  start(e, t) {
    this.clear(), this.currentId = setTimeout(() => {
      this.currentId = null, t();
    }, e);
  }
}
function FB() {
  const n24 = OB(x_.create).current;
  return kB(n24.disposeEffect), n24;
}
let S_ = true, F1 = false;
const zB = new x_(), BB = { text: true, search: true, url: true, tel: true, email: true, password: true, number: true, date: true, month: true, week: true, time: true, datetime: true, "datetime-local": true };
function VB(n24) {
  const { type: e, tagName: t } = n24;
  return !!(t === "INPUT" && BB[e] && !n24.readOnly || t === "TEXTAREA" && !n24.readOnly || n24.isContentEditable);
}
function HB(n24) {
  n24.metaKey || n24.altKey || n24.ctrlKey || (S_ = true);
}
function ky() {
  S_ = false;
}
function GB() {
  this.visibilityState === "hidden" && F1 && (S_ = true);
}
function WB(n24) {
  n24.addEventListener("keydown", HB, true), n24.addEventListener("mousedown", ky, true), n24.addEventListener("pointerdown", ky, true), n24.addEventListener("touchstart", ky, true), n24.addEventListener("visibilitychange", GB, true);
}
function XB(n24) {
  const { target: e } = n24;
  try {
    return e.matches(":focus-visible");
  } catch {
  }
  return S_ || VB(e);
}
function jB() {
  const n24 = ne.useCallback((r) => {
    r != null && WB(r.ownerDocument);
  }, []), e = ne.useRef(false);
  function t() {
    return e.current ? (F1 = true, zB.start(100, () => {
      F1 = false;
    }), e.current = false, true) : false;
  }
  function i(r) {
    return XB(r) ? (e.current = true, true) : false;
  }
  return { isFocusVisibleRef: e, onFocus: i, onBlur: t, ref: n24 };
}
function J3(n24, e, t = void 0) {
  const i = {};
  return Object.keys(n24).forEach((r) => {
    i[r] = n24[r].reduce((s, o) => {
      if (o) {
        const a = e(o);
        a !== "" && s.push(a), t && t[o] && s.push(t[o]);
      }
      return s;
    }, []).join(" ");
  }), i;
}
const Q3 = ne.createContext(null);
function eL() {
  return ne.useContext(Q3);
}
const $B = typeof Symbol == "function" && Symbol.for, YB = $B ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function qB(n24, e) {
  return typeof e == "function" ? e(n24) : dt({}, n24, e);
}
function KB(n24) {
  const { children: e, theme: t } = n24, i = eL(), r = ne.useMemo(() => {
    const s = i === null ? t : qB(i, t);
    return s != null && (s[YB] = i !== null), s;
  }, [t, i]);
  return Be.jsx(Q3.Provider, { value: r, children: e });
}
const ZB = ["value"], JB = ne.createContext();
function QB(n24) {
  let { value: e } = n24, t = Xi(n24, ZB);
  return Be.jsx(JB.Provider, dt({ value: e ?? true }, t));
}
const tL = ne.createContext(void 0);
function e4({ value: n24, children: e }) {
  return Be.jsx(tL.Provider, { value: n24, children: e });
}
function t4(n24) {
  const { theme: e, name: t, props: i } = n24;
  if (!e || !e.components || !e.components[t]) return i;
  const r = e.components[t];
  return r.defaultProps ? u0(r.defaultProps, i) : !r.styleOverrides && !r.variants ? u0(r, i) : i;
}
function n4({ props: n24, name: e }) {
  const t = ne.useContext(tL);
  return t4({ props: n24, name: e, theme: { components: t } });
}
const Pb = {};
function Lb(n24, e, t, i = false) {
  return ne.useMemo(() => {
    const r = n24 && e[n24] || e;
    if (typeof t == "function") {
      const s = t(r), o = n24 ? dt({}, e, { [n24]: s }) : s;
      return i ? () => o : o;
    }
    return n24 ? dt({}, e, { [n24]: t }) : dt({}, e, t);
  }, [n24, e, t, i]);
}
function i4(n24) {
  const { children: e, theme: t, themeId: i } = n24, r = G3(Pb), s = eL() || Pb, o = Lb(i, r, t), a = Lb(i, s, t, true), l = o.direction === "rtl";
  return Be.jsx(KB, { theme: a, children: Be.jsx(sf.Provider, { value: o, children: Be.jsx(QB, { value: l, children: Be.jsx(e4, { value: o == null ? void 0 : o.components, children: e }) }) }) });
}
function r4(n24, e) {
  return dt({ toolbar: { minHeight: 56, [n24.up("xs")]: { "@media (orientation: landscape)": { minHeight: 48 } }, [n24.up("sm")]: { minHeight: 64 } } }, e);
}
var Nn = {}, nL = { exports: {} };
(function(n24) {
  function e(t) {
    return t && t.__esModule ? t : { default: t };
  }
  n24.exports = e, n24.exports.__esModule = true, n24.exports.default = n24.exports;
})(nL);
var iL = nL.exports;
const s4 = za(hF), o4 = za(PB);
var rL = iL;
Object.defineProperty(Nn, "__esModule", { value: true });
Nn.alpha = lL;
Nn.blend = y4;
Nn.colorChannel = void 0;
var a4 = Nn.darken = hw;
Nn.decomposeColor = ls;
Nn.emphasize = uL;
var l4 = Nn.getContrastRatio = p4;
Nn.getLuminance = c0;
Nn.hexToRgb = sL;
Nn.hslToRgb = aL;
var u4 = Nn.lighten = dw;
Nn.private_safeAlpha = m4;
Nn.private_safeColorChannel = void 0;
Nn.private_safeDarken = g4;
Nn.private_safeEmphasize = v4;
Nn.private_safeLighten = _4;
Nn.recomposeColor = of;
Nn.rgbToHex = d4;
var Ib = rL(s4), c4 = rL(o4);
function fw(n24, e = 0, t = 1) {
  return (0, c4.default)(n24, e, t);
}
function sL(n24) {
  n24 = n24.slice(1);
  const e = new RegExp(`.{1,${n24.length >= 6 ? 2 : 1}}`, "g");
  let t = n24.match(e);
  return t && t[0].length === 1 && (t = t.map((i) => i + i)), t ? `rgb${t.length === 4 ? "a" : ""}(${t.map((i, r) => r < 3 ? parseInt(i, 16) : Math.round(parseInt(i, 16) / 255 * 1e3) / 1e3).join(", ")})` : "";
}
function f4(n24) {
  const e = n24.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function ls(n24) {
  if (n24.type) return n24;
  if (n24.charAt(0) === "#") return ls(sL(n24));
  const e = n24.indexOf("("), t = n24.substring(0, e);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(t) === -1) throw new Error((0, Ib.default)(9, n24));
  let i = n24.substring(e + 1, n24.length - 1), r;
  if (t === "color") {
    if (i = i.split(" "), r = i.shift(), i.length === 4 && i[3].charAt(0) === "/" && (i[3] = i[3].slice(1)), ["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(r) === -1) throw new Error((0, Ib.default)(10, r));
  } else i = i.split(",");
  return i = i.map((s) => parseFloat(s)), { type: t, values: i, colorSpace: r };
}
const oL = (n24) => {
  const e = ls(n24);
  return e.values.slice(0, 3).map((t, i) => e.type.indexOf("hsl") !== -1 && i !== 0 ? `${t}%` : t).join(" ");
};
Nn.colorChannel = oL;
const h4 = (n24, e) => {
  try {
    return oL(n24);
  } catch {
    return n24;
  }
};
Nn.private_safeColorChannel = h4;
function of(n24) {
  const { type: e, colorSpace: t } = n24;
  let { values: i } = n24;
  return e.indexOf("rgb") !== -1 ? i = i.map((r, s) => s < 3 ? parseInt(r, 10) : r) : e.indexOf("hsl") !== -1 && (i[1] = `${i[1]}%`, i[2] = `${i[2]}%`), e.indexOf("color") !== -1 ? i = `${t} ${i.join(" ")}` : i = `${i.join(", ")}`, `${e}(${i})`;
}
function d4(n24) {
  if (n24.indexOf("#") === 0) return n24;
  const { values: e } = ls(n24);
  return `#${e.map((t, i) => f4(i === 3 ? Math.round(255 * t) : t)).join("")}`;
}
function aL(n24) {
  n24 = ls(n24);
  const { values: e } = n24, t = e[0], i = e[1] / 100, r = e[2] / 100, s = i * Math.min(r, 1 - r), o = (f, h = (f + t / 30) % 12) => r - s * Math.max(Math.min(h - 3, 9 - h, 1), -1);
  let a = "rgb";
  const l = [Math.round(o(0) * 255), Math.round(o(8) * 255), Math.round(o(4) * 255)];
  return n24.type === "hsla" && (a += "a", l.push(e[3])), of({ type: a, values: l });
}
function c0(n24) {
  n24 = ls(n24);
  let e = n24.type === "hsl" || n24.type === "hsla" ? ls(aL(n24)).values : n24.values;
  return e = e.map((t) => (n24.type !== "color" && (t /= 255), t <= 0.03928 ? t / 12.92 : ((t + 0.055) / 1.055) ** 2.4)), Number((0.2126 * e[0] + 0.7152 * e[1] + 0.0722 * e[2]).toFixed(3));
}
function p4(n24, e) {
  const t = c0(n24), i = c0(e);
  return (Math.max(t, i) + 0.05) / (Math.min(t, i) + 0.05);
}
function lL(n24, e) {
  return n24 = ls(n24), e = fw(e), (n24.type === "rgb" || n24.type === "hsl") && (n24.type += "a"), n24.type === "color" ? n24.values[3] = `/${e}` : n24.values[3] = e, of(n24);
}
function m4(n24, e, t) {
  try {
    return lL(n24, e);
  } catch {
    return n24;
  }
}
function hw(n24, e) {
  if (n24 = ls(n24), e = fw(e), n24.type.indexOf("hsl") !== -1) n24.values[2] *= 1 - e;
  else if (n24.type.indexOf("rgb") !== -1 || n24.type.indexOf("color") !== -1) for (let t = 0; t < 3; t += 1) n24.values[t] *= 1 - e;
  return of(n24);
}
function g4(n24, e, t) {
  try {
    return hw(n24, e);
  } catch {
    return n24;
  }
}
function dw(n24, e) {
  if (n24 = ls(n24), e = fw(e), n24.type.indexOf("hsl") !== -1) n24.values[2] += (100 - n24.values[2]) * e;
  else if (n24.type.indexOf("rgb") !== -1) for (let t = 0; t < 3; t += 1) n24.values[t] += (255 - n24.values[t]) * e;
  else if (n24.type.indexOf("color") !== -1) for (let t = 0; t < 3; t += 1) n24.values[t] += (1 - n24.values[t]) * e;
  return of(n24);
}
function _4(n24, e, t) {
  try {
    return dw(n24, e);
  } catch {
    return n24;
  }
}
function uL(n24, e = 0.15) {
  return c0(n24) > 0.5 ? hw(n24, e) : dw(n24, e);
}
function v4(n24, e, t) {
  try {
    return uL(n24, e);
  } catch {
    return n24;
  }
}
function y4(n24, e, t, i = 1) {
  const r = (l, f) => Math.round((l ** (1 / i) * (1 - t) + f ** (1 / i) * t) ** i), s = ls(n24), o = ls(e), a = [r(s.values[0], o.values[0]), r(s.values[1], o.values[1]), r(s.values[2], o.values[2])];
  return of({ type: "rgb", values: a });
}
const Zh = { black: "#000", white: "#fff" }, x4 = { 50: "#fafafa", 100: "#f5f5f5", 200: "#eeeeee", 300: "#e0e0e0", 400: "#bdbdbd", 500: "#9e9e9e", 600: "#757575", 700: "#616161", 800: "#424242", 900: "#212121", A100: "#f5f5f5", A200: "#eeeeee", A400: "#bdbdbd", A700: "#616161" }, Tu = { 50: "#f3e5f5", 200: "#ce93d8", 300: "#ba68c8", 400: "#ab47bc", 500: "#9c27b0", 700: "#7b1fa2" }, Au = { 300: "#e57373", 400: "#ef5350", 500: "#f44336", 700: "#d32f2f", 800: "#c62828" }, Gf = { 300: "#ffb74d", 400: "#ffa726", 500: "#ff9800", 700: "#f57c00", 900: "#e65100" }, bu = { 50: "#e3f2fd", 200: "#90caf9", 400: "#42a5f5", 700: "#1976d2", 800: "#1565c0" }, Cu = { 300: "#4fc3f7", 400: "#29b6f6", 500: "#03a9f4", 700: "#0288d1", 900: "#01579b" }, Ru = { 300: "#81c784", 400: "#66bb6a", 500: "#4caf50", 700: "#388e3c", 800: "#2e7d32", 900: "#1b5e20" }, S4 = ["mode", "contrastThreshold", "tonalOffset"], Nb = { text: { primary: "rgba(0, 0, 0, 0.87)", secondary: "rgba(0, 0, 0, 0.6)", disabled: "rgba(0, 0, 0, 0.38)" }, divider: "rgba(0, 0, 0, 0.12)", background: { paper: Zh.white, default: Zh.white }, action: { active: "rgba(0, 0, 0, 0.54)", hover: "rgba(0, 0, 0, 0.04)", hoverOpacity: 0.04, selected: "rgba(0, 0, 0, 0.08)", selectedOpacity: 0.08, disabled: "rgba(0, 0, 0, 0.26)", disabledBackground: "rgba(0, 0, 0, 0.12)", disabledOpacity: 0.38, focus: "rgba(0, 0, 0, 0.12)", focusOpacity: 0.12, activatedOpacity: 0.12 } }, Fy = { text: { primary: Zh.white, secondary: "rgba(255, 255, 255, 0.7)", disabled: "rgba(255, 255, 255, 0.5)", icon: "rgba(255, 255, 255, 0.5)" }, divider: "rgba(255, 255, 255, 0.12)", background: { paper: "#121212", default: "#121212" }, action: { active: Zh.white, hover: "rgba(255, 255, 255, 0.08)", hoverOpacity: 0.08, selected: "rgba(255, 255, 255, 0.16)", selectedOpacity: 0.16, disabled: "rgba(255, 255, 255, 0.3)", disabledBackground: "rgba(255, 255, 255, 0.12)", disabledOpacity: 0.38, focus: "rgba(255, 255, 255, 0.12)", focusOpacity: 0.12, activatedOpacity: 0.24 } };
function Db(n24, e, t, i) {
  const r = i.light || i, s = i.dark || i * 1.5;
  n24[e] || (n24.hasOwnProperty(t) ? n24[e] = n24[t] : e === "light" ? n24.light = u4(n24.main, r) : e === "dark" && (n24.dark = a4(n24.main, s)));
}
function M4(n24 = "light") {
  return n24 === "dark" ? { main: bu[200], light: bu[50], dark: bu[400] } : { main: bu[700], light: bu[400], dark: bu[800] };
}
function w4(n24 = "light") {
  return n24 === "dark" ? { main: Tu[200], light: Tu[50], dark: Tu[400] } : { main: Tu[500], light: Tu[300], dark: Tu[700] };
}
function E4(n24 = "light") {
  return n24 === "dark" ? { main: Au[500], light: Au[300], dark: Au[700] } : { main: Au[700], light: Au[400], dark: Au[800] };
}
function T4(n24 = "light") {
  return n24 === "dark" ? { main: Cu[400], light: Cu[300], dark: Cu[700] } : { main: Cu[700], light: Cu[500], dark: Cu[900] };
}
function A4(n24 = "light") {
  return n24 === "dark" ? { main: Ru[400], light: Ru[300], dark: Ru[700] } : { main: Ru[800], light: Ru[500], dark: Ru[900] };
}
function b4(n24 = "light") {
  return n24 === "dark" ? { main: Gf[400], light: Gf[300], dark: Gf[700] } : { main: "#ed6c02", light: Gf[500], dark: Gf[900] };
}
function C4(n24) {
  const { mode: e = "light", contrastThreshold: t = 3, tonalOffset: i = 0.2 } = n24, r = Xi(n24, S4), s = n24.primary || M4(e), o = n24.secondary || w4(e), a = n24.error || E4(e), l = n24.info || T4(e), f = n24.success || A4(e), h = n24.warning || b4(e);
  function d(S) {
    return l4(S, Fy.text.primary) >= t ? Fy.text.primary : Nb.text.primary;
  }
  const p = ({ color: S, name: M, mainShade: m = 500, lightShade: w = 300, darkShade: E = 700 }) => {
    if (S = dt({}, S), !S.main && S[m] && (S.main = S[m]), !S.hasOwnProperty("main")) throw new Error(ql(11, M ? ` (${M})` : "", m));
    if (typeof S.main != "string") throw new Error(ql(12, M ? ` (${M})` : "", JSON.stringify(S.main)));
    return Db(S, "light", w, i), Db(S, "dark", E, i), S.contrastText || (S.contrastText = d(S.main)), S;
  }, g = { dark: Fy, light: Nb };
  return Qs(dt({ common: dt({}, Zh), mode: e, primary: p({ color: s, name: "primary" }), secondary: p({ color: o, name: "secondary", mainShade: "A400", lightShade: "A200", darkShade: "A700" }), error: p({ color: a, name: "error" }), warning: p({ color: h, name: "warning" }), info: p({ color: l, name: "info" }), success: p({ color: f, name: "success" }), grey: x4, contrastThreshold: t, getContrastText: d, augmentColor: p, tonalOffset: i }, g[e]), r);
}
const R4 = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function P4(n24) {
  return Math.round(n24 * 1e5) / 1e5;
}
const Ob = { textTransform: "uppercase" }, Ub = '"Roboto", "Helvetica", "Arial", sans-serif';
function L4(n24, e) {
  const t = typeof e == "function" ? e(n24) : e, { fontFamily: i = Ub, fontSize: r = 14, fontWeightLight: s = 300, fontWeightRegular: o = 400, fontWeightMedium: a = 500, fontWeightBold: l = 700, htmlFontSize: f = 16, allVariants: h, pxToRem: d } = t, p = Xi(t, R4), g = r / 14, v = d || ((m) => `${m / f * g}rem`), S = (m, w, E, A, P) => dt({ fontFamily: i, fontWeight: m, fontSize: v(w), lineHeight: E }, i === Ub ? { letterSpacing: `${P4(A / w)}em` } : {}, P, h), M = { h1: S(s, 96, 1.167, -1.5), h2: S(s, 60, 1.2, -0.5), h3: S(o, 48, 1.167, 0), h4: S(o, 34, 1.235, 0.25), h5: S(o, 24, 1.334, 0), h6: S(a, 20, 1.6, 0.15), subtitle1: S(o, 16, 1.75, 0.15), subtitle2: S(a, 14, 1.57, 0.1), body1: S(o, 16, 1.5, 0.15), body2: S(o, 14, 1.43, 0.15), button: S(a, 14, 1.75, 0.4, Ob), caption: S(o, 12, 1.66, 0.4), overline: S(o, 12, 2.66, 1, Ob), inherit: { fontFamily: "inherit", fontWeight: "inherit", fontSize: "inherit", lineHeight: "inherit", letterSpacing: "inherit" } };
  return Qs(dt({ htmlFontSize: f, pxToRem: v, fontFamily: i, fontSize: r, fontWeightLight: s, fontWeightRegular: o, fontWeightMedium: a, fontWeightBold: l }, M), p, { clone: false });
}
const I4 = 0.2, N4 = 0.14, D4 = 0.12;
function sn(...n24) {
  return [`${n24[0]}px ${n24[1]}px ${n24[2]}px ${n24[3]}px rgba(0,0,0,${I4})`, `${n24[4]}px ${n24[5]}px ${n24[6]}px ${n24[7]}px rgba(0,0,0,${N4})`, `${n24[8]}px ${n24[9]}px ${n24[10]}px ${n24[11]}px rgba(0,0,0,${D4})`].join(",");
}
const O4 = ["none", sn(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), sn(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), sn(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), sn(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), sn(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), sn(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), sn(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), sn(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), sn(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), sn(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), sn(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), sn(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), sn(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), sn(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), sn(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), sn(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), sn(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), sn(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), sn(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), sn(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), sn(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), sn(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), sn(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), sn(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)], U4 = ["duration", "easing", "delay"], k4 = { easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)", easeOut: "cubic-bezier(0.0, 0, 0.2, 1)", easeIn: "cubic-bezier(0.4, 0, 1, 1)", sharp: "cubic-bezier(0.4, 0, 0.6, 1)" }, F4 = { shortest: 150, shorter: 200, short: 250, standard: 300, complex: 375, enteringScreen: 225, leavingScreen: 195 };
function kb(n24) {
  return `${Math.round(n24)}ms`;
}
function z4(n24) {
  if (!n24) return 0;
  const e = n24 / 36;
  return Math.round((4 + 15 * e ** 0.25 + e / 5) * 10);
}
function B4(n24) {
  const e = dt({}, k4, n24.easing), t = dt({}, F4, n24.duration);
  return dt({ getAutoHeightDuration: z4, create: (r = ["all"], s = {}) => {
    const { duration: o = t.standard, easing: a = e.easeInOut, delay: l = 0 } = s;
    return Xi(s, U4), (Array.isArray(r) ? r : [r]).map((f) => `${f} ${typeof o == "string" ? o : kb(o)} ${a} ${typeof l == "string" ? l : kb(l)}`).join(",");
  } }, n24, { easing: e, duration: t });
}
const V4 = { mobileStepper: 1e3, fab: 1050, speedDial: 1050, appBar: 1100, drawer: 1200, modal: 1300, snackbar: 1400, tooltip: 1500 }, H4 = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function pw(n24 = {}, ...e) {
  const { mixins: t = {}, palette: i = {}, transitions: r = {}, typography: s = {} } = n24, o = Xi(n24, H4);
  if (n24.vars && n24.generateCssVars === void 0) throw new Error(ql(18));
  const a = C4(i), l = aw(n24);
  let f = Qs(l, { mixins: r4(l.breakpoints, t), palette: a, shadows: O4.slice(), typography: L4(a, s), transitions: B4(r), zIndex: dt({}, V4) });
  return f = Qs(f, o), f = e.reduce((h, d) => Qs(h, d), f), f.unstable_sxConfig = dt({}, Ud, o == null ? void 0 : o.unstable_sxConfig), f.unstable_sx = function(d) {
    return kd({ sx: d, theme: this });
  }, f;
}
const G4 = pw();
var Fd = {}, zy = { exports: {} }, Fb;
function W4() {
  return Fb || (Fb = 1, function(n24) {
    function e(t, i) {
      if (t == null) return {};
      var r = {};
      for (var s in t) if ({}.hasOwnProperty.call(t, s)) {
        if (i.indexOf(s) !== -1) continue;
        r[s] = t[s];
      }
      return r;
    }
    n24.exports = e, n24.exports.__esModule = true, n24.exports.default = n24.exports;
  }(zy)), zy.exports;
}
const X4 = za(yz), j4 = za(xz), $4 = za(Az), Y4 = za(CB), q4 = za(dB), K4 = za(yB);
var af = iL;
Object.defineProperty(Fd, "__esModule", { value: true });
var Z4 = Fd.default = c5;
Fd.shouldForwardProp = wg;
Fd.systemDefaultTheme = void 0;
var Kr = af(D3()), z1 = af(W4()), zb = r5(X4), J4 = j4;
af($4);
af(Y4);
var Q4 = af(q4), e5 = af(K4);
const t5 = ["ownerState"], n5 = ["variants"], i5 = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function cL(n24) {
  if (typeof WeakMap != "function") return null;
  var e = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
  return (cL = function(i) {
    return i ? t : e;
  })(n24);
}
function r5(n24, e) {
  if (n24 && n24.__esModule) return n24;
  if (n24 === null || typeof n24 != "object" && typeof n24 != "function") return { default: n24 };
  var t = cL(e);
  if (t && t.has(n24)) return t.get(n24);
  var i = { __proto__: null }, r = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var s in n24) if (s !== "default" && Object.prototype.hasOwnProperty.call(n24, s)) {
    var o = r ? Object.getOwnPropertyDescriptor(n24, s) : null;
    o && (o.get || o.set) ? Object.defineProperty(i, s, o) : i[s] = n24[s];
  }
  return i.default = n24, t && t.set(n24, i), i;
}
function s5(n24) {
  return Object.keys(n24).length === 0;
}
function o5(n24) {
  return typeof n24 == "string" && n24.charCodeAt(0) > 96;
}
function wg(n24) {
  return n24 !== "ownerState" && n24 !== "theme" && n24 !== "sx" && n24 !== "as";
}
const a5 = Fd.systemDefaultTheme = (0, Q4.default)(), l5 = (n24) => n24 && n24.charAt(0).toLowerCase() + n24.slice(1);
function dm({ defaultTheme: n24, theme: e, themeId: t }) {
  return s5(e) ? n24 : e[t] || e;
}
function u5(n24) {
  return n24 ? (e, t) => t[n24] : null;
}
function Eg(n24, e) {
  let { ownerState: t } = e, i = (0, z1.default)(e, t5);
  const r = typeof n24 == "function" ? n24((0, Kr.default)({ ownerState: t }, i)) : n24;
  if (Array.isArray(r)) return r.flatMap((s) => Eg(s, (0, Kr.default)({ ownerState: t }, i)));
  if (r && typeof r == "object" && Array.isArray(r.variants)) {
    const { variants: s = [] } = r;
    let a = (0, z1.default)(r, n5);
    return s.forEach((l) => {
      let f = true;
      typeof l.props == "function" ? f = l.props((0, Kr.default)({ ownerState: t }, i, t)) : Object.keys(l.props).forEach((h) => {
        (t == null ? void 0 : t[h]) !== l.props[h] && i[h] !== l.props[h] && (f = false);
      }), f && (Array.isArray(a) || (a = [a]), a.push(typeof l.style == "function" ? l.style((0, Kr.default)({ ownerState: t }, i, t)) : l.style));
    }), a;
  }
  return r;
}
function c5(n24 = {}) {
  const { themeId: e, defaultTheme: t = a5, rootShouldForwardProp: i = wg, slotShouldForwardProp: r = wg } = n24, s = (o) => (0, e5.default)((0, Kr.default)({}, o, { theme: dm((0, Kr.default)({}, o, { defaultTheme: t, themeId: e })) }));
  return s.__mui_systemSx = true, (o, a = {}) => {
    (0, zb.internal_processStyles)(o, (P) => P.filter((R) => !(R != null && R.__mui_systemSx)));
    const { name: l, slot: f, skipVariantsResolver: h, skipSx: d, overridesResolver: p = u5(l5(f)) } = a, g = (0, z1.default)(a, i5), v = h !== void 0 ? h : f && f !== "Root" && f !== "root" || false, S = d || false;
    let M, m = wg;
    f === "Root" || f === "root" ? m = i : f ? m = r : o5(o) && (m = void 0);
    const w = (0, zb.default)(o, (0, Kr.default)({ shouldForwardProp: m, label: M }, g)), E = (P) => typeof P == "function" && P.__emotion_real !== P || (0, J4.isPlainObject)(P) ? (R) => Eg(P, (0, Kr.default)({}, R, { theme: dm({ theme: R.theme, defaultTheme: t, themeId: e }) })) : P, A = (P, ...R) => {
      let L = E(P);
      const D = R ? R.map(E) : [];
      l && p && D.push((N) => {
        const j = dm((0, Kr.default)({}, N, { defaultTheme: t, themeId: e }));
        if (!j.components || !j.components[l] || !j.components[l].styleOverrides) return null;
        const Z = j.components[l].styleOverrides, G = {};
        return Object.entries(Z).forEach(([J, q]) => {
          G[J] = Eg(q, (0, Kr.default)({}, N, { theme: j }));
        }), p(N, G);
      }), l && !v && D.push((N) => {
        var j;
        const Z = dm((0, Kr.default)({}, N, { defaultTheme: t, themeId: e })), G = Z == null || (j = Z.components) == null || (j = j[l]) == null ? void 0 : j.variants;
        return Eg({ variants: G }, (0, Kr.default)({}, N, { theme: Z }));
      }), S || D.push(s);
      const F = D.length - R.length;
      if (Array.isArray(P) && F > 0) {
        const N = new Array(F).fill("");
        L = [...P, ...N], L.raw = [...P.raw, ...N];
      }
      const C = w(L, ...D);
      return o.muiName && (C.muiName = o.muiName), C;
    };
    return w.withConfig && (A.withConfig = w.withConfig), A;
  };
}
function f5(n24) {
  return n24 !== "ownerState" && n24 !== "theme" && n24 !== "sx" && n24 !== "as";
}
const h5 = (n24) => f5(n24) && n24 !== "classes", M_ = Z4({ themeId: o0, defaultTheme: G4, rootShouldForwardProp: h5 }), d5 = ["theme"];
function p5(n24) {
  let { theme: e } = n24, t = Xi(n24, d5);
  const i = e[o0];
  let r = i || e;
  return typeof e != "function" && (i && !i.vars ? r = dt({}, i, { vars: null }) : e && !e.vars && (r = dt({}, e, { vars: null }))), Be.jsx(i4, dt({}, t, { themeId: i ? o0 : void 0, theme: r }));
}
let m5 = pw({ typography: { fontFamily: "Work Sans" }, components: { MuiToggleButton: { styleOverrides: { root: { cursor: "none", textTransform: "lowercase", backgroundColor: "whitesmoke", color: "black", px: "10", border: "1px solid grey", "&:hover": { backgroundColor: "#e0e0e0" }, "&.Mui-selected": { backgroundColor: "black", color: "white" }, "&.Mui-selected:hover": { backgroundColor: "#222222" } } }, defaultProps: { disableRipple: true } } } });
/**
* @license
* Copyright 2010-2023 Three.js Authors
* SPDX-License-Identifier: MIT
*/
const w_ = "161", g5 = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, _5 = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, fL = 0, B1 = 1, hL = 2, v5 = 3, dL = 0, E_ = 1, wh = 2, vs = 3, ko = 0, Gi = 1, Xs = 2, Lo = 0, Dl = 1, V1 = 2, H1 = 3, G1 = 4, pL = 5, pa = 100, mL = 101, gL = 102, W1 = 103, X1 = 104, _L = 200, vL = 201, yL = 202, xL = 203, f0 = 204, h0 = 205, SL = 206, ML = 207, wL = 208, EL = 209, TL = 210, AL = 211, bL = 212, CL = 213, RL = 214, PL = 0, LL = 1, IL = 2, Jh = 3, NL = 4, DL = 5, OL = 6, UL = 7, zd = 0, kL = 1, FL = 2, eo = 0, zL = 1, BL = 2, VL = 3, mw = 4, HL = 5, GL = 6, j1 = "attached", WL = "detached", T_ = 300, Fo = 301, Oa = 302, Qh = 303, ed = 304, lf = 306, td = 1e3, Ai = 1001, nd = 1002, Pn = 1003, d0 = 1004, y5 = 1004, xl = 1005, x5 = 1005, fn = 1006, Eh = 1007, S5 = 1007, $s = 1008, M5 = 1008, to = 1009, XL = 1010, jL = 1011, A_ = 1012, gw = 1013, Co = 1014, ns = 1015, Hc = 1016, _w = 1017, vw = 1018, Ca = 1020, $L = 1021, zi = 1023, YL = 1024, qL = 1025, Ra = 1026, Kl = 1027, KL = 1028, yw = 1029, ZL = 1030, xw = 1031, Sw = 1033, Tg = 33776, Ag = 33777, bg = 33778, Cg = 33779, $1 = 35840, Y1 = 35841, q1 = 35842, K1 = 35843, Mw = 36196, Z1 = 37492, J1 = 37496, Q1 = 37808, eS = 37809, tS = 37810, nS = 37811, iS = 37812, rS = 37813, sS = 37814, oS = 37815, aS = 37816, lS = 37817, uS = 37818, cS = 37819, fS = 37820, hS = 37821, Rg = 36492, dS = 36494, pS = 36495, JL = 36283, mS = 36284, gS = 36285, _S = 36286, QL = 2200, eI = 2201, tI = 2202, id = 2300, rd = 2301, Pg = 2302, Al = 2400, bl = 2401, sd = 2402, b_ = 2500, ww = 2501, w5 = 0, E5 = 1, T5 = 2, Ew = 3e3, Pa = 3001, nI = 3200, iI = 3201, Ga = 0, rI = 1, Mr = "", Xn = "srgb", so = "srgb-linear", C_ = "display-p3", Bd = "display-p3-linear", od = "linear", Zt = "srgb", ad = "rec709", ld = "p3", A5 = 0, _l = 7680, b5 = 7681, C5 = 7682, R5 = 7683, P5 = 34055, L5 = 34056, I5 = 5386, N5 = 512, D5 = 513, O5 = 514, U5 = 515, k5 = 516, F5 = 517, z5 = 518, vS = 519, sI = 512, oI = 513, aI = 514, Tw = 515, lI = 516, uI = 517, cI = 518, fI = 519, ud = 35044, B5 = 35048, V5 = 35040, H5 = 35045, G5 = 35049, W5 = 35041, X5 = 35046, j5 = 35050, $5 = 35042, Y5 = "100", yS = "300 es", p0 = 1035, Ys = 2e3, cd = 2001;
class Go {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return false;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const Si = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Bb = 1234567;
const Ol = Math.PI / 180, Gc = 180 / Math.PI;
function Rr() {
  const n24 = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
  return (Si[n24 & 255] + Si[n24 >> 8 & 255] + Si[n24 >> 16 & 255] + Si[n24 >> 24 & 255] + "-" + Si[e & 255] + Si[e >> 8 & 255] + "-" + Si[e >> 16 & 15 | 64] + Si[e >> 24 & 255] + "-" + Si[t & 63 | 128] + Si[t >> 8 & 255] + "-" + Si[t >> 16 & 255] + Si[t >> 24 & 255] + Si[i & 255] + Si[i >> 8 & 255] + Si[i >> 16 & 255] + Si[i >> 24 & 255]).toLowerCase();
}
function wn(n24, e, t) {
  return Math.max(e, Math.min(t, n24));
}
function Aw(n24, e) {
  return (n24 % e + e) % e;
}
function q5(n24, e, t, i, r) {
  return i + (n24 - e) * (r - i) / (t - e);
}
function K5(n24, e, t) {
  return n24 !== e ? (t - n24) / (e - n24) : 0;
}
function Th(n24, e, t) {
  return (1 - t) * n24 + t * e;
}
function Z5(n24, e, t, i) {
  return Th(n24, e, 1 - Math.exp(-t * i));
}
function J5(n24, e = 1) {
  return e - Math.abs(Aw(n24, e * 2) - e);
}
function Q5(n24, e, t) {
  return n24 <= e ? 0 : n24 >= t ? 1 : (n24 = (n24 - e) / (t - e), n24 * n24 * (3 - 2 * n24));
}
function eV(n24, e, t) {
  return n24 <= e ? 0 : n24 >= t ? 1 : (n24 = (n24 - e) / (t - e), n24 * n24 * n24 * (n24 * (n24 * 6 - 15) + 10));
}
function tV(n24, e) {
  return n24 + Math.floor(Math.random() * (e - n24 + 1));
}
function nV(n24, e) {
  return n24 + Math.random() * (e - n24);
}
function iV(n24) {
  return n24 * (0.5 - Math.random());
}
function rV(n24) {
  n24 !== void 0 && (Bb = n24);
  let e = Bb += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function sV(n24) {
  return n24 * Ol;
}
function oV(n24) {
  return n24 * Gc;
}
function xS(n24) {
  return (n24 & n24 - 1) === 0 && n24 !== 0;
}
function aV(n24) {
  return Math.pow(2, Math.ceil(Math.log(n24) / Math.LN2));
}
function m0(n24) {
  return Math.pow(2, Math.floor(Math.log(n24) / Math.LN2));
}
function lV(n24, e, t, i, r) {
  const s = Math.cos, o = Math.sin, a = s(t / 2), l = o(t / 2), f = s((e + i) / 2), h = o((e + i) / 2), d = s((e - i) / 2), p = o((e - i) / 2), g = s((i - e) / 2), v = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n24.set(a * h, l * d, l * p, a * f);
      break;
    case "YZY":
      n24.set(l * p, a * h, l * d, a * f);
      break;
    case "ZXZ":
      n24.set(l * d, l * p, a * h, a * f);
      break;
    case "XZX":
      n24.set(a * h, l * v, l * g, a * f);
      break;
    case "YXY":
      n24.set(l * g, a * h, l * v, a * f);
      break;
    case "ZYZ":
      n24.set(l * v, l * g, a * h, a * f);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
  }
}
function Bi(n24, e) {
  switch (e.constructor) {
    case Float32Array:
      return n24;
    case Uint32Array:
      return n24 / 4294967295;
    case Uint16Array:
      return n24 / 65535;
    case Uint8Array:
      return n24 / 255;
    case Int32Array:
      return Math.max(n24 / 2147483647, -1);
    case Int16Array:
      return Math.max(n24 / 32767, -1);
    case Int8Array:
      return Math.max(n24 / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function vt(n24, e) {
  switch (e.constructor) {
    case Float32Array:
      return n24;
    case Uint32Array:
      return Math.round(n24 * 4294967295);
    case Uint16Array:
      return Math.round(n24 * 65535);
    case Uint8Array:
      return Math.round(n24 * 255);
    case Int32Array:
      return Math.round(n24 * 2147483647);
    case Int16Array:
      return Math.round(n24 * 32767);
    case Int8Array:
      return Math.round(n24 * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const SS = { DEG2RAD: Ol, RAD2DEG: Gc, generateUUID: Rr, clamp: wn, euclideanModulo: Aw, mapLinear: q5, inverseLerp: K5, lerp: Th, damp: Z5, pingpong: J5, smoothstep: Q5, smootherstep: eV, randInt: tV, randFloat: nV, randFloatSpread: iV, seededRandom: rV, degToRad: sV, radToDeg: oV, isPowerOfTwo: xS, ceilPowerOfTwo: aV, floorPowerOfTwo: m0, setQuaternionFromProperEuler: lV, normalize: vt, denormalize: Bi };
class _e {
  constructor(e = 0, t = 0) {
    _e.prototype.isVector2 = true, this.x = e, this.y = t;
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = e.elements;
    return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(wn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, o = this.y - e.y;
    return this.x = s * i - o * r + e.x, this.y = s * r + o * i + e.y, this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Mt {
  constructor(e, t, i, r, s, o, a, l, f) {
    Mt.prototype.isMatrix3 = true, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, f);
  }
  set(e, t, i, r, s, o, a, l, f) {
    const h = this.elements;
    return h[0] = e, h[1] = r, h[2] = a, h[3] = t, h[4] = s, h[5] = l, h[6] = i, h[7] = o, h[8] = f, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[3], l = i[6], f = i[1], h = i[4], d = i[7], p = i[2], g = i[5], v = i[8], S = r[0], M = r[3], m = r[6], w = r[1], E = r[4], A = r[7], P = r[2], R = r[5], L = r[8];
    return s[0] = o * S + a * w + l * P, s[3] = o * M + a * E + l * R, s[6] = o * m + a * A + l * L, s[1] = f * S + h * w + d * P, s[4] = f * M + h * E + d * R, s[7] = f * m + h * A + d * L, s[2] = p * S + g * w + v * P, s[5] = p * M + g * E + v * R, s[8] = p * m + g * A + v * L, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], h = e[8];
    return t * o * h - t * a * f - i * s * h + i * a * l + r * s * f - r * o * l;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], h = e[8], d = h * o - a * f, p = a * l - h * s, g = f * s - o * l, v = t * d + i * p + r * g;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const S = 1 / v;
    return e[0] = d * S, e[1] = (r * f - h * i) * S, e[2] = (a * i - r * o) * S, e[3] = p * S, e[4] = (h * t - r * l) * S, e[5] = (r * s - a * t) * S, e[6] = g * S, e[7] = (i * l - f * t) * S, e[8] = (o * t - i * s) * S, this;
  }
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s), f = Math.sin(s);
    return this.set(i * l, i * f, -i * (l * o + f * a) + o + e, -r * f, r * l, -r * (-f * o + l * a) + a + t, 0, 0, 1), this;
  }
  scale(e, t) {
    return this.premultiply(By.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(By.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(By.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const By = new Mt();
function hI(n24) {
  for (let e = n24.length - 1; e >= 0; --e) if (n24[e] >= 65535) return true;
  return false;
}
const uV = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array };
function pc(n24, e) {
  return new uV[n24](e);
}
function fd(n24) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n24);
}
function dI() {
  const n24 = fd("canvas");
  return n24.style.display = "block", n24;
}
const Vb = {};
function Ul(n24) {
  n24 in Vb || (Vb[n24] = true, console.warn(n24));
}
const Hb = new Mt().set(0.8224621, 0.177538, 0, 0.0331941, 0.9668058, 0, 0.0170827, 0.0723974, 0.9105199), Gb = new Mt().set(1.2249401, -0.2249404, 0, -0.0420569, 1.0420571, 0, -0.0196376, -0.0786361, 1.0982735), pm = { [so]: { transfer: od, primaries: ad, toReference: (n24) => n24, fromReference: (n24) => n24 }, [Xn]: { transfer: Zt, primaries: ad, toReference: (n24) => n24.convertSRGBToLinear(), fromReference: (n24) => n24.convertLinearToSRGB() }, [Bd]: { transfer: od, primaries: ld, toReference: (n24) => n24.applyMatrix3(Gb), fromReference: (n24) => n24.applyMatrix3(Hb) }, [C_]: { transfer: Zt, primaries: ld, toReference: (n24) => n24.convertSRGBToLinear().applyMatrix3(Gb), fromReference: (n24) => n24.applyMatrix3(Hb).convertLinearToSRGB() } }, cV = /* @__PURE__ */ new Set([so, Bd]), Ht = { enabled: true, _workingColorSpace: so, get workingColorSpace() {
  return this._workingColorSpace;
}, set workingColorSpace(n24) {
  if (!cV.has(n24)) throw new Error(`Unsupported working color space, "${n24}".`);
  this._workingColorSpace = n24;
}, convert: function(n24, e, t) {
  if (this.enabled === false || e === t || !e || !t) return n24;
  const i = pm[e].toReference, r = pm[t].fromReference;
  return r(i(n24));
}, fromWorkingColorSpace: function(n24, e) {
  return this.convert(n24, this._workingColorSpace, e);
}, toWorkingColorSpace: function(n24, e) {
  return this.convert(n24, e, this._workingColorSpace);
}, getPrimaries: function(n24) {
  return pm[n24].primaries;
}, getTransfer: function(n24) {
  return n24 === Mr ? od : pm[n24].transfer;
} };
function Pc(n24) {
  return n24 < 0.04045 ? n24 * 0.0773993808 : Math.pow(n24 * 0.9478672986 + 0.0521327014, 2.4);
}
function Vy(n24) {
  return n24 < 31308e-7 ? n24 * 12.92 : 1.055 * Math.pow(n24, 0.41666) - 0.055;
}
let Pu;
class bw {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Pu === void 0 && (Pu = fd("canvas")), Pu.width = e.width, Pu.height = e.height;
      const i = Pu.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = Pu;
    }
    return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", 0.6)) : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = fd("canvas");
      t.width = e.width, t.height = e.height;
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Pc(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Pc(t[i] / 255) * 255) : t[i] = Pc(t[i]);
      return { data: t, width: e.width, height: e.height };
    } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let fV = 0;
class Cl {
  constructor(e = null) {
    this.isSource = true, Object.defineProperty(this, "id", { value: fV++ }), this.uuid = Rr(), this.data = e, this.dataReady = true, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" }, r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++) r[o].isDataTexture ? s.push(Hy(r[o].image)) : s.push(Hy(r[o]));
      } else s = Hy(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function Hy(n24) {
  return typeof HTMLImageElement < "u" && n24 instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n24 instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n24 instanceof ImageBitmap ? bw.getDataURL(n24) : n24.data ? { data: Array.from(n24.data), width: n24.width, height: n24.height, type: n24.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let hV = 0;
class Tn extends Go {
  constructor(e = Tn.DEFAULT_IMAGE, t = Tn.DEFAULT_MAPPING, i = Ai, r = Ai, s = fn, o = $s, a = zi, l = to, f = Tn.DEFAULT_ANISOTROPY, h = Mr) {
    super(), this.isTexture = true, Object.defineProperty(this, "id", { value: hV++ }), this.uuid = Rr(), this.name = "", this.source = new Cl(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = f, this.format = a, this.internalFormat = null, this.type = l, this.offset = new _e(0, 0), this.repeat = new _e(1, 1), this.center = new _e(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new Mt(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, typeof h == "string" ? this.colorSpace = h : (Ul("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = h === Pa ? Xn : Mr), this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = false, this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = { metadata: { version: 4.6, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(e).uuid, mapping: this.mapping, channel: this.channel, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, internalFormat: this.internalFormat, type: this.type, colorSpace: this.colorSpace, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment };
    return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== T_) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
      case td:
        e.x = e.x - Math.floor(e.x);
        break;
      case Ai:
        e.x = e.x < 0 ? 0 : 1;
        break;
      case nd:
        Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
        break;
    }
    if (e.y < 0 || e.y > 1) switch (this.wrapT) {
      case td:
        e.y = e.y - Math.floor(e.y);
        break;
      case Ai:
        e.y = e.y < 0 ? 0 : 1;
        break;
      case nd:
        Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
        break;
    }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === true && (this.version++, this.source.needsUpdate = true);
  }
  get encoding() {
    return Ul("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace === Xn ? Pa : Ew;
  }
  set encoding(e) {
    Ul("THREE.Texture: Property .encoding has been replaced by .colorSpace."), this.colorSpace = e === Pa ? Xn : Mr;
  }
}
Tn.DEFAULT_IMAGE = null;
Tn.DEFAULT_MAPPING = T_;
Tn.DEFAULT_ANISOTROPY = 1;
class Gt {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    Gt.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = r;
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return this.x = e, this.y = t, this.z = i, this.w = r, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setW(e) {
    return this.w = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = this.w, o = e.elements;
    return this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s, this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s, this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s, this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements, f = l[0], h = l[4], d = l[8], p = l[1], g = l[5], v = l[9], S = l[2], M = l[6], m = l[10];
    if (Math.abs(h - p) < 0.01 && Math.abs(d - S) < 0.01 && Math.abs(v - M) < 0.01) {
      if (Math.abs(h + p) < 0.1 && Math.abs(d + S) < 0.1 && Math.abs(v + M) < 0.1 && Math.abs(f + g + m - 3) < 0.1) return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const E = (f + 1) / 2, A = (g + 1) / 2, P = (m + 1) / 2, R = (h + p) / 4, L = (d + S) / 4, D = (v + M) / 4;
      return E > A && E > P ? E < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(E), r = R / i, s = L / i) : A > P ? A < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(A), i = R / r, s = D / r) : P < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(P), i = L / s, r = D / s), this.set(i, r, s, t), this;
    }
    let w = Math.sqrt((M - v) * (M - v) + (d - S) * (d - S) + (p - h) * (p - h));
    return Math.abs(w) < 1e-3 && (w = 1), this.x = (M - v) / w, this.y = (d - S) / w, this.z = (p - h) / w, this.w = Math.acos((f + g + m - 1) / 2), this;
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class pI extends Go {
  constructor(e = 1, t = 1, i = {}) {
    super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new Gt(0, 0, e, t), this.scissorTest = false, this.viewport = new Gt(0, 0, e, t);
    const r = { width: e, height: t, depth: 1 };
    i.encoding !== void 0 && (Ul("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."), i.colorSpace = i.encoding === Pa ? Xn : Mr), i = Object.assign({ generateMipmaps: false, internalFormat: null, minFilter: fn, depthBuffer: true, stencilBuffer: false, depthTexture: null, samples: 0 }, i), this.texture = new Tn(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.flipY = false, this.texture.generateMipmaps = i.generateMipmaps, this.texture.internalFormat = i.internalFormat, this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.depthTexture = i.depthTexture, this.samples = i.samples;
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) && (this.width = e, this.height = t, this.depth = i, this.texture.image.width = e, this.texture.image.height = t, this.texture.image.depth = i, this.dispose()), this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.texture = e.texture.clone(), this.texture.isRenderTargetTexture = true;
    const t = Object.assign({}, e.texture.image);
    return this.texture.source = new Cl(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class As extends pI {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), this.isWebGLRenderTarget = true;
  }
}
class R_ extends Tn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isDataArrayTexture = true, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Pn, this.minFilter = Pn, this.wrapR = Ai, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class dV extends As {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGLArrayRenderTarget = true, this.depth = i, this.texture = new R_(null, e, t, i), this.texture.isRenderTargetTexture = true;
  }
}
class Cw extends Tn {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null), this.isData3DTexture = true, this.image = { data: e, width: t, height: i, depth: r }, this.magFilter = Pn, this.minFilter = Pn, this.wrapR = Ai, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
class pV extends As {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGL3DRenderTarget = true, this.depth = i, this.texture = new Cw(null, e, t, i), this.texture.isRenderTargetTexture = true;
  }
}
class mV extends As {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), this.isWebGLMultipleRenderTargets = true;
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++) this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = true;
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      this.width = e, this.height = t, this.depth = i;
      for (let r = 0, s = this.texture.length; r < s; r++) this.texture[r].image.width = e, this.texture[r].image.height = t, this.texture[r].image.depth = i;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(), this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.texture.length = 0;
    for (let t = 0, i = e.texture.length; t < i; t++) this.texture[t] = e.texture[t].clone(), this.texture[t].isRenderTargetTexture = true;
    return this;
  }
}
class rr {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = r;
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0], f = i[r + 1], h = i[r + 2], d = i[r + 3];
    const p = s[o + 0], g = s[o + 1], v = s[o + 2], S = s[o + 3];
    if (a === 0) {
      e[t + 0] = l, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
      return;
    }
    if (a === 1) {
      e[t + 0] = p, e[t + 1] = g, e[t + 2] = v, e[t + 3] = S;
      return;
    }
    if (d !== S || l !== p || f !== g || h !== v) {
      let M = 1 - a;
      const m = l * p + f * g + h * v + d * S, w = m >= 0 ? 1 : -1, E = 1 - m * m;
      if (E > Number.EPSILON) {
        const P = Math.sqrt(E), R = Math.atan2(P, m * w);
        M = Math.sin(M * R) / P, a = Math.sin(a * R) / P;
      }
      const A = a * w;
      if (l = l * M + p * A, f = f * M + g * A, h = h * M + v * A, d = d * M + S * A, M === 1 - a) {
        const P = 1 / Math.sqrt(l * l + f * f + h * h + d * d);
        l *= P, f *= P, h *= P, d *= P;
      }
    }
    e[t] = l, e[t + 1] = f, e[t + 2] = h, e[t + 3] = d;
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r], l = i[r + 1], f = i[r + 2], h = i[r + 3], d = s[o], p = s[o + 1], g = s[o + 2], v = s[o + 3];
    return e[t] = a * v + h * d + l * g - f * p, e[t + 1] = l * v + h * p + f * d - a * g, e[t + 2] = f * v + h * g + a * p - l * d, e[t + 3] = h * v - a * d - l * p - f * g, e;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  set(e, t, i, r) {
    return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  setFromEuler(e, t = true) {
    const i = e._x, r = e._y, s = e._z, o = e._order, a = Math.cos, l = Math.sin, f = a(i / 2), h = a(r / 2), d = a(s / 2), p = l(i / 2), g = l(r / 2), v = l(s / 2);
    switch (o) {
      case "XYZ":
        this._x = p * h * d + f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "YXZ":
        this._x = p * h * d + f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d + p * g * v;
        break;
      case "ZXY":
        this._x = p * h * d - f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "ZYX":
        this._x = p * h * d - f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d + p * g * v;
        break;
      case "YZX":
        this._x = p * h * d + f * g * v, this._y = f * g * d + p * h * v, this._z = f * h * v - p * g * d, this._w = f * h * d - p * g * v;
        break;
      case "XZY":
        this._x = p * h * d - f * g * v, this._y = f * g * d - p * h * v, this._z = f * h * v + p * g * d, this._w = f * h * d + p * g * v;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o);
    }
    return t === true && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2, r = Math.sin(i);
    return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e) {
    const t = e.elements, i = t[0], r = t[4], s = t[8], o = t[1], a = t[5], l = t[9], f = t[2], h = t[6], d = t[10], p = i + a + d;
    if (p > 0) {
      const g = 0.5 / Math.sqrt(p + 1);
      this._w = 0.25 / g, this._x = (h - l) * g, this._y = (s - f) * g, this._z = (o - r) * g;
    } else if (i > a && i > d) {
      const g = 2 * Math.sqrt(1 + i - a - d);
      this._w = (h - l) / g, this._x = 0.25 * g, this._y = (r + o) / g, this._z = (s + f) / g;
    } else if (a > d) {
      const g = 2 * Math.sqrt(1 + a - i - d);
      this._w = (s - f) / g, this._x = (r + o) / g, this._y = 0.25 * g, this._z = (l + h) / g;
    } else {
      const g = 2 * Math.sqrt(1 + d - i - a);
      this._w = (o - r) / g, this._x = (s + f) / g, this._y = (l + h) / g, this._z = 0.25 * g;
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(wn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x, r = e._y, s = e._z, o = e._w, a = t._x, l = t._y, f = t._z, h = t._w;
    return this._x = i * h + o * a + r * f - s * l, this._y = r * h + o * l + s * a - i * f, this._z = s * h + o * f + i * l - r * a, this._w = o * h - i * a - r * l - s * f, this._onChangeCallback(), this;
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x, r = this._y, s = this._z, o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = i, this._y = r, this._z = s, this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const g = 1 - t;
      return this._w = g * o + t * this._w, this._x = g * i + t * this._x, this._y = g * r + t * this._y, this._z = g * s + t * this._z, this.normalize(), this;
    }
    const f = Math.sqrt(l), h = Math.atan2(f, a), d = Math.sin((1 - t) * h) / f, p = Math.sin(t * h) / f;
    return this._w = o * d + this._w * p, this._x = i * d + this._x * p, this._y = r * d + this._y * p, this._z = s * d + this._z * p, this._onChangeCallback(), this;
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(), t = Math.sqrt(1 - e), i = Math.sqrt(e), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random();
    return this.set(t * Math.cos(r), i * Math.sin(s), i * Math.cos(s), t * Math.sin(r));
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class V {
  constructor(e = 0, t = 0, i = 0) {
    V.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
  }
  set(e, t, i) {
    return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
  }
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  setX(e) {
    return this.x = e, this;
  }
  setY(e) {
    return this.y = e, this;
  }
  setZ(e) {
    return this.z = e, this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  applyEuler(e) {
    return this.applyQuaternion(Wb.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(Wb.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements, o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o, this;
  }
  applyQuaternion(e) {
    const t = this.x, i = this.y, r = this.z, s = e.x, o = e.y, a = e.z, l = e.w, f = 2 * (o * r - a * i), h = 2 * (a * t - s * r), d = 2 * (s * i - o * t);
    return this.x = t + l * f + o * d - a * h, this.y = i + l * h + a * f - s * d, this.z = r + l * d + s * h - o * f, this;
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  transformDirection(e) {
    const t = this.x, i = this.y, r = this.z, s = e.elements;
    return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
  }
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  clamp(e, t) {
    return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this;
  }
  clampScalar(e, t) {
    return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this;
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(Math.max(e, Math.min(t, i)));
  }
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  lerpVectors(e, t, i) {
    return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x, r = e.y, s = e.z, o = t.x, a = t.y, l = t.z;
    return this.x = r * l - s * a, this.y = s * o - i * l, this.z = i * a - r * o, this;
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return Gy.copy(this).projectOnVector(e), this.sub(Gy);
  }
  reflect(e) {
    return this.sub(Gy.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(wn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = i, this.z = r, this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2, t = Math.random() * Math.PI * 2, i = Math.sqrt(1 - e ** 2);
    return this.x = i * Math.cos(t), this.y = i * Math.sin(t), this.z = e, this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Gy = new V(), Wb = new rr();
class Wi {
  constructor(e = new V(1 / 0, 1 / 0, 1 / 0), t = new V(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(ps.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(ps.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = ps.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = false) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = false) {
    e.updateWorldMatrix(false, false);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (t === true && s !== void 0 && e.isInstancedMesh !== true) for (let o = 0, a = s.count; o < a; o++) e.isMesh === true ? e.getVertexPosition(o, ps) : ps.fromBufferAttribute(s, o), ps.applyMatrix4(e.matrixWorld), this.expandByPoint(ps);
      else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), mm.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), mm.copy(i.boundingBox)), mm.applyMatrix4(e.matrixWorld), this.union(mm);
    }
    const r = e.children;
    for (let s = 0, o = r.length; s < o; s++) this.expandByObject(r[s], t);
    return this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z);
  }
  intersectsSphere(e) {
    return this.clampPoint(e.center, ps), ps.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  intersectsPlane(e) {
    let t, i;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return false;
    this.getCenter(Wf), gm.subVectors(this.max, Wf), Lu.subVectors(e.a, Wf), Iu.subVectors(e.b, Wf), Nu.subVectors(e.c, Wf), ea.subVectors(Iu, Lu), ta.subVectors(Nu, Iu), il.subVectors(Lu, Nu);
    let t = [0, -ea.z, ea.y, 0, -ta.z, ta.y, 0, -il.z, il.y, ea.z, 0, -ea.x, ta.z, 0, -ta.x, il.z, 0, -il.x, -ea.y, ea.x, 0, -ta.y, ta.x, 0, -il.y, il.x, 0];
    return !Wy(t, Lu, Iu, Nu, gm) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !Wy(t, Lu, Iu, Nu, gm)) ? false : (_m.crossVectors(ea, ta), t = [_m.x, _m.y, _m.z], Wy(t, Lu, Iu, Nu, gm));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ps).distanceTo(e);
  }
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(ps).length() * 0.5), e;
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty() ? this : (mo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), mo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), mo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), mo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), mo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), mo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), mo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), mo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(mo), this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const mo = [new V(), new V(), new V(), new V(), new V(), new V(), new V(), new V()], ps = new V(), mm = new Wi(), Lu = new V(), Iu = new V(), Nu = new V(), ea = new V(), ta = new V(), il = new V(), Wf = new V(), gm = new V(), _m = new V(), rl = new V();
function Wy(n24, e, t, i, r) {
  for (let s = 0, o = n24.length - 3; s <= o; s += 3) {
    rl.fromArray(n24, s);
    const a = r.x * Math.abs(rl.x) + r.y * Math.abs(rl.y) + r.z * Math.abs(rl.z), l = e.dot(rl), f = t.dot(rl), h = i.dot(rl);
    if (Math.max(-Math.max(l, f, h), Math.min(l, f, h)) > a) return false;
  }
  return true;
}
const gV = new Wi(), Xf = new V(), Xy = new V();
class Ri {
  constructor(e = new V(), t = -1) {
    this.isSphere = true, this.center = e, this.radius = t;
  }
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : gV.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++) r = Math.max(r, i.distanceToSquared(e[s]));
    return this.radius = Math.sqrt(r), this;
  }
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
    Xf.subVectors(e, this.center);
    const t = Xf.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t), r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Xf, r / i), this.radius += r;
    }
    return this;
  }
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (Xy.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Xf.copy(e.center).add(Xy)), this.expandByPoint(Xf.copy(e.center).sub(Xy))), this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const go = new V(), jy = new V(), vm = new V(), na = new V(), $y = new V(), ym = new V(), Yy = new V();
class uf {
  constructor(e = new V(), t = new V(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, go)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = go.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (go.copy(this.origin).addScaledVector(this.direction, t), go.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    jy.copy(e).add(t).multiplyScalar(0.5), vm.copy(t).sub(e).normalize(), na.copy(this.origin).sub(jy);
    const s = e.distanceTo(t) * 0.5, o = -this.direction.dot(vm), a = na.dot(this.direction), l = -na.dot(vm), f = na.lengthSq(), h = Math.abs(1 - o * o);
    let d, p, g, v;
    if (h > 0) if (d = o * l - a, p = o * a - l, v = s * h, d >= 0) if (p >= -v) if (p <= v) {
      const S = 1 / h;
      d *= S, p *= S, g = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + f;
    } else p = s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * l) + f;
    else p = -s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * l) + f;
    else p <= -v ? (d = Math.max(0, -(-o * s + a)), p = d > 0 ? -s : Math.min(Math.max(-s, -l), s), g = -d * d + p * (p + 2 * l) + f) : p <= v ? (d = 0, p = Math.min(Math.max(-s, -l), s), g = p * (p + 2 * l) + f) : (d = Math.max(0, -(o * s + a)), p = d > 0 ? s : Math.min(Math.max(-s, -l), s), g = -d * d + p * (p + 2 * l) + f);
    else p = o > 0 ? -s : s, d = Math.max(0, -(o * p + a)), g = -d * d + p * (p + 2 * l) + f;
    return i && i.copy(this.origin).addScaledVector(this.direction, d), r && r.copy(jy).addScaledVector(vm, p), g;
  }
  intersectSphere(e, t) {
    go.subVectors(e.center, this.origin);
    const i = go.dot(this.direction), r = go.dot(go) - i * i, s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r), a = i - o, l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const f = 1 / this.direction.x, h = 1 / this.direction.y, d = 1 / this.direction.z, p = this.origin;
    return f >= 0 ? (i = (e.min.x - p.x) * f, r = (e.max.x - p.x) * f) : (i = (e.max.x - p.x) * f, r = (e.min.x - p.x) * f), h >= 0 ? (s = (e.min.y - p.y) * h, o = (e.max.y - p.y) * h) : (s = (e.max.y - p.y) * h, o = (e.min.y - p.y) * h), i > o || s > r || ((s > i || isNaN(i)) && (i = s), (o < r || isNaN(r)) && (r = o), d >= 0 ? (a = (e.min.z - p.z) * d, l = (e.max.z - p.z) * d) : (a = (e.max.z - p.z) * d, l = (e.min.z - p.z) * d), i > l || a > r) || ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t);
  }
  intersectsBox(e) {
    return this.intersectBox(e, go) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    $y.subVectors(t, e), ym.subVectors(i, e), Yy.crossVectors($y, ym);
    let o = this.direction.dot(Yy), a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) a = -1, o = -o;
    else return null;
    na.subVectors(this.origin, e);
    const l = a * this.direction.dot(ym.crossVectors(na, ym));
    if (l < 0) return null;
    const f = a * this.direction.dot($y.cross(na));
    if (f < 0 || l + f > o) return null;
    const h = -a * na.dot(Yy);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class lt {
  constructor(e, t, i, r, s, o, a, l, f, h, d, p, g, v, S, M) {
    lt.prototype.isMatrix4 = true, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, r, s, o, a, l, f, h, d, p, g, v, S, M);
  }
  set(e, t, i, r, s, o, a, l, f, h, d, p, g, v, S, M) {
    const m = this.elements;
    return m[0] = e, m[4] = t, m[8] = i, m[12] = r, m[1] = s, m[5] = o, m[9] = a, m[13] = l, m[2] = f, m[6] = h, m[10] = d, m[14] = p, m[3] = g, m[7] = v, m[11] = S, m[15] = M, this;
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new lt().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements, i = e.elements;
    return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
  }
  copyPosition(e) {
    const t = this.elements, i = e.elements;
    return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
  }
  extractBasis(e, t, i) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
  }
  makeBasis(e, t, i) {
    return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
  }
  extractRotation(e) {
    const t = this.elements, i = e.elements, r = 1 / Du.setFromMatrixColumn(e, 0).length(), s = 1 / Du.setFromMatrixColumn(e, 1).length(), o = 1 / Du.setFromMatrixColumn(e, 2).length();
    return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * o, t[9] = i[9] * o, t[10] = i[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromEuler(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z, o = Math.cos(i), a = Math.sin(i), l = Math.cos(r), f = Math.sin(r), h = Math.cos(s), d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h, g = o * d, v = a * h, S = a * d;
      t[0] = l * h, t[4] = -l * d, t[8] = f, t[1] = g + v * f, t[5] = p - S * f, t[9] = -a * l, t[2] = S - p * f, t[6] = v + g * f, t[10] = o * l;
    } else if (e.order === "YXZ") {
      const p = l * h, g = l * d, v = f * h, S = f * d;
      t[0] = p + S * a, t[4] = v * a - g, t[8] = o * f, t[1] = o * d, t[5] = o * h, t[9] = -a, t[2] = g * a - v, t[6] = S + p * a, t[10] = o * l;
    } else if (e.order === "ZXY") {
      const p = l * h, g = l * d, v = f * h, S = f * d;
      t[0] = p - S * a, t[4] = -o * d, t[8] = v + g * a, t[1] = g + v * a, t[5] = o * h, t[9] = S - p * a, t[2] = -o * f, t[6] = a, t[10] = o * l;
    } else if (e.order === "ZYX") {
      const p = o * h, g = o * d, v = a * h, S = a * d;
      t[0] = l * h, t[4] = v * f - g, t[8] = p * f + S, t[1] = l * d, t[5] = S * f + p, t[9] = g * f - v, t[2] = -f, t[6] = a * l, t[10] = o * l;
    } else if (e.order === "YZX") {
      const p = o * l, g = o * f, v = a * l, S = a * f;
      t[0] = l * h, t[4] = S - p * d, t[8] = v * d + g, t[1] = d, t[5] = o * h, t[9] = -a * h, t[2] = -f * h, t[6] = g * d + v, t[10] = p - S * d;
    } else if (e.order === "XZY") {
      const p = o * l, g = o * f, v = a * l, S = a * f;
      t[0] = l * h, t[4] = -d, t[8] = f * h, t[1] = p * d + S, t[5] = o * h, t[9] = g * d - v, t[2] = v * d - g, t[6] = a * h, t[10] = S * d + p;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  makeRotationFromQuaternion(e) {
    return this.compose(_V, e, vV);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return _r.subVectors(e, t), _r.lengthSq() === 0 && (_r.z = 1), _r.normalize(), ia.crossVectors(i, _r), ia.lengthSq() === 0 && (Math.abs(i.z) === 1 ? _r.x += 1e-4 : _r.z += 1e-4, _r.normalize(), ia.crossVectors(i, _r)), ia.normalize(), xm.crossVectors(_r, ia), r[0] = ia.x, r[4] = xm.x, r[8] = _r.x, r[1] = ia.y, r[5] = xm.y, r[9] = _r.y, r[2] = ia.z, r[6] = xm.z, r[10] = _r.z, this;
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements, r = t.elements, s = this.elements, o = i[0], a = i[4], l = i[8], f = i[12], h = i[1], d = i[5], p = i[9], g = i[13], v = i[2], S = i[6], M = i[10], m = i[14], w = i[3], E = i[7], A = i[11], P = i[15], R = r[0], L = r[4], D = r[8], F = r[12], C = r[1], N = r[5], j = r[9], Z = r[13], G = r[2], J = r[6], q = r[10], ae = r[14], B = r[3], Y = r[7], $ = r[11], ee = r[15];
    return s[0] = o * R + a * C + l * G + f * B, s[4] = o * L + a * N + l * J + f * Y, s[8] = o * D + a * j + l * q + f * $, s[12] = o * F + a * Z + l * ae + f * ee, s[1] = h * R + d * C + p * G + g * B, s[5] = h * L + d * N + p * J + g * Y, s[9] = h * D + d * j + p * q + g * $, s[13] = h * F + d * Z + p * ae + g * ee, s[2] = v * R + S * C + M * G + m * B, s[6] = v * L + S * N + M * J + m * Y, s[10] = v * D + S * j + M * q + m * $, s[14] = v * F + S * Z + M * ae + m * ee, s[3] = w * R + E * C + A * G + P * B, s[7] = w * L + E * N + A * J + P * Y, s[11] = w * D + E * j + A * q + P * $, s[15] = w * F + E * Z + A * ae + P * ee, this;
  }
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  determinant() {
    const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], o = e[1], a = e[5], l = e[9], f = e[13], h = e[2], d = e[6], p = e[10], g = e[14], v = e[3], S = e[7], M = e[11], m = e[15];
    return v * (+s * l * d - r * f * d - s * a * p + i * f * p + r * a * g - i * l * g) + S * (+t * l * g - t * f * p + s * o * p - r * o * g + r * f * h - s * l * h) + M * (+t * f * d - t * a * g - s * o * d + i * o * g + s * a * h - i * f * h) + m * (-r * a * h - t * l * d + t * a * p + r * o * d - i * o * p + i * l * h);
  }
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
  }
  invert() {
    const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], o = e[4], a = e[5], l = e[6], f = e[7], h = e[8], d = e[9], p = e[10], g = e[11], v = e[12], S = e[13], M = e[14], m = e[15], w = d * M * f - S * p * f + S * l * g - a * M * g - d * l * m + a * p * m, E = v * p * f - h * M * f - v * l * g + o * M * g + h * l * m - o * p * m, A = h * S * f - v * d * f + v * a * g - o * S * g - h * a * m + o * d * m, P = v * d * l - h * S * l - v * a * p + o * S * p + h * a * M - o * d * M, R = t * w + i * E + r * A + s * P;
    if (R === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / R;
    return e[0] = w * L, e[1] = (S * p * s - d * M * s - S * r * g + i * M * g + d * r * m - i * p * m) * L, e[2] = (a * M * s - S * l * s + S * r * f - i * M * f - a * r * m + i * l * m) * L, e[3] = (d * l * s - a * p * s - d * r * f + i * p * f + a * r * g - i * l * g) * L, e[4] = E * L, e[5] = (h * M * s - v * p * s + v * r * g - t * M * g - h * r * m + t * p * m) * L, e[6] = (v * l * s - o * M * s - v * r * f + t * M * f + o * r * m - t * l * m) * L, e[7] = (o * p * s - h * l * s + h * r * f - t * p * f - o * r * g + t * l * g) * L, e[8] = A * L, e[9] = (v * d * s - h * S * s - v * i * g + t * S * g + h * i * m - t * d * m) * L, e[10] = (o * S * s - v * a * s + v * i * f - t * S * f - o * i * m + t * a * m) * L, e[11] = (h * a * s - o * d * s - h * i * f + t * d * f + o * i * g - t * a * g) * L, e[12] = P * L, e[13] = (h * S * r - v * d * r + v * i * p - t * S * p - h * i * M + t * d * M) * L, e[14] = (v * a * r - o * S * r - v * i * l + t * S * l + o * i * M - t * a * M) * L, e[15] = (o * d * r - h * a * r + h * i * l - t * d * l - o * i * p + t * a * p) * L, this;
  }
  scale(e) {
    const t = this.elements, i = e.x, r = e.y, s = e.z;
    return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
  }
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e), i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t), r = Math.sin(t), s = 1 - i, o = e.x, a = e.y, l = e.z, f = s * o, h = s * a;
    return this.set(f * o + i, f * a - r * l, f * l + r * a, 0, f * a + r * l, h * a + i, h * l - r * o, 0, f * l - r * a, h * l + r * o, s * l * l + i, 0, 0, 0, 0, 1), this;
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements, s = t._x, o = t._y, a = t._z, l = t._w, f = s + s, h = o + o, d = a + a, p = s * f, g = s * h, v = s * d, S = o * h, M = o * d, m = a * d, w = l * f, E = l * h, A = l * d, P = i.x, R = i.y, L = i.z;
    return r[0] = (1 - (S + m)) * P, r[1] = (g + A) * P, r[2] = (v - E) * P, r[3] = 0, r[4] = (g - A) * R, r[5] = (1 - (p + m)) * R, r[6] = (M + w) * R, r[7] = 0, r[8] = (v + E) * L, r[9] = (M - w) * L, r[10] = (1 - (p + S)) * L, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Du.set(r[0], r[1], r[2]).length();
    const o = Du.set(r[4], r[5], r[6]).length(), a = Du.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], ms.copy(this);
    const f = 1 / s, h = 1 / o, d = 1 / a;
    return ms.elements[0] *= f, ms.elements[1] *= f, ms.elements[2] *= f, ms.elements[4] *= h, ms.elements[5] *= h, ms.elements[6] *= h, ms.elements[8] *= d, ms.elements[9] *= d, ms.elements[10] *= d, t.setFromRotationMatrix(ms), i.x = s, i.y = o, i.z = a, this;
  }
  makePerspective(e, t, i, r, s, o, a = Ys) {
    const l = this.elements, f = 2 * s / (t - e), h = 2 * s / (i - r), d = (t + e) / (t - e), p = (i + r) / (i - r);
    let g, v;
    if (a === Ys) g = -(o + s) / (o - s), v = -2 * o * s / (o - s);
    else if (a === cd) g = -o / (o - s), v = -o * s / (o - s);
    else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
    return l[0] = f, l[4] = 0, l[8] = d, l[12] = 0, l[1] = 0, l[5] = h, l[9] = p, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = g, l[14] = v, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
  }
  makeOrthographic(e, t, i, r, s, o, a = Ys) {
    const l = this.elements, f = 1 / (t - e), h = 1 / (i - r), d = 1 / (o - s), p = (t + e) * f, g = (i + r) * h;
    let v, S;
    if (a === Ys) v = (o + s) * d, S = -2 * d;
    else if (a === cd) v = s * d, S = -1 * d;
    else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
    return l[0] = 2 * f, l[4] = 0, l[8] = 0, l[12] = -p, l[1] = 0, l[5] = 2 * h, l[9] = 0, l[13] = -g, l[2] = 0, l[6] = 0, l[10] = S, l[14] = -v, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
  }
  equals(e) {
    const t = this.elements, i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return false;
    return true;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
  }
}
const Du = new V(), ms = new lt(), _V = new V(0, 0, 0), vV = new V(1, 1, 1), ia = new V(), xm = new V(), _r = new V(), Xb = new lt(), jb = new rr();
class Vd {
  constructor(e = 0, t = 0, i = 0, r = Vd.DEFAULT_ORDER) {
    this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = r;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  setFromRotationMatrix(e, t = this._order, i = true) {
    const r = e.elements, s = r[0], o = r[4], a = r[8], l = r[1], f = r[5], h = r[9], d = r[2], p = r[6], g = r[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(wn(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(-h, g), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(p, f), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-wn(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._y = Math.atan2(a, g), this._z = Math.atan2(l, f)) : (this._y = Math.atan2(-d, s), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(wn(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._y = Math.atan2(-d, g), this._z = Math.atan2(-o, f)) : (this._y = 0, this._z = Math.atan2(l, s));
        break;
      case "ZYX":
        this._y = Math.asin(-wn(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._x = Math.atan2(p, g), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, f));
        break;
      case "YZX":
        this._z = Math.asin(wn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-h, f), this._y = Math.atan2(-d, s)) : (this._x = 0, this._y = Math.atan2(a, g));
        break;
      case "XZY":
        this._z = Math.asin(-wn(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(p, f), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-h, g), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, i === true && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return Xb.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Xb, t, i);
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return jb.setFromEuler(this), this.setFromQuaternion(jb, e);
  }
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
Vd.DEFAULT_ORDER = "XYZ";
class kl {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let yV = 0;
const $b = new V(), Ou = new rr(), _o = new lt(), Sm = new V(), jf = new V(), xV = new V(), SV = new rr(), Yb = new V(1, 0, 0), qb = new V(0, 1, 0), Kb = new V(0, 0, 1), MV = { type: "added" }, wV = { type: "removed" };
class Ot extends Go {
  constructor() {
    super(), this.isObject3D = true, Object.defineProperty(this, "id", { value: yV++ }), this.uuid = Rr(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Ot.DEFAULT_UP.clone();
    const e = new V(), t = new Vd(), i = new rr(), r = new V(1, 1, 1);
    function s() {
      i.setFromEuler(t, false);
    }
    function o() {
      t.setFromQuaternion(i, void 0, false);
    }
    t._onChange(s), i._onChange(o), Object.defineProperties(this, { position: { configurable: true, enumerable: true, value: e }, rotation: { configurable: true, enumerable: true, value: t }, quaternion: { configurable: true, enumerable: true, value: i }, scale: { configurable: true, enumerable: true, value: r }, modelViewMatrix: { value: new lt() }, normalMatrix: { value: new Mt() } }), this.matrix = new lt(), this.matrixWorld = new lt(), this.matrixAutoUpdate = Ot.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Ot.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new kl(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
  }
  onBeforeShadow() {
  }
  onAfterShadow() {
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, true);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ou.setFromAxisAngle(e, t), this.quaternion.multiply(Ou), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ou.setFromAxisAngle(e, t), this.quaternion.premultiply(Ou), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Yb, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(qb, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Kb, e);
  }
  translateOnAxis(e, t) {
    return $b.copy(e).applyQuaternion(this.quaternion), this.position.add($b.multiplyScalar(t)), this;
  }
  translateX(e) {
    return this.translateOnAxis(Yb, e);
  }
  translateY(e) {
    return this.translateOnAxis(qb, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Kb, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return this.updateWorldMatrix(true, false), e.applyMatrix4(_o.copy(this.matrixWorld).invert());
  }
  lookAt(e, t, i) {
    e.isVector3 ? Sm.copy(e) : Sm.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(true, false), jf.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _o.lookAt(jf, Sm, this.up) : _o.lookAt(Sm, jf, this.up), this.quaternion.setFromRotationMatrix(_o), r && (_o.extractRotation(r.matrixWorld), Ou.setFromRotationMatrix(_o), this.quaternion.premultiply(Ou.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.parent !== null && e.parent.remove(e), e.parent = this, this.children.push(e), e.dispatchEvent(MV)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(wV)), this;
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return this.updateWorldMatrix(true, false), _o.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), _o.multiply(e.parent.matrixWorld)), e.applyMatrix4(_o), this.add(e), e.updateWorldMatrix(false, true), this;
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t, i = []) {
    this[e] === t && i.push(this);
    const r = this.children;
    for (let s = 0, o = r.length; s < o; s++) r[s].getObjectsByProperty(e, t, i);
    return i;
  }
  getWorldPosition(e) {
    return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(jf, e, xV), e;
  }
  getWorldScale(e) {
    return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(jf, SV, e), e;
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(true, false);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {
  }
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === false) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = false, e = true);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === true || e === true) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (e === true && i !== null && i.matrixWorldAutoUpdate === true && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), t === true) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === true && a.updateWorldMatrix(false, true);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", i = {};
    t && (e = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, i.metadata = { version: 4.6, type: "Object", generator: "Object3D.toJSON" });
    const r = {};
    r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === true && (r.castShadow = true), this.receiveShadow === true && (r.receiveShadow = true), this.visible === false && (r.visible = false), this.frustumCulled === false && (r.frustumCulled = false), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === false && (r.matrixAutoUpdate = false), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((a) => ({ boxInitialized: a.boxInitialized, boxMin: a.box.min.toArray(), boxMax: a.box.max.toArray(), sphereInitialized: a.sphereInitialized, sphereRadius: a.sphere.radius, sphereCenter: a.sphere.center.toArray() })), r.maxGeometryCount = this._maxGeometryCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this.boundingSphere !== null && (r.boundingSphere = { center: r.boundingSphere.center.toArray(), radius: r.boundingSphere.radius }), this.boundingBox !== null && (r.boundingBox = { min: r.boundingBox.min.toArray(), max: r.boundingBox.max.toArray() }));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l)) for (let f = 0, h = l.length; f < h; f++) {
          const d = l[f];
          s(e.shapes, d);
        }
        else s(e.shapes, l);
      }
    }
    if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
      const a = [];
      for (let l = 0, f = this.material.length; l < f; l++) a.push(s(e.materials, this.material[l]));
      r.material = a;
    } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++) r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries), l = o(e.materials), f = o(e.textures), h = o(e.images), d = o(e.shapes), p = o(e.skeletons), g = o(e.animations), v = o(e.nodes);
      a.length > 0 && (i.geometries = a), l.length > 0 && (i.materials = l), f.length > 0 && (i.textures = f), h.length > 0 && (i.images = h), d.length > 0 && (i.shapes = d), p.length > 0 && (i.skeletons = p), g.length > 0 && (i.animations = g), v.length > 0 && (i.nodes = v);
    }
    return i.object = r, i;
    function o(a) {
      const l = [];
      for (const f in a) {
        const h = a[f];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = true) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
      const r = e.children[i];
      this.add(r.clone());
    }
    return this;
  }
}
Ot.DEFAULT_UP = new V(0, 1, 0);
Ot.DEFAULT_MATRIX_AUTO_UPDATE = true;
Ot.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
const gs = new V(), vo = new V(), qy = new V(), yo = new V(), Uu = new V(), ku = new V(), Zb = new V(), Ky = new V(), Zy = new V(), Jy = new V();
class wr {
  constructor(e = new V(), t = new V(), i = new V()) {
    this.a = e, this.b = t, this.c = i;
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), gs.subVectors(e, t), r.cross(gs);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    gs.subVectors(r, t), vo.subVectors(i, t), qy.subVectors(e, t);
    const o = gs.dot(gs), a = gs.dot(vo), l = gs.dot(qy), f = vo.dot(vo), h = vo.dot(qy), d = o * f - a * a;
    if (d === 0) return s.set(0, 0, 0), null;
    const p = 1 / d, g = (f * l - a * h) * p, v = (o * h - a * l) * p;
    return s.set(1 - g - v, v, g);
  }
  static containsPoint(e, t, i, r) {
    return this.getBarycoord(e, t, i, r, yo) === null ? false : yo.x >= 0 && yo.y >= 0 && yo.x + yo.y <= 1;
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return this.getBarycoord(e, t, i, r, yo) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, yo.x), l.addScaledVector(o, yo.y), l.addScaledVector(a, yo.z), l);
  }
  static isFrontFacing(e, t, i, r) {
    return gs.subVectors(i, t), vo.subVectors(e, t), gs.cross(vo).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return gs.subVectors(this.c, this.b), vo.subVectors(this.a, this.b), gs.cross(vo).length() * 0.5;
  }
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return wr.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return wr.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getInterpolation(e, t, i, r, s) {
    return wr.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return wr.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return wr.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a, r = this.b, s = this.c;
    let o, a;
    Uu.subVectors(r, i), ku.subVectors(s, i), Ky.subVectors(e, i);
    const l = Uu.dot(Ky), f = ku.dot(Ky);
    if (l <= 0 && f <= 0) return t.copy(i);
    Zy.subVectors(e, r);
    const h = Uu.dot(Zy), d = ku.dot(Zy);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = l * d - h * f;
    if (p <= 0 && l >= 0 && h <= 0) return o = l / (l - h), t.copy(i).addScaledVector(Uu, o);
    Jy.subVectors(e, s);
    const g = Uu.dot(Jy), v = ku.dot(Jy);
    if (v >= 0 && g <= v) return t.copy(s);
    const S = g * f - l * v;
    if (S <= 0 && f >= 0 && v <= 0) return a = f / (f - v), t.copy(i).addScaledVector(ku, a);
    const M = h * v - g * d;
    if (M <= 0 && d - h >= 0 && g - v >= 0) return Zb.subVectors(s, r), a = (d - h) / (d - h + (g - v)), t.copy(r).addScaledVector(Zb, a);
    const m = 1 / (M + S + p);
    return o = S * m, a = p * m, t.copy(i).addScaledVector(Uu, o).addScaledVector(ku, a);
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const mI = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, ra = { h: 0, s: 0, l: 0 }, Mm = { h: 0, s: 0, l: 0 };
function Qy(n24, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n24 + (e - n24) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n24 + (e - n24) * 6 * (2 / 3 - t) : n24;
}
class Ve {
  constructor(e, t, i) {
    return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
  }
  set(e, t, i) {
    if (t === void 0 && i === void 0) {
      const r = e;
      r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  setHex(e, t = Xn) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ht.toWorkingColorSpace(this, t), this;
  }
  setRGB(e, t, i, r = Ht.workingColorSpace) {
    return this.r = e, this.g = t, this.b = i, Ht.toWorkingColorSpace(this, r), this;
  }
  setHSL(e, t, i, r = Ht.workingColorSpace) {
    if (e = Aw(e, 1), t = wn(t, 0, 1), i = wn(i, 0, 1), t === 0) this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, o = 2 * i - s;
      this.r = Qy(o, s, e + 1 / 3), this.g = Qy(o, s, e), this.b = Qy(o, s, e - 1 / 3);
    }
    return Ht.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Xn) {
    function i(s) {
      s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let r;
    if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let s;
      const o = r[1], a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
          if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
          break;
        case "hsl":
        case "hsla":
          if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const s = r[1], o = s.length;
      if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Xn) {
    const i = mI[e.toLowerCase()];
    return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copySRGBToLinear(e) {
    return this.r = Pc(e.r), this.g = Pc(e.g), this.b = Pc(e.b), this;
  }
  copyLinearToSRGB(e) {
    return this.r = Vy(e.r), this.g = Vy(e.g), this.b = Vy(e.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Xn) {
    return Ht.fromWorkingColorSpace(Mi.copy(this), e), Math.round(wn(Mi.r * 255, 0, 255)) * 65536 + Math.round(wn(Mi.g * 255, 0, 255)) * 256 + Math.round(wn(Mi.b * 255, 0, 255));
  }
  getHexString(e = Xn) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Ht.workingColorSpace) {
    Ht.fromWorkingColorSpace(Mi.copy(this), t);
    const i = Mi.r, r = Mi.g, s = Mi.b, o = Math.max(i, r, s), a = Math.min(i, r, s);
    let l, f;
    const h = (a + o) / 2;
    if (a === o) l = 0, f = 0;
    else {
      const d = o - a;
      switch (f = h <= 0.5 ? d / (o + a) : d / (2 - o - a), o) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return e.h = l, e.s = f, e.l = h, e;
  }
  getRGB(e, t = Ht.workingColorSpace) {
    return Ht.fromWorkingColorSpace(Mi.copy(this), t), e.r = Mi.r, e.g = Mi.g, e.b = Mi.b, e;
  }
  getStyle(e = Xn) {
    Ht.fromWorkingColorSpace(Mi.copy(this), e);
    const t = Mi.r, i = Mi.g, r = Mi.b;
    return e !== Xn ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
  }
  offsetHSL(e, t, i) {
    return this.getHSL(ra), this.setHSL(ra.h + e, ra.s + t, ra.l + i);
  }
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  lerpColors(e, t, i) {
    return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
  }
  lerpHSL(e, t) {
    this.getHSL(ra), e.getHSL(Mm);
    const i = Th(ra.h, Mm.h, t), r = Th(ra.s, Mm.s, t), s = Th(ra.l, Mm.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  applyMatrix3(e) {
    const t = this.r, i = this.g, r = this.b, s = e.elements;
    return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this;
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Mi = new Ve();
Ve.NAMES = mI;
let EV = 0;
class Ii extends Go {
  constructor() {
    super(), this.isMaterial = true, Object.defineProperty(this, "id", { value: EV++ }), this.uuid = Rr(), this.name = "", this.type = "Material", this.blending = Dl, this.side = ko, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = f0, this.blendDst = h0, this.blendEquation = pa, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ve(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Jh, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = vS, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = _l, this.stencilZFail = _l, this.stencilZPass = _l, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0) for (const t in e) {
      const i = e[t];
      if (i === void 0) {
        console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
        continue;
      }
      const r = this[t];
      if (r === void 0) {
        console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
        continue;
      }
      r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i;
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = { metadata: { version: 4.6, type: "Material", generator: "Material.toJSON" } };
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Dl && (i.blending = this.blending), this.side !== ko && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== f0 && (i.blendSrc = this.blendSrc), this.blendDst !== h0 && (i.blendDst = this.blendDst), this.blendEquation !== pa && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Jh && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== vS && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== _l && (i.stencilFail = this.stencilFail), this.stencilZFail !== _l && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== _l && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures), o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
}
class Wa extends Ii {
  constructor(e) {
    super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const To = TV();
function TV() {
  const n24 = new ArrayBuffer(4), e = new Float32Array(n24), t = new Uint32Array(n24), i = new Uint32Array(512), r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const f = l - 127;
    f < -27 ? (i[l] = 0, i[l | 256] = 32768, r[l] = 24, r[l | 256] = 24) : f < -14 ? (i[l] = 1024 >> -f - 14, i[l | 256] = 1024 >> -f - 14 | 32768, r[l] = -f - 1, r[l | 256] = -f - 1) : f <= 15 ? (i[l] = f + 15 << 10, i[l | 256] = f + 15 << 10 | 32768, r[l] = 13, r[l | 256] = 13) : f < 128 ? (i[l] = 31744, i[l | 256] = 64512, r[l] = 24, r[l | 256] = 24) : (i[l] = 31744, i[l | 256] = 64512, r[l] = 13, r[l | 256] = 13);
  }
  const s = new Uint32Array(2048), o = new Uint32Array(64), a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let f = l << 13, h = 0;
    for (; !(f & 8388608); ) f <<= 1, h -= 8388608;
    f &= -8388609, h += 947912704, s[l] = f | h;
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + (l - 1024 << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  o[31] = 1199570944, o[32] = 2147483648;
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return { floatView: e, uint32View: t, baseTable: i, shiftTable: r, mantissaTable: s, exponentTable: o, offsetTable: a };
}
function Ji(n24) {
  Math.abs(n24) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n24 = wn(n24, -65504, 65504), To.floatView[0] = n24;
  const e = To.uint32View[0], t = e >> 23 & 511;
  return To.baseTable[t] + ((e & 8388607) >> To.shiftTable[t]);
}
function uh(n24) {
  const e = n24 >> 10;
  return To.uint32View[0] = To.mantissaTable[To.offsetTable[e] + (n24 & 1023)] + To.exponentTable[e], To.floatView[0];
}
const AV = { toHalfFloat: Ji, fromHalfFloat: uh }, kn = new V(), wm = new _e();
class zt {
  constructor(e, t, i = false) {
    if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = true, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = ud, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.gpuType = ns, this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  get updateRange() {
    return Ul("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  copyAt(e, t, i) {
    e *= this.itemSize, i *= t.itemSize;
    for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) wm.fromBufferAttribute(this, t), wm.applyMatrix3(e), this.setXY(t, wm.x, wm.y);
    else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) kn.fromBufferAttribute(this, t), kn.applyMatrix3(e), this.setXYZ(t, kn.x, kn.y, kn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++) kn.fromBufferAttribute(this, t), kn.applyMatrix4(e), this.setXYZ(t, kn.x, kn.y, kn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) kn.fromBufferAttribute(this, t), kn.applyNormalMatrix(e), this.setXYZ(t, kn.x, kn.y, kn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) kn.fromBufferAttribute(this, t), kn.transformDirection(e), this.setXYZ(t, kn.x, kn.y, kn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Bi(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = vt(i, this.array)), this.array[e * this.itemSize + t] = i, this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array), s = vt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized };
    return this.name !== "" && (e.name = this.name), this.usage !== ud && (e.usage = this.usage), e;
  }
}
class bV extends zt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class CV extends zt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class RV extends zt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class PV extends zt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class Rw extends zt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class LV extends zt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class Pw extends zt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class IV extends zt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = true;
  }
  getX(e) {
    let t = uh(this.array[e * this.itemSize]);
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize] = Ji(t), this;
  }
  getY(e) {
    let t = uh(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 1] = Ji(t), this;
  }
  getZ(e) {
    let t = uh(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 2] = Ji(t), this;
  }
  getW(e) {
    let t = uh(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.array[e * this.itemSize + 3] = Ji(t), this;
  }
  setXY(e, t, i) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.array[e + 0] = Ji(t), this.array[e + 1] = Ji(i), this;
  }
  setXYZ(e, t, i, r) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array)), this.array[e + 0] = Ji(t), this.array[e + 1] = Ji(i), this.array[e + 2] = Ji(r), this;
  }
  setXYZW(e, t, i, r, s) {
    return e *= this.itemSize, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array), s = vt(s, this.array)), this.array[e + 0] = Ji(t), this.array[e + 1] = Ji(i), this.array[e + 2] = Ji(r), this.array[e + 3] = Ji(s), this;
  }
}
class Ye extends zt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class NV extends zt {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let DV = 0;
const Yr = new lt(), ex = new Ot(), Fu = new V(), vr = new Wi(), $f = new Wi(), ei = new V();
class xt extends Go {
  constructor() {
    super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", { value: DV++ }), this.uuid = Rr(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (hI(e) ? Pw : Rw)(e, 1) : this.index = e, this;
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new Mt().getNormalMatrix(e);
      i.applyNormalMatrix(s), i.needsUpdate = true;
    }
    const r = this.attributes.tangent;
    return r !== void 0 && (r.transformDirection(e), r.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  applyQuaternion(e) {
    return Yr.makeRotationFromQuaternion(e), this.applyMatrix4(Yr), this;
  }
  rotateX(e) {
    return Yr.makeRotationX(e), this.applyMatrix4(Yr), this;
  }
  rotateY(e) {
    return Yr.makeRotationY(e), this.applyMatrix4(Yr), this;
  }
  rotateZ(e) {
    return Yr.makeRotationZ(e), this.applyMatrix4(Yr), this;
  }
  translate(e, t, i) {
    return Yr.makeTranslation(e, t, i), this.applyMatrix4(Yr), this;
  }
  scale(e, t, i) {
    return Yr.makeScale(e, t, i), this.applyMatrix4(Yr), this;
  }
  lookAt(e) {
    return ex.lookAt(e), ex.updateMatrix(), this.applyMatrix4(ex.matrix), this;
  }
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(Fu).negate(), this.translate(Fu.x, Fu.y, Fu.z), this;
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ye(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Wi());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new V(-1 / 0, -1 / 0, -1 / 0), new V(1 / 0, 1 / 0, 1 / 0));
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, r = t.length; i < r; i++) {
        const s = t[i];
        vr.setFromBufferAttribute(s), this.morphTargetsRelative ? (ei.addVectors(this.boundingBox.min, vr.min), this.boundingBox.expandByPoint(ei), ei.addVectors(this.boundingBox.max, vr.max), this.boundingBox.expandByPoint(ei)) : (this.boundingBox.expandByPoint(vr.min), this.boundingBox.expandByPoint(vr.max));
      }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ri());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new V(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if (vr.setFromBufferAttribute(e), t) for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s];
        $f.setFromBufferAttribute(a), this.morphTargetsRelative ? (ei.addVectors(vr.min, $f.min), vr.expandByPoint(ei), ei.addVectors(vr.max, $f.max), vr.expandByPoint(ei)) : (vr.expandByPoint($f.min), vr.expandByPoint($f.max));
      }
      vr.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++) ei.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(ei));
      if (t) for (let s = 0, o = t.length; s < o; s++) {
        const a = t[s], l = this.morphTargetsRelative;
        for (let f = 0, h = a.count; f < h; f++) ei.fromBufferAttribute(a, f), l && (Fu.fromBufferAttribute(e, f), ei.add(Fu)), r = Math.max(r, i.distanceToSquared(ei));
      }
      this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const i = e.array, r = t.position.array, s = t.normal.array, o = t.uv.array, a = r.length / 3;
    this.hasAttribute("tangent") === false && this.setAttribute("tangent", new zt(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array, f = [], h = [];
    for (let C = 0; C < a; C++) f[C] = new V(), h[C] = new V();
    const d = new V(), p = new V(), g = new V(), v = new _e(), S = new _e(), M = new _e(), m = new V(), w = new V();
    function E(C, N, j) {
      d.fromArray(r, C * 3), p.fromArray(r, N * 3), g.fromArray(r, j * 3), v.fromArray(o, C * 2), S.fromArray(o, N * 2), M.fromArray(o, j * 2), p.sub(d), g.sub(d), S.sub(v), M.sub(v);
      const Z = 1 / (S.x * M.y - M.x * S.y);
      isFinite(Z) && (m.copy(p).multiplyScalar(M.y).addScaledVector(g, -S.y).multiplyScalar(Z), w.copy(g).multiplyScalar(S.x).addScaledVector(p, -M.x).multiplyScalar(Z), f[C].add(m), f[N].add(m), f[j].add(m), h[C].add(w), h[N].add(w), h[j].add(w));
    }
    let A = this.groups;
    A.length === 0 && (A = [{ start: 0, count: i.length }]);
    for (let C = 0, N = A.length; C < N; ++C) {
      const j = A[C], Z = j.start, G = j.count;
      for (let J = Z, q = Z + G; J < q; J += 3) E(i[J + 0], i[J + 1], i[J + 2]);
    }
    const P = new V(), R = new V(), L = new V(), D = new V();
    function F(C) {
      L.fromArray(s, C * 3), D.copy(L);
      const N = f[C];
      P.copy(N), P.sub(L.multiplyScalar(L.dot(N))).normalize(), R.crossVectors(D, N);
      const Z = R.dot(h[C]) < 0 ? -1 : 1;
      l[C * 4] = P.x, l[C * 4 + 1] = P.y, l[C * 4 + 2] = P.z, l[C * 4 + 3] = Z;
    }
    for (let C = 0, N = A.length; C < N; ++C) {
      const j = A[C], Z = j.start, G = j.count;
      for (let J = Z, q = Z + G; J < q; J += 3) F(i[J + 0]), F(i[J + 1]), F(i[J + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0) i = new zt(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
      else for (let p = 0, g = i.count; p < g; p++) i.setXYZ(p, 0, 0, 0);
      const r = new V(), s = new V(), o = new V(), a = new V(), l = new V(), f = new V(), h = new V(), d = new V();
      if (e) for (let p = 0, g = e.count; p < g; p += 3) {
        const v = e.getX(p + 0), S = e.getX(p + 1), M = e.getX(p + 2);
        r.fromBufferAttribute(t, v), s.fromBufferAttribute(t, S), o.fromBufferAttribute(t, M), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), a.fromBufferAttribute(i, v), l.fromBufferAttribute(i, S), f.fromBufferAttribute(i, M), a.add(h), l.add(h), f.add(h), i.setXYZ(v, a.x, a.y, a.z), i.setXYZ(S, l.x, l.y, l.z), i.setXYZ(M, f.x, f.y, f.z);
      }
      else for (let p = 0, g = t.count; p < g; p += 3) r.fromBufferAttribute(t, p + 0), s.fromBufferAttribute(t, p + 1), o.fromBufferAttribute(t, p + 2), h.subVectors(o, s), d.subVectors(r, s), h.cross(d), i.setXYZ(p + 0, h.x, h.y, h.z), i.setXYZ(p + 1, h.x, h.y, h.z), i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), i.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++) ei.fromBufferAttribute(e, t), ei.normalize(), e.setXYZ(t, ei.x, ei.y, ei.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const f = a.array, h = a.itemSize, d = a.normalized, p = new f.constructor(l.length * h);
      let g = 0, v = 0;
      for (let S = 0, M = l.length; S < M; S++) {
        a.isInterleavedBufferAttribute ? g = l[S] * a.data.stride + a.offset : g = l[S] * h;
        for (let m = 0; m < h; m++) p[v++] = f[g++];
      }
      return new zt(p, h, d);
    }
    if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new xt(), i = this.index.array, r = this.attributes;
    for (const a in r) {
      const l = r[a], f = e(l, i);
      t.setAttribute(a, f);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [], f = s[a];
      for (let h = 0, d = f.length; h < d; h++) {
        const p = f[h], g = e(p, i);
        l.push(g);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const f = o[a];
      t.addGroup(f.start, f.count, f.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const l = this.parameters;
      for (const f in l) l[f] !== void 0 && (e[f] = l[f]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = { type: t.array.constructor.name, array: Array.prototype.slice.call(t.array) });
    const i = this.attributes;
    for (const l in i) {
      const f = i[l];
      e.data.attributes[l] = f.toJSON(e.data);
    }
    const r = {};
    let s = false;
    for (const l in this.morphAttributes) {
      const f = this.morphAttributes[l], h = [];
      for (let d = 0, p = f.length; d < p; d++) {
        const g = f[d];
        h.push(g.toJSON(e.data));
      }
      h.length > 0 && (r[l] = h, s = true);
    }
    s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return a !== null && (e.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), e;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const f in r) {
      const h = r[f];
      this.setAttribute(f, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const f in s) {
      const h = [], d = s[f];
      for (let p = 0, g = d.length; p < g; p++) h.push(d[p].clone(t));
      this.morphAttributes[f] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let f = 0, h = o.length; f < h; f++) {
      const d = o[f];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Jb = new lt(), sl = new uf(), Em = new Ri(), Qb = new V(), zu = new V(), Bu = new V(), Vu = new V(), tx = new V(), Tm = new V(), Am = new _e(), bm = new _e(), Cm = new _e(), eC = new V(), tC = new V(), nC = new V(), Rm = new V(), Pm = new V();
class Hn extends Ot {
  constructor(e = new xt(), t = new Wa()) {
    super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      Tm.set(0, 0, 0);
      for (let l = 0, f = s.length; l < f; l++) {
        const h = a[l], d = s[l];
        h !== 0 && (tx.fromBufferAttribute(d, e), o ? Tm.addScaledVector(tx, h) : Tm.addScaledVector(tx.sub(t), h));
      }
      t.add(Tm);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.material, s = this.matrixWorld;
    r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Em.copy(i.boundingSphere), Em.applyMatrix4(s), sl.copy(e.ray).recast(e.near), !(Em.containsPoint(sl.origin) === false && (sl.intersectSphere(Em, Qb) === null || sl.origin.distanceToSquared(Qb) > (e.far - e.near) ** 2)) && (Jb.copy(s).invert(), sl.copy(e.ray).applyMatrix4(Jb), !(i.boundingBox !== null && sl.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, sl)));
  }
  _computeIntersections(e, t, i) {
    let r;
    const s = this.geometry, o = this.material, a = s.index, l = s.attributes.position, f = s.attributes.uv, h = s.attributes.uv1, d = s.attributes.normal, p = s.groups, g = s.drawRange;
    if (a !== null) if (Array.isArray(o)) for (let v = 0, S = p.length; v < S; v++) {
      const M = p[v], m = o[M.materialIndex], w = Math.max(M.start, g.start), E = Math.min(a.count, Math.min(M.start + M.count, g.start + g.count));
      for (let A = w, P = E; A < P; A += 3) {
        const R = a.getX(A), L = a.getX(A + 1), D = a.getX(A + 2);
        r = Lm(this, m, e, i, f, h, d, R, L, D), r && (r.faceIndex = Math.floor(A / 3), r.face.materialIndex = M.materialIndex, t.push(r));
      }
    }
    else {
      const v = Math.max(0, g.start), S = Math.min(a.count, g.start + g.count);
      for (let M = v, m = S; M < m; M += 3) {
        const w = a.getX(M), E = a.getX(M + 1), A = a.getX(M + 2);
        r = Lm(this, o, e, i, f, h, d, w, E, A), r && (r.faceIndex = Math.floor(M / 3), t.push(r));
      }
    }
    else if (l !== void 0) if (Array.isArray(o)) for (let v = 0, S = p.length; v < S; v++) {
      const M = p[v], m = o[M.materialIndex], w = Math.max(M.start, g.start), E = Math.min(l.count, Math.min(M.start + M.count, g.start + g.count));
      for (let A = w, P = E; A < P; A += 3) {
        const R = A, L = A + 1, D = A + 2;
        r = Lm(this, m, e, i, f, h, d, R, L, D), r && (r.faceIndex = Math.floor(A / 3), r.face.materialIndex = M.materialIndex, t.push(r));
      }
    }
    else {
      const v = Math.max(0, g.start), S = Math.min(l.count, g.start + g.count);
      for (let M = v, m = S; M < m; M += 3) {
        const w = M, E = M + 1, A = M + 2;
        r = Lm(this, o, e, i, f, h, d, w, E, A), r && (r.faceIndex = Math.floor(M / 3), t.push(r));
      }
    }
  }
}
function OV(n24, e, t, i, r, s, o, a) {
  let l;
  if (e.side === Gi ? l = i.intersectTriangle(o, s, r, true, a) : l = i.intersectTriangle(r, s, o, e.side === ko, a), l === null) return null;
  Pm.copy(a), Pm.applyMatrix4(n24.matrixWorld);
  const f = t.ray.origin.distanceTo(Pm);
  return f < t.near || f > t.far ? null : { distance: f, point: Pm.clone(), object: n24 };
}
function Lm(n24, e, t, i, r, s, o, a, l, f) {
  n24.getVertexPosition(a, zu), n24.getVertexPosition(l, Bu), n24.getVertexPosition(f, Vu);
  const h = OV(n24, e, t, i, zu, Bu, Vu, Rm);
  if (h) {
    r && (Am.fromBufferAttribute(r, a), bm.fromBufferAttribute(r, l), Cm.fromBufferAttribute(r, f), h.uv = wr.getInterpolation(Rm, zu, Bu, Vu, Am, bm, Cm, new _e())), s && (Am.fromBufferAttribute(s, a), bm.fromBufferAttribute(s, l), Cm.fromBufferAttribute(s, f), h.uv1 = wr.getInterpolation(Rm, zu, Bu, Vu, Am, bm, Cm, new _e()), h.uv2 = h.uv1), o && (eC.fromBufferAttribute(o, a), tC.fromBufferAttribute(o, l), nC.fromBufferAttribute(o, f), h.normal = wr.getInterpolation(Rm, zu, Bu, Vu, eC, tC, nC, new V()), h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: l, c: f, normal: new V(), materialIndex: 0 };
    wr.getNormal(zu, Bu, Vu, d.normal), h.face = d;
  }
  return h;
}
class nu extends xt {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(), this.type = "BoxGeometry", this.parameters = { width: e, height: t, depth: i, widthSegments: r, heightSegments: s, depthSegments: o };
    const a = this;
    r = Math.floor(r), s = Math.floor(s), o = Math.floor(o);
    const l = [], f = [], h = [], d = [];
    let p = 0, g = 0;
    v("z", "y", "x", -1, -1, i, t, e, o, s, 0), v("z", "y", "x", 1, -1, i, t, -e, o, s, 1), v("x", "z", "y", 1, 1, e, i, t, r, o, 2), v("x", "z", "y", 1, -1, e, i, -t, r, o, 3), v("x", "y", "z", 1, -1, e, t, i, r, s, 4), v("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new Ye(f, 3)), this.setAttribute("normal", new Ye(h, 3)), this.setAttribute("uv", new Ye(d, 2));
    function v(S, M, m, w, E, A, P, R, L, D, F) {
      const C = A / L, N = P / D, j = A / 2, Z = P / 2, G = R / 2, J = L + 1, q = D + 1;
      let ae = 0, B = 0;
      const Y = new V();
      for (let $ = 0; $ < q; $++) {
        const ee = $ * N - Z;
        for (let ue = 0; ue < J; ue++) {
          const Ae = ue * C - j;
          Y[S] = Ae * w, Y[M] = ee * E, Y[m] = G, f.push(Y.x, Y.y, Y.z), Y[S] = 0, Y[M] = 0, Y[m] = R > 0 ? 1 : -1, h.push(Y.x, Y.y, Y.z), d.push(ue / L), d.push(1 - $ / D), ae += 1;
        }
      }
      for (let $ = 0; $ < D; $++) for (let ee = 0; ee < L; ee++) {
        const ue = p + ee + J * $, Ae = p + ee + J * ($ + 1), te = p + (ee + 1) + J * ($ + 1), de = p + (ee + 1) + J * $;
        l.push(ue, Ae, de), l.push(Ae, te, de), B += 6;
      }
      a.addGroup(g, B, F), g += B, p += ae;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new nu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
function Wc(n24) {
  const e = {};
  for (const t in n24) {
    e[t] = {};
    for (const i in n24[t]) {
      const r = n24[t][i];
      r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
    }
  }
  return e;
}
function ki(n24) {
  const e = {};
  for (let t = 0; t < n24.length; t++) {
    const i = Wc(n24[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function UV(n24) {
  const e = [];
  for (let t = 0; t < n24.length; t++) e.push(n24[t].clone());
  return e;
}
function gI(n24) {
  return n24.getRenderTarget() === null ? n24.outputColorSpace : Ht.workingColorSpace;
}
const _I = { clone: Wc, merge: ki };
var kV = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, FV = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class bs extends Ii {
  constructor(e) {
    super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = kV, this.fragmentShader = FV, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = { derivatives: false, fragDepth: false, drawBuffers: false, shaderTextureLOD: false, clipCullDistance: false, multiDraw: false }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv1: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Wc(e.uniforms), this.uniformsGroups = UV(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture ? t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid } : o && o.isColor ? t.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? t.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? t.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? t.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? t.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? t.uniforms[r] = { type: "m4", value: o.toArray() } : t.uniforms[r] = { value: o };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const i = {};
    for (const r in this.extensions) this.extensions[r] === true && (i[r] = true);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Hd extends Ot {
  constructor() {
    super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new lt(), this.projectionMatrix = new lt(), this.projectionMatrixInverse = new lt(), this.coordinateSystem = Ys;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const sa = new V(), iC = new _e(), rC = new _e();
class ni extends Hd {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Gc * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Ol * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  getEffectiveFOV() {
    return Gc * 2 * Math.atan(Math.tan(Ol * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, t, i) {
    sa.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(sa.x, sa.y).multiplyScalar(-e / sa.z), sa.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(sa.x, sa.y).multiplyScalar(-e / sa.z);
  }
  getViewSize(e, t) {
    return this.getViewBounds(e, iC, rC), t.subVectors(rC, iC);
  }
  setViewOffset(e, t, i, r, s, o) {
    this.aspect = e / t, this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(Ol * 0.5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth, f = o.fullHeight;
      s += o.offsetX * r / l, t -= o.offsetY * i / f, r *= o.width / l, i *= o.height / f;
    }
    const a = this.filmOffset;
    a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
const Hu = -90, Gu = 1;
class vI extends Ot {
  constructor(e, t, i) {
    super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const r = new ni(Hu, Gu, e, t);
    r.layers = this.layers, this.add(r);
    const s = new ni(Hu, Gu, e, t);
    s.layers = this.layers, this.add(s);
    const o = new ni(Hu, Gu, e, t);
    o.layers = this.layers, this.add(o);
    const a = new ni(Hu, Gu, e, t);
    a.layers = this.layers, this.add(a);
    const l = new ni(Hu, Gu, e, t);
    l.layers = this.layers, this.add(l);
    const f = new ni(Hu, Gu, e, t);
    f.layers = this.layers, this.add(f);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [i, r, s, o, a, l] = t;
    for (const f of t) this.remove(f);
    if (e === Ys) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
    else if (e === cd) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
    else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const f of t) this.add(f), f.updateMatrixWorld();
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [s, o, a, l, f, h] = this.children, d = e.getRenderTarget(), p = e.getActiveCubeFace(), g = e.getActiveMipmapLevel(), v = e.xr.enabled;
    e.xr.enabled = false;
    const S = i.texture.generateMipmaps;
    i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, o), e.setRenderTarget(i, 2, r), e.render(t, a), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, f), i.texture.generateMipmaps = S, e.setRenderTarget(i, 5, r), e.render(t, h), e.setRenderTarget(d, p, g), e.xr.enabled = v, i.texture.needsPMREMUpdate = true;
  }
}
class Gd extends Tn {
  constructor(e, t, i, r, s, o, a, l, f, h) {
    e = e !== void 0 ? e : [], t = t !== void 0 ? t : Fo, super(e, t, i, r, s, o, a, l, f, h), this.isCubeTexture = true, this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class yI extends As {
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = true;
    const i = { width: e, height: e, depth: 1 }, r = [i, i, i, i, i, i];
    t.encoding !== void 0 && (Ul("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."), t.colorSpace = t.encoding === Pa ? Xn : Mr), this.texture = new Gd(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : fn;
  }
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const i = { uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			` }, r = new nu(5, 5, 5), s = new bs({ name: "CubemapFromEquirect", uniforms: Wc(i.uniforms), vertexShader: i.vertexShader, fragmentShader: i.fragmentShader, side: Gi, blending: Lo });
    s.uniforms.tEquirect.value = t;
    const o = new Hn(r, s), a = t.minFilter;
    return t.minFilter === $s && (t.minFilter = fn), new vI(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this;
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const nx = new V(), zV = new V(), BV = new Mt();
class ca {
  constructor(e = new V(1, 0, 0), t = 0) {
    this.isPlane = true, this.normal = e, this.constant = t;
  }
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), this.constant = r, this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = nx.subVectors(i, t).cross(zV.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(nx), r = this.normal.dot(i);
    if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
    return t < 0 && i > 0 || i < 0 && t > 0;
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || BV.getNormalMatrix(e), r = this.coplanarPoint(nx).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
    return this.constant = -r.dot(s), this;
  }
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ol = new Ri(), Im = new V();
class Wd {
  constructor(e = new ca(), t = new ca(), i = new ca(), r = new ca(), s = new ca(), o = new ca()) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return a[0].copy(e), a[1].copy(t), a[2].copy(i), a[3].copy(r), a[4].copy(s), a[5].copy(o), this;
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = Ys) {
    const i = this.planes, r = e.elements, s = r[0], o = r[1], a = r[2], l = r[3], f = r[4], h = r[5], d = r[6], p = r[7], g = r[8], v = r[9], S = r[10], M = r[11], m = r[12], w = r[13], E = r[14], A = r[15];
    if (i[0].setComponents(l - s, p - f, M - g, A - m).normalize(), i[1].setComponents(l + s, p + f, M + g, A + m).normalize(), i[2].setComponents(l + o, p + h, M + v, A + w).normalize(), i[3].setComponents(l - o, p - h, M - v, A - w).normalize(), i[4].setComponents(l - a, p - d, M - S, A - E).normalize(), t === Ys) i[5].setComponents(l + a, p + d, M + S, A + E).normalize();
    else if (t === cd) i[5].setComponents(a, d, S, E).normalize();
    else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), ol.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), ol.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ol);
  }
  intersectsSprite(e) {
    return ol.center.set(0, 0, 0), ol.radius = 0.7071067811865476, ol.applyMatrix4(e.matrixWorld), this.intersectsSphere(ol);
  }
  intersectsSphere(e) {
    const t = this.planes, i = e.center, r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return false;
    return true;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (Im.x = r.normal.x > 0 ? e.max.x : e.min.x, Im.y = r.normal.y > 0 ? e.max.y : e.min.y, Im.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Im) < 0) return false;
    }
    return true;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function xI() {
  let n24 = null, e = false, t = null, i = null;
  function r(s, o) {
    t(s, o), i = n24.requestAnimationFrame(r);
  }
  return { start: function() {
    e !== true && t !== null && (i = n24.requestAnimationFrame(r), e = true);
  }, stop: function() {
    n24.cancelAnimationFrame(i), e = false;
  }, setAnimationLoop: function(s) {
    t = s;
  }, setContext: function(s) {
    n24 = s;
  } };
}
function VV(n24, e) {
  const t = e.isWebGL2, i = /* @__PURE__ */ new WeakMap();
  function r(f, h) {
    const d = f.array, p = f.usage, g = d.byteLength, v = n24.createBuffer();
    n24.bindBuffer(h, v), n24.bufferData(h, d, p), f.onUploadCallback();
    let S;
    if (d instanceof Float32Array) S = n24.FLOAT;
    else if (d instanceof Uint16Array) if (f.isFloat16BufferAttribute) if (t) S = n24.HALF_FLOAT;
    else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
    else S = n24.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) S = n24.SHORT;
    else if (d instanceof Uint32Array) S = n24.UNSIGNED_INT;
    else if (d instanceof Int32Array) S = n24.INT;
    else if (d instanceof Int8Array) S = n24.BYTE;
    else if (d instanceof Uint8Array) S = n24.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) S = n24.UNSIGNED_BYTE;
    else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + d);
    return { buffer: v, type: S, bytesPerElement: d.BYTES_PER_ELEMENT, version: f.version, size: g };
  }
  function s(f, h, d) {
    const p = h.array, g = h._updateRange, v = h.updateRanges;
    if (n24.bindBuffer(d, f), g.count === -1 && v.length === 0 && n24.bufferSubData(d, 0, p), v.length !== 0) {
      for (let S = 0, M = v.length; S < M; S++) {
        const m = v[S];
        t ? n24.bufferSubData(d, m.start * p.BYTES_PER_ELEMENT, p, m.start, m.count) : n24.bufferSubData(d, m.start * p.BYTES_PER_ELEMENT, p.subarray(m.start, m.start + m.count));
      }
      h.clearUpdateRanges();
    }
    g.count !== -1 && (t ? n24.bufferSubData(d, g.offset * p.BYTES_PER_ELEMENT, p, g.offset, g.count) : n24.bufferSubData(d, g.offset * p.BYTES_PER_ELEMENT, p.subarray(g.offset, g.offset + g.count)), g.count = -1), h.onUploadCallback();
  }
  function o(f) {
    return f.isInterleavedBufferAttribute && (f = f.data), i.get(f);
  }
  function a(f) {
    f.isInterleavedBufferAttribute && (f = f.data);
    const h = i.get(f);
    h && (n24.deleteBuffer(h.buffer), i.delete(f));
  }
  function l(f, h) {
    if (f.isGLBufferAttribute) {
      const p = i.get(f);
      (!p || p.version < f.version) && i.set(f, { buffer: f.buffer, type: f.type, bytesPerElement: f.elementSize, version: f.version });
      return;
    }
    f.isInterleavedBufferAttribute && (f = f.data);
    const d = i.get(f);
    if (d === void 0) i.set(f, r(f, h));
    else if (d.version < f.version) {
      if (d.size !== f.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      s(d.buffer, f, h), d.version = f.version;
    }
  }
  return { get: o, remove: a, update: l };
}
class iu extends xt {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = { width: e, height: t, widthSegments: i, heightSegments: r };
    const s = e / 2, o = t / 2, a = Math.floor(i), l = Math.floor(r), f = a + 1, h = l + 1, d = e / a, p = t / l, g = [], v = [], S = [], M = [];
    for (let m = 0; m < h; m++) {
      const w = m * p - o;
      for (let E = 0; E < f; E++) {
        const A = E * d - s;
        v.push(A, -w, 0), S.push(0, 0, 1), M.push(E / a), M.push(1 - m / l);
      }
    }
    for (let m = 0; m < l; m++) for (let w = 0; w < a; w++) {
      const E = w + f * m, A = w + f * (m + 1), P = w + 1 + f * (m + 1), R = w + 1 + f * m;
      g.push(E, A, R), g.push(A, P, R);
    }
    this.setIndex(g), this.setAttribute("position", new Ye(v, 3)), this.setAttribute("normal", new Ye(S, 3)), this.setAttribute("uv", new Ye(M, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new iu(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var HV = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, GV = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, WV = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, XV = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, jV = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, $V = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, YV = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, qV = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, KV = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, ZV = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`, JV = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, QV = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, eH = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, tH = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, nH = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, iH = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, rH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, sH = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, oH = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, aH = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, lH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, uH = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, cH = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, fH = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, hH = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, dH = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, pH = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, mH = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, gH = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, _H = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, vH = "gl_FragColor = linearToOutputTexel( gl_FragColor );", yH = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`, xH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, SH = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, MH = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, wH = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, EH = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, TH = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, AH = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, bH = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, CH = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, RH = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, PH = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, LH = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, IH = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, NH = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, DH = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, OH = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, UH = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, kH = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, FH = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, zH = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, BH = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, VH = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, HH = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, GH = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, WH = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, XH = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, jH = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, $H = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, YH = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, qH = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, KH = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, ZH = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, JH = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, QH = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, eG = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, tG = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, nG = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, iG = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, rG = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, sG = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, oG = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, aG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, lG = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, uG = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, cG = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, fG = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, hG = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, dG = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, pG = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, mG = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, gG = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, _G = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, vG = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, yG = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, xG = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, SG = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, MG = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, wG = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, EG = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, TG = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, AG = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, bG = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, CG = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, RG = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, PG = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, LG = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, IG = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, NG = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, DG = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, OG = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, UG = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, kG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, FG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, zG = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, BG = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const VG = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, HG = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, GG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, WG = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, XG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, jG = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, $G = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, YG = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, qG = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, KG = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, ZG = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, JG = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, QG = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, e6 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, t6 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, n6 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, i6 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, r6 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, s6 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, o6 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, a6 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, l6 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, u6 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, c6 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, f6 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, h6 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, d6 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, p6 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, m6 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, g6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, _6 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, v6 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, y6 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, x6 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, yt = { alphahash_fragment: HV, alphahash_pars_fragment: GV, alphamap_fragment: WV, alphamap_pars_fragment: XV, alphatest_fragment: jV, alphatest_pars_fragment: $V, aomap_fragment: YV, aomap_pars_fragment: qV, batching_pars_vertex: KV, batching_vertex: ZV, begin_vertex: JV, beginnormal_vertex: QV, bsdfs: eH, iridescence_fragment: tH, bumpmap_pars_fragment: nH, clipping_planes_fragment: iH, clipping_planes_pars_fragment: rH, clipping_planes_pars_vertex: sH, clipping_planes_vertex: oH, color_fragment: aH, color_pars_fragment: lH, color_pars_vertex: uH, color_vertex: cH, common: fH, cube_uv_reflection_fragment: hH, defaultnormal_vertex: dH, displacementmap_pars_vertex: pH, displacementmap_vertex: mH, emissivemap_fragment: gH, emissivemap_pars_fragment: _H, colorspace_fragment: vH, colorspace_pars_fragment: yH, envmap_fragment: xH, envmap_common_pars_fragment: SH, envmap_pars_fragment: MH, envmap_pars_vertex: wH, envmap_physical_pars_fragment: OH, envmap_vertex: EH, fog_vertex: TH, fog_pars_vertex: AH, fog_fragment: bH, fog_pars_fragment: CH, gradientmap_pars_fragment: RH, lightmap_fragment: PH, lightmap_pars_fragment: LH, lights_lambert_fragment: IH, lights_lambert_pars_fragment: NH, lights_pars_begin: DH, lights_toon_fragment: UH, lights_toon_pars_fragment: kH, lights_phong_fragment: FH, lights_phong_pars_fragment: zH, lights_physical_fragment: BH, lights_physical_pars_fragment: VH, lights_fragment_begin: HH, lights_fragment_maps: GH, lights_fragment_end: WH, logdepthbuf_fragment: XH, logdepthbuf_pars_fragment: jH, logdepthbuf_pars_vertex: $H, logdepthbuf_vertex: YH, map_fragment: qH, map_pars_fragment: KH, map_particle_fragment: ZH, map_particle_pars_fragment: JH, metalnessmap_fragment: QH, metalnessmap_pars_fragment: eG, morphcolor_vertex: tG, morphnormal_vertex: nG, morphtarget_pars_vertex: iG, morphtarget_vertex: rG, normal_fragment_begin: sG, normal_fragment_maps: oG, normal_pars_fragment: aG, normal_pars_vertex: lG, normal_vertex: uG, normalmap_pars_fragment: cG, clearcoat_normal_fragment_begin: fG, clearcoat_normal_fragment_maps: hG, clearcoat_pars_fragment: dG, iridescence_pars_fragment: pG, opaque_fragment: mG, packing: gG, premultiplied_alpha_fragment: _G, project_vertex: vG, dithering_fragment: yG, dithering_pars_fragment: xG, roughnessmap_fragment: SG, roughnessmap_pars_fragment: MG, shadowmap_pars_fragment: wG, shadowmap_pars_vertex: EG, shadowmap_vertex: TG, shadowmask_pars_fragment: AG, skinbase_vertex: bG, skinning_pars_vertex: CG, skinning_vertex: RG, skinnormal_vertex: PG, specularmap_fragment: LG, specularmap_pars_fragment: IG, tonemapping_fragment: NG, tonemapping_pars_fragment: DG, transmission_fragment: OG, transmission_pars_fragment: UG, uv_pars_fragment: kG, uv_pars_vertex: FG, uv_vertex: zG, worldpos_vertex: BG, background_vert: VG, background_frag: HG, backgroundCube_vert: GG, backgroundCube_frag: WG, cube_vert: XG, cube_frag: jG, depth_vert: $G, depth_frag: YG, distanceRGBA_vert: qG, distanceRGBA_frag: KG, equirect_vert: ZG, equirect_frag: JG, linedashed_vert: QG, linedashed_frag: e6, meshbasic_vert: t6, meshbasic_frag: n6, meshlambert_vert: i6, meshlambert_frag: r6, meshmatcap_vert: s6, meshmatcap_frag: o6, meshnormal_vert: a6, meshnormal_frag: l6, meshphong_vert: u6, meshphong_frag: c6, meshphysical_vert: f6, meshphysical_frag: h6, meshtoon_vert: d6, meshtoon_frag: p6, points_vert: m6, points_frag: g6, shadow_vert: _6, shadow_frag: v6, sprite_vert: y6, sprite_frag: x6 }, Pe = { common: { diffuse: { value: new Ve(16777215) }, opacity: { value: 1 }, map: { value: null }, mapTransform: { value: new Mt() }, alphaMap: { value: null }, alphaMapTransform: { value: new Mt() }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null }, specularMapTransform: { value: new Mt() } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: 0.98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 }, aoMapTransform: { value: new Mt() } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 }, lightMapTransform: { value: new Mt() } }, bumpmap: { bumpMap: { value: null }, bumpMapTransform: { value: new Mt() }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalMapTransform: { value: new Mt() }, normalScale: { value: new _e(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementMapTransform: { value: new Mt() }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, emissivemap: { emissiveMap: { value: null }, emissiveMapTransform: { value: new Mt() } }, metalnessmap: { metalnessMap: { value: null }, metalnessMapTransform: { value: new Mt() } }, roughnessmap: { roughnessMap: { value: null }, roughnessMapTransform: { value: new Mt() } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Ve(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Ve(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaMapTransform: { value: new Mt() }, alphaTest: { value: 0 }, uvTransform: { value: new Mt() } }, sprite: { diffuse: { value: new Ve(16777215) }, opacity: { value: 1 }, center: { value: new _e(0.5, 0.5) }, rotation: { value: 0 }, map: { value: null }, mapTransform: { value: new Mt() }, alphaMap: { value: null }, alphaMapTransform: { value: new Mt() }, alphaTest: { value: 0 } } }, Ss = { basic: { uniforms: ki([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.fog]), vertexShader: yt.meshbasic_vert, fragmentShader: yt.meshbasic_frag }, lambert: { uniforms: ki([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, Pe.lights, { emissive: { value: new Ve(0) } }]), vertexShader: yt.meshlambert_vert, fragmentShader: yt.meshlambert_frag }, phong: { uniforms: ki([Pe.common, Pe.specularmap, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, Pe.lights, { emissive: { value: new Ve(0) }, specular: { value: new Ve(1118481) }, shininess: { value: 30 } }]), vertexShader: yt.meshphong_vert, fragmentShader: yt.meshphong_frag }, standard: { uniforms: ki([Pe.common, Pe.envmap, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.roughnessmap, Pe.metalnessmap, Pe.fog, Pe.lights, { emissive: { value: new Ve(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: yt.meshphysical_vert, fragmentShader: yt.meshphysical_frag }, toon: { uniforms: ki([Pe.common, Pe.aomap, Pe.lightmap, Pe.emissivemap, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.gradientmap, Pe.fog, Pe.lights, { emissive: { value: new Ve(0) } }]), vertexShader: yt.meshtoon_vert, fragmentShader: yt.meshtoon_frag }, matcap: { uniforms: ki([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, Pe.fog, { matcap: { value: null } }]), vertexShader: yt.meshmatcap_vert, fragmentShader: yt.meshmatcap_frag }, points: { uniforms: ki([Pe.points, Pe.fog]), vertexShader: yt.points_vert, fragmentShader: yt.points_frag }, dashed: { uniforms: ki([Pe.common, Pe.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: yt.linedashed_vert, fragmentShader: yt.linedashed_frag }, depth: { uniforms: ki([Pe.common, Pe.displacementmap]), vertexShader: yt.depth_vert, fragmentShader: yt.depth_frag }, normal: { uniforms: ki([Pe.common, Pe.bumpmap, Pe.normalmap, Pe.displacementmap, { opacity: { value: 1 } }]), vertexShader: yt.meshnormal_vert, fragmentShader: yt.meshnormal_frag }, sprite: { uniforms: ki([Pe.sprite, Pe.fog]), vertexShader: yt.sprite_vert, fragmentShader: yt.sprite_frag }, background: { uniforms: { uvTransform: { value: new Mt() }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: yt.background_vert, fragmentShader: yt.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: yt.backgroundCube_vert, fragmentShader: yt.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: yt.cube_vert, fragmentShader: yt.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: yt.equirect_vert, fragmentShader: yt.equirect_frag }, distanceRGBA: { uniforms: ki([Pe.common, Pe.displacementmap, { referencePosition: { value: new V() }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: yt.distanceRGBA_vert, fragmentShader: yt.distanceRGBA_frag }, shadow: { uniforms: ki([Pe.lights, Pe.fog, { color: { value: new Ve(0) }, opacity: { value: 1 } }]), vertexShader: yt.shadow_vert, fragmentShader: yt.shadow_frag } };
Ss.physical = { uniforms: ki([Ss.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatMapTransform: { value: new Mt() }, clearcoatNormalMap: { value: null }, clearcoatNormalMapTransform: { value: new Mt() }, clearcoatNormalScale: { value: new _e(1, 1) }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatRoughnessMapTransform: { value: new Mt() }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceMapTransform: { value: new Mt() }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, iridescenceThicknessMapTransform: { value: new Mt() }, sheen: { value: 0 }, sheenColor: { value: new Ve(0) }, sheenColorMap: { value: null }, sheenColorMapTransform: { value: new Mt() }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, sheenRoughnessMapTransform: { value: new Mt() }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionMapTransform: { value: new Mt() }, transmissionSamplerSize: { value: new _e() }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, thicknessMapTransform: { value: new Mt() }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Ve(0) }, specularColor: { value: new Ve(1, 1, 1) }, specularColorMap: { value: null }, specularColorMapTransform: { value: new Mt() }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularIntensityMapTransform: { value: new Mt() }, anisotropyVector: { value: new _e() }, anisotropyMap: { value: null }, anisotropyMapTransform: { value: new Mt() } }]), vertexShader: yt.meshphysical_vert, fragmentShader: yt.meshphysical_frag };
const Nm = { r: 0, b: 0, g: 0 };
function S6(n24, e, t, i, r, s, o) {
  const a = new Ve(0);
  let l = s === true ? 0 : 1, f, h, d = null, p = 0, g = null;
  function v(M, m) {
    let w = false, E = m.isScene === true ? m.background : null;
    E && E.isTexture && (E = (m.backgroundBlurriness > 0 ? t : e).get(E)), E === null ? S(a, l) : E && E.isColor && (S(E, 1), w = true);
    const A = n24.xr.getEnvironmentBlendMode();
    A === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, o) : A === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, o), (n24.autoClear || w) && n24.clear(n24.autoClearColor, n24.autoClearDepth, n24.autoClearStencil), E && (E.isCubeTexture || E.mapping === lf) ? (h === void 0 && (h = new Hn(new nu(1, 1, 1), new bs({ name: "BackgroundCubeMaterial", uniforms: Wc(Ss.backgroundCube.uniforms), vertexShader: Ss.backgroundCube.vertexShader, fragmentShader: Ss.backgroundCube.fragmentShader, side: Gi, depthTest: false, depthWrite: false, fog: false })), h.geometry.deleteAttribute("normal"), h.geometry.deleteAttribute("uv"), h.onBeforeRender = function(P, R, L) {
      this.matrixWorld.copyPosition(L.matrixWorld);
    }, Object.defineProperty(h.material, "envMap", { get: function() {
      return this.uniforms.envMap.value;
    } }), r.update(h)), h.material.uniforms.envMap.value = E, h.material.uniforms.flipEnvMap.value = E.isCubeTexture && E.isRenderTargetTexture === false ? -1 : 1, h.material.uniforms.backgroundBlurriness.value = m.backgroundBlurriness, h.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, h.material.toneMapped = Ht.getTransfer(E.colorSpace) !== Zt, (d !== E || p !== E.version || g !== n24.toneMapping) && (h.material.needsUpdate = true, d = E, p = E.version, g = n24.toneMapping), h.layers.enableAll(), M.unshift(h, h.geometry, h.material, 0, 0, null)) : E && E.isTexture && (f === void 0 && (f = new Hn(new iu(2, 2), new bs({ name: "BackgroundMaterial", uniforms: Wc(Ss.background.uniforms), vertexShader: Ss.background.vertexShader, fragmentShader: Ss.background.fragmentShader, side: ko, depthTest: false, depthWrite: false, fog: false })), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", { get: function() {
      return this.uniforms.t2D.value;
    } }), r.update(f)), f.material.uniforms.t2D.value = E, f.material.uniforms.backgroundIntensity.value = m.backgroundIntensity, f.material.toneMapped = Ht.getTransfer(E.colorSpace) !== Zt, E.matrixAutoUpdate === true && E.updateMatrix(), f.material.uniforms.uvTransform.value.copy(E.matrix), (d !== E || p !== E.version || g !== n24.toneMapping) && (f.material.needsUpdate = true, d = E, p = E.version, g = n24.toneMapping), f.layers.enableAll(), M.unshift(f, f.geometry, f.material, 0, 0, null));
  }
  function S(M, m) {
    M.getRGB(Nm, gI(n24)), i.buffers.color.setClear(Nm.r, Nm.g, Nm.b, m, o);
  }
  return { getClearColor: function() {
    return a;
  }, setClearColor: function(M, m = 1) {
    a.set(M), l = m, S(a, l);
  }, getClearAlpha: function() {
    return l;
  }, setClearAlpha: function(M) {
    l = M, S(a, l);
  }, render: v };
}
function M6(n24, e, t, i) {
  const r = n24.getParameter(n24.MAX_VERTEX_ATTRIBS), s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"), o = i.isWebGL2 || s !== null, a = {}, l = M(null);
  let f = l, h = false;
  function d(G, J, q, ae, B) {
    let Y = false;
    if (o) {
      const $ = S(ae, q, J);
      f !== $ && (f = $, g(f.object)), Y = m(G, ae, q, B), Y && w(G, ae, q, B);
    } else {
      const $ = J.wireframe === true;
      (f.geometry !== ae.id || f.program !== q.id || f.wireframe !== $) && (f.geometry = ae.id, f.program = q.id, f.wireframe = $, Y = true);
    }
    B !== null && t.update(B, n24.ELEMENT_ARRAY_BUFFER), (Y || h) && (h = false, D(G, J, q, ae), B !== null && n24.bindBuffer(n24.ELEMENT_ARRAY_BUFFER, t.get(B).buffer));
  }
  function p() {
    return i.isWebGL2 ? n24.createVertexArray() : s.createVertexArrayOES();
  }
  function g(G) {
    return i.isWebGL2 ? n24.bindVertexArray(G) : s.bindVertexArrayOES(G);
  }
  function v(G) {
    return i.isWebGL2 ? n24.deleteVertexArray(G) : s.deleteVertexArrayOES(G);
  }
  function S(G, J, q) {
    const ae = q.wireframe === true;
    let B = a[G.id];
    B === void 0 && (B = {}, a[G.id] = B);
    let Y = B[J.id];
    Y === void 0 && (Y = {}, B[J.id] = Y);
    let $ = Y[ae];
    return $ === void 0 && ($ = M(p()), Y[ae] = $), $;
  }
  function M(G) {
    const J = [], q = [], ae = [];
    for (let B = 0; B < r; B++) J[B] = 0, q[B] = 0, ae[B] = 0;
    return { geometry: null, program: null, wireframe: false, newAttributes: J, enabledAttributes: q, attributeDivisors: ae, object: G, attributes: {}, index: null };
  }
  function m(G, J, q, ae) {
    const B = f.attributes, Y = J.attributes;
    let $ = 0;
    const ee = q.getAttributes();
    for (const ue in ee) if (ee[ue].location >= 0) {
      const te = B[ue];
      let de = Y[ue];
      if (de === void 0 && (ue === "instanceMatrix" && G.instanceMatrix && (de = G.instanceMatrix), ue === "instanceColor" && G.instanceColor && (de = G.instanceColor)), te === void 0 || te.attribute !== de || de && te.data !== de.data) return true;
      $++;
    }
    return f.attributesNum !== $ || f.index !== ae;
  }
  function w(G, J, q, ae) {
    const B = {}, Y = J.attributes;
    let $ = 0;
    const ee = q.getAttributes();
    for (const ue in ee) if (ee[ue].location >= 0) {
      let te = Y[ue];
      te === void 0 && (ue === "instanceMatrix" && G.instanceMatrix && (te = G.instanceMatrix), ue === "instanceColor" && G.instanceColor && (te = G.instanceColor));
      const de = {};
      de.attribute = te, te && te.data && (de.data = te.data), B[ue] = de, $++;
    }
    f.attributes = B, f.attributesNum = $, f.index = ae;
  }
  function E() {
    const G = f.newAttributes;
    for (let J = 0, q = G.length; J < q; J++) G[J] = 0;
  }
  function A(G) {
    P(G, 0);
  }
  function P(G, J) {
    const q = f.newAttributes, ae = f.enabledAttributes, B = f.attributeDivisors;
    q[G] = 1, ae[G] === 0 && (n24.enableVertexAttribArray(G), ae[G] = 1), B[G] !== J && ((i.isWebGL2 ? n24 : e.get("ANGLE_instanced_arrays"))[i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](G, J), B[G] = J);
  }
  function R() {
    const G = f.newAttributes, J = f.enabledAttributes;
    for (let q = 0, ae = J.length; q < ae; q++) J[q] !== G[q] && (n24.disableVertexAttribArray(q), J[q] = 0);
  }
  function L(G, J, q, ae, B, Y, $) {
    $ === true ? n24.vertexAttribIPointer(G, J, q, B, Y) : n24.vertexAttribPointer(G, J, q, ae, B, Y);
  }
  function D(G, J, q, ae) {
    if (i.isWebGL2 === false && (G.isInstancedMesh || ae.isInstancedBufferGeometry) && e.get("ANGLE_instanced_arrays") === null) return;
    E();
    const B = ae.attributes, Y = q.getAttributes(), $ = J.defaultAttributeValues;
    for (const ee in Y) {
      const ue = Y[ee];
      if (ue.location >= 0) {
        let Ae = B[ee];
        if (Ae === void 0 && (ee === "instanceMatrix" && G.instanceMatrix && (Ae = G.instanceMatrix), ee === "instanceColor" && G.instanceColor && (Ae = G.instanceColor)), Ae !== void 0) {
          const te = Ae.normalized, de = Ae.itemSize, Ee = t.get(Ae);
          if (Ee === void 0) continue;
          const Ie = Ee.buffer, Ze = Ee.type, Oe = Ee.bytesPerElement, at = i.isWebGL2 === true && (Ze === n24.INT || Ze === n24.UNSIGNED_INT || Ae.gpuType === gw);
          if (Ae.isInterleavedBufferAttribute) {
            const Ge = Ae.data, X = Ge.stride, Se = Ae.offset;
            if (Ge.isInstancedInterleavedBuffer) {
              for (let pe = 0; pe < ue.locationSize; pe++) P(ue.location + pe, Ge.meshPerAttribute);
              G.isInstancedMesh !== true && ae._maxInstanceCount === void 0 && (ae._maxInstanceCount = Ge.meshPerAttribute * Ge.count);
            } else for (let pe = 0; pe < ue.locationSize; pe++) A(ue.location + pe);
            n24.bindBuffer(n24.ARRAY_BUFFER, Ie);
            for (let pe = 0; pe < ue.locationSize; pe++) L(ue.location + pe, de / ue.locationSize, Ze, te, X * Oe, (Se + de / ue.locationSize * pe) * Oe, at);
          } else {
            if (Ae.isInstancedBufferAttribute) {
              for (let Ge = 0; Ge < ue.locationSize; Ge++) P(ue.location + Ge, Ae.meshPerAttribute);
              G.isInstancedMesh !== true && ae._maxInstanceCount === void 0 && (ae._maxInstanceCount = Ae.meshPerAttribute * Ae.count);
            } else for (let Ge = 0; Ge < ue.locationSize; Ge++) A(ue.location + Ge);
            n24.bindBuffer(n24.ARRAY_BUFFER, Ie);
            for (let Ge = 0; Ge < ue.locationSize; Ge++) L(ue.location + Ge, de / ue.locationSize, Ze, te, de * Oe, de / ue.locationSize * Ge * Oe, at);
          }
        } else if ($ !== void 0) {
          const te = $[ee];
          if (te !== void 0) switch (te.length) {
            case 2:
              n24.vertexAttrib2fv(ue.location, te);
              break;
            case 3:
              n24.vertexAttrib3fv(ue.location, te);
              break;
            case 4:
              n24.vertexAttrib4fv(ue.location, te);
              break;
            default:
              n24.vertexAttrib1fv(ue.location, te);
          }
        }
      }
    }
    R();
  }
  function F() {
    j();
    for (const G in a) {
      const J = a[G];
      for (const q in J) {
        const ae = J[q];
        for (const B in ae) v(ae[B].object), delete ae[B];
        delete J[q];
      }
      delete a[G];
    }
  }
  function C(G) {
    if (a[G.id] === void 0) return;
    const J = a[G.id];
    for (const q in J) {
      const ae = J[q];
      for (const B in ae) v(ae[B].object), delete ae[B];
      delete J[q];
    }
    delete a[G.id];
  }
  function N(G) {
    for (const J in a) {
      const q = a[J];
      if (q[G.id] === void 0) continue;
      const ae = q[G.id];
      for (const B in ae) v(ae[B].object), delete ae[B];
      delete q[G.id];
    }
  }
  function j() {
    Z(), h = true, f !== l && (f = l, g(f.object));
  }
  function Z() {
    l.geometry = null, l.program = null, l.wireframe = false;
  }
  return { setup: d, reset: j, resetDefaultState: Z, dispose: F, releaseStatesOfGeometry: C, releaseStatesOfProgram: N, initAttributes: E, enableAttribute: A, disableUnusedAttributes: R };
}
function w6(n24, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(h) {
    s = h;
  }
  function a(h, d) {
    n24.drawArrays(s, h, d), t.update(d, s, 1);
  }
  function l(h, d, p) {
    if (p === 0) return;
    let g, v;
    if (r) g = n24, v = "drawArraysInstanced";
    else if (g = e.get("ANGLE_instanced_arrays"), v = "drawArraysInstancedANGLE", g === null) {
      console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    g[v](s, h, d, p), t.update(d, s, p);
  }
  function f(h, d, p) {
    if (p === 0) return;
    const g = e.get("WEBGL_multi_draw");
    if (g === null) for (let v = 0; v < p; v++) this.render(h[v], d[v]);
    else {
      g.multiDrawArraysWEBGL(s, h, 0, d, 0, p);
      let v = 0;
      for (let S = 0; S < p; S++) v += d[S];
      t.update(v, s, 1);
    }
  }
  this.setMode = o, this.render = a, this.renderInstances = l, this.renderMultiDraw = f;
}
function E6(n24, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === true) {
      const L = e.get("EXT_texture_filter_anisotropic");
      i = n24.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(L) {
    if (L === "highp") {
      if (n24.getShaderPrecisionFormat(n24.VERTEX_SHADER, n24.HIGH_FLOAT).precision > 0 && n24.getShaderPrecisionFormat(n24.FRAGMENT_SHADER, n24.HIGH_FLOAT).precision > 0) return "highp";
      L = "mediump";
    }
    return L === "mediump" && n24.getShaderPrecisionFormat(n24.VERTEX_SHADER, n24.MEDIUM_FLOAT).precision > 0 && n24.getShaderPrecisionFormat(n24.FRAGMENT_SHADER, n24.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
  }
  const o = typeof WebGL2RenderingContext < "u" && n24.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l);
  const f = o || e.has("WEBGL_draw_buffers"), h = t.logarithmicDepthBuffer === true, d = n24.getParameter(n24.MAX_TEXTURE_IMAGE_UNITS), p = n24.getParameter(n24.MAX_VERTEX_TEXTURE_IMAGE_UNITS), g = n24.getParameter(n24.MAX_TEXTURE_SIZE), v = n24.getParameter(n24.MAX_CUBE_MAP_TEXTURE_SIZE), S = n24.getParameter(n24.MAX_VERTEX_ATTRIBS), M = n24.getParameter(n24.MAX_VERTEX_UNIFORM_VECTORS), m = n24.getParameter(n24.MAX_VARYING_VECTORS), w = n24.getParameter(n24.MAX_FRAGMENT_UNIFORM_VECTORS), E = p > 0, A = o || e.has("OES_texture_float"), P = E && A, R = o ? n24.getParameter(n24.MAX_SAMPLES) : 0;
  return { isWebGL2: o, drawBuffers: f, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: h, maxTextures: d, maxVertexTextures: p, maxTextureSize: g, maxCubemapSize: v, maxAttributes: S, maxVertexUniforms: M, maxVaryings: m, maxFragmentUniforms: w, vertexTextures: E, floatFragmentTextures: A, floatVertexTextures: P, maxSamples: R };
}
function T6(n24) {
  const e = this;
  let t = null, i = 0, r = false, s = false;
  const o = new ca(), a = new Mt(), l = { value: null, needsUpdate: false };
  this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(d, p) {
    const g = d.length !== 0 || p || i !== 0 || r;
    return r = p, i = d.length, g;
  }, this.beginShadows = function() {
    s = true, h(null);
  }, this.endShadows = function() {
    s = false;
  }, this.setGlobalState = function(d, p) {
    t = h(d, p, 0);
  }, this.setState = function(d, p, g) {
    const v = d.clippingPlanes, S = d.clipIntersection, M = d.clipShadows, m = n24.get(d);
    if (!r || v === null || v.length === 0 || s && !M) s ? h(null) : f();
    else {
      const w = s ? 0 : i, E = w * 4;
      let A = m.clippingState || null;
      l.value = A, A = h(v, p, E, g);
      for (let P = 0; P !== E; ++P) A[P] = t[P];
      m.clippingState = A, this.numIntersection = S ? this.numPlanes : 0, this.numPlanes += w;
    }
  };
  function f() {
    l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
  }
  function h(d, p, g, v) {
    const S = d !== null ? d.length : 0;
    let M = null;
    if (S !== 0) {
      if (M = l.value, v !== true || M === null) {
        const m = g + S * 4, w = p.matrixWorldInverse;
        a.getNormalMatrix(w), (M === null || M.length < m) && (M = new Float32Array(m));
        for (let E = 0, A = g; E !== S; ++E, A += 4) o.copy(d[E]).applyMatrix4(w, a), o.normal.toArray(M, A), M[A + 3] = o.constant;
      }
      l.value = M, l.needsUpdate = true;
    }
    return e.numPlanes = S, e.numIntersection = 0, M;
  }
}
function A6(n24) {
  let e = /* @__PURE__ */ new WeakMap();
  function t(o, a) {
    return a === Qh ? o.mapping = Fo : a === ed && (o.mapping = Oa), o;
  }
  function i(o) {
    if (o && o.isTexture) {
      const a = o.mapping;
      if (a === Qh || a === ed) if (e.has(o)) {
        const l = e.get(o).texture;
        return t(l, o.mapping);
      } else {
        const l = o.image;
        if (l && l.height > 0) {
          const f = new yI(l.height);
          return f.fromEquirectangularTexture(n24, o), e.set(o, f), o.addEventListener("dispose", r), t(f.texture, o.mapping);
        } else return null;
      }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: s };
}
class Xd extends Hd {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null && (this.view = { enabled: true, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
    let s = i - e, o = i + e, a = r + t, l = r - t;
    if (this.view !== null && this.view.enabled) {
      const f = (this.right - this.left) / this.view.fullWidth / this.zoom, h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      s += f * this.view.offsetX, o = s + f * this.view.width, a -= h * this.view.offsetY, l = a - h * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const mc = 4, sC = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], Sl = 20, ix = new Xd(), oC = new Ve();
let rx = null, sx = 0, ox = 0;
const vl = (1 + Math.sqrt(5)) / 2, Wu = 1 / vl, aC = [new V(1, 1, 1), new V(-1, 1, 1), new V(1, 1, -1), new V(-1, 1, -1), new V(0, vl, Wu), new V(0, vl, -Wu), new V(Wu, 0, vl), new V(-Wu, 0, vl), new V(vl, Wu, 0), new V(-vl, Wu, 0)];
class MS {
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    rx = this._renderer.getRenderTarget(), sx = this._renderer.getActiveCubeFace(), ox = this._renderer.getActiveMipmapLevel(), this._setSize(256);
    const s = this._allocateTargets();
    return s.depthBuffer = true, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = cC(), this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = uC(), this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(rx, sx, ox), e.scissorTest = false, Dm(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Fo || e.mapping === Oa ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), rx = this._renderer.getRenderTarget(), sx = this._renderer.getActiveCubeFace(), ox = this._renderer.getActiveMipmapLevel();
    const i = t || this._allocateTargets();
    return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = { magFilter: fn, minFilter: fn, generateMipmaps: false, type: Hc, format: zi, colorSpace: so, depthBuffer: false }, r = lC(e, t, i);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = lC(e, t, i);
      const { _lodMax: s } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = b6(s)), this._blurMaterial = C6(s, e, t);
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Hn(this._lodPlanes[0], e);
    this._renderer.compile(t, ix);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new ni(90, 1, t, i), l = [1, -1, 1, 1, 1, 1], f = [1, 1, 1, -1, -1, -1], h = this._renderer, d = h.autoClear, p = h.toneMapping;
    h.getClearColor(oC), h.toneMapping = eo, h.autoClear = false;
    const g = new Wa({ name: "PMREM.Background", side: Gi, depthWrite: false, depthTest: false }), v = new Hn(new nu(), g);
    let S = false;
    const M = e.background;
    M ? M.isColor && (g.color.copy(M), e.background = null, S = true) : (g.color.copy(oC), S = true);
    for (let m = 0; m < 6; m++) {
      const w = m % 3;
      w === 0 ? (a.up.set(0, l[m], 0), a.lookAt(f[m], 0, 0)) : w === 1 ? (a.up.set(0, 0, l[m]), a.lookAt(0, f[m], 0)) : (a.up.set(0, l[m], 0), a.lookAt(0, 0, f[m]));
      const E = this._cubeSize;
      Dm(r, w * E, m > 2 ? E : 0, E, E), h.setRenderTarget(r), S && h.render(v, a), h.render(e, a);
    }
    v.geometry.dispose(), v.material.dispose(), h.toneMapping = p, h.autoClear = d, e.background = M;
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer, r = e.mapping === Fo || e.mapping === Oa;
    r ? (this._cubemapMaterial === null && (this._cubemapMaterial = cC()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = uC());
    const s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Hn(this._lodPlanes[0], s), a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    Dm(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, ix);
  }
  _applyPMREM(e) {
    const t = this._renderer, i = t.autoClear;
    t.autoClear = false;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = aC[(r - 1) % aC.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s), this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer, f = this._blurMaterial;
    o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const h = 3, d = new Hn(this._lodPlanes[r], f), p = f.uniforms, g = this._sizeLods[i] - 1, v = isFinite(s) ? Math.PI / (2 * g) : 2 * Math.PI / (2 * Sl - 1), S = s / v, M = isFinite(s) ? 1 + Math.floor(h * S) : Sl;
    M > Sl && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${M} samples when the maximum is set to ${Sl}`);
    const m = [];
    let w = 0;
    for (let L = 0; L < Sl; ++L) {
      const D = L / S, F = Math.exp(-D * D / 2);
      m.push(F), L === 0 ? w += F : L < M && (w += 2 * F);
    }
    for (let L = 0; L < m.length; L++) m[L] = m[L] / w;
    p.envMap.value = e.texture, p.samples.value = M, p.weights.value = m, p.latitudinal.value = o === "latitudinal", a && (p.poleAxis.value = a);
    const { _lodMax: E } = this;
    p.dTheta.value = v, p.mipInt.value = E - i;
    const A = this._sizeLods[r], P = 3 * A * (r > E - mc ? r - E + mc : 0), R = 4 * (this._cubeSize - A);
    Dm(t, P, R, 3 * A, 2 * A), l.setRenderTarget(t), l.render(d, ix);
  }
}
function b6(n24) {
  const e = [], t = [], i = [];
  let r = n24;
  const s = n24 - mc + 1 + sC.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n24 - mc ? l = sC[o - n24 + mc - 1] : o === 0 && (l = 0), i.push(l);
    const f = 1 / (a - 2), h = -f, d = 1 + f, p = [h, h, d, h, d, d, h, h, d, d, h, d], g = 6, v = 6, S = 3, M = 2, m = 1, w = new Float32Array(S * v * g), E = new Float32Array(M * v * g), A = new Float32Array(m * v * g);
    for (let R = 0; R < g; R++) {
      const L = R % 3 * 2 / 3 - 1, D = R > 2 ? 0 : -1, F = [L, D, 0, L + 2 / 3, D, 0, L + 2 / 3, D + 1, 0, L, D, 0, L + 2 / 3, D + 1, 0, L, D + 1, 0];
      w.set(F, S * v * R), E.set(p, M * v * R);
      const C = [R, R, R, R, R, R];
      A.set(C, m * v * R);
    }
    const P = new xt();
    P.setAttribute("position", new zt(w, S)), P.setAttribute("uv", new zt(E, M)), P.setAttribute("faceIndex", new zt(A, m)), e.push(P), r > mc && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function lC(n24, e, t) {
  const i = new As(n24, e, t);
  return i.texture.mapping = lf, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
}
function Dm(n24, e, t, i, r) {
  n24.viewport.set(e, t, i, r), n24.scissor.set(e, t, i, r);
}
function C6(n24, e, t) {
  const i = new Float32Array(Sl), r = new V(0, 1, 0);
  return new bs({ name: "SphericalGaussianBlur", defines: { n: Sl, CUBEUV_TEXEL_WIDTH: 1 / e, CUBEUV_TEXEL_HEIGHT: 1 / t, CUBEUV_MAX_MIP: `${n24}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: i }, latitudinal: { value: false }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: Lw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Lo, depthTest: false, depthWrite: false });
}
function uC() {
  return new bs({ name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Lw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Lo, depthTest: false, depthWrite: false });
}
function cC() {
  return new bs({ name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Lw(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Lo, depthTest: false, depthWrite: false });
}
function Lw() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function R6(n24) {
  let e = /* @__PURE__ */ new WeakMap(), t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping, f = l === Qh || l === ed, h = l === Fo || l === Oa;
      if (f || h) if (a.isRenderTargetTexture && a.needsPMREMUpdate === true) {
        a.needsPMREMUpdate = false;
        let d = e.get(a);
        return t === null && (t = new MS(n24)), d = f ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d), e.set(a, d), d.texture;
      } else {
        if (e.has(a)) return e.get(a).texture;
        {
          const d = a.image;
          if (f && d && d.height > 0 || h && d && r(d)) {
            t === null && (t = new MS(n24));
            const p = f ? t.fromEquirectangular(a) : t.fromCubemap(a);
            return e.set(a, p), a.addEventListener("dispose", s), p.texture;
          } else return null;
        }
      }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const f = 6;
    for (let h = 0; h < f; h++) a[h] !== void 0 && l++;
    return l === f;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const f = e.get(l);
    f !== void 0 && (e.delete(l), f.dispose());
  }
  function o() {
    e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
  }
  return { get: i, dispose: o };
}
function P6(n24) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r = n24.getExtension("WEBGL_depth_texture") || n24.getExtension("MOZ_WEBGL_depth_texture") || n24.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r = n24.getExtension("EXT_texture_filter_anisotropic") || n24.getExtension("MOZ_EXT_texture_filter_anisotropic") || n24.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r = n24.getExtension("WEBGL_compressed_texture_s3tc") || n24.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n24.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r = n24.getExtension("WEBGL_compressed_texture_pvrtc") || n24.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n24.getExtension(i);
    }
    return e[i] = r, r;
  }
  return { has: function(i) {
    return t(i) !== null;
  }, init: function(i) {
    i.isWebGL2 ? (t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance")) : (t("WEBGL_depth_texture"), t("OES_texture_float"), t("OES_texture_half_float"), t("OES_texture_half_float_linear"), t("OES_standard_derivatives"), t("OES_element_index_uint"), t("OES_vertex_array_object"), t("ANGLE_instanced_arrays")), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture");
  }, get: function(i) {
    const r = t(i);
    return r === null && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), r;
  } };
}
function L6(n24, e, t, i) {
  const r = {}, s = /* @__PURE__ */ new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    for (const v in p.morphAttributes) {
      const S = p.morphAttributes[v];
      for (let M = 0, m = S.length; M < m; M++) e.remove(S[M]);
    }
    p.removeEventListener("dispose", o), delete r[p.id];
    const g = s.get(p);
    g && (e.remove(g), s.delete(p)), i.releaseStatesOfGeometry(p), p.isInstancedBufferGeometry === true && delete p._maxInstanceCount, t.memory.geometries--;
  }
  function a(d, p) {
    return r[p.id] === true || (p.addEventListener("dispose", o), r[p.id] = true, t.memory.geometries++), p;
  }
  function l(d) {
    const p = d.attributes;
    for (const v in p) e.update(p[v], n24.ARRAY_BUFFER);
    const g = d.morphAttributes;
    for (const v in g) {
      const S = g[v];
      for (let M = 0, m = S.length; M < m; M++) e.update(S[M], n24.ARRAY_BUFFER);
    }
  }
  function f(d) {
    const p = [], g = d.index, v = d.attributes.position;
    let S = 0;
    if (g !== null) {
      const w = g.array;
      S = g.version;
      for (let E = 0, A = w.length; E < A; E += 3) {
        const P = w[E + 0], R = w[E + 1], L = w[E + 2];
        p.push(P, R, R, L, L, P);
      }
    } else if (v !== void 0) {
      const w = v.array;
      S = v.version;
      for (let E = 0, A = w.length / 3 - 1; E < A; E += 3) {
        const P = E + 0, R = E + 1, L = E + 2;
        p.push(P, R, R, L, L, P);
      }
    } else return;
    const M = new (hI(p) ? Pw : Rw)(p, 1);
    M.version = S;
    const m = s.get(d);
    m && e.remove(m), s.set(d, M);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const g = d.index;
      g !== null && p.version < g.version && f(d);
    } else f(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function I6(n24, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(g) {
    s = g;
  }
  let a, l;
  function f(g) {
    a = g.type, l = g.bytesPerElement;
  }
  function h(g, v) {
    n24.drawElements(s, v, a, g * l), t.update(v, s, 1);
  }
  function d(g, v, S) {
    if (S === 0) return;
    let M, m;
    if (r) M = n24, m = "drawElementsInstanced";
    else if (M = e.get("ANGLE_instanced_arrays"), m = "drawElementsInstancedANGLE", M === null) {
      console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
      return;
    }
    M[m](s, v, a, g * l, S), t.update(v, s, S);
  }
  function p(g, v, S) {
    if (S === 0) return;
    const M = e.get("WEBGL_multi_draw");
    if (M === null) for (let m = 0; m < S; m++) this.render(g[m] / l, v[m]);
    else {
      M.multiDrawElementsWEBGL(s, v, 0, a, g, 0, S);
      let m = 0;
      for (let w = 0; w < S; w++) m += v[w];
      t.update(m, s, 1);
    }
  }
  this.setMode = o, this.setIndex = f, this.render = h, this.renderInstances = d, this.renderMultiDraw = p;
}
function N6(n24) {
  const e = { geometries: 0, textures: 0 }, t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch (t.calls++, o) {
      case n24.TRIANGLES:
        t.triangles += a * (s / 3);
        break;
      case n24.LINES:
        t.lines += a * (s / 2);
        break;
      case n24.LINE_STRIP:
        t.lines += a * (s - 1);
        break;
      case n24.LINE_LOOP:
        t.lines += a * s;
        break;
      case n24.POINTS:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
  }
  return { memory: e, render: t, programs: null, autoReset: true, reset: r, update: i };
}
function D6(n24, e) {
  return n24[0] - e[0];
}
function O6(n24, e) {
  return Math.abs(e[1]) - Math.abs(n24[1]);
}
function U6(n24, e, t) {
  const i = {}, r = new Float32Array(8), s = /* @__PURE__ */ new WeakMap(), o = new Gt(), a = [];
  for (let f = 0; f < 8; f++) a[f] = [f, 0];
  function l(f, h, d) {
    const p = f.morphTargetInfluences;
    if (e.isWebGL2 === true) {
      const v = h.morphAttributes.position || h.morphAttributes.normal || h.morphAttributes.color, S = v !== void 0 ? v.length : 0;
      let M = s.get(h);
      if (M === void 0 || M.count !== S) {
        let J = function() {
          Z.dispose(), s.delete(h), h.removeEventListener("dispose", J);
        };
        var g = J;
        M !== void 0 && M.texture.dispose();
        const E = h.morphAttributes.position !== void 0, A = h.morphAttributes.normal !== void 0, P = h.morphAttributes.color !== void 0, R = h.morphAttributes.position || [], L = h.morphAttributes.normal || [], D = h.morphAttributes.color || [];
        let F = 0;
        E === true && (F = 1), A === true && (F = 2), P === true && (F = 3);
        let C = h.attributes.position.count * F, N = 1;
        C > e.maxTextureSize && (N = Math.ceil(C / e.maxTextureSize), C = e.maxTextureSize);
        const j = new Float32Array(C * N * 4 * S), Z = new R_(j, C, N, S);
        Z.type = ns, Z.needsUpdate = true;
        const G = F * 4;
        for (let q = 0; q < S; q++) {
          const ae = R[q], B = L[q], Y = D[q], $ = C * N * 4 * q;
          for (let ee = 0; ee < ae.count; ee++) {
            const ue = ee * G;
            E === true && (o.fromBufferAttribute(ae, ee), j[$ + ue + 0] = o.x, j[$ + ue + 1] = o.y, j[$ + ue + 2] = o.z, j[$ + ue + 3] = 0), A === true && (o.fromBufferAttribute(B, ee), j[$ + ue + 4] = o.x, j[$ + ue + 5] = o.y, j[$ + ue + 6] = o.z, j[$ + ue + 7] = 0), P === true && (o.fromBufferAttribute(Y, ee), j[$ + ue + 8] = o.x, j[$ + ue + 9] = o.y, j[$ + ue + 10] = o.z, j[$ + ue + 11] = Y.itemSize === 4 ? o.w : 1);
          }
        }
        M = { count: S, texture: Z, size: new _e(C, N) }, s.set(h, M), h.addEventListener("dispose", J);
      }
      let m = 0;
      for (let E = 0; E < p.length; E++) m += p[E];
      const w = h.morphTargetsRelative ? 1 : 1 - m;
      d.getUniforms().setValue(n24, "morphTargetBaseInfluence", w), d.getUniforms().setValue(n24, "morphTargetInfluences", p), d.getUniforms().setValue(n24, "morphTargetsTexture", M.texture, t), d.getUniforms().setValue(n24, "morphTargetsTextureSize", M.size);
    } else {
      const v = p === void 0 ? 0 : p.length;
      let S = i[h.id];
      if (S === void 0 || S.length !== v) {
        S = [];
        for (let A = 0; A < v; A++) S[A] = [A, 0];
        i[h.id] = S;
      }
      for (let A = 0; A < v; A++) {
        const P = S[A];
        P[0] = A, P[1] = p[A];
      }
      S.sort(O6);
      for (let A = 0; A < 8; A++) A < v && S[A][1] ? (a[A][0] = S[A][0], a[A][1] = S[A][1]) : (a[A][0] = Number.MAX_SAFE_INTEGER, a[A][1] = 0);
      a.sort(D6);
      const M = h.morphAttributes.position, m = h.morphAttributes.normal;
      let w = 0;
      for (let A = 0; A < 8; A++) {
        const P = a[A], R = P[0], L = P[1];
        R !== Number.MAX_SAFE_INTEGER && L ? (M && h.getAttribute("morphTarget" + A) !== M[R] && h.setAttribute("morphTarget" + A, M[R]), m && h.getAttribute("morphNormal" + A) !== m[R] && h.setAttribute("morphNormal" + A, m[R]), r[A] = L, w += L) : (M && h.hasAttribute("morphTarget" + A) === true && h.deleteAttribute("morphTarget" + A), m && h.hasAttribute("morphNormal" + A) === true && h.deleteAttribute("morphNormal" + A), r[A] = 0);
      }
      const E = h.morphTargetsRelative ? 1 : 1 - w;
      d.getUniforms().setValue(n24, "morphTargetBaseInfluence", E), d.getUniforms().setValue(n24, "morphTargetInfluences", r);
    }
  }
  return { update: l };
}
function k6(n24, e, t, i) {
  let r = /* @__PURE__ */ new WeakMap();
  function s(l) {
    const f = i.render.frame, h = l.geometry, d = e.get(l, h);
    if (r.get(d) !== f && (e.update(d), r.set(d, f)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === false && l.addEventListener("dispose", a), r.get(l) !== f && (t.update(l.instanceMatrix, n24.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n24.ARRAY_BUFFER), r.set(l, f))), l.isSkinnedMesh) {
      const p = l.skeleton;
      r.get(p) !== f && (p.update(), r.set(p, f));
    }
    return d;
  }
  function o() {
    r = /* @__PURE__ */ new WeakMap();
  }
  function a(l) {
    const f = l.target;
    f.removeEventListener("dispose", a), t.remove(f.instanceMatrix), f.instanceColor !== null && t.remove(f.instanceColor);
  }
  return { update: s, dispose: o };
}
class Iw extends Tn {
  constructor(e, t, i, r, s, o, a, l, f, h) {
    if (h = h !== void 0 ? h : Ra, h !== Ra && h !== Kl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    i === void 0 && h === Ra && (i = Co), i === void 0 && h === Kl && (i = Ca), super(null, r, s, o, a, l, h, i, f), this.isDepthTexture = true, this.image = { width: e, height: t }, this.magFilter = a !== void 0 ? a : Pn, this.minFilter = l !== void 0 ? l : Pn, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const SI = new Tn(), MI = new Iw(1, 1);
MI.compareFunction = Tw;
const wI = new R_(), EI = new Cw(), TI = new Gd(), fC = [], hC = [], dC = new Float32Array(16), pC = new Float32Array(9), mC = new Float32Array(4);
function cf(n24, e, t) {
  const i = n24[0];
  if (i <= 0 || i > 0) return n24;
  const r = e * t;
  let s = fC[r];
  if (s === void 0 && (s = new Float32Array(r), fC[r] = s), e !== 0) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) a += t, n24[o].toArray(s, a);
  }
  return s;
}
function $n(n24, e) {
  if (n24.length !== e.length) return false;
  for (let t = 0, i = n24.length; t < i; t++) if (n24[t] !== e[t]) return false;
  return true;
}
function Yn(n24, e) {
  for (let t = 0, i = e.length; t < i; t++) n24[t] = e[t];
}
function P_(n24, e) {
  let t = hC[e];
  t === void 0 && (t = new Int32Array(e), hC[e] = t);
  for (let i = 0; i !== e; ++i) t[i] = n24.allocateTextureUnit();
  return t;
}
function F6(n24, e) {
  const t = this.cache;
  t[0] !== e && (n24.uniform1f(this.addr, e), t[0] = e);
}
function z6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n24.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if ($n(t, e)) return;
    n24.uniform2fv(this.addr, e), Yn(t, e);
  }
}
function B6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n24.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n24.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
  else {
    if ($n(t, e)) return;
    n24.uniform3fv(this.addr, e), Yn(t, e);
  }
}
function V6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n24.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if ($n(t, e)) return;
    n24.uniform4fv(this.addr, e), Yn(t, e);
  }
}
function H6(n24, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if ($n(t, e)) return;
    n24.uniformMatrix2fv(this.addr, false, e), Yn(t, e);
  } else {
    if ($n(t, i)) return;
    mC.set(i), n24.uniformMatrix2fv(this.addr, false, mC), Yn(t, i);
  }
}
function G6(n24, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if ($n(t, e)) return;
    n24.uniformMatrix3fv(this.addr, false, e), Yn(t, e);
  } else {
    if ($n(t, i)) return;
    pC.set(i), n24.uniformMatrix3fv(this.addr, false, pC), Yn(t, i);
  }
}
function W6(n24, e) {
  const t = this.cache, i = e.elements;
  if (i === void 0) {
    if ($n(t, e)) return;
    n24.uniformMatrix4fv(this.addr, false, e), Yn(t, e);
  } else {
    if ($n(t, i)) return;
    dC.set(i), n24.uniformMatrix4fv(this.addr, false, dC), Yn(t, i);
  }
}
function X6(n24, e) {
  const t = this.cache;
  t[0] !== e && (n24.uniform1i(this.addr, e), t[0] = e);
}
function j6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n24.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if ($n(t, e)) return;
    n24.uniform2iv(this.addr, e), Yn(t, e);
  }
}
function $6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n24.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if ($n(t, e)) return;
    n24.uniform3iv(this.addr, e), Yn(t, e);
  }
}
function Y6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n24.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if ($n(t, e)) return;
    n24.uniform4iv(this.addr, e), Yn(t, e);
  }
}
function q6(n24, e) {
  const t = this.cache;
  t[0] !== e && (n24.uniform1ui(this.addr, e), t[0] = e);
}
function K6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n24.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
  else {
    if ($n(t, e)) return;
    n24.uniform2uiv(this.addr, e), Yn(t, e);
  }
}
function Z6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n24.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
  else {
    if ($n(t, e)) return;
    n24.uniform3uiv(this.addr, e), Yn(t, e);
  }
}
function J6(n24, e) {
  const t = this.cache;
  if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n24.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
  else {
    if ($n(t, e)) return;
    n24.uniform4uiv(this.addr, e), Yn(t, e);
  }
}
function Q6(n24, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n24.uniform1i(this.addr, r), i[0] = r);
  const s = this.type === n24.SAMPLER_2D_SHADOW ? MI : SI;
  t.setTexture2D(e || s, r);
}
function e8(n24, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n24.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || EI, r);
}
function t8(n24, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n24.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || TI, r);
}
function n8(n24, e, t) {
  const i = this.cache, r = t.allocateTextureUnit();
  i[0] !== r && (n24.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || wI, r);
}
function i8(n24) {
  switch (n24) {
    case 5126:
      return F6;
    case 35664:
      return z6;
    case 35665:
      return B6;
    case 35666:
      return V6;
    case 35674:
      return H6;
    case 35675:
      return G6;
    case 35676:
      return W6;
    case 5124:
    case 35670:
      return X6;
    case 35667:
    case 35671:
      return j6;
    case 35668:
    case 35672:
      return $6;
    case 35669:
    case 35673:
      return Y6;
    case 5125:
      return q6;
    case 36294:
      return K6;
    case 36295:
      return Z6;
    case 36296:
      return J6;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Q6;
    case 35679:
    case 36299:
    case 36307:
      return e8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return t8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return n8;
  }
}
function r8(n24, e) {
  n24.uniform1fv(this.addr, e);
}
function s8(n24, e) {
  const t = cf(e, this.size, 2);
  n24.uniform2fv(this.addr, t);
}
function o8(n24, e) {
  const t = cf(e, this.size, 3);
  n24.uniform3fv(this.addr, t);
}
function a8(n24, e) {
  const t = cf(e, this.size, 4);
  n24.uniform4fv(this.addr, t);
}
function l8(n24, e) {
  const t = cf(e, this.size, 4);
  n24.uniformMatrix2fv(this.addr, false, t);
}
function u8(n24, e) {
  const t = cf(e, this.size, 9);
  n24.uniformMatrix3fv(this.addr, false, t);
}
function c8(n24, e) {
  const t = cf(e, this.size, 16);
  n24.uniformMatrix4fv(this.addr, false, t);
}
function f8(n24, e) {
  n24.uniform1iv(this.addr, e);
}
function h8(n24, e) {
  n24.uniform2iv(this.addr, e);
}
function d8(n24, e) {
  n24.uniform3iv(this.addr, e);
}
function p8(n24, e) {
  n24.uniform4iv(this.addr, e);
}
function m8(n24, e) {
  n24.uniform1uiv(this.addr, e);
}
function g8(n24, e) {
  n24.uniform2uiv(this.addr, e);
}
function _8(n24, e) {
  n24.uniform3uiv(this.addr, e);
}
function v8(n24, e) {
  n24.uniform4uiv(this.addr, e);
}
function y8(n24, e, t) {
  const i = this.cache, r = e.length, s = P_(t, r);
  $n(i, s) || (n24.uniform1iv(this.addr, s), Yn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || SI, s[o]);
}
function x8(n24, e, t) {
  const i = this.cache, r = e.length, s = P_(t, r);
  $n(i, s) || (n24.uniform1iv(this.addr, s), Yn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || EI, s[o]);
}
function S8(n24, e, t) {
  const i = this.cache, r = e.length, s = P_(t, r);
  $n(i, s) || (n24.uniform1iv(this.addr, s), Yn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || TI, s[o]);
}
function M8(n24, e, t) {
  const i = this.cache, r = e.length, s = P_(t, r);
  $n(i, s) || (n24.uniform1iv(this.addr, s), Yn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || wI, s[o]);
}
function w8(n24) {
  switch (n24) {
    case 5126:
      return r8;
    case 35664:
      return s8;
    case 35665:
      return o8;
    case 35666:
      return a8;
    case 35674:
      return l8;
    case 35675:
      return u8;
    case 35676:
      return c8;
    case 5124:
    case 35670:
      return f8;
    case 35667:
    case 35671:
      return h8;
    case 35668:
    case 35672:
      return d8;
    case 35669:
    case 35673:
      return p8;
    case 5125:
      return m8;
    case 36294:
      return g8;
    case 36295:
      return _8;
    case 36296:
      return v8;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return y8;
    case 35679:
    case 36299:
    case 36307:
      return x8;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return S8;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return M8;
  }
}
class E8 {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = i8(t.type);
  }
}
class T8 {
  constructor(e, t, i) {
    this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = w8(t.type);
  }
}
class A8 {
  constructor(e) {
    this.id = e, this.seq = [], this.map = {};
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const ax = /(\w+)(\])?(\[|\.)?/g;
function gC(n24, e) {
  n24.seq.push(e), n24.map[e.id] = e;
}
function b8(n24, e, t) {
  const i = n24.name, r = i.length;
  for (ax.lastIndex = 0; ; ) {
    const s = ax.exec(i), o = ax.lastIndex;
    let a = s[1];
    const l = s[2] === "]", f = s[3];
    if (l && (a = a | 0), f === void 0 || f === "[" && o + 2 === r) {
      gC(t, f === void 0 ? new E8(a, n24, e) : new T8(a, n24, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && (d = new A8(a), gC(t, d)), t = d;
    }
  }
}
class Lg {
  constructor(e, t) {
    this.seq = [], this.map = {};
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r), o = e.getUniformLocation(t, s.name);
      b8(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s], l = i[a.id];
      l.needsUpdate !== false && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function _C(n24, e, t) {
  const i = n24.createShader(e);
  return n24.shaderSource(i, t), n24.compileShader(i), i;
}
const C8 = 37297;
let R8 = 0;
function P8(n24, e) {
  const t = n24.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function L8(n24) {
  const e = Ht.getPrimaries(Ht.workingColorSpace), t = Ht.getPrimaries(n24);
  let i;
  switch (e === t ? i = "" : e === ld && t === ad ? i = "LinearDisplayP3ToLinearSRGB" : e === ad && t === ld && (i = "LinearSRGBToLinearDisplayP3"), n24) {
    case so:
    case Bd:
      return [i, "LinearTransferOETF"];
    case Xn:
    case C_:
      return [i, "sRGBTransferOETF"];
    default:
      return console.warn("THREE.WebGLProgram: Unsupported color space:", n24), [i, "LinearTransferOETF"];
  }
}
function vC(n24, e, t) {
  const i = n24.getShaderParameter(e, n24.COMPILE_STATUS), r = n24.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return t.toUpperCase() + `

` + r + `

` + P8(n24.getShaderSource(e), o);
  } else return r;
}
function I8(n24, e) {
  const t = L8(e);
  return `vec4 ${n24}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`;
}
function N8(n24, e) {
  let t;
  switch (e) {
    case zL:
      t = "Linear";
      break;
    case BL:
      t = "Reinhard";
      break;
    case VL:
      t = "OptimizedCineon";
      break;
    case mw:
      t = "ACESFilmic";
      break;
    case GL:
      t = "AgX";
      break;
    case HL:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
  }
  return "vec3 " + n24 + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
}
function D8(n24) {
  return [n24.extensionDerivatives || n24.envMapCubeUVHeight || n24.bumpMap || n24.normalMapTangentSpace || n24.clearcoatNormalMap || n24.flatShading || n24.alphaToCoverage || n24.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (n24.extensionFragDepth || n24.logarithmicDepthBuffer) && n24.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", n24.extensionDrawBuffers && n24.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (n24.extensionShaderTextureLOD || n24.envMap || n24.transmission) && n24.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(gc).join(`
`);
}
function O8(n24) {
  return [n24.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n24.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(gc).join(`
`);
}
function U8(n24) {
  const e = [];
  for (const t in n24) {
    const i = n24[t];
    i !== false && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function k8(n24, e) {
  const t = {}, i = n24.getProgramParameter(e, n24.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = n24.getActiveAttrib(e, r), o = s.name;
    let a = 1;
    s.type === n24.FLOAT_MAT2 && (a = 2), s.type === n24.FLOAT_MAT3 && (a = 3), s.type === n24.FLOAT_MAT4 && (a = 4), t[o] = { type: s.type, location: n24.getAttribLocation(e, o), locationSize: a };
  }
  return t;
}
function gc(n24) {
  return n24 !== "";
}
function yC(n24, e) {
  const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n24.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function xC(n24, e) {
  return n24.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
}
const F8 = /^[ \t]*#include +<([\w\d./]+)>/gm;
function wS(n24) {
  return n24.replace(F8, B8);
}
const z8 = /* @__PURE__ */ new Map([["encodings_fragment", "colorspace_fragment"], ["encodings_pars_fragment", "colorspace_pars_fragment"], ["output_fragment", "opaque_fragment"]]);
function B8(n24, e) {
  let t = yt[e];
  if (t === void 0) {
    const i = z8.get(e);
    if (i !== void 0) t = yt[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return wS(t);
}
const V8 = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function SC(n24) {
  return n24.replace(V8, H8);
}
function H8(n24, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function MC(n24) {
  let e = `precision ${n24.precision} float;
	precision ${n24.precision} int;
	precision ${n24.precision} sampler2D;
	precision ${n24.precision} samplerCube;
	`;
  return n24.isWebGL2 && (e += `precision ${n24.precision} sampler3D;
		precision ${n24.precision} sampler2DArray;
		precision ${n24.precision} sampler2DShadow;
		precision ${n24.precision} samplerCubeShadow;
		precision ${n24.precision} sampler2DArrayShadow;
		precision ${n24.precision} isampler2D;
		precision ${n24.precision} isampler3D;
		precision ${n24.precision} isamplerCube;
		precision ${n24.precision} isampler2DArray;
		precision ${n24.precision} usampler2D;
		precision ${n24.precision} usampler3D;
		precision ${n24.precision} usamplerCube;
		precision ${n24.precision} usampler2DArray;
		`), n24.precision === "highp" ? e += `
#define HIGH_PRECISION` : n24.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n24.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
}
function G8(n24) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return n24.shadowMapType === E_ ? e = "SHADOWMAP_TYPE_PCF" : n24.shadowMapType === wh ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n24.shadowMapType === vs && (e = "SHADOWMAP_TYPE_VSM"), e;
}
function W8(n24) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n24.envMap) switch (n24.envMapMode) {
    case Fo:
    case Oa:
      e = "ENVMAP_TYPE_CUBE";
      break;
    case lf:
      e = "ENVMAP_TYPE_CUBE_UV";
      break;
  }
  return e;
}
function X8(n24) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n24.envMap) switch (n24.envMapMode) {
    case Oa:
      e = "ENVMAP_MODE_REFRACTION";
      break;
  }
  return e;
}
function j8(n24) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n24.envMap) switch (n24.combine) {
    case zd:
      e = "ENVMAP_BLENDING_MULTIPLY";
      break;
    case kL:
      e = "ENVMAP_BLENDING_MIX";
      break;
    case FL:
      e = "ENVMAP_BLENDING_ADD";
      break;
  }
  return e;
}
function $8(n24) {
  const e = n24.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2, i = 1 / e;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)), texelHeight: i, maxMip: t };
}
function Y8(n24, e, t, i) {
  const r = n24.getContext(), s = t.defines;
  let o = t.vertexShader, a = t.fragmentShader;
  const l = G8(t), f = W8(t), h = X8(t), d = j8(t), p = $8(t), g = t.isWebGL2 ? "" : D8(t), v = O8(t), S = U8(s), M = r.createProgram();
  let m, w, E = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
  t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(gc).join(`
`), m.length > 0 && (m += `
`), w = [g, "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(gc).join(`
`), w.length > 0 && (w += `
`)) : (m = [MC(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "", t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 && t.isWebGL2 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(gc).join(`
`), w = [g, MC(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + f : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "", p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "", p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.useLegacyLights ? "#define LEGACY_LIGHTS" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.logarithmicDepthBuffer && t.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== eo ? "#define TONE_MAPPING" : "", t.toneMapping !== eo ? yt.tonemapping_pars_fragment : "", t.toneMapping !== eo ? N8("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", yt.colorspace_pars_fragment, I8("linearToOutputTexel", t.outputColorSpace), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(gc).join(`
`)), o = wS(o), o = yC(o, t), o = xC(o, t), a = wS(a), a = yC(a, t), a = xC(a, t), o = SC(o), a = SC(a), t.isWebGL2 && t.isRawShaderMaterial !== true && (E = `#version 300 es
`, m = [v, "precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m, w = ["precision mediump sampler2DArray;", "#define varying in", t.glslVersion === yS ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === yS ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + w);
  const A = E + m + o, P = E + w + a, R = _C(r, r.VERTEX_SHADER, A), L = _C(r, r.FRAGMENT_SHADER, P);
  r.attachShader(M, R), r.attachShader(M, L), t.index0AttributeName !== void 0 ? r.bindAttribLocation(M, 0, t.index0AttributeName) : t.morphTargets === true && r.bindAttribLocation(M, 0, "position"), r.linkProgram(M);
  function D(j) {
    if (n24.debug.checkShaderErrors) {
      const Z = r.getProgramInfoLog(M).trim(), G = r.getShaderInfoLog(R).trim(), J = r.getShaderInfoLog(L).trim();
      let q = true, ae = true;
      if (r.getProgramParameter(M, r.LINK_STATUS) === false) if (q = false, typeof n24.debug.onShaderError == "function") n24.debug.onShaderError(r, M, R, L);
      else {
        const B = vC(r, R, "vertex"), Y = vC(r, L, "fragment");
        console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(M, r.VALIDATE_STATUS) + `

Material Name: ` + j.name + `
Material Type: ` + j.type + `

Program Info Log: ` + Z + `
` + B + `
` + Y);
      }
      else Z !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Z) : (G === "" || J === "") && (ae = false);
      ae && (j.diagnostics = { runnable: q, programLog: Z, vertexShader: { log: G, prefix: m }, fragmentShader: { log: J, prefix: w } });
    }
    r.deleteShader(R), r.deleteShader(L), F = new Lg(r, M), C = k8(r, M);
  }
  let F;
  this.getUniforms = function() {
    return F === void 0 && D(this), F;
  };
  let C;
  this.getAttributes = function() {
    return C === void 0 && D(this), C;
  };
  let N = t.rendererExtensionParallelShaderCompile === false;
  return this.isReady = function() {
    return N === false && (N = r.getProgramParameter(M, C8)), N;
  }, this.destroy = function() {
    i.releaseStatesOfProgram(this), r.deleteProgram(M), this.program = void 0;
  }, this.type = t.shaderType, this.name = t.shaderName, this.id = R8++, this.cacheKey = e, this.usedTimes = 1, this.program = M, this.vertexShader = R, this.fragmentShader = L, this;
}
let q8 = 0;
class K8 {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
  }
  update(e) {
    const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), o = this._getShaderCacheForMaterial(e);
    return o.has(r) === false && (o.add(r), r.usedTimes++), o.has(s) === false && (o.add(s), s.usedTimes++), this;
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && (i = new Z8(e), t.set(e, i)), i;
  }
}
class Z8 {
  constructor(e) {
    this.id = q8++, this.code = e, this.usedTimes = 0;
  }
}
function J8(n24, e, t, i, r, s, o) {
  const a = new kl(), l = new K8(), f = /* @__PURE__ */ new Set(), h = [], d = r.isWebGL2, p = r.logarithmicDepthBuffer, g = r.vertexTextures;
  let v = r.precision;
  const S = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" };
  function M(C) {
    return f.add(C), C === 0 ? "uv" : `uv${C}`;
  }
  function m(C, N, j, Z, G) {
    const J = Z.fog, q = G.geometry, ae = C.isMeshStandardMaterial ? Z.environment : null, B = (C.isMeshStandardMaterial ? t : e).get(C.envMap || ae), Y = B && B.mapping === lf ? B.image.height : null, $ = S[C.type];
    C.precision !== null && (v = r.getMaxPrecision(C.precision), v !== C.precision && console.warn("THREE.WebGLProgram.getParameters:", C.precision, "not supported, using", v, "instead."));
    const ee = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color, ue = ee !== void 0 ? ee.length : 0;
    let Ae = 0;
    q.morphAttributes.position !== void 0 && (Ae = 1), q.morphAttributes.normal !== void 0 && (Ae = 2), q.morphAttributes.color !== void 0 && (Ae = 3);
    let te, de, Ee, Ie;
    if ($) {
      const Vt = Ss[$];
      te = Vt.vertexShader, de = Vt.fragmentShader;
    } else te = C.vertexShader, de = C.fragmentShader, l.update(C), Ee = l.getVertexShaderID(C), Ie = l.getFragmentShaderID(C);
    const Ze = n24.getRenderTarget(), Oe = G.isInstancedMesh === true, at = G.isBatchedMesh === true, Ge = !!C.map, X = !!C.matcap, Se = !!B, pe = !!C.aoMap, we = !!C.lightMap, me = !!C.bumpMap, qe = !!C.normalMap, Ne = !!C.displacementMap, U = !!C.emissiveMap, O = !!C.metalnessMap, ie = !!C.roughnessMap, xe = C.anisotropy > 0, ve = C.clearcoat > 0, ge = C.iridescence > 0, ze = C.sheen > 0, Le = C.transmission > 0, ke = xe && !!C.anisotropyMap, et = ve && !!C.clearcoatMap, Re = ve && !!C.clearcoatNormalMap, ye = ve && !!C.clearcoatRoughnessMap, bt = ge && !!C.iridescenceMap, gt = ge && !!C.iridescenceThicknessMap, ut = ze && !!C.sheenColorMap, tt = ze && !!C.sheenRoughnessMap, je = !!C.specularMap, _t = !!C.specularColorMap, Lt = !!C.specularIntensityMap, $t = Le && !!C.transmissionMap, Tt = Le && !!C.thicknessMap, Bt = !!C.gradientMap, W = !!C.alphaMap, be = C.alphaTest > 0, Ce = !!C.alphaHash, $e = !!C.extensions;
    let nt = eo;
    C.toneMapped && (Ze === null || Ze.isXRRenderTarget === true) && (nt = n24.toneMapping);
    const Ut = { isWebGL2: d, shaderID: $, shaderType: C.type, shaderName: C.name, vertexShader: te, fragmentShader: de, defines: C.defines, customVertexShaderID: Ee, customFragmentShaderID: Ie, isRawShaderMaterial: C.isRawShaderMaterial === true, glslVersion: C.glslVersion, precision: v, batching: at, instancing: Oe, instancingColor: Oe && G.instanceColor !== null, supportsVertexTextures: g, outputColorSpace: Ze === null ? n24.outputColorSpace : Ze.isXRRenderTarget === true ? Ze.texture.colorSpace : so, alphaToCoverage: !!C.alphaToCoverage, map: Ge, matcap: X, envMap: Se, envMapMode: Se && B.mapping, envMapCubeUVHeight: Y, aoMap: pe, lightMap: we, bumpMap: me, normalMap: qe, displacementMap: g && Ne, emissiveMap: U, normalMapObjectSpace: qe && C.normalMapType === rI, normalMapTangentSpace: qe && C.normalMapType === Ga, metalnessMap: O, roughnessMap: ie, anisotropy: xe, anisotropyMap: ke, clearcoat: ve, clearcoatMap: et, clearcoatNormalMap: Re, clearcoatRoughnessMap: ye, iridescence: ge, iridescenceMap: bt, iridescenceThicknessMap: gt, sheen: ze, sheenColorMap: ut, sheenRoughnessMap: tt, specularMap: je, specularColorMap: _t, specularIntensityMap: Lt, transmission: Le, transmissionMap: $t, thicknessMap: Tt, gradientMap: Bt, opaque: C.transparent === false && C.blending === Dl && C.alphaToCoverage === false, alphaMap: W, alphaTest: be, alphaHash: Ce, combine: C.combine, mapUv: Ge && M(C.map.channel), aoMapUv: pe && M(C.aoMap.channel), lightMapUv: we && M(C.lightMap.channel), bumpMapUv: me && M(C.bumpMap.channel), normalMapUv: qe && M(C.normalMap.channel), displacementMapUv: Ne && M(C.displacementMap.channel), emissiveMapUv: U && M(C.emissiveMap.channel), metalnessMapUv: O && M(C.metalnessMap.channel), roughnessMapUv: ie && M(C.roughnessMap.channel), anisotropyMapUv: ke && M(C.anisotropyMap.channel), clearcoatMapUv: et && M(C.clearcoatMap.channel), clearcoatNormalMapUv: Re && M(C.clearcoatNormalMap.channel), clearcoatRoughnessMapUv: ye && M(C.clearcoatRoughnessMap.channel), iridescenceMapUv: bt && M(C.iridescenceMap.channel), iridescenceThicknessMapUv: gt && M(C.iridescenceThicknessMap.channel), sheenColorMapUv: ut && M(C.sheenColorMap.channel), sheenRoughnessMapUv: tt && M(C.sheenRoughnessMap.channel), specularMapUv: je && M(C.specularMap.channel), specularColorMapUv: _t && M(C.specularColorMap.channel), specularIntensityMapUv: Lt && M(C.specularIntensityMap.channel), transmissionMapUv: $t && M(C.transmissionMap.channel), thicknessMapUv: Tt && M(C.thicknessMap.channel), alphaMapUv: W && M(C.alphaMap.channel), vertexTangents: !!q.attributes.tangent && (qe || xe), vertexColors: C.vertexColors, vertexAlphas: C.vertexColors === true && !!q.attributes.color && q.attributes.color.itemSize === 4, pointsUvs: G.isPoints === true && !!q.attributes.uv && (Ge || W), fog: !!J, useFog: C.fog === true, fogExp2: !!J && J.isFogExp2, flatShading: C.flatShading === true, sizeAttenuation: C.sizeAttenuation === true, logarithmicDepthBuffer: p, skinning: G.isSkinnedMesh === true, morphTargets: q.morphAttributes.position !== void 0, morphNormals: q.morphAttributes.normal !== void 0, morphColors: q.morphAttributes.color !== void 0, morphTargetsCount: ue, morphTextureStride: Ae, numDirLights: N.directional.length, numPointLights: N.point.length, numSpotLights: N.spot.length, numSpotLightMaps: N.spotLightMap.length, numRectAreaLights: N.rectArea.length, numHemiLights: N.hemi.length, numDirLightShadows: N.directionalShadowMap.length, numPointLightShadows: N.pointShadowMap.length, numSpotLightShadows: N.spotShadowMap.length, numSpotLightShadowsWithMaps: N.numSpotLightShadowsWithMaps, numLightProbes: N.numLightProbes, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: C.dithering, shadowMapEnabled: n24.shadowMap.enabled && j.length > 0, shadowMapType: n24.shadowMap.type, toneMapping: nt, useLegacyLights: n24._useLegacyLights, decodeVideoTexture: Ge && C.map.isVideoTexture === true && Ht.getTransfer(C.map.colorSpace) === Zt, premultipliedAlpha: C.premultipliedAlpha, doubleSided: C.side === Xs, flipSided: C.side === Gi, useDepthPacking: C.depthPacking >= 0, depthPacking: C.depthPacking || 0, index0AttributeName: C.index0AttributeName, extensionDerivatives: $e && C.extensions.derivatives === true, extensionFragDepth: $e && C.extensions.fragDepth === true, extensionDrawBuffers: $e && C.extensions.drawBuffers === true, extensionShaderTextureLOD: $e && C.extensions.shaderTextureLOD === true, extensionClipCullDistance: $e && C.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"), extensionMultiDraw: $e && C.extensions.multiDraw === true && i.has("WEBGL_multi_draw"), rendererExtensionFragDepth: d || i.has("EXT_frag_depth"), rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"), rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"), customProgramCacheKey: C.customProgramCacheKey() };
    return Ut.vertexUv1s = f.has(1), Ut.vertexUv2s = f.has(2), Ut.vertexUv3s = f.has(3), f.clear(), Ut;
  }
  function w(C) {
    const N = [];
    if (C.shaderID ? N.push(C.shaderID) : (N.push(C.customVertexShaderID), N.push(C.customFragmentShaderID)), C.defines !== void 0) for (const j in C.defines) N.push(j), N.push(C.defines[j]);
    return C.isRawShaderMaterial === false && (E(N, C), A(N, C), N.push(n24.outputColorSpace)), N.push(C.customProgramCacheKey), N.join();
  }
  function E(C, N) {
    C.push(N.precision), C.push(N.outputColorSpace), C.push(N.envMapMode), C.push(N.envMapCubeUVHeight), C.push(N.mapUv), C.push(N.alphaMapUv), C.push(N.lightMapUv), C.push(N.aoMapUv), C.push(N.bumpMapUv), C.push(N.normalMapUv), C.push(N.displacementMapUv), C.push(N.emissiveMapUv), C.push(N.metalnessMapUv), C.push(N.roughnessMapUv), C.push(N.anisotropyMapUv), C.push(N.clearcoatMapUv), C.push(N.clearcoatNormalMapUv), C.push(N.clearcoatRoughnessMapUv), C.push(N.iridescenceMapUv), C.push(N.iridescenceThicknessMapUv), C.push(N.sheenColorMapUv), C.push(N.sheenRoughnessMapUv), C.push(N.specularMapUv), C.push(N.specularColorMapUv), C.push(N.specularIntensityMapUv), C.push(N.transmissionMapUv), C.push(N.thicknessMapUv), C.push(N.combine), C.push(N.fogExp2), C.push(N.sizeAttenuation), C.push(N.morphTargetsCount), C.push(N.morphAttributeCount), C.push(N.numDirLights), C.push(N.numPointLights), C.push(N.numSpotLights), C.push(N.numSpotLightMaps), C.push(N.numHemiLights), C.push(N.numRectAreaLights), C.push(N.numDirLightShadows), C.push(N.numPointLightShadows), C.push(N.numSpotLightShadows), C.push(N.numSpotLightShadowsWithMaps), C.push(N.numLightProbes), C.push(N.shadowMapType), C.push(N.toneMapping), C.push(N.numClippingPlanes), C.push(N.numClipIntersection), C.push(N.depthPacking);
  }
  function A(C, N) {
    a.disableAll(), N.isWebGL2 && a.enable(0), N.supportsVertexTextures && a.enable(1), N.instancing && a.enable(2), N.instancingColor && a.enable(3), N.matcap && a.enable(4), N.envMap && a.enable(5), N.normalMapObjectSpace && a.enable(6), N.normalMapTangentSpace && a.enable(7), N.clearcoat && a.enable(8), N.iridescence && a.enable(9), N.alphaTest && a.enable(10), N.vertexColors && a.enable(11), N.vertexAlphas && a.enable(12), N.vertexUv1s && a.enable(13), N.vertexUv2s && a.enable(14), N.vertexUv3s && a.enable(15), N.vertexTangents && a.enable(16), N.anisotropy && a.enable(17), N.alphaHash && a.enable(18), N.batching && a.enable(19), C.push(a.mask), a.disableAll(), N.fog && a.enable(0), N.useFog && a.enable(1), N.flatShading && a.enable(2), N.logarithmicDepthBuffer && a.enable(3), N.skinning && a.enable(4), N.morphTargets && a.enable(5), N.morphNormals && a.enable(6), N.morphColors && a.enable(7), N.premultipliedAlpha && a.enable(8), N.shadowMapEnabled && a.enable(9), N.useLegacyLights && a.enable(10), N.doubleSided && a.enable(11), N.flipSided && a.enable(12), N.useDepthPacking && a.enable(13), N.dithering && a.enable(14), N.transmission && a.enable(15), N.sheen && a.enable(16), N.opaque && a.enable(17), N.pointsUvs && a.enable(18), N.decodeVideoTexture && a.enable(19), N.alphaToCoverage && a.enable(20), C.push(a.mask);
  }
  function P(C) {
    const N = S[C.type];
    let j;
    if (N) {
      const Z = Ss[N];
      j = _I.clone(Z.uniforms);
    } else j = C.uniforms;
    return j;
  }
  function R(C, N) {
    let j;
    for (let Z = 0, G = h.length; Z < G; Z++) {
      const J = h[Z];
      if (J.cacheKey === N) {
        j = J, ++j.usedTimes;
        break;
      }
    }
    return j === void 0 && (j = new Y8(n24, N, C, s), h.push(j)), j;
  }
  function L(C) {
    if (--C.usedTimes === 0) {
      const N = h.indexOf(C);
      h[N] = h[h.length - 1], h.pop(), C.destroy();
    }
  }
  function D(C) {
    l.remove(C);
  }
  function F() {
    l.dispose();
  }
  return { getParameters: m, getProgramCacheKey: w, getUniforms: P, acquireProgram: R, releaseProgram: L, releaseShaderCache: D, programs: h, dispose: F };
}
function Q8() {
  let n24 = /* @__PURE__ */ new WeakMap();
  function e(s) {
    let o = n24.get(s);
    return o === void 0 && (o = {}, n24.set(s, o)), o;
  }
  function t(s) {
    n24.delete(s);
  }
  function i(s, o, a) {
    n24.get(s)[o] = a;
  }
  function r() {
    n24 = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function eW(n24, e) {
  return n24.groupOrder !== e.groupOrder ? n24.groupOrder - e.groupOrder : n24.renderOrder !== e.renderOrder ? n24.renderOrder - e.renderOrder : n24.material.id !== e.material.id ? n24.material.id - e.material.id : n24.z !== e.z ? n24.z - e.z : n24.id - e.id;
}
function wC(n24, e) {
  return n24.groupOrder !== e.groupOrder ? n24.groupOrder - e.groupOrder : n24.renderOrder !== e.renderOrder ? n24.renderOrder - e.renderOrder : n24.z !== e.z ? e.z - n24.z : n24.id - e.id;
}
function EC() {
  const n24 = [];
  let e = 0;
  const t = [], i = [], r = [];
  function s() {
    e = 0, t.length = 0, i.length = 0, r.length = 0;
  }
  function o(d, p, g, v, S, M) {
    let m = n24[e];
    return m === void 0 ? (m = { id: d.id, object: d, geometry: p, material: g, groupOrder: v, renderOrder: d.renderOrder, z: S, group: M }, n24[e] = m) : (m.id = d.id, m.object = d, m.geometry = p, m.material = g, m.groupOrder = v, m.renderOrder = d.renderOrder, m.z = S, m.group = M), e++, m;
  }
  function a(d, p, g, v, S, M) {
    const m = o(d, p, g, v, S, M);
    g.transmission > 0 ? i.push(m) : g.transparent === true ? r.push(m) : t.push(m);
  }
  function l(d, p, g, v, S, M) {
    const m = o(d, p, g, v, S, M);
    g.transmission > 0 ? i.unshift(m) : g.transparent === true ? r.unshift(m) : t.unshift(m);
  }
  function f(d, p) {
    t.length > 1 && t.sort(d || eW), i.length > 1 && i.sort(p || wC), r.length > 1 && r.sort(p || wC);
  }
  function h() {
    for (let d = e, p = n24.length; d < p; d++) {
      const g = n24[d];
      if (g.id === null) break;
      g.id = null, g.object = null, g.geometry = null, g.material = null, g.group = null;
    }
  }
  return { opaque: t, transmissive: i, transparent: r, init: s, push: a, unshift: l, finish: h, sort: f };
}
function tW() {
  let n24 = /* @__PURE__ */ new WeakMap();
  function e(i, r) {
    const s = n24.get(i);
    let o;
    return s === void 0 ? (o = new EC(), n24.set(i, [o])) : r >= s.length ? (o = new EC(), s.push(o)) : o = s[r], o;
  }
  function t() {
    n24 = /* @__PURE__ */ new WeakMap();
  }
  return { get: e, dispose: t };
}
function nW() {
  const n24 = {};
  return { get: function(e) {
    if (n24[e.id] !== void 0) return n24[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { direction: new V(), color: new Ve() };
        break;
      case "SpotLight":
        t = { position: new V(), direction: new V(), color: new Ve(), distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 };
        break;
      case "PointLight":
        t = { position: new V(), color: new Ve(), distance: 0, decay: 0 };
        break;
      case "HemisphereLight":
        t = { direction: new V(), skyColor: new Ve(), groundColor: new Ve() };
        break;
      case "RectAreaLight":
        t = { color: new Ve(), position: new V(), halfWidth: new V(), halfHeight: new V() };
        break;
    }
    return n24[e.id] = t, t;
  } };
}
function iW() {
  const n24 = {};
  return { get: function(e) {
    if (n24[e.id] !== void 0) return n24[e.id];
    let t;
    switch (e.type) {
      case "DirectionalLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e() };
        break;
      case "SpotLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e() };
        break;
      case "PointLight":
        t = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new _e(), shadowCameraNear: 1, shadowCameraFar: 1e3 };
        break;
    }
    return n24[e.id] = t, t;
  } };
}
let rW = 0;
function sW(n24, e) {
  return (e.castShadow ? 2 : 0) - (n24.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n24.map ? 1 : 0);
}
function oW(n24, e) {
  const t = new nW(), i = iW(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1, numLightProbes: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0, numLightProbes: 0 };
  for (let h = 0; h < 9; h++) r.probe.push(new V());
  const s = new V(), o = new lt(), a = new lt();
  function l(h, d) {
    let p = 0, g = 0, v = 0;
    for (let j = 0; j < 9; j++) r.probe[j].set(0, 0, 0);
    let S = 0, M = 0, m = 0, w = 0, E = 0, A = 0, P = 0, R = 0, L = 0, D = 0, F = 0;
    h.sort(sW);
    const C = d === true ? Math.PI : 1;
    for (let j = 0, Z = h.length; j < Z; j++) {
      const G = h[j], J = G.color, q = G.intensity, ae = G.distance, B = G.shadow && G.shadow.map ? G.shadow.map.texture : null;
      if (G.isAmbientLight) p += J.r * q * C, g += J.g * q * C, v += J.b * q * C;
      else if (G.isLightProbe) {
        for (let Y = 0; Y < 9; Y++) r.probe[Y].addScaledVector(G.sh.coefficients[Y], q);
        F++;
      } else if (G.isDirectionalLight) {
        const Y = t.get(G);
        if (Y.color.copy(G.color).multiplyScalar(G.intensity * C), G.castShadow) {
          const $ = G.shadow, ee = i.get(G);
          ee.shadowBias = $.bias, ee.shadowNormalBias = $.normalBias, ee.shadowRadius = $.radius, ee.shadowMapSize = $.mapSize, r.directionalShadow[S] = ee, r.directionalShadowMap[S] = B, r.directionalShadowMatrix[S] = G.shadow.matrix, A++;
        }
        r.directional[S] = Y, S++;
      } else if (G.isSpotLight) {
        const Y = t.get(G);
        Y.position.setFromMatrixPosition(G.matrixWorld), Y.color.copy(J).multiplyScalar(q * C), Y.distance = ae, Y.coneCos = Math.cos(G.angle), Y.penumbraCos = Math.cos(G.angle * (1 - G.penumbra)), Y.decay = G.decay, r.spot[m] = Y;
        const $ = G.shadow;
        if (G.map && (r.spotLightMap[L] = G.map, L++, $.updateMatrices(G), G.castShadow && D++), r.spotLightMatrix[m] = $.matrix, G.castShadow) {
          const ee = i.get(G);
          ee.shadowBias = $.bias, ee.shadowNormalBias = $.normalBias, ee.shadowRadius = $.radius, ee.shadowMapSize = $.mapSize, r.spotShadow[m] = ee, r.spotShadowMap[m] = B, R++;
        }
        m++;
      } else if (G.isRectAreaLight) {
        const Y = t.get(G);
        Y.color.copy(J).multiplyScalar(q), Y.halfWidth.set(G.width * 0.5, 0, 0), Y.halfHeight.set(0, G.height * 0.5, 0), r.rectArea[w] = Y, w++;
      } else if (G.isPointLight) {
        const Y = t.get(G);
        if (Y.color.copy(G.color).multiplyScalar(G.intensity * C), Y.distance = G.distance, Y.decay = G.decay, G.castShadow) {
          const $ = G.shadow, ee = i.get(G);
          ee.shadowBias = $.bias, ee.shadowNormalBias = $.normalBias, ee.shadowRadius = $.radius, ee.shadowMapSize = $.mapSize, ee.shadowCameraNear = $.camera.near, ee.shadowCameraFar = $.camera.far, r.pointShadow[M] = ee, r.pointShadowMap[M] = B, r.pointShadowMatrix[M] = G.shadow.matrix, P++;
        }
        r.point[M] = Y, M++;
      } else if (G.isHemisphereLight) {
        const Y = t.get(G);
        Y.skyColor.copy(G.color).multiplyScalar(q * C), Y.groundColor.copy(G.groundColor).multiplyScalar(q * C), r.hemi[E] = Y, E++;
      }
    }
    w > 0 && (e.isWebGL2 ? n24.has("OES_texture_float_linear") === true ? (r.rectAreaLTC1 = Pe.LTC_FLOAT_1, r.rectAreaLTC2 = Pe.LTC_FLOAT_2) : (r.rectAreaLTC1 = Pe.LTC_HALF_1, r.rectAreaLTC2 = Pe.LTC_HALF_2) : n24.has("OES_texture_float_linear") === true ? (r.rectAreaLTC1 = Pe.LTC_FLOAT_1, r.rectAreaLTC2 = Pe.LTC_FLOAT_2) : n24.has("OES_texture_half_float_linear") === true ? (r.rectAreaLTC1 = Pe.LTC_HALF_1, r.rectAreaLTC2 = Pe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = p, r.ambient[1] = g, r.ambient[2] = v;
    const N = r.hash;
    (N.directionalLength !== S || N.pointLength !== M || N.spotLength !== m || N.rectAreaLength !== w || N.hemiLength !== E || N.numDirectionalShadows !== A || N.numPointShadows !== P || N.numSpotShadows !== R || N.numSpotMaps !== L || N.numLightProbes !== F) && (r.directional.length = S, r.spot.length = m, r.rectArea.length = w, r.point.length = M, r.hemi.length = E, r.directionalShadow.length = A, r.directionalShadowMap.length = A, r.pointShadow.length = P, r.pointShadowMap.length = P, r.spotShadow.length = R, r.spotShadowMap.length = R, r.directionalShadowMatrix.length = A, r.pointShadowMatrix.length = P, r.spotLightMatrix.length = R + L - D, r.spotLightMap.length = L, r.numSpotLightShadowsWithMaps = D, r.numLightProbes = F, N.directionalLength = S, N.pointLength = M, N.spotLength = m, N.rectAreaLength = w, N.hemiLength = E, N.numDirectionalShadows = A, N.numPointShadows = P, N.numSpotShadows = R, N.numSpotMaps = L, N.numLightProbes = F, r.version = rW++);
  }
  function f(h, d) {
    let p = 0, g = 0, v = 0, S = 0, M = 0;
    const m = d.matrixWorldInverse;
    for (let w = 0, E = h.length; w < E; w++) {
      const A = h[w];
      if (A.isDirectionalLight) {
        const P = r.directional[p];
        P.direction.setFromMatrixPosition(A.matrixWorld), s.setFromMatrixPosition(A.target.matrixWorld), P.direction.sub(s), P.direction.transformDirection(m), p++;
      } else if (A.isSpotLight) {
        const P = r.spot[v];
        P.position.setFromMatrixPosition(A.matrixWorld), P.position.applyMatrix4(m), P.direction.setFromMatrixPosition(A.matrixWorld), s.setFromMatrixPosition(A.target.matrixWorld), P.direction.sub(s), P.direction.transformDirection(m), v++;
      } else if (A.isRectAreaLight) {
        const P = r.rectArea[S];
        P.position.setFromMatrixPosition(A.matrixWorld), P.position.applyMatrix4(m), a.identity(), o.copy(A.matrixWorld), o.premultiply(m), a.extractRotation(o), P.halfWidth.set(A.width * 0.5, 0, 0), P.halfHeight.set(0, A.height * 0.5, 0), P.halfWidth.applyMatrix4(a), P.halfHeight.applyMatrix4(a), S++;
      } else if (A.isPointLight) {
        const P = r.point[g];
        P.position.setFromMatrixPosition(A.matrixWorld), P.position.applyMatrix4(m), g++;
      } else if (A.isHemisphereLight) {
        const P = r.hemi[M];
        P.direction.setFromMatrixPosition(A.matrixWorld), P.direction.transformDirection(m), M++;
      }
    }
  }
  return { setup: l, setupView: f, state: r };
}
function TC(n24, e) {
  const t = new oW(n24, e), i = [], r = [];
  function s() {
    i.length = 0, r.length = 0;
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function l(d) {
    t.setup(i, d);
  }
  function f(d) {
    t.setupView(i, d);
  }
  return { init: s, state: { lightsArray: i, shadowsArray: r, lights: t }, setupLights: l, setupLightsView: f, pushLight: o, pushShadow: a };
}
function aW(n24, e) {
  let t = /* @__PURE__ */ new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return a === void 0 ? (l = new TC(n24, e), t.set(s, [l])) : o >= a.length ? (l = new TC(n24, e), a.push(l)) : l = a[o], l;
  }
  function r() {
    t = /* @__PURE__ */ new WeakMap();
  }
  return { get: i, dispose: r };
}
class Nw extends Ii {
  constructor(e) {
    super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = nI, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
  }
}
class Dw extends Ii {
  constructor(e) {
    super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
  }
}
const lW = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, uW = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function cW(n24, e, t) {
  let i = new Wd();
  const r = new _e(), s = new _e(), o = new Gt(), a = new Nw({ depthPacking: iI }), l = new Dw(), f = {}, h = t.maxTextureSize, d = { [ko]: Gi, [Gi]: ko, [Xs]: Xs }, p = new bs({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new _e() }, radius: { value: 4 } }, vertexShader: lW, fragmentShader: uW }), g = p.clone();
  g.defines.HORIZONTAL_PASS = 1;
  const v = new xt();
  v.setAttribute("position", new zt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
  const S = new Hn(v, p), M = this;
  this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = E_;
  let m = this.type;
  this.render = function(R, L, D) {
    if (M.enabled === false || M.autoUpdate === false && M.needsUpdate === false || R.length === 0) return;
    const F = n24.getRenderTarget(), C = n24.getActiveCubeFace(), N = n24.getActiveMipmapLevel(), j = n24.state;
    j.setBlending(Lo), j.buffers.color.setClear(1, 1, 1, 1), j.buffers.depth.setTest(true), j.setScissorTest(false);
    const Z = m !== vs && this.type === vs, G = m === vs && this.type !== vs;
    for (let J = 0, q = R.length; J < q; J++) {
      const ae = R[J], B = ae.shadow;
      if (B === void 0) {
        console.warn("THREE.WebGLShadowMap:", ae, "has no shadow.");
        continue;
      }
      if (B.autoUpdate === false && B.needsUpdate === false) continue;
      r.copy(B.mapSize);
      const Y = B.getFrameExtents();
      if (r.multiply(Y), s.copy(B.mapSize), (r.x > h || r.y > h) && (r.x > h && (s.x = Math.floor(h / Y.x), r.x = s.x * Y.x, B.mapSize.x = s.x), r.y > h && (s.y = Math.floor(h / Y.y), r.y = s.y * Y.y, B.mapSize.y = s.y)), B.map === null || Z === true || G === true) {
        const ee = this.type !== vs ? { minFilter: Pn, magFilter: Pn } : {};
        B.map !== null && B.map.dispose(), B.map = new As(r.x, r.y, ee), B.map.texture.name = ae.name + ".shadowMap", B.camera.updateProjectionMatrix();
      }
      n24.setRenderTarget(B.map), n24.clear();
      const $ = B.getViewportCount();
      for (let ee = 0; ee < $; ee++) {
        const ue = B.getViewport(ee);
        o.set(s.x * ue.x, s.y * ue.y, s.x * ue.z, s.y * ue.w), j.viewport(o), B.updateMatrices(ae, ee), i = B.getFrustum(), A(L, D, B.camera, ae, this.type);
      }
      B.isPointLightShadow !== true && this.type === vs && w(B, D), B.needsUpdate = false;
    }
    m = this.type, M.needsUpdate = false, n24.setRenderTarget(F, C, N);
  };
  function w(R, L) {
    const D = e.update(S);
    p.defines.VSM_SAMPLES !== R.blurSamples && (p.defines.VSM_SAMPLES = R.blurSamples, g.defines.VSM_SAMPLES = R.blurSamples, p.needsUpdate = true, g.needsUpdate = true), R.mapPass === null && (R.mapPass = new As(r.x, r.y)), p.uniforms.shadow_pass.value = R.map.texture, p.uniforms.resolution.value = R.mapSize, p.uniforms.radius.value = R.radius, n24.setRenderTarget(R.mapPass), n24.clear(), n24.renderBufferDirect(L, null, D, p, S, null), g.uniforms.shadow_pass.value = R.mapPass.texture, g.uniforms.resolution.value = R.mapSize, g.uniforms.radius.value = R.radius, n24.setRenderTarget(R.map), n24.clear(), n24.renderBufferDirect(L, null, D, g, S, null);
  }
  function E(R, L, D, F) {
    let C = null;
    const N = D.isPointLight === true ? R.customDistanceMaterial : R.customDepthMaterial;
    if (N !== void 0) C = N;
    else if (C = D.isPointLight === true ? l : a, n24.localClippingEnabled && L.clipShadows === true && Array.isArray(L.clippingPlanes) && L.clippingPlanes.length !== 0 || L.displacementMap && L.displacementScale !== 0 || L.alphaMap && L.alphaTest > 0 || L.map && L.alphaTest > 0) {
      const j = C.uuid, Z = L.uuid;
      let G = f[j];
      G === void 0 && (G = {}, f[j] = G);
      let J = G[Z];
      J === void 0 && (J = C.clone(), G[Z] = J, L.addEventListener("dispose", P)), C = J;
    }
    if (C.visible = L.visible, C.wireframe = L.wireframe, F === vs ? C.side = L.shadowSide !== null ? L.shadowSide : L.side : C.side = L.shadowSide !== null ? L.shadowSide : d[L.side], C.alphaMap = L.alphaMap, C.alphaTest = L.alphaTest, C.map = L.map, C.clipShadows = L.clipShadows, C.clippingPlanes = L.clippingPlanes, C.clipIntersection = L.clipIntersection, C.displacementMap = L.displacementMap, C.displacementScale = L.displacementScale, C.displacementBias = L.displacementBias, C.wireframeLinewidth = L.wireframeLinewidth, C.linewidth = L.linewidth, D.isPointLight === true && C.isMeshDistanceMaterial === true) {
      const j = n24.properties.get(C);
      j.light = D;
    }
    return C;
  }
  function A(R, L, D, F, C) {
    if (R.visible === false) return;
    if (R.layers.test(L.layers) && (R.isMesh || R.isLine || R.isPoints) && (R.castShadow || R.receiveShadow && C === vs) && (!R.frustumCulled || i.intersectsObject(R))) {
      R.modelViewMatrix.multiplyMatrices(D.matrixWorldInverse, R.matrixWorld);
      const Z = e.update(R), G = R.material;
      if (Array.isArray(G)) {
        const J = Z.groups;
        for (let q = 0, ae = J.length; q < ae; q++) {
          const B = J[q], Y = G[B.materialIndex];
          if (Y && Y.visible) {
            const $ = E(R, Y, F, C);
            R.onBeforeShadow(n24, R, L, D, Z, $, B), n24.renderBufferDirect(D, null, Z, $, R, B), R.onAfterShadow(n24, R, L, D, Z, $, B);
          }
        }
      } else if (G.visible) {
        const J = E(R, G, F, C);
        R.onBeforeShadow(n24, R, L, D, Z, J, null), n24.renderBufferDirect(D, null, Z, J, R, null), R.onAfterShadow(n24, R, L, D, Z, J, null);
      }
    }
    const j = R.children;
    for (let Z = 0, G = j.length; Z < G; Z++) A(j[Z], L, D, F, C);
  }
  function P(R) {
    R.target.removeEventListener("dispose", P);
    for (const D in f) {
      const F = f[D], C = R.target.uuid;
      C in F && (F[C].dispose(), delete F[C]);
    }
  }
}
function fW(n24, e, t) {
  const i = t.isWebGL2;
  function r() {
    let W = false;
    const be = new Gt();
    let Ce = null;
    const $e = new Gt(0, 0, 0, 0);
    return { setMask: function(nt) {
      Ce !== nt && !W && (n24.colorMask(nt, nt, nt, nt), Ce = nt);
    }, setLocked: function(nt) {
      W = nt;
    }, setClear: function(nt, Ut, Vt, Dn, Ni) {
      Ni === true && (nt *= Dn, Ut *= Dn, Vt *= Dn), be.set(nt, Ut, Vt, Dn), $e.equals(be) === false && (n24.clearColor(nt, Ut, Vt, Dn), $e.copy(be));
    }, reset: function() {
      W = false, Ce = null, $e.set(-1, 0, 0, 0);
    } };
  }
  function s() {
    let W = false, be = null, Ce = null, $e = null;
    return { setTest: function(nt) {
      nt ? Oe(n24.DEPTH_TEST) : at(n24.DEPTH_TEST);
    }, setMask: function(nt) {
      be !== nt && !W && (n24.depthMask(nt), be = nt);
    }, setFunc: function(nt) {
      if (Ce !== nt) {
        switch (nt) {
          case PL:
            n24.depthFunc(n24.NEVER);
            break;
          case LL:
            n24.depthFunc(n24.ALWAYS);
            break;
          case IL:
            n24.depthFunc(n24.LESS);
            break;
          case Jh:
            n24.depthFunc(n24.LEQUAL);
            break;
          case NL:
            n24.depthFunc(n24.EQUAL);
            break;
          case DL:
            n24.depthFunc(n24.GEQUAL);
            break;
          case OL:
            n24.depthFunc(n24.GREATER);
            break;
          case UL:
            n24.depthFunc(n24.NOTEQUAL);
            break;
          default:
            n24.depthFunc(n24.LEQUAL);
        }
        Ce = nt;
      }
    }, setLocked: function(nt) {
      W = nt;
    }, setClear: function(nt) {
      $e !== nt && (n24.clearDepth(nt), $e = nt);
    }, reset: function() {
      W = false, be = null, Ce = null, $e = null;
    } };
  }
  function o() {
    let W = false, be = null, Ce = null, $e = null, nt = null, Ut = null, Vt = null, Dn = null, Ni = null;
    return { setTest: function(jt) {
      W || (jt ? Oe(n24.STENCIL_TEST) : at(n24.STENCIL_TEST));
    }, setMask: function(jt) {
      be !== jt && !W && (n24.stencilMask(jt), be = jt);
    }, setFunc: function(jt, oi, kr) {
      (Ce !== jt || $e !== oi || nt !== kr) && (n24.stencilFunc(jt, oi, kr), Ce = jt, $e = oi, nt = kr);
    }, setOp: function(jt, oi, kr) {
      (Ut !== jt || Vt !== oi || Dn !== kr) && (n24.stencilOp(jt, oi, kr), Ut = jt, Vt = oi, Dn = kr);
    }, setLocked: function(jt) {
      W = jt;
    }, setClear: function(jt) {
      Ni !== jt && (n24.clearStencil(jt), Ni = jt);
    }, reset: function() {
      W = false, be = null, Ce = null, $e = null, nt = null, Ut = null, Vt = null, Dn = null, Ni = null;
    } };
  }
  const a = new r(), l = new s(), f = new o(), h = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap();
  let p = {}, g = {}, v = /* @__PURE__ */ new WeakMap(), S = [], M = null, m = false, w = null, E = null, A = null, P = null, R = null, L = null, D = null, F = new Ve(0, 0, 0), C = 0, N = false, j = null, Z = null, G = null, J = null, q = null;
  const ae = n24.getParameter(n24.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let B = false, Y = 0;
  const $ = n24.getParameter(n24.VERSION);
  $.indexOf("WebGL") !== -1 ? (Y = parseFloat(/^WebGL (\d)/.exec($)[1]), B = Y >= 1) : $.indexOf("OpenGL ES") !== -1 && (Y = parseFloat(/^OpenGL ES (\d)/.exec($)[1]), B = Y >= 2);
  let ee = null, ue = {};
  const Ae = n24.getParameter(n24.SCISSOR_BOX), te = n24.getParameter(n24.VIEWPORT), de = new Gt().fromArray(Ae), Ee = new Gt().fromArray(te);
  function Ie(W, be, Ce, $e) {
    const nt = new Uint8Array(4), Ut = n24.createTexture();
    n24.bindTexture(W, Ut), n24.texParameteri(W, n24.TEXTURE_MIN_FILTER, n24.NEAREST), n24.texParameteri(W, n24.TEXTURE_MAG_FILTER, n24.NEAREST);
    for (let Vt = 0; Vt < Ce; Vt++) i && (W === n24.TEXTURE_3D || W === n24.TEXTURE_2D_ARRAY) ? n24.texImage3D(be, 0, n24.RGBA, 1, 1, $e, 0, n24.RGBA, n24.UNSIGNED_BYTE, nt) : n24.texImage2D(be + Vt, 0, n24.RGBA, 1, 1, 0, n24.RGBA, n24.UNSIGNED_BYTE, nt);
    return Ut;
  }
  const Ze = {};
  Ze[n24.TEXTURE_2D] = Ie(n24.TEXTURE_2D, n24.TEXTURE_2D, 1), Ze[n24.TEXTURE_CUBE_MAP] = Ie(n24.TEXTURE_CUBE_MAP, n24.TEXTURE_CUBE_MAP_POSITIVE_X, 6), i && (Ze[n24.TEXTURE_2D_ARRAY] = Ie(n24.TEXTURE_2D_ARRAY, n24.TEXTURE_2D_ARRAY, 1, 1), Ze[n24.TEXTURE_3D] = Ie(n24.TEXTURE_3D, n24.TEXTURE_3D, 1, 1)), a.setClear(0, 0, 0, 1), l.setClear(1), f.setClear(0), Oe(n24.DEPTH_TEST), l.setFunc(Jh), Ne(false), U(B1), Oe(n24.CULL_FACE), me(Lo);
  function Oe(W) {
    p[W] !== true && (n24.enable(W), p[W] = true);
  }
  function at(W) {
    p[W] !== false && (n24.disable(W), p[W] = false);
  }
  function Ge(W, be) {
    return g[W] !== be ? (n24.bindFramebuffer(W, be), g[W] = be, i && (W === n24.DRAW_FRAMEBUFFER && (g[n24.FRAMEBUFFER] = be), W === n24.FRAMEBUFFER && (g[n24.DRAW_FRAMEBUFFER] = be)), true) : false;
  }
  function X(W, be) {
    let Ce = S, $e = false;
    if (W) if (Ce = v.get(be), Ce === void 0 && (Ce = [], v.set(be, Ce)), W.isWebGLMultipleRenderTargets) {
      const nt = W.texture;
      if (Ce.length !== nt.length || Ce[0] !== n24.COLOR_ATTACHMENT0) {
        for (let Ut = 0, Vt = nt.length; Ut < Vt; Ut++) Ce[Ut] = n24.COLOR_ATTACHMENT0 + Ut;
        Ce.length = nt.length, $e = true;
      }
    } else Ce[0] !== n24.COLOR_ATTACHMENT0 && (Ce[0] = n24.COLOR_ATTACHMENT0, $e = true);
    else Ce[0] !== n24.BACK && (Ce[0] = n24.BACK, $e = true);
    $e && (t.isWebGL2 ? n24.drawBuffers(Ce) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Ce));
  }
  function Se(W) {
    return M !== W ? (n24.useProgram(W), M = W, true) : false;
  }
  const pe = { [pa]: n24.FUNC_ADD, [mL]: n24.FUNC_SUBTRACT, [gL]: n24.FUNC_REVERSE_SUBTRACT };
  if (i) pe[W1] = n24.MIN, pe[X1] = n24.MAX;
  else {
    const W = e.get("EXT_blend_minmax");
    W !== null && (pe[W1] = W.MIN_EXT, pe[X1] = W.MAX_EXT);
  }
  const we = { [_L]: n24.ZERO, [vL]: n24.ONE, [yL]: n24.SRC_COLOR, [f0]: n24.SRC_ALPHA, [TL]: n24.SRC_ALPHA_SATURATE, [wL]: n24.DST_COLOR, [SL]: n24.DST_ALPHA, [xL]: n24.ONE_MINUS_SRC_COLOR, [h0]: n24.ONE_MINUS_SRC_ALPHA, [EL]: n24.ONE_MINUS_DST_COLOR, [ML]: n24.ONE_MINUS_DST_ALPHA, [AL]: n24.CONSTANT_COLOR, [bL]: n24.ONE_MINUS_CONSTANT_COLOR, [CL]: n24.CONSTANT_ALPHA, [RL]: n24.ONE_MINUS_CONSTANT_ALPHA };
  function me(W, be, Ce, $e, nt, Ut, Vt, Dn, Ni, jt) {
    if (W === Lo) {
      m === true && (at(n24.BLEND), m = false);
      return;
    }
    if (m === false && (Oe(n24.BLEND), m = true), W !== pL) {
      if (W !== w || jt !== N) {
        if ((E !== pa || R !== pa) && (n24.blendEquation(n24.FUNC_ADD), E = pa, R = pa), jt) switch (W) {
          case Dl:
            n24.blendFuncSeparate(n24.ONE, n24.ONE_MINUS_SRC_ALPHA, n24.ONE, n24.ONE_MINUS_SRC_ALPHA);
            break;
          case V1:
            n24.blendFunc(n24.ONE, n24.ONE);
            break;
          case H1:
            n24.blendFuncSeparate(n24.ZERO, n24.ONE_MINUS_SRC_COLOR, n24.ZERO, n24.ONE);
            break;
          case G1:
            n24.blendFuncSeparate(n24.ZERO, n24.SRC_COLOR, n24.ZERO, n24.SRC_ALPHA);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", W);
            break;
        }
        else switch (W) {
          case Dl:
            n24.blendFuncSeparate(n24.SRC_ALPHA, n24.ONE_MINUS_SRC_ALPHA, n24.ONE, n24.ONE_MINUS_SRC_ALPHA);
            break;
          case V1:
            n24.blendFunc(n24.SRC_ALPHA, n24.ONE);
            break;
          case H1:
            n24.blendFuncSeparate(n24.ZERO, n24.ONE_MINUS_SRC_COLOR, n24.ZERO, n24.ONE);
            break;
          case G1:
            n24.blendFunc(n24.ZERO, n24.SRC_COLOR);
            break;
          default:
            console.error("THREE.WebGLState: Invalid blending: ", W);
            break;
        }
        A = null, P = null, L = null, D = null, F.set(0, 0, 0), C = 0, w = W, N = jt;
      }
      return;
    }
    nt = nt || be, Ut = Ut || Ce, Vt = Vt || $e, (be !== E || nt !== R) && (n24.blendEquationSeparate(pe[be], pe[nt]), E = be, R = nt), (Ce !== A || $e !== P || Ut !== L || Vt !== D) && (n24.blendFuncSeparate(we[Ce], we[$e], we[Ut], we[Vt]), A = Ce, P = $e, L = Ut, D = Vt), (Dn.equals(F) === false || Ni !== C) && (n24.blendColor(Dn.r, Dn.g, Dn.b, Ni), F.copy(Dn), C = Ni), w = W, N = false;
  }
  function qe(W, be) {
    W.side === Xs ? at(n24.CULL_FACE) : Oe(n24.CULL_FACE);
    let Ce = W.side === Gi;
    be && (Ce = !Ce), Ne(Ce), W.blending === Dl && W.transparent === false ? me(Lo) : me(W.blending, W.blendEquation, W.blendSrc, W.blendDst, W.blendEquationAlpha, W.blendSrcAlpha, W.blendDstAlpha, W.blendColor, W.blendAlpha, W.premultipliedAlpha), l.setFunc(W.depthFunc), l.setTest(W.depthTest), l.setMask(W.depthWrite), a.setMask(W.colorWrite);
    const $e = W.stencilWrite;
    f.setTest($e), $e && (f.setMask(W.stencilWriteMask), f.setFunc(W.stencilFunc, W.stencilRef, W.stencilFuncMask), f.setOp(W.stencilFail, W.stencilZFail, W.stencilZPass)), ie(W.polygonOffset, W.polygonOffsetFactor, W.polygonOffsetUnits), W.alphaToCoverage === true ? Oe(n24.SAMPLE_ALPHA_TO_COVERAGE) : at(n24.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function Ne(W) {
    j !== W && (W ? n24.frontFace(n24.CW) : n24.frontFace(n24.CCW), j = W);
  }
  function U(W) {
    W !== fL ? (Oe(n24.CULL_FACE), W !== Z && (W === B1 ? n24.cullFace(n24.BACK) : W === hL ? n24.cullFace(n24.FRONT) : n24.cullFace(n24.FRONT_AND_BACK))) : at(n24.CULL_FACE), Z = W;
  }
  function O(W) {
    W !== G && (B && n24.lineWidth(W), G = W);
  }
  function ie(W, be, Ce) {
    W ? (Oe(n24.POLYGON_OFFSET_FILL), (J !== be || q !== Ce) && (n24.polygonOffset(be, Ce), J = be, q = Ce)) : at(n24.POLYGON_OFFSET_FILL);
  }
  function xe(W) {
    W ? Oe(n24.SCISSOR_TEST) : at(n24.SCISSOR_TEST);
  }
  function ve(W) {
    W === void 0 && (W = n24.TEXTURE0 + ae - 1), ee !== W && (n24.activeTexture(W), ee = W);
  }
  function ge(W, be, Ce) {
    Ce === void 0 && (ee === null ? Ce = n24.TEXTURE0 + ae - 1 : Ce = ee);
    let $e = ue[Ce];
    $e === void 0 && ($e = { type: void 0, texture: void 0 }, ue[Ce] = $e), ($e.type !== W || $e.texture !== be) && (ee !== Ce && (n24.activeTexture(Ce), ee = Ce), n24.bindTexture(W, be || Ze[W]), $e.type = W, $e.texture = be);
  }
  function ze() {
    const W = ue[ee];
    W !== void 0 && W.type !== void 0 && (n24.bindTexture(W.type, null), W.type = void 0, W.texture = void 0);
  }
  function Le() {
    try {
      n24.compressedTexImage2D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function ke() {
    try {
      n24.compressedTexImage3D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function et() {
    try {
      n24.texSubImage2D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function Re() {
    try {
      n24.texSubImage3D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function ye() {
    try {
      n24.compressedTexSubImage2D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function bt() {
    try {
      n24.compressedTexSubImage3D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function gt() {
    try {
      n24.texStorage2D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function ut() {
    try {
      n24.texStorage3D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function tt() {
    try {
      n24.texImage2D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function je() {
    try {
      n24.texImage3D.apply(n24, arguments);
    } catch (W) {
      console.error("THREE.WebGLState:", W);
    }
  }
  function _t(W) {
    de.equals(W) === false && (n24.scissor(W.x, W.y, W.z, W.w), de.copy(W));
  }
  function Lt(W) {
    Ee.equals(W) === false && (n24.viewport(W.x, W.y, W.z, W.w), Ee.copy(W));
  }
  function $t(W, be) {
    let Ce = d.get(be);
    Ce === void 0 && (Ce = /* @__PURE__ */ new WeakMap(), d.set(be, Ce));
    let $e = Ce.get(W);
    $e === void 0 && ($e = n24.getUniformBlockIndex(be, W.name), Ce.set(W, $e));
  }
  function Tt(W, be) {
    const $e = d.get(be).get(W);
    h.get(be) !== $e && (n24.uniformBlockBinding(be, $e, W.__bindingPointIndex), h.set(be, $e));
  }
  function Bt() {
    n24.disable(n24.BLEND), n24.disable(n24.CULL_FACE), n24.disable(n24.DEPTH_TEST), n24.disable(n24.POLYGON_OFFSET_FILL), n24.disable(n24.SCISSOR_TEST), n24.disable(n24.STENCIL_TEST), n24.disable(n24.SAMPLE_ALPHA_TO_COVERAGE), n24.blendEquation(n24.FUNC_ADD), n24.blendFunc(n24.ONE, n24.ZERO), n24.blendFuncSeparate(n24.ONE, n24.ZERO, n24.ONE, n24.ZERO), n24.blendColor(0, 0, 0, 0), n24.colorMask(true, true, true, true), n24.clearColor(0, 0, 0, 0), n24.depthMask(true), n24.depthFunc(n24.LESS), n24.clearDepth(1), n24.stencilMask(4294967295), n24.stencilFunc(n24.ALWAYS, 0, 4294967295), n24.stencilOp(n24.KEEP, n24.KEEP, n24.KEEP), n24.clearStencil(0), n24.cullFace(n24.BACK), n24.frontFace(n24.CCW), n24.polygonOffset(0, 0), n24.activeTexture(n24.TEXTURE0), n24.bindFramebuffer(n24.FRAMEBUFFER, null), i === true && (n24.bindFramebuffer(n24.DRAW_FRAMEBUFFER, null), n24.bindFramebuffer(n24.READ_FRAMEBUFFER, null)), n24.useProgram(null), n24.lineWidth(1), n24.scissor(0, 0, n24.canvas.width, n24.canvas.height), n24.viewport(0, 0, n24.canvas.width, n24.canvas.height), p = {}, ee = null, ue = {}, g = {}, v = /* @__PURE__ */ new WeakMap(), S = [], M = null, m = false, w = null, E = null, A = null, P = null, R = null, L = null, D = null, F = new Ve(0, 0, 0), C = 0, N = false, j = null, Z = null, G = null, J = null, q = null, de.set(0, 0, n24.canvas.width, n24.canvas.height), Ee.set(0, 0, n24.canvas.width, n24.canvas.height), a.reset(), l.reset(), f.reset();
  }
  return { buffers: { color: a, depth: l, stencil: f }, enable: Oe, disable: at, bindFramebuffer: Ge, drawBuffers: X, useProgram: Se, setBlending: me, setMaterial: qe, setFlipSided: Ne, setCullFace: U, setLineWidth: O, setPolygonOffset: ie, setScissorTest: xe, activeTexture: ve, bindTexture: ge, unbindTexture: ze, compressedTexImage2D: Le, compressedTexImage3D: ke, texImage2D: tt, texImage3D: je, updateUBOMapping: $t, uniformBlockBinding: Tt, texStorage2D: gt, texStorage3D: ut, texSubImage2D: et, texSubImage3D: Re, compressedTexSubImage2D: ye, compressedTexSubImage3D: bt, scissor: _t, viewport: Lt, reset: Bt };
}
function hW(n24, e, t, i, r, s, o) {
  const a = r.isWebGL2, l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), h = /* @__PURE__ */ new WeakMap();
  let d;
  const p = /* @__PURE__ */ new WeakMap();
  let g = false;
  try {
    g = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {
  }
  function v(U, O) {
    return g ? new OffscreenCanvas(U, O) : fd("canvas");
  }
  function S(U, O, ie, xe) {
    let ve = 1;
    if ((U.width > xe || U.height > xe) && (ve = xe / Math.max(U.width, U.height)), ve < 1 || O === true) if (typeof HTMLImageElement < "u" && U instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && U instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && U instanceof ImageBitmap) {
      const ge = O ? m0 : Math.floor, ze = ge(ve * U.width), Le = ge(ve * U.height);
      d === void 0 && (d = v(ze, Le));
      const ke = ie ? v(ze, Le) : d;
      return ke.width = ze, ke.height = Le, ke.getContext("2d").drawImage(U, 0, 0, ze, Le), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + U.width + "x" + U.height + ") to (" + ze + "x" + Le + ")."), ke;
    } else return "data" in U && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + U.width + "x" + U.height + ")."), U;
    return U;
  }
  function M(U) {
    return xS(U.width) && xS(U.height);
  }
  function m(U) {
    return a ? false : U.wrapS !== Ai || U.wrapT !== Ai || U.minFilter !== Pn && U.minFilter !== fn;
  }
  function w(U, O) {
    return U.generateMipmaps && O && U.minFilter !== Pn && U.minFilter !== fn;
  }
  function E(U) {
    n24.generateMipmap(U);
  }
  function A(U, O, ie, xe, ve = false) {
    if (a === false) return O;
    if (U !== null) {
      if (n24[U] !== void 0) return n24[U];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + U + "'");
    }
    let ge = O;
    if (O === n24.RED && (ie === n24.FLOAT && (ge = n24.R32F), ie === n24.HALF_FLOAT && (ge = n24.R16F), ie === n24.UNSIGNED_BYTE && (ge = n24.R8)), O === n24.RED_INTEGER && (ie === n24.UNSIGNED_BYTE && (ge = n24.R8UI), ie === n24.UNSIGNED_SHORT && (ge = n24.R16UI), ie === n24.UNSIGNED_INT && (ge = n24.R32UI), ie === n24.BYTE && (ge = n24.R8I), ie === n24.SHORT && (ge = n24.R16I), ie === n24.INT && (ge = n24.R32I)), O === n24.RG && (ie === n24.FLOAT && (ge = n24.RG32F), ie === n24.HALF_FLOAT && (ge = n24.RG16F), ie === n24.UNSIGNED_BYTE && (ge = n24.RG8)), O === n24.RGBA) {
      const ze = ve ? od : Ht.getTransfer(xe);
      ie === n24.FLOAT && (ge = n24.RGBA32F), ie === n24.HALF_FLOAT && (ge = n24.RGBA16F), ie === n24.UNSIGNED_BYTE && (ge = ze === Zt ? n24.SRGB8_ALPHA8 : n24.RGBA8), ie === n24.UNSIGNED_SHORT_4_4_4_4 && (ge = n24.RGBA4), ie === n24.UNSIGNED_SHORT_5_5_5_1 && (ge = n24.RGB5_A1);
    }
    return (ge === n24.R16F || ge === n24.R32F || ge === n24.RG16F || ge === n24.RG32F || ge === n24.RGBA16F || ge === n24.RGBA32F) && e.get("EXT_color_buffer_float"), ge;
  }
  function P(U, O, ie) {
    return w(U, ie) === true || U.isFramebufferTexture && U.minFilter !== Pn && U.minFilter !== fn ? Math.log2(Math.max(O.width, O.height)) + 1 : U.mipmaps !== void 0 && U.mipmaps.length > 0 ? U.mipmaps.length : U.isCompressedTexture && Array.isArray(U.image) ? O.mipmaps.length : 1;
  }
  function R(U) {
    return U === Pn || U === d0 || U === xl ? n24.NEAREST : n24.LINEAR;
  }
  function L(U) {
    const O = U.target;
    O.removeEventListener("dispose", L), F(O), O.isVideoTexture && h.delete(O);
  }
  function D(U) {
    const O = U.target;
    O.removeEventListener("dispose", D), N(O);
  }
  function F(U) {
    const O = i.get(U);
    if (O.__webglInit === void 0) return;
    const ie = U.source, xe = p.get(ie);
    if (xe) {
      const ve = xe[O.__cacheKey];
      ve.usedTimes--, ve.usedTimes === 0 && C(U), Object.keys(xe).length === 0 && p.delete(ie);
    }
    i.remove(U);
  }
  function C(U) {
    const O = i.get(U);
    n24.deleteTexture(O.__webglTexture);
    const ie = U.source, xe = p.get(ie);
    delete xe[O.__cacheKey], o.memory.textures--;
  }
  function N(U) {
    const O = U.texture, ie = i.get(U), xe = i.get(O);
    if (xe.__webglTexture !== void 0 && (n24.deleteTexture(xe.__webglTexture), o.memory.textures--), U.depthTexture && U.depthTexture.dispose(), U.isWebGLCubeRenderTarget) for (let ve = 0; ve < 6; ve++) {
      if (Array.isArray(ie.__webglFramebuffer[ve])) for (let ge = 0; ge < ie.__webglFramebuffer[ve].length; ge++) n24.deleteFramebuffer(ie.__webglFramebuffer[ve][ge]);
      else n24.deleteFramebuffer(ie.__webglFramebuffer[ve]);
      ie.__webglDepthbuffer && n24.deleteRenderbuffer(ie.__webglDepthbuffer[ve]);
    }
    else {
      if (Array.isArray(ie.__webglFramebuffer)) for (let ve = 0; ve < ie.__webglFramebuffer.length; ve++) n24.deleteFramebuffer(ie.__webglFramebuffer[ve]);
      else n24.deleteFramebuffer(ie.__webglFramebuffer);
      if (ie.__webglDepthbuffer && n24.deleteRenderbuffer(ie.__webglDepthbuffer), ie.__webglMultisampledFramebuffer && n24.deleteFramebuffer(ie.__webglMultisampledFramebuffer), ie.__webglColorRenderbuffer) for (let ve = 0; ve < ie.__webglColorRenderbuffer.length; ve++) ie.__webglColorRenderbuffer[ve] && n24.deleteRenderbuffer(ie.__webglColorRenderbuffer[ve]);
      ie.__webglDepthRenderbuffer && n24.deleteRenderbuffer(ie.__webglDepthRenderbuffer);
    }
    if (U.isWebGLMultipleRenderTargets) for (let ve = 0, ge = O.length; ve < ge; ve++) {
      const ze = i.get(O[ve]);
      ze.__webglTexture && (n24.deleteTexture(ze.__webglTexture), o.memory.textures--), i.remove(O[ve]);
    }
    i.remove(O), i.remove(U);
  }
  let j = 0;
  function Z() {
    j = 0;
  }
  function G() {
    const U = j;
    return U >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + U + " texture units while this GPU supports only " + r.maxTextures), j += 1, U;
  }
  function J(U) {
    const O = [];
    return O.push(U.wrapS), O.push(U.wrapT), O.push(U.wrapR || 0), O.push(U.magFilter), O.push(U.minFilter), O.push(U.anisotropy), O.push(U.internalFormat), O.push(U.format), O.push(U.type), O.push(U.generateMipmaps), O.push(U.premultiplyAlpha), O.push(U.flipY), O.push(U.unpackAlignment), O.push(U.colorSpace), O.join();
  }
  function q(U, O) {
    const ie = i.get(U);
    if (U.isVideoTexture && qe(U), U.isRenderTargetTexture === false && U.version > 0 && ie.__version !== U.version) {
      const xe = U.image;
      if (xe === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      else if (xe.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      else {
        de(ie, U, O);
        return;
      }
    }
    t.bindTexture(n24.TEXTURE_2D, ie.__webglTexture, n24.TEXTURE0 + O);
  }
  function ae(U, O) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      de(ie, U, O);
      return;
    }
    t.bindTexture(n24.TEXTURE_2D_ARRAY, ie.__webglTexture, n24.TEXTURE0 + O);
  }
  function B(U, O) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      de(ie, U, O);
      return;
    }
    t.bindTexture(n24.TEXTURE_3D, ie.__webglTexture, n24.TEXTURE0 + O);
  }
  function Y(U, O) {
    const ie = i.get(U);
    if (U.version > 0 && ie.__version !== U.version) {
      Ee(ie, U, O);
      return;
    }
    t.bindTexture(n24.TEXTURE_CUBE_MAP, ie.__webglTexture, n24.TEXTURE0 + O);
  }
  const $ = { [td]: n24.REPEAT, [Ai]: n24.CLAMP_TO_EDGE, [nd]: n24.MIRRORED_REPEAT }, ee = { [Pn]: n24.NEAREST, [d0]: n24.NEAREST_MIPMAP_NEAREST, [xl]: n24.NEAREST_MIPMAP_LINEAR, [fn]: n24.LINEAR, [Eh]: n24.LINEAR_MIPMAP_NEAREST, [$s]: n24.LINEAR_MIPMAP_LINEAR }, ue = { [sI]: n24.NEVER, [fI]: n24.ALWAYS, [oI]: n24.LESS, [Tw]: n24.LEQUAL, [aI]: n24.EQUAL, [cI]: n24.GEQUAL, [lI]: n24.GREATER, [uI]: n24.NOTEQUAL };
  function Ae(U, O, ie) {
    if (O.type === ns && e.has("OES_texture_float_linear") === false && (O.magFilter === fn || O.magFilter === Eh || O.magFilter === xl || O.magFilter === $s || O.minFilter === fn || O.minFilter === Eh || O.minFilter === xl || O.minFilter === $s) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), ie ? (n24.texParameteri(U, n24.TEXTURE_WRAP_S, $[O.wrapS]), n24.texParameteri(U, n24.TEXTURE_WRAP_T, $[O.wrapT]), (U === n24.TEXTURE_3D || U === n24.TEXTURE_2D_ARRAY) && n24.texParameteri(U, n24.TEXTURE_WRAP_R, $[O.wrapR]), n24.texParameteri(U, n24.TEXTURE_MAG_FILTER, ee[O.magFilter]), n24.texParameteri(U, n24.TEXTURE_MIN_FILTER, ee[O.minFilter])) : (n24.texParameteri(U, n24.TEXTURE_WRAP_S, n24.CLAMP_TO_EDGE), n24.texParameteri(U, n24.TEXTURE_WRAP_T, n24.CLAMP_TO_EDGE), (U === n24.TEXTURE_3D || U === n24.TEXTURE_2D_ARRAY) && n24.texParameteri(U, n24.TEXTURE_WRAP_R, n24.CLAMP_TO_EDGE), (O.wrapS !== Ai || O.wrapT !== Ai) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), n24.texParameteri(U, n24.TEXTURE_MAG_FILTER, R(O.magFilter)), n24.texParameteri(U, n24.TEXTURE_MIN_FILTER, R(O.minFilter)), O.minFilter !== Pn && O.minFilter !== fn && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), O.compareFunction && (n24.texParameteri(U, n24.TEXTURE_COMPARE_MODE, n24.COMPARE_REF_TO_TEXTURE), n24.texParameteri(U, n24.TEXTURE_COMPARE_FUNC, ue[O.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
      const xe = e.get("EXT_texture_filter_anisotropic");
      if (O.magFilter === Pn || O.minFilter !== xl && O.minFilter !== $s || O.type === ns && e.has("OES_texture_float_linear") === false || a === false && O.type === Hc && e.has("OES_texture_half_float_linear") === false) return;
      (O.anisotropy > 1 || i.get(O).__currentAnisotropy) && (n24.texParameterf(U, xe.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, r.getMaxAnisotropy())), i.get(O).__currentAnisotropy = O.anisotropy);
    }
  }
  function te(U, O) {
    let ie = false;
    U.__webglInit === void 0 && (U.__webglInit = true, O.addEventListener("dispose", L));
    const xe = O.source;
    let ve = p.get(xe);
    ve === void 0 && (ve = {}, p.set(xe, ve));
    const ge = J(O);
    if (ge !== U.__cacheKey) {
      ve[ge] === void 0 && (ve[ge] = { texture: n24.createTexture(), usedTimes: 0 }, o.memory.textures++, ie = true), ve[ge].usedTimes++;
      const ze = ve[U.__cacheKey];
      ze !== void 0 && (ve[U.__cacheKey].usedTimes--, ze.usedTimes === 0 && C(O)), U.__cacheKey = ge, U.__webglTexture = ve[ge].texture;
    }
    return ie;
  }
  function de(U, O, ie) {
    let xe = n24.TEXTURE_2D;
    (O.isDataArrayTexture || O.isCompressedArrayTexture) && (xe = n24.TEXTURE_2D_ARRAY), O.isData3DTexture && (xe = n24.TEXTURE_3D);
    const ve = te(U, O), ge = O.source;
    t.bindTexture(xe, U.__webglTexture, n24.TEXTURE0 + ie);
    const ze = i.get(ge);
    if (ge.version !== ze.__version || ve === true) {
      t.activeTexture(n24.TEXTURE0 + ie);
      const Le = Ht.getPrimaries(Ht.workingColorSpace), ke = O.colorSpace === Mr ? null : Ht.getPrimaries(O.colorSpace), et = O.colorSpace === Mr || Le === ke ? n24.NONE : n24.BROWSER_DEFAULT_WEBGL;
      n24.pixelStorei(n24.UNPACK_FLIP_Y_WEBGL, O.flipY), n24.pixelStorei(n24.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), n24.pixelStorei(n24.UNPACK_ALIGNMENT, O.unpackAlignment), n24.pixelStorei(n24.UNPACK_COLORSPACE_CONVERSION_WEBGL, et);
      const Re = m(O) && M(O.image) === false;
      let ye = S(O.image, Re, false, r.maxTextureSize);
      ye = Ne(O, ye);
      const bt = M(ye) || a, gt = s.convert(O.format, O.colorSpace);
      let ut = s.convert(O.type), tt = A(O.internalFormat, gt, ut, O.colorSpace, O.isVideoTexture);
      Ae(xe, O, bt);
      let je;
      const _t = O.mipmaps, Lt = a && O.isVideoTexture !== true && tt !== Mw, $t = ze.__version === void 0 || ve === true, Tt = ge.dataReady, Bt = P(O, ye, bt);
      if (O.isDepthTexture) tt = n24.DEPTH_COMPONENT, a ? O.type === ns ? tt = n24.DEPTH_COMPONENT32F : O.type === Co ? tt = n24.DEPTH_COMPONENT24 : O.type === Ca ? tt = n24.DEPTH24_STENCIL8 : tt = n24.DEPTH_COMPONENT16 : O.type === ns && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), O.format === Ra && tt === n24.DEPTH_COMPONENT && O.type !== A_ && O.type !== Co && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), O.type = Co, ut = s.convert(O.type)), O.format === Kl && tt === n24.DEPTH_COMPONENT && (tt = n24.DEPTH_STENCIL, O.type !== Ca && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), O.type = Ca, ut = s.convert(O.type))), $t && (Lt ? t.texStorage2D(n24.TEXTURE_2D, 1, tt, ye.width, ye.height) : t.texImage2D(n24.TEXTURE_2D, 0, tt, ye.width, ye.height, 0, gt, ut, null));
      else if (O.isDataTexture) if (_t.length > 0 && bt) {
        Lt && $t && t.texStorage2D(n24.TEXTURE_2D, Bt, tt, _t[0].width, _t[0].height);
        for (let W = 0, be = _t.length; W < be; W++) je = _t[W], Lt ? Tt && t.texSubImage2D(n24.TEXTURE_2D, W, 0, 0, je.width, je.height, gt, ut, je.data) : t.texImage2D(n24.TEXTURE_2D, W, tt, je.width, je.height, 0, gt, ut, je.data);
        O.generateMipmaps = false;
      } else Lt ? ($t && t.texStorage2D(n24.TEXTURE_2D, Bt, tt, ye.width, ye.height), Tt && t.texSubImage2D(n24.TEXTURE_2D, 0, 0, 0, ye.width, ye.height, gt, ut, ye.data)) : t.texImage2D(n24.TEXTURE_2D, 0, tt, ye.width, ye.height, 0, gt, ut, ye.data);
      else if (O.isCompressedTexture) if (O.isCompressedArrayTexture) {
        Lt && $t && t.texStorage3D(n24.TEXTURE_2D_ARRAY, Bt, tt, _t[0].width, _t[0].height, ye.depth);
        for (let W = 0, be = _t.length; W < be; W++) je = _t[W], O.format !== zi ? gt !== null ? Lt ? Tt && t.compressedTexSubImage3D(n24.TEXTURE_2D_ARRAY, W, 0, 0, 0, je.width, je.height, ye.depth, gt, je.data, 0, 0) : t.compressedTexImage3D(n24.TEXTURE_2D_ARRAY, W, tt, je.width, je.height, ye.depth, 0, je.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Lt ? Tt && t.texSubImage3D(n24.TEXTURE_2D_ARRAY, W, 0, 0, 0, je.width, je.height, ye.depth, gt, ut, je.data) : t.texImage3D(n24.TEXTURE_2D_ARRAY, W, tt, je.width, je.height, ye.depth, 0, gt, ut, je.data);
      } else {
        Lt && $t && t.texStorage2D(n24.TEXTURE_2D, Bt, tt, _t[0].width, _t[0].height);
        for (let W = 0, be = _t.length; W < be; W++) je = _t[W], O.format !== zi ? gt !== null ? Lt ? Tt && t.compressedTexSubImage2D(n24.TEXTURE_2D, W, 0, 0, je.width, je.height, gt, je.data) : t.compressedTexImage2D(n24.TEXTURE_2D, W, tt, je.width, je.height, 0, je.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Lt ? Tt && t.texSubImage2D(n24.TEXTURE_2D, W, 0, 0, je.width, je.height, gt, ut, je.data) : t.texImage2D(n24.TEXTURE_2D, W, tt, je.width, je.height, 0, gt, ut, je.data);
      }
      else if (O.isDataArrayTexture) Lt ? ($t && t.texStorage3D(n24.TEXTURE_2D_ARRAY, Bt, tt, ye.width, ye.height, ye.depth), Tt && t.texSubImage3D(n24.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ye.width, ye.height, ye.depth, gt, ut, ye.data)) : t.texImage3D(n24.TEXTURE_2D_ARRAY, 0, tt, ye.width, ye.height, ye.depth, 0, gt, ut, ye.data);
      else if (O.isData3DTexture) Lt ? ($t && t.texStorage3D(n24.TEXTURE_3D, Bt, tt, ye.width, ye.height, ye.depth), Tt && t.texSubImage3D(n24.TEXTURE_3D, 0, 0, 0, 0, ye.width, ye.height, ye.depth, gt, ut, ye.data)) : t.texImage3D(n24.TEXTURE_3D, 0, tt, ye.width, ye.height, ye.depth, 0, gt, ut, ye.data);
      else if (O.isFramebufferTexture) {
        if ($t) if (Lt) t.texStorage2D(n24.TEXTURE_2D, Bt, tt, ye.width, ye.height);
        else {
          let W = ye.width, be = ye.height;
          for (let Ce = 0; Ce < Bt; Ce++) t.texImage2D(n24.TEXTURE_2D, Ce, tt, W, be, 0, gt, ut, null), W >>= 1, be >>= 1;
        }
      } else if (_t.length > 0 && bt) {
        Lt && $t && t.texStorage2D(n24.TEXTURE_2D, Bt, tt, _t[0].width, _t[0].height);
        for (let W = 0, be = _t.length; W < be; W++) je = _t[W], Lt ? Tt && t.texSubImage2D(n24.TEXTURE_2D, W, 0, 0, gt, ut, je) : t.texImage2D(n24.TEXTURE_2D, W, tt, gt, ut, je);
        O.generateMipmaps = false;
      } else Lt ? ($t && t.texStorage2D(n24.TEXTURE_2D, Bt, tt, ye.width, ye.height), Tt && t.texSubImage2D(n24.TEXTURE_2D, 0, 0, 0, gt, ut, ye)) : t.texImage2D(n24.TEXTURE_2D, 0, tt, gt, ut, ye);
      w(O, bt) && E(xe), ze.__version = ge.version, O.onUpdate && O.onUpdate(O);
    }
    U.__version = O.version;
  }
  function Ee(U, O, ie) {
    if (O.image.length !== 6) return;
    const xe = te(U, O), ve = O.source;
    t.bindTexture(n24.TEXTURE_CUBE_MAP, U.__webglTexture, n24.TEXTURE0 + ie);
    const ge = i.get(ve);
    if (ve.version !== ge.__version || xe === true) {
      t.activeTexture(n24.TEXTURE0 + ie);
      const ze = Ht.getPrimaries(Ht.workingColorSpace), Le = O.colorSpace === Mr ? null : Ht.getPrimaries(O.colorSpace), ke = O.colorSpace === Mr || ze === Le ? n24.NONE : n24.BROWSER_DEFAULT_WEBGL;
      n24.pixelStorei(n24.UNPACK_FLIP_Y_WEBGL, O.flipY), n24.pixelStorei(n24.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), n24.pixelStorei(n24.UNPACK_ALIGNMENT, O.unpackAlignment), n24.pixelStorei(n24.UNPACK_COLORSPACE_CONVERSION_WEBGL, ke);
      const et = O.isCompressedTexture || O.image[0].isCompressedTexture, Re = O.image[0] && O.image[0].isDataTexture, ye = [];
      for (let W = 0; W < 6; W++) !et && !Re ? ye[W] = S(O.image[W], false, true, r.maxCubemapSize) : ye[W] = Re ? O.image[W].image : O.image[W], ye[W] = Ne(O, ye[W]);
      const bt = ye[0], gt = M(bt) || a, ut = s.convert(O.format, O.colorSpace), tt = s.convert(O.type), je = A(O.internalFormat, ut, tt, O.colorSpace), _t = a && O.isVideoTexture !== true, Lt = ge.__version === void 0 || xe === true, $t = ve.dataReady;
      let Tt = P(O, bt, gt);
      Ae(n24.TEXTURE_CUBE_MAP, O, gt);
      let Bt;
      if (et) {
        _t && Lt && t.texStorage2D(n24.TEXTURE_CUBE_MAP, Tt, je, bt.width, bt.height);
        for (let W = 0; W < 6; W++) {
          Bt = ye[W].mipmaps;
          for (let be = 0; be < Bt.length; be++) {
            const Ce = Bt[be];
            O.format !== zi ? ut !== null ? _t ? $t && t.compressedTexSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be, 0, 0, Ce.width, Ce.height, ut, Ce.data) : t.compressedTexImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be, je, Ce.width, Ce.height, 0, Ce.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _t ? $t && t.texSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be, 0, 0, Ce.width, Ce.height, ut, tt, Ce.data) : t.texImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be, je, Ce.width, Ce.height, 0, ut, tt, Ce.data);
          }
        }
      } else {
        Bt = O.mipmaps, _t && Lt && (Bt.length > 0 && Tt++, t.texStorage2D(n24.TEXTURE_CUBE_MAP, Tt, je, ye[0].width, ye[0].height));
        for (let W = 0; W < 6; W++) if (Re) {
          _t ? $t && t.texSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, ye[W].width, ye[W].height, ut, tt, ye[W].data) : t.texImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, je, ye[W].width, ye[W].height, 0, ut, tt, ye[W].data);
          for (let be = 0; be < Bt.length; be++) {
            const $e = Bt[be].image[W].image;
            _t ? $t && t.texSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be + 1, 0, 0, $e.width, $e.height, ut, tt, $e.data) : t.texImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be + 1, je, $e.width, $e.height, 0, ut, tt, $e.data);
          }
        } else {
          _t ? $t && t.texSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, 0, 0, ut, tt, ye[W]) : t.texImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, 0, je, ut, tt, ye[W]);
          for (let be = 0; be < Bt.length; be++) {
            const Ce = Bt[be];
            _t ? $t && t.texSubImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be + 1, 0, 0, ut, tt, Ce.image[W]) : t.texImage2D(n24.TEXTURE_CUBE_MAP_POSITIVE_X + W, be + 1, je, ut, tt, Ce.image[W]);
          }
        }
      }
      w(O, gt) && E(n24.TEXTURE_CUBE_MAP), ge.__version = ve.version, O.onUpdate && O.onUpdate(O);
    }
    U.__version = O.version;
  }
  function Ie(U, O, ie, xe, ve, ge) {
    const ze = s.convert(ie.format, ie.colorSpace), Le = s.convert(ie.type), ke = A(ie.internalFormat, ze, Le, ie.colorSpace);
    if (!i.get(O).__hasExternalTextures) {
      const Re = Math.max(1, O.width >> ge), ye = Math.max(1, O.height >> ge);
      ve === n24.TEXTURE_3D || ve === n24.TEXTURE_2D_ARRAY ? t.texImage3D(ve, ge, ke, Re, ye, O.depth, 0, ze, Le, null) : t.texImage2D(ve, ge, ke, Re, ye, 0, ze, Le, null);
    }
    t.bindFramebuffer(n24.FRAMEBUFFER, U), me(O) ? l.framebufferTexture2DMultisampleEXT(n24.FRAMEBUFFER, xe, ve, i.get(ie).__webglTexture, 0, we(O)) : (ve === n24.TEXTURE_2D || ve >= n24.TEXTURE_CUBE_MAP_POSITIVE_X && ve <= n24.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n24.framebufferTexture2D(n24.FRAMEBUFFER, xe, ve, i.get(ie).__webglTexture, ge), t.bindFramebuffer(n24.FRAMEBUFFER, null);
  }
  function Ze(U, O, ie) {
    if (n24.bindRenderbuffer(n24.RENDERBUFFER, U), O.depthBuffer && !O.stencilBuffer) {
      let xe = a === true ? n24.DEPTH_COMPONENT24 : n24.DEPTH_COMPONENT16;
      if (ie || me(O)) {
        const ve = O.depthTexture;
        ve && ve.isDepthTexture && (ve.type === ns ? xe = n24.DEPTH_COMPONENT32F : ve.type === Co && (xe = n24.DEPTH_COMPONENT24));
        const ge = we(O);
        me(O) ? l.renderbufferStorageMultisampleEXT(n24.RENDERBUFFER, ge, xe, O.width, O.height) : n24.renderbufferStorageMultisample(n24.RENDERBUFFER, ge, xe, O.width, O.height);
      } else n24.renderbufferStorage(n24.RENDERBUFFER, xe, O.width, O.height);
      n24.framebufferRenderbuffer(n24.FRAMEBUFFER, n24.DEPTH_ATTACHMENT, n24.RENDERBUFFER, U);
    } else if (O.depthBuffer && O.stencilBuffer) {
      const xe = we(O);
      ie && me(O) === false ? n24.renderbufferStorageMultisample(n24.RENDERBUFFER, xe, n24.DEPTH24_STENCIL8, O.width, O.height) : me(O) ? l.renderbufferStorageMultisampleEXT(n24.RENDERBUFFER, xe, n24.DEPTH24_STENCIL8, O.width, O.height) : n24.renderbufferStorage(n24.RENDERBUFFER, n24.DEPTH_STENCIL, O.width, O.height), n24.framebufferRenderbuffer(n24.FRAMEBUFFER, n24.DEPTH_STENCIL_ATTACHMENT, n24.RENDERBUFFER, U);
    } else {
      const xe = O.isWebGLMultipleRenderTargets === true ? O.texture : [O.texture];
      for (let ve = 0; ve < xe.length; ve++) {
        const ge = xe[ve], ze = s.convert(ge.format, ge.colorSpace), Le = s.convert(ge.type), ke = A(ge.internalFormat, ze, Le, ge.colorSpace), et = we(O);
        ie && me(O) === false ? n24.renderbufferStorageMultisample(n24.RENDERBUFFER, et, ke, O.width, O.height) : me(O) ? l.renderbufferStorageMultisampleEXT(n24.RENDERBUFFER, et, ke, O.width, O.height) : n24.renderbufferStorage(n24.RENDERBUFFER, ke, O.width, O.height);
      }
    }
    n24.bindRenderbuffer(n24.RENDERBUFFER, null);
  }
  function Oe(U, O) {
    if (O && O.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
    if (t.bindFramebuffer(n24.FRAMEBUFFER, U), !(O.depthTexture && O.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    (!i.get(O.depthTexture).__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = true), q(O.depthTexture, 0);
    const xe = i.get(O.depthTexture).__webglTexture, ve = we(O);
    if (O.depthTexture.format === Ra) me(O) ? l.framebufferTexture2DMultisampleEXT(n24.FRAMEBUFFER, n24.DEPTH_ATTACHMENT, n24.TEXTURE_2D, xe, 0, ve) : n24.framebufferTexture2D(n24.FRAMEBUFFER, n24.DEPTH_ATTACHMENT, n24.TEXTURE_2D, xe, 0);
    else if (O.depthTexture.format === Kl) me(O) ? l.framebufferTexture2DMultisampleEXT(n24.FRAMEBUFFER, n24.DEPTH_STENCIL_ATTACHMENT, n24.TEXTURE_2D, xe, 0, ve) : n24.framebufferTexture2D(n24.FRAMEBUFFER, n24.DEPTH_STENCIL_ATTACHMENT, n24.TEXTURE_2D, xe, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function at(U) {
    const O = i.get(U), ie = U.isWebGLCubeRenderTarget === true;
    if (U.depthTexture && !O.__autoAllocateDepthBuffer) {
      if (ie) throw new Error("target.depthTexture not supported in Cube render targets");
      Oe(O.__webglFramebuffer, U);
    } else if (ie) {
      O.__webglDepthbuffer = [];
      for (let xe = 0; xe < 6; xe++) t.bindFramebuffer(n24.FRAMEBUFFER, O.__webglFramebuffer[xe]), O.__webglDepthbuffer[xe] = n24.createRenderbuffer(), Ze(O.__webglDepthbuffer[xe], U, false);
    } else t.bindFramebuffer(n24.FRAMEBUFFER, O.__webglFramebuffer), O.__webglDepthbuffer = n24.createRenderbuffer(), Ze(O.__webglDepthbuffer, U, false);
    t.bindFramebuffer(n24.FRAMEBUFFER, null);
  }
  function Ge(U, O, ie) {
    const xe = i.get(U);
    O !== void 0 && Ie(xe.__webglFramebuffer, U, U.texture, n24.COLOR_ATTACHMENT0, n24.TEXTURE_2D, 0), ie !== void 0 && at(U);
  }
  function X(U) {
    const O = U.texture, ie = i.get(U), xe = i.get(O);
    U.addEventListener("dispose", D), U.isWebGLMultipleRenderTargets !== true && (xe.__webglTexture === void 0 && (xe.__webglTexture = n24.createTexture()), xe.__version = O.version, o.memory.textures++);
    const ve = U.isWebGLCubeRenderTarget === true, ge = U.isWebGLMultipleRenderTargets === true, ze = M(U) || a;
    if (ve) {
      ie.__webglFramebuffer = [];
      for (let Le = 0; Le < 6; Le++) if (a && O.mipmaps && O.mipmaps.length > 0) {
        ie.__webglFramebuffer[Le] = [];
        for (let ke = 0; ke < O.mipmaps.length; ke++) ie.__webglFramebuffer[Le][ke] = n24.createFramebuffer();
      } else ie.__webglFramebuffer[Le] = n24.createFramebuffer();
    } else {
      if (a && O.mipmaps && O.mipmaps.length > 0) {
        ie.__webglFramebuffer = [];
        for (let Le = 0; Le < O.mipmaps.length; Le++) ie.__webglFramebuffer[Le] = n24.createFramebuffer();
      } else ie.__webglFramebuffer = n24.createFramebuffer();
      if (ge) if (r.drawBuffers) {
        const Le = U.texture;
        for (let ke = 0, et = Le.length; ke < et; ke++) {
          const Re = i.get(Le[ke]);
          Re.__webglTexture === void 0 && (Re.__webglTexture = n24.createTexture(), o.memory.textures++);
        }
      } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
      if (a && U.samples > 0 && me(U) === false) {
        const Le = ge ? O : [O];
        ie.__webglMultisampledFramebuffer = n24.createFramebuffer(), ie.__webglColorRenderbuffer = [], t.bindFramebuffer(n24.FRAMEBUFFER, ie.__webglMultisampledFramebuffer);
        for (let ke = 0; ke < Le.length; ke++) {
          const et = Le[ke];
          ie.__webglColorRenderbuffer[ke] = n24.createRenderbuffer(), n24.bindRenderbuffer(n24.RENDERBUFFER, ie.__webglColorRenderbuffer[ke]);
          const Re = s.convert(et.format, et.colorSpace), ye = s.convert(et.type), bt = A(et.internalFormat, Re, ye, et.colorSpace, U.isXRRenderTarget === true), gt = we(U);
          n24.renderbufferStorageMultisample(n24.RENDERBUFFER, gt, bt, U.width, U.height), n24.framebufferRenderbuffer(n24.FRAMEBUFFER, n24.COLOR_ATTACHMENT0 + ke, n24.RENDERBUFFER, ie.__webglColorRenderbuffer[ke]);
        }
        n24.bindRenderbuffer(n24.RENDERBUFFER, null), U.depthBuffer && (ie.__webglDepthRenderbuffer = n24.createRenderbuffer(), Ze(ie.__webglDepthRenderbuffer, U, true)), t.bindFramebuffer(n24.FRAMEBUFFER, null);
      }
    }
    if (ve) {
      t.bindTexture(n24.TEXTURE_CUBE_MAP, xe.__webglTexture), Ae(n24.TEXTURE_CUBE_MAP, O, ze);
      for (let Le = 0; Le < 6; Le++) if (a && O.mipmaps && O.mipmaps.length > 0) for (let ke = 0; ke < O.mipmaps.length; ke++) Ie(ie.__webglFramebuffer[Le][ke], U, O, n24.COLOR_ATTACHMENT0, n24.TEXTURE_CUBE_MAP_POSITIVE_X + Le, ke);
      else Ie(ie.__webglFramebuffer[Le], U, O, n24.COLOR_ATTACHMENT0, n24.TEXTURE_CUBE_MAP_POSITIVE_X + Le, 0);
      w(O, ze) && E(n24.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (ge) {
      const Le = U.texture;
      for (let ke = 0, et = Le.length; ke < et; ke++) {
        const Re = Le[ke], ye = i.get(Re);
        t.bindTexture(n24.TEXTURE_2D, ye.__webglTexture), Ae(n24.TEXTURE_2D, Re, ze), Ie(ie.__webglFramebuffer, U, Re, n24.COLOR_ATTACHMENT0 + ke, n24.TEXTURE_2D, 0), w(Re, ze) && E(n24.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let Le = n24.TEXTURE_2D;
      if ((U.isWebGL3DRenderTarget || U.isWebGLArrayRenderTarget) && (a ? Le = U.isWebGL3DRenderTarget ? n24.TEXTURE_3D : n24.TEXTURE_2D_ARRAY : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), t.bindTexture(Le, xe.__webglTexture), Ae(Le, O, ze), a && O.mipmaps && O.mipmaps.length > 0) for (let ke = 0; ke < O.mipmaps.length; ke++) Ie(ie.__webglFramebuffer[ke], U, O, n24.COLOR_ATTACHMENT0, Le, ke);
      else Ie(ie.__webglFramebuffer, U, O, n24.COLOR_ATTACHMENT0, Le, 0);
      w(O, ze) && E(Le), t.unbindTexture();
    }
    U.depthBuffer && at(U);
  }
  function Se(U) {
    const O = M(U) || a, ie = U.isWebGLMultipleRenderTargets === true ? U.texture : [U.texture];
    for (let xe = 0, ve = ie.length; xe < ve; xe++) {
      const ge = ie[xe];
      if (w(ge, O)) {
        const ze = U.isWebGLCubeRenderTarget ? n24.TEXTURE_CUBE_MAP : n24.TEXTURE_2D, Le = i.get(ge).__webglTexture;
        t.bindTexture(ze, Le), E(ze), t.unbindTexture();
      }
    }
  }
  function pe(U) {
    if (a && U.samples > 0 && me(U) === false) {
      const O = U.isWebGLMultipleRenderTargets ? U.texture : [U.texture], ie = U.width, xe = U.height;
      let ve = n24.COLOR_BUFFER_BIT;
      const ge = [], ze = U.stencilBuffer ? n24.DEPTH_STENCIL_ATTACHMENT : n24.DEPTH_ATTACHMENT, Le = i.get(U), ke = U.isWebGLMultipleRenderTargets === true;
      if (ke) for (let et = 0; et < O.length; et++) t.bindFramebuffer(n24.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), n24.framebufferRenderbuffer(n24.FRAMEBUFFER, n24.COLOR_ATTACHMENT0 + et, n24.RENDERBUFFER, null), t.bindFramebuffer(n24.FRAMEBUFFER, Le.__webglFramebuffer), n24.framebufferTexture2D(n24.DRAW_FRAMEBUFFER, n24.COLOR_ATTACHMENT0 + et, n24.TEXTURE_2D, null, 0);
      t.bindFramebuffer(n24.READ_FRAMEBUFFER, Le.__webglMultisampledFramebuffer), t.bindFramebuffer(n24.DRAW_FRAMEBUFFER, Le.__webglFramebuffer);
      for (let et = 0; et < O.length; et++) {
        ge.push(n24.COLOR_ATTACHMENT0 + et), U.depthBuffer && ge.push(ze);
        const Re = Le.__ignoreDepthValues !== void 0 ? Le.__ignoreDepthValues : false;
        if (Re === false && (U.depthBuffer && (ve |= n24.DEPTH_BUFFER_BIT), U.stencilBuffer && (ve |= n24.STENCIL_BUFFER_BIT)), ke && n24.framebufferRenderbuffer(n24.READ_FRAMEBUFFER, n24.COLOR_ATTACHMENT0, n24.RENDERBUFFER, Le.__webglColorRenderbuffer[et]), Re === true && (n24.invalidateFramebuffer(n24.READ_FRAMEBUFFER, [ze]), n24.invalidateFramebuffer(n24.DRAW_FRAMEBUFFER, [ze])), ke) {
          const ye = i.get(O[et]).__webglTexture;
          n24.framebufferTexture2D(n24.DRAW_FRAMEBUFFER, n24.COLOR_ATTACHMENT0, n24.TEXTURE_2D, ye, 0);
        }
        n24.blitFramebuffer(0, 0, ie, xe, 0, 0, ie, xe, ve, n24.NEAREST), f && n24.invalidateFramebuffer(n24.READ_FRAMEBUFFER, ge);
      }
      if (t.bindFramebuffer(n24.READ_FRAMEBUFFER, null), t.bindFramebuffer(n24.DRAW_FRAMEBUFFER, null), ke) for (let et = 0; et < O.length; et++) {
        t.bindFramebuffer(n24.FRAMEBUFFER, Le.__webglMultisampledFramebuffer), n24.framebufferRenderbuffer(n24.FRAMEBUFFER, n24.COLOR_ATTACHMENT0 + et, n24.RENDERBUFFER, Le.__webglColorRenderbuffer[et]);
        const Re = i.get(O[et]).__webglTexture;
        t.bindFramebuffer(n24.FRAMEBUFFER, Le.__webglFramebuffer), n24.framebufferTexture2D(n24.DRAW_FRAMEBUFFER, n24.COLOR_ATTACHMENT0 + et, n24.TEXTURE_2D, Re, 0);
      }
      t.bindFramebuffer(n24.DRAW_FRAMEBUFFER, Le.__webglMultisampledFramebuffer);
    }
  }
  function we(U) {
    return Math.min(r.maxSamples, U.samples);
  }
  function me(U) {
    const O = i.get(U);
    return a && U.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && O.__useRenderToTexture !== false;
  }
  function qe(U) {
    const O = o.render.frame;
    h.get(U) !== O && (h.set(U, O), U.update());
  }
  function Ne(U, O) {
    const ie = U.colorSpace, xe = U.format, ve = U.type;
    return U.isCompressedTexture === true || U.isVideoTexture === true || U.format === p0 || ie !== so && ie !== Mr && (Ht.getTransfer(ie) === Zt ? a === false ? e.has("EXT_sRGB") === true && xe === zi ? (U.format = p0, U.minFilter = fn, U.generateMipmaps = false) : O = bw.sRGBToLinear(O) : (xe !== zi || ve !== to) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ie)), O;
  }
  this.allocateTextureUnit = G, this.resetTextureUnits = Z, this.setTexture2D = q, this.setTexture2DArray = ae, this.setTexture3D = B, this.setTextureCube = Y, this.rebindTextures = Ge, this.setupRenderTarget = X, this.updateRenderTargetMipmap = Se, this.updateMultisampleRenderTarget = pe, this.setupDepthRenderbuffer = at, this.setupFrameBufferTexture = Ie, this.useMultisampledRTT = me;
}
function AI(n24, e, t) {
  const i = t.isWebGL2;
  function r(s, o = Mr) {
    let a;
    const l = Ht.getTransfer(o);
    if (s === to) return n24.UNSIGNED_BYTE;
    if (s === _w) return n24.UNSIGNED_SHORT_4_4_4_4;
    if (s === vw) return n24.UNSIGNED_SHORT_5_5_5_1;
    if (s === XL) return n24.BYTE;
    if (s === jL) return n24.SHORT;
    if (s === A_) return n24.UNSIGNED_SHORT;
    if (s === gw) return n24.INT;
    if (s === Co) return n24.UNSIGNED_INT;
    if (s === ns) return n24.FLOAT;
    if (s === Hc) return i ? n24.HALF_FLOAT : (a = e.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null);
    if (s === $L) return n24.ALPHA;
    if (s === zi) return n24.RGBA;
    if (s === YL) return n24.LUMINANCE;
    if (s === qL) return n24.LUMINANCE_ALPHA;
    if (s === Ra) return n24.DEPTH_COMPONENT;
    if (s === Kl) return n24.DEPTH_STENCIL;
    if (s === p0) return a = e.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === KL) return n24.RED;
    if (s === yw) return n24.RED_INTEGER;
    if (s === ZL) return n24.RG;
    if (s === xw) return n24.RG_INTEGER;
    if (s === Sw) return n24.RGBA_INTEGER;
    if (s === Tg || s === Ag || s === bg || s === Cg) if (l === Zt) if (a = e.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) {
      if (s === Tg) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      if (s === Ag) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      if (s === bg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
      if (s === Cg) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    } else return null;
    else if (a = e.get("WEBGL_compressed_texture_s3tc"), a !== null) {
      if (s === Tg) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
      if (s === Ag) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
      if (s === bg) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
      if (s === Cg) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
    } else return null;
    if (s === $1 || s === Y1 || s === q1 || s === K1) if (a = e.get("WEBGL_compressed_texture_pvrtc"), a !== null) {
      if (s === $1) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
      if (s === Y1) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
      if (s === q1) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
      if (s === K1) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
    } else return null;
    if (s === Mw) return a = e.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null;
    if (s === Z1 || s === J1) if (a = e.get("WEBGL_compressed_texture_etc"), a !== null) {
      if (s === Z1) return l === Zt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
      if (s === J1) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC;
    } else return null;
    if (s === Q1 || s === eS || s === tS || s === nS || s === iS || s === rS || s === sS || s === oS || s === aS || s === lS || s === uS || s === cS || s === fS || s === hS) if (a = e.get("WEBGL_compressed_texture_astc"), a !== null) {
      if (s === Q1) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
      if (s === eS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
      if (s === tS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
      if (s === nS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
      if (s === iS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
      if (s === rS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
      if (s === sS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
      if (s === oS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
      if (s === aS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
      if (s === lS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
      if (s === uS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
      if (s === cS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
      if (s === fS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
      if (s === hS) return l === Zt ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
    } else return null;
    if (s === Rg || s === dS || s === pS) if (a = e.get("EXT_texture_compression_bptc"), a !== null) {
      if (s === Rg) return l === Zt ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      if (s === dS) return a.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
      if (s === pS) return a.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
    } else return null;
    if (s === JL || s === mS || s === gS || s === _S) if (a = e.get("EXT_texture_compression_rgtc"), a !== null) {
      if (s === Rg) return a.COMPRESSED_RED_RGTC1_EXT;
      if (s === mS) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
      if (s === gS) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
      if (s === _S) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
    } else return null;
    return s === Ca ? i ? n24.UNSIGNED_INT_24_8 : (a = e.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : n24[s] !== void 0 ? n24[s] : null;
  }
  return { convert: r };
}
class bI extends ni {
  constructor(e = []) {
    super(), this.isArrayCamera = true, this.cameras = e;
  }
}
class _c extends Ot {
  constructor() {
    super(), this.isGroup = true, this.type = "Group";
  }
}
const dW = { type: "move" };
class lx {
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  getHandSpace() {
    return this._hand === null && (this._hand = new _c(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = { pinching: false }), this._hand;
  }
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new _c(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new V(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new V()), this._targetRay;
  }
  getGripSpace() {
    return this._grip === null && (this._grip = new _c(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new V(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new V()), this._grip;
  }
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
  }
  update(e, t, i) {
    let r = null, s = null, o = null;
    const a = this._targetRay, l = this._grip, f = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (f && e.hand) {
        o = true;
        for (const S of e.hand.values()) {
          const M = t.getJointPose(S, i), m = this._getHandJoint(f, S);
          M !== null && (m.matrix.fromArray(M.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = true, m.jointRadius = M.radius), m.visible = M !== null;
        }
        const h = f.joints["index-finger-tip"], d = f.joints["thumb-tip"], p = h.position.distanceTo(d.position), g = 0.02, v = 5e-3;
        f.inputState.pinching && p > g + v ? (f.inputState.pinching = false, this.dispatchEvent({ type: "pinchend", handedness: e.handedness, target: this })) : !f.inputState.pinching && p <= g - v && (f.inputState.pinching = true, this.dispatchEvent({ type: "pinchstart", handedness: e.handedness, target: this }));
      } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, s.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = false, s.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = false));
      a !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = true, r.linearVelocity ? (a.hasLinearVelocity = true, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = false, r.angularVelocity ? (a.hasAngularVelocity = true, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = false, this.dispatchEvent(dW)));
    }
    return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), f !== null && (f.visible = o !== null), this;
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new _c();
      i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
    }
    return e.joints[t.jointName];
  }
}
const pW = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, mW = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class gW {
  constructor() {
    this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
  }
  init(e, t, i) {
    if (this.texture === null) {
      const r = new Tn(), s = e.properties.get(r);
      s.__webglTexture = t.texture, (t.depthNear != i.depthNear || t.depthFar != i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
    }
  }
  render(e, t) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const i = t.cameras[0].viewport, r = new bs({ extensions: { fragDepth: true }, vertexShader: pW, fragmentShader: mW, uniforms: { depthColor: { value: this.texture }, depthWidth: { value: i.z }, depthHeight: { value: i.w } } });
        this.mesh = new Hn(new iu(20, 20), r);
      }
      e.render(this.mesh, t);
    }
  }
  reset() {
    this.texture = null, this.mesh = null;
  }
}
class _W extends Go {
  constructor(e, t) {
    super();
    const i = this;
    let r = null, s = 1, o = null, a = "local-floor", l = 1, f = null, h = null, d = null, p = null, g = null, v = null;
    const S = new gW(), M = t.getContextAttributes();
    let m = null, w = null;
    const E = [], A = [], P = new _e();
    let R = null;
    const L = new ni();
    L.layers.enable(1), L.viewport = new Gt();
    const D = new ni();
    D.layers.enable(2), D.viewport = new Gt();
    const F = [L, D], C = new bI();
    C.layers.enable(1), C.layers.enable(2);
    let N = null, j = null;
    this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(te) {
      let de = E[te];
      return de === void 0 && (de = new lx(), E[te] = de), de.getTargetRaySpace();
    }, this.getControllerGrip = function(te) {
      let de = E[te];
      return de === void 0 && (de = new lx(), E[te] = de), de.getGripSpace();
    }, this.getHand = function(te) {
      let de = E[te];
      return de === void 0 && (de = new lx(), E[te] = de), de.getHandSpace();
    };
    function Z(te) {
      const de = A.indexOf(te.inputSource);
      if (de === -1) return;
      const Ee = E[de];
      Ee !== void 0 && (Ee.update(te.inputSource, te.frame, f || o), Ee.dispatchEvent({ type: te.type, data: te.inputSource }));
    }
    function G() {
      r.removeEventListener("select", Z), r.removeEventListener("selectstart", Z), r.removeEventListener("selectend", Z), r.removeEventListener("squeeze", Z), r.removeEventListener("squeezestart", Z), r.removeEventListener("squeezeend", Z), r.removeEventListener("end", G), r.removeEventListener("inputsourceschange", J);
      for (let te = 0; te < E.length; te++) {
        const de = A[te];
        de !== null && (A[te] = null, E[te].disconnect(de));
      }
      N = null, j = null, S.reset(), e.setRenderTarget(m), g = null, p = null, d = null, r = null, w = null, Ae.stop(), i.isPresenting = false, e.setPixelRatio(R), e.setSize(P.width, P.height, false), i.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(te) {
      s = te, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
    }, this.setReferenceSpaceType = function(te) {
      a = te, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
    }, this.getReferenceSpace = function() {
      return f || o;
    }, this.setReferenceSpace = function(te) {
      f = te;
    }, this.getBaseLayer = function() {
      return p !== null ? p : g;
    }, this.getBinding = function() {
      return d;
    }, this.getFrame = function() {
      return v;
    }, this.getSession = function() {
      return r;
    }, this.setSession = async function(te) {
      if (r = te, r !== null) {
        if (m = e.getRenderTarget(), r.addEventListener("select", Z), r.addEventListener("selectstart", Z), r.addEventListener("selectend", Z), r.addEventListener("squeeze", Z), r.addEventListener("squeezestart", Z), r.addEventListener("squeezeend", Z), r.addEventListener("end", G), r.addEventListener("inputsourceschange", J), M.xrCompatible !== true && await t.makeXRCompatible(), R = e.getPixelRatio(), e.getSize(P), r.renderState.layers === void 0 || e.capabilities.isWebGL2 === false) {
          const de = { antialias: r.renderState.layers === void 0 ? M.antialias : true, alpha: true, depth: M.depth, stencil: M.stencil, framebufferScaleFactor: s };
          g = new XRWebGLLayer(r, t, de), r.updateRenderState({ baseLayer: g }), e.setPixelRatio(1), e.setSize(g.framebufferWidth, g.framebufferHeight, false), w = new As(g.framebufferWidth, g.framebufferHeight, { format: zi, type: to, colorSpace: e.outputColorSpace, stencilBuffer: M.stencil });
        } else {
          let de = null, Ee = null, Ie = null;
          M.depth && (Ie = M.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, de = M.stencil ? Kl : Ra, Ee = M.stencil ? Ca : Co);
          const Ze = { colorFormat: t.RGBA8, depthFormat: Ie, scaleFactor: s };
          d = new XRWebGLBinding(r, t), p = d.createProjectionLayer(Ze), r.updateRenderState({ layers: [p] }), e.setPixelRatio(1), e.setSize(p.textureWidth, p.textureHeight, false), w = new As(p.textureWidth, p.textureHeight, { format: zi, type: to, depthTexture: new Iw(p.textureWidth, p.textureHeight, Ee, void 0, void 0, void 0, void 0, void 0, void 0, de), stencilBuffer: M.stencil, colorSpace: e.outputColorSpace, samples: M.antialias ? 4 : 0 });
          const Oe = e.properties.get(w);
          Oe.__ignoreDepthValues = p.ignoreDepthValues;
        }
        w.isXRRenderTarget = true, this.setFoveation(l), f = null, o = await r.requestReferenceSpace(a), Ae.setContext(r), Ae.start(), i.isPresenting = true, i.dispatchEvent({ type: "sessionstart" });
      }
    }, this.getEnvironmentBlendMode = function() {
      if (r !== null) return r.environmentBlendMode;
    };
    function J(te) {
      for (let de = 0; de < te.removed.length; de++) {
        const Ee = te.removed[de], Ie = A.indexOf(Ee);
        Ie >= 0 && (A[Ie] = null, E[Ie].disconnect(Ee));
      }
      for (let de = 0; de < te.added.length; de++) {
        const Ee = te.added[de];
        let Ie = A.indexOf(Ee);
        if (Ie === -1) {
          for (let Oe = 0; Oe < E.length; Oe++) if (Oe >= A.length) {
            A.push(Ee), Ie = Oe;
            break;
          } else if (A[Oe] === null) {
            A[Oe] = Ee, Ie = Oe;
            break;
          }
          if (Ie === -1) break;
        }
        const Ze = E[Ie];
        Ze && Ze.connect(Ee);
      }
    }
    const q = new V(), ae = new V();
    function B(te, de, Ee) {
      q.setFromMatrixPosition(de.matrixWorld), ae.setFromMatrixPosition(Ee.matrixWorld);
      const Ie = q.distanceTo(ae), Ze = de.projectionMatrix.elements, Oe = Ee.projectionMatrix.elements, at = Ze[14] / (Ze[10] - 1), Ge = Ze[14] / (Ze[10] + 1), X = (Ze[9] + 1) / Ze[5], Se = (Ze[9] - 1) / Ze[5], pe = (Ze[8] - 1) / Ze[0], we = (Oe[8] + 1) / Oe[0], me = at * pe, qe = at * we, Ne = Ie / (-pe + we), U = Ne * -pe;
      de.matrixWorld.decompose(te.position, te.quaternion, te.scale), te.translateX(U), te.translateZ(Ne), te.matrixWorld.compose(te.position, te.quaternion, te.scale), te.matrixWorldInverse.copy(te.matrixWorld).invert();
      const O = at + Ne, ie = Ge + Ne, xe = me - U, ve = qe + (Ie - U), ge = X * Ge / ie * O, ze = Se * Ge / ie * O;
      te.projectionMatrix.makePerspective(xe, ve, ge, ze, O, ie), te.projectionMatrixInverse.copy(te.projectionMatrix).invert();
    }
    function Y(te, de) {
      de === null ? te.matrixWorld.copy(te.matrix) : te.matrixWorld.multiplyMatrices(de.matrixWorld, te.matrix), te.matrixWorldInverse.copy(te.matrixWorld).invert();
    }
    this.updateCamera = function(te) {
      if (r === null) return;
      S.texture !== null && (te.near = S.depthNear, te.far = S.depthFar), C.near = D.near = L.near = te.near, C.far = D.far = L.far = te.far, (N !== C.near || j !== C.far) && (r.updateRenderState({ depthNear: C.near, depthFar: C.far }), N = C.near, j = C.far, L.near = N, L.far = j, D.near = N, D.far = j, L.updateProjectionMatrix(), D.updateProjectionMatrix(), te.updateProjectionMatrix());
      const de = te.parent, Ee = C.cameras;
      Y(C, de);
      for (let Ie = 0; Ie < Ee.length; Ie++) Y(Ee[Ie], de);
      Ee.length === 2 ? B(C, L, D) : C.projectionMatrix.copy(L.projectionMatrix), $(te, C, de);
    };
    function $(te, de, Ee) {
      Ee === null ? te.matrix.copy(de.matrixWorld) : (te.matrix.copy(Ee.matrixWorld), te.matrix.invert(), te.matrix.multiply(de.matrixWorld)), te.matrix.decompose(te.position, te.quaternion, te.scale), te.updateMatrixWorld(true), te.projectionMatrix.copy(de.projectionMatrix), te.projectionMatrixInverse.copy(de.projectionMatrixInverse), te.isPerspectiveCamera && (te.fov = Gc * 2 * Math.atan(1 / te.projectionMatrix.elements[5]), te.zoom = 1);
    }
    this.getCamera = function() {
      return C;
    }, this.getFoveation = function() {
      if (!(p === null && g === null)) return l;
    }, this.setFoveation = function(te) {
      l = te, p !== null && (p.fixedFoveation = te), g !== null && g.fixedFoveation !== void 0 && (g.fixedFoveation = te);
    }, this.hasDepthSensing = function() {
      return S.texture !== null;
    };
    let ee = null;
    function ue(te, de) {
      if (h = de.getViewerPose(f || o), v = de, h !== null) {
        const Ee = h.views;
        g !== null && (e.setRenderTargetFramebuffer(w, g.framebuffer), e.setRenderTarget(w));
        let Ie = false;
        Ee.length !== C.cameras.length && (C.cameras.length = 0, Ie = true);
        for (let Oe = 0; Oe < Ee.length; Oe++) {
          const at = Ee[Oe];
          let Ge = null;
          if (g !== null) Ge = g.getViewport(at);
          else {
            const Se = d.getViewSubImage(p, at);
            Ge = Se.viewport, Oe === 0 && (e.setRenderTargetTextures(w, Se.colorTexture, p.ignoreDepthValues ? void 0 : Se.depthStencilTexture), e.setRenderTarget(w));
          }
          let X = F[Oe];
          X === void 0 && (X = new ni(), X.layers.enable(Oe), X.viewport = new Gt(), F[Oe] = X), X.matrix.fromArray(at.transform.matrix), X.matrix.decompose(X.position, X.quaternion, X.scale), X.projectionMatrix.fromArray(at.projectionMatrix), X.projectionMatrixInverse.copy(X.projectionMatrix).invert(), X.viewport.set(Ge.x, Ge.y, Ge.width, Ge.height), Oe === 0 && (C.matrix.copy(X.matrix), C.matrix.decompose(C.position, C.quaternion, C.scale)), Ie === true && C.cameras.push(X);
        }
        const Ze = r.enabledFeatures;
        if (Ze && Ze.includes("depth-sensing")) {
          const Oe = d.getDepthInformation(Ee[0]);
          Oe && Oe.isValid && Oe.texture && S.init(e, Oe, r.renderState);
        }
      }
      for (let Ee = 0; Ee < E.length; Ee++) {
        const Ie = A[Ee], Ze = E[Ee];
        Ie !== null && Ze !== void 0 && Ze.update(Ie, de, f || o);
      }
      S.render(e, C), ee && ee(te, de), de.detectedPlanes && i.dispatchEvent({ type: "planesdetected", data: de }), v = null;
    }
    const Ae = new xI();
    Ae.setAnimationLoop(ue), this.setAnimationLoop = function(te) {
      ee = te;
    }, this.dispose = function() {
    };
  }
}
function vW(n24, e) {
  function t(M, m) {
    M.matrixAutoUpdate === true && M.updateMatrix(), m.value.copy(M.matrix);
  }
  function i(M, m) {
    m.color.getRGB(M.fogColor.value, gI(n24)), m.isFog ? (M.fogNear.value = m.near, M.fogFar.value = m.far) : m.isFogExp2 && (M.fogDensity.value = m.density);
  }
  function r(M, m, w, E, A) {
    m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(M, m) : m.isMeshToonMaterial ? (s(M, m), d(M, m)) : m.isMeshPhongMaterial ? (s(M, m), h(M, m)) : m.isMeshStandardMaterial ? (s(M, m), p(M, m), m.isMeshPhysicalMaterial && g(M, m, A)) : m.isMeshMatcapMaterial ? (s(M, m), v(M, m)) : m.isMeshDepthMaterial ? s(M, m) : m.isMeshDistanceMaterial ? (s(M, m), S(M, m)) : m.isMeshNormalMaterial ? s(M, m) : m.isLineBasicMaterial ? (o(M, m), m.isLineDashedMaterial && a(M, m)) : m.isPointsMaterial ? l(M, m, w, E) : m.isSpriteMaterial ? f(M, m) : m.isShadowMaterial ? (M.color.value.copy(m.color), M.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = false);
  }
  function s(M, m) {
    M.opacity.value = m.opacity, m.color && M.diffuse.value.copy(m.color), m.emissive && M.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (M.map.value = m.map, t(m.map, M.mapTransform)), m.alphaMap && (M.alphaMap.value = m.alphaMap, t(m.alphaMap, M.alphaMapTransform)), m.bumpMap && (M.bumpMap.value = m.bumpMap, t(m.bumpMap, M.bumpMapTransform), M.bumpScale.value = m.bumpScale, m.side === Gi && (M.bumpScale.value *= -1)), m.normalMap && (M.normalMap.value = m.normalMap, t(m.normalMap, M.normalMapTransform), M.normalScale.value.copy(m.normalScale), m.side === Gi && M.normalScale.value.negate()), m.displacementMap && (M.displacementMap.value = m.displacementMap, t(m.displacementMap, M.displacementMapTransform), M.displacementScale.value = m.displacementScale, M.displacementBias.value = m.displacementBias), m.emissiveMap && (M.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, M.emissiveMapTransform)), m.specularMap && (M.specularMap.value = m.specularMap, t(m.specularMap, M.specularMapTransform)), m.alphaTest > 0 && (M.alphaTest.value = m.alphaTest);
    const w = e.get(m).envMap;
    if (w && (M.envMap.value = w, M.flipEnvMap.value = w.isCubeTexture && w.isRenderTargetTexture === false ? -1 : 1, M.reflectivity.value = m.reflectivity, M.ior.value = m.ior, M.refractionRatio.value = m.refractionRatio), m.lightMap) {
      M.lightMap.value = m.lightMap;
      const E = n24._useLegacyLights === true ? Math.PI : 1;
      M.lightMapIntensity.value = m.lightMapIntensity * E, t(m.lightMap, M.lightMapTransform);
    }
    m.aoMap && (M.aoMap.value = m.aoMap, M.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, M.aoMapTransform));
  }
  function o(M, m) {
    M.diffuse.value.copy(m.color), M.opacity.value = m.opacity, m.map && (M.map.value = m.map, t(m.map, M.mapTransform));
  }
  function a(M, m) {
    M.dashSize.value = m.dashSize, M.totalSize.value = m.dashSize + m.gapSize, M.scale.value = m.scale;
  }
  function l(M, m, w, E) {
    M.diffuse.value.copy(m.color), M.opacity.value = m.opacity, M.size.value = m.size * w, M.scale.value = E * 0.5, m.map && (M.map.value = m.map, t(m.map, M.uvTransform)), m.alphaMap && (M.alphaMap.value = m.alphaMap, t(m.alphaMap, M.alphaMapTransform)), m.alphaTest > 0 && (M.alphaTest.value = m.alphaTest);
  }
  function f(M, m) {
    M.diffuse.value.copy(m.color), M.opacity.value = m.opacity, M.rotation.value = m.rotation, m.map && (M.map.value = m.map, t(m.map, M.mapTransform)), m.alphaMap && (M.alphaMap.value = m.alphaMap, t(m.alphaMap, M.alphaMapTransform)), m.alphaTest > 0 && (M.alphaTest.value = m.alphaTest);
  }
  function h(M, m) {
    M.specular.value.copy(m.specular), M.shininess.value = Math.max(m.shininess, 1e-4);
  }
  function d(M, m) {
    m.gradientMap && (M.gradientMap.value = m.gradientMap);
  }
  function p(M, m) {
    M.metalness.value = m.metalness, m.metalnessMap && (M.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, M.metalnessMapTransform)), M.roughness.value = m.roughness, m.roughnessMap && (M.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, M.roughnessMapTransform)), e.get(m).envMap && (M.envMapIntensity.value = m.envMapIntensity);
  }
  function g(M, m, w) {
    M.ior.value = m.ior, m.sheen > 0 && (M.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), M.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (M.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, M.sheenColorMapTransform)), m.sheenRoughnessMap && (M.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, M.sheenRoughnessMapTransform))), m.clearcoat > 0 && (M.clearcoat.value = m.clearcoat, M.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (M.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, M.clearcoatMapTransform)), m.clearcoatRoughnessMap && (M.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, M.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (M.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, M.clearcoatNormalMapTransform), M.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Gi && M.clearcoatNormalScale.value.negate())), m.iridescence > 0 && (M.iridescence.value = m.iridescence, M.iridescenceIOR.value = m.iridescenceIOR, M.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], M.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (M.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, M.iridescenceMapTransform)), m.iridescenceThicknessMap && (M.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, M.iridescenceThicknessMapTransform))), m.transmission > 0 && (M.transmission.value = m.transmission, M.transmissionSamplerMap.value = w.texture, M.transmissionSamplerSize.value.set(w.width, w.height), m.transmissionMap && (M.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, M.transmissionMapTransform)), M.thickness.value = m.thickness, m.thicknessMap && (M.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, M.thicknessMapTransform)), M.attenuationDistance.value = m.attenuationDistance, M.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (M.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (M.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, M.anisotropyMapTransform))), M.specularIntensity.value = m.specularIntensity, M.specularColor.value.copy(m.specularColor), m.specularColorMap && (M.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, M.specularColorMapTransform)), m.specularIntensityMap && (M.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, M.specularIntensityMapTransform));
  }
  function v(M, m) {
    m.matcap && (M.matcap.value = m.matcap);
  }
  function S(M, m) {
    const w = e.get(m).light;
    M.referencePosition.value.setFromMatrixPosition(w.matrixWorld), M.nearDistance.value = w.shadow.camera.near, M.farDistance.value = w.shadow.camera.far;
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function yW(n24, e, t, i) {
  let r = {}, s = {}, o = [];
  const a = t.isWebGL2 ? n24.getParameter(n24.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(w, E) {
    const A = E.program;
    i.uniformBlockBinding(w, A);
  }
  function f(w, E) {
    let A = r[w.id];
    A === void 0 && (v(w), A = h(w), r[w.id] = A, w.addEventListener("dispose", M));
    const P = E.program;
    i.updateUBOMapping(w, P);
    const R = e.render.frame;
    s[w.id] !== R && (p(w), s[w.id] = R);
  }
  function h(w) {
    const E = d();
    w.__bindingPointIndex = E;
    const A = n24.createBuffer(), P = w.__size, R = w.usage;
    return n24.bindBuffer(n24.UNIFORM_BUFFER, A), n24.bufferData(n24.UNIFORM_BUFFER, P, R), n24.bindBuffer(n24.UNIFORM_BUFFER, null), n24.bindBufferBase(n24.UNIFORM_BUFFER, E, A), A;
  }
  function d() {
    for (let w = 0; w < a; w++) if (o.indexOf(w) === -1) return o.push(w), w;
    return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
  }
  function p(w) {
    const E = r[w.id], A = w.uniforms, P = w.__cache;
    n24.bindBuffer(n24.UNIFORM_BUFFER, E);
    for (let R = 0, L = A.length; R < L; R++) {
      const D = Array.isArray(A[R]) ? A[R] : [A[R]];
      for (let F = 0, C = D.length; F < C; F++) {
        const N = D[F];
        if (g(N, R, F, P) === true) {
          const j = N.__offset, Z = Array.isArray(N.value) ? N.value : [N.value];
          let G = 0;
          for (let J = 0; J < Z.length; J++) {
            const q = Z[J], ae = S(q);
            typeof q == "number" || typeof q == "boolean" ? (N.__data[0] = q, n24.bufferSubData(n24.UNIFORM_BUFFER, j + G, N.__data)) : q.isMatrix3 ? (N.__data[0] = q.elements[0], N.__data[1] = q.elements[1], N.__data[2] = q.elements[2], N.__data[3] = 0, N.__data[4] = q.elements[3], N.__data[5] = q.elements[4], N.__data[6] = q.elements[5], N.__data[7] = 0, N.__data[8] = q.elements[6], N.__data[9] = q.elements[7], N.__data[10] = q.elements[8], N.__data[11] = 0) : (q.toArray(N.__data, G), G += ae.storage / Float32Array.BYTES_PER_ELEMENT);
          }
          n24.bufferSubData(n24.UNIFORM_BUFFER, j, N.__data);
        }
      }
    }
    n24.bindBuffer(n24.UNIFORM_BUFFER, null);
  }
  function g(w, E, A, P) {
    const R = w.value, L = E + "_" + A;
    if (P[L] === void 0) return typeof R == "number" || typeof R == "boolean" ? P[L] = R : P[L] = R.clone(), true;
    {
      const D = P[L];
      if (typeof R == "number" || typeof R == "boolean") {
        if (D !== R) return P[L] = R, true;
      } else if (D.equals(R) === false) return D.copy(R), true;
    }
    return false;
  }
  function v(w) {
    const E = w.uniforms;
    let A = 0;
    const P = 16;
    for (let L = 0, D = E.length; L < D; L++) {
      const F = Array.isArray(E[L]) ? E[L] : [E[L]];
      for (let C = 0, N = F.length; C < N; C++) {
        const j = F[C], Z = Array.isArray(j.value) ? j.value : [j.value];
        for (let G = 0, J = Z.length; G < J; G++) {
          const q = Z[G], ae = S(q), B = A % P;
          B !== 0 && P - B < ae.boundary && (A += P - B), j.__data = new Float32Array(ae.storage / Float32Array.BYTES_PER_ELEMENT), j.__offset = A, A += ae.storage;
        }
      }
    }
    const R = A % P;
    return R > 0 && (A += P - R), w.__size = A, w.__cache = {}, this;
  }
  function S(w) {
    const E = { boundary: 0, storage: 0 };
    return typeof w == "number" || typeof w == "boolean" ? (E.boundary = 4, E.storage = 4) : w.isVector2 ? (E.boundary = 8, E.storage = 8) : w.isVector3 || w.isColor ? (E.boundary = 16, E.storage = 12) : w.isVector4 ? (E.boundary = 16, E.storage = 16) : w.isMatrix3 ? (E.boundary = 48, E.storage = 48) : w.isMatrix4 ? (E.boundary = 64, E.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), E;
  }
  function M(w) {
    const E = w.target;
    E.removeEventListener("dispose", M);
    const A = o.indexOf(E.__bindingPointIndex);
    o.splice(A, 1), n24.deleteBuffer(r[E.id]), delete r[E.id], delete s[E.id];
  }
  function m() {
    for (const w in r) n24.deleteBuffer(r[w]);
    o = [], r = {}, s = {};
  }
  return { bind: l, update: f, dispose: m };
}
class Ow {
  constructor(e = {}) {
    const { canvas: t = dI(), context: i = null, depth: r = true, stencil: s = true, alpha: o = false, antialias: a = false, premultipliedAlpha: l = true, preserveDrawingBuffer: f = false, powerPreference: h = "default", failIfMajorPerformanceCaveat: d = false } = e;
    this.isWebGLRenderer = true;
    let p;
    i !== null ? p = i.getContextAttributes().alpha : p = o;
    const g = new Uint32Array(4), v = new Int32Array(4);
    let S = null, M = null;
    const m = [], w = [];
    this.domElement = t, this.debug = { checkShaderErrors: true, onShaderError: null }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Xn, this._useLegacyLights = false, this.toneMapping = eo, this.toneMappingExposure = 1;
    const E = this;
    let A = false, P = 0, R = 0, L = null, D = -1, F = null;
    const C = new Gt(), N = new Gt();
    let j = null;
    const Z = new Ve(0);
    let G = 0, J = t.width, q = t.height, ae = 1, B = null, Y = null;
    const $ = new Gt(0, 0, J, q), ee = new Gt(0, 0, J, q);
    let ue = false;
    const Ae = new Wd();
    let te = false, de = false, Ee = null;
    const Ie = new lt(), Ze = new _e(), Oe = new V(), at = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function Ge() {
      return L === null ? ae : 1;
    }
    let X = i;
    function Se(k, re) {
      for (let le = 0; le < k.length; le++) {
        const ce = k[le], oe = t.getContext(ce, re);
        if (oe !== null) return oe;
      }
      return null;
    }
    try {
      const k = { alpha: true, depth: r, stencil: s, antialias: a, premultipliedAlpha: l, preserveDrawingBuffer: f, powerPreference: h, failIfMajorPerformanceCaveat: d };
      if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${w_}`), t.addEventListener("webglcontextlost", Bt, false), t.addEventListener("webglcontextrestored", W, false), t.addEventListener("webglcontextcreationerror", be, false), X === null) {
        const re = ["webgl2", "webgl", "experimental-webgl"];
        if (E.isWebGL1Renderer === true && re.shift(), X = Se(re, k), X === null) throw Se(re) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" && X instanceof WebGLRenderingContext && console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."), X.getShaderPrecisionFormat === void 0 && (X.getShaderPrecisionFormat = function() {
        return { rangeMin: 1, rangeMax: 1, precision: 1 };
      });
    } catch (k) {
      throw console.error("THREE.WebGLRenderer: " + k.message), k;
    }
    let pe, we, me, qe, Ne, U, O, ie, xe, ve, ge, ze, Le, ke, et, Re, ye, bt, gt, ut, tt, je, _t, Lt;
    function $t() {
      pe = new P6(X), we = new E6(X, pe, e), pe.init(we), je = new AI(X, pe, we), me = new fW(X, pe, we), qe = new N6(X), Ne = new Q8(), U = new hW(X, pe, me, Ne, we, je, qe), O = new A6(E), ie = new R6(E), xe = new VV(X, we), _t = new M6(X, pe, xe, we), ve = new L6(X, xe, qe, _t), ge = new k6(X, ve, xe, qe), gt = new U6(X, we, U), Re = new T6(Ne), ze = new J8(E, O, ie, pe, we, _t, Re), Le = new vW(E, Ne), ke = new tW(), et = new aW(pe, we), bt = new S6(E, O, ie, me, ge, p, l), ye = new cW(E, ge, we), Lt = new yW(X, qe, we, me), ut = new w6(X, pe, qe, we), tt = new I6(X, pe, qe, we), qe.programs = ze.programs, E.capabilities = we, E.extensions = pe, E.properties = Ne, E.renderLists = ke, E.shadowMap = ye, E.state = me, E.info = qe;
    }
    $t();
    const Tt = new _W(E, X);
    this.xr = Tt, this.getContext = function() {
      return X;
    }, this.getContextAttributes = function() {
      return X.getContextAttributes();
    }, this.forceContextLoss = function() {
      const k = pe.get("WEBGL_lose_context");
      k && k.loseContext();
    }, this.forceContextRestore = function() {
      const k = pe.get("WEBGL_lose_context");
      k && k.restoreContext();
    }, this.getPixelRatio = function() {
      return ae;
    }, this.setPixelRatio = function(k) {
      k !== void 0 && (ae = k, this.setSize(J, q, false));
    }, this.getSize = function(k) {
      return k.set(J, q);
    }, this.setSize = function(k, re, le = true) {
      if (Tt.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      J = k, q = re, t.width = Math.floor(k * ae), t.height = Math.floor(re * ae), le === true && (t.style.width = k + "px", t.style.height = re + "px"), this.setViewport(0, 0, k, re);
    }, this.getDrawingBufferSize = function(k) {
      return k.set(J * ae, q * ae).floor();
    }, this.setDrawingBufferSize = function(k, re, le) {
      J = k, q = re, ae = le, t.width = Math.floor(k * le), t.height = Math.floor(re * le), this.setViewport(0, 0, k, re);
    }, this.getCurrentViewport = function(k) {
      return k.copy(C);
    }, this.getViewport = function(k) {
      return k.copy($);
    }, this.setViewport = function(k, re, le, ce) {
      k.isVector4 ? $.set(k.x, k.y, k.z, k.w) : $.set(k, re, le, ce), me.viewport(C.copy($).multiplyScalar(ae).floor());
    }, this.getScissor = function(k) {
      return k.copy(ee);
    }, this.setScissor = function(k, re, le, ce) {
      k.isVector4 ? ee.set(k.x, k.y, k.z, k.w) : ee.set(k, re, le, ce), me.scissor(N.copy(ee).multiplyScalar(ae).floor());
    }, this.getScissorTest = function() {
      return ue;
    }, this.setScissorTest = function(k) {
      me.setScissorTest(ue = k);
    }, this.setOpaqueSort = function(k) {
      B = k;
    }, this.setTransparentSort = function(k) {
      Y = k;
    }, this.getClearColor = function(k) {
      return k.copy(bt.getClearColor());
    }, this.setClearColor = function() {
      bt.setClearColor.apply(bt, arguments);
    }, this.getClearAlpha = function() {
      return bt.getClearAlpha();
    }, this.setClearAlpha = function() {
      bt.setClearAlpha.apply(bt, arguments);
    }, this.clear = function(k = true, re = true, le = true) {
      let ce = 0;
      if (k) {
        let oe = false;
        if (L !== null) {
          const Fe = L.texture.format;
          oe = Fe === Sw || Fe === xw || Fe === yw;
        }
        if (oe) {
          const Fe = L.texture.type, Je = Fe === to || Fe === Co || Fe === A_ || Fe === Ca || Fe === _w || Fe === vw, rt = bt.getClearColor(), st = bt.getClearAlpha(), ft = rt.r, ct = rt.g, ht = rt.b;
          Je ? (g[0] = ft, g[1] = ct, g[2] = ht, g[3] = st, X.clearBufferuiv(X.COLOR, 0, g)) : (v[0] = ft, v[1] = ct, v[2] = ht, v[3] = st, X.clearBufferiv(X.COLOR, 0, v));
        } else ce |= X.COLOR_BUFFER_BIT;
      }
      re && (ce |= X.DEPTH_BUFFER_BIT), le && (ce |= X.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), X.clear(ce);
    }, this.clearColor = function() {
      this.clear(true, false, false);
    }, this.clearDepth = function() {
      this.clear(false, true, false);
    }, this.clearStencil = function() {
      this.clear(false, false, true);
    }, this.dispose = function() {
      t.removeEventListener("webglcontextlost", Bt, false), t.removeEventListener("webglcontextrestored", W, false), t.removeEventListener("webglcontextcreationerror", be, false), ke.dispose(), et.dispose(), Ne.dispose(), O.dispose(), ie.dispose(), ge.dispose(), _t.dispose(), Lt.dispose(), ze.dispose(), Tt.dispose(), Tt.removeEventListener("sessionstart", Ni), Tt.removeEventListener("sessionend", jt), Ee && (Ee.dispose(), Ee = null), oi.stop();
    };
    function Bt(k) {
      k.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = true;
    }
    function W() {
      console.log("THREE.WebGLRenderer: Context Restored."), A = false;
      const k = qe.autoReset, re = ye.enabled, le = ye.autoUpdate, ce = ye.needsUpdate, oe = ye.type;
      $t(), qe.autoReset = k, ye.enabled = re, ye.autoUpdate = le, ye.needsUpdate = ce, ye.type = oe;
    }
    function be(k) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", k.statusMessage);
    }
    function Ce(k) {
      const re = k.target;
      re.removeEventListener("dispose", Ce), $e(re);
    }
    function $e(k) {
      nt(k), Ne.remove(k);
    }
    function nt(k) {
      const re = Ne.get(k).programs;
      re !== void 0 && (re.forEach(function(le) {
        ze.releaseProgram(le);
      }), k.isShaderMaterial && ze.releaseShaderCache(k));
    }
    this.renderBufferDirect = function(k, re, le, ce, oe, Fe) {
      re === null && (re = at);
      const Je = oe.isMesh && oe.matrixWorld.determinant() < 0, rt = nv(k, re, le, ce, oe);
      me.setMaterial(ce, Je);
      let st = le.index, ft = 1;
      if (ce.wireframe === true) {
        if (st = ve.getWireframeAttribute(le), st === void 0) return;
        ft = 2;
      }
      const ct = le.drawRange, ht = le.attributes.position;
      let ln = ct.start * ft, ai = (ct.start + ct.count) * ft;
      Fe !== null && (ln = Math.max(ln, Fe.start * ft), ai = Math.min(ai, (Fe.start + Fe.count) * ft)), st !== null ? (ln = Math.max(ln, 0), ai = Math.min(ai, st.count)) : ht != null && (ln = Math.max(ln, 0), ai = Math.min(ai, ht.count));
      const Qt = ai - ln;
      if (Qt < 0 || Qt === 1 / 0) return;
      _t.setup(oe, ce, rt, le, st);
      let qn, ot = ut;
      if (st !== null && (qn = xe.get(st), ot = tt, ot.setIndex(qn)), oe.isMesh) ce.wireframe === true ? (me.setLineWidth(ce.wireframeLinewidth * Ge()), ot.setMode(X.LINES)) : ot.setMode(X.TRIANGLES);
      else if (oe.isLine) {
        let We = ce.linewidth;
        We === void 0 && (We = 1), me.setLineWidth(We * Ge()), oe.isLineSegments ? ot.setMode(X.LINES) : oe.isLineLoop ? ot.setMode(X.LINE_LOOP) : ot.setMode(X.LINE_STRIP);
      } else oe.isPoints ? ot.setMode(X.POINTS) : oe.isSprite && ot.setMode(X.TRIANGLES);
      if (oe.isBatchedMesh) ot.renderMultiDraw(oe._multiDrawStarts, oe._multiDrawCounts, oe._multiDrawCount);
      else if (oe.isInstancedMesh) ot.renderInstances(ln, Qt, oe.count);
      else if (le.isInstancedBufferGeometry) {
        const We = le._maxInstanceCount !== void 0 ? le._maxInstanceCount : 1 / 0, Fr = Math.min(le.instanceCount, We);
        ot.renderInstances(ln, Qt, Fr);
      } else ot.render(ln, Qt);
    };
    function Ut(k, re, le) {
      k.transparent === true && k.side === Xs && k.forceSinglePass === false ? (k.side = Gi, k.needsUpdate = true, uu(k, re, le), k.side = ko, k.needsUpdate = true, uu(k, re, le), k.side = Xs) : uu(k, re, le);
    }
    this.compile = function(k, re, le = null) {
      le === null && (le = k), M = et.get(le), M.init(), w.push(M), le.traverseVisible(function(oe) {
        oe.isLight && oe.layers.test(re.layers) && (M.pushLight(oe), oe.castShadow && M.pushShadow(oe));
      }), k !== le && k.traverseVisible(function(oe) {
        oe.isLight && oe.layers.test(re.layers) && (M.pushLight(oe), oe.castShadow && M.pushShadow(oe));
      }), M.setupLights(E._useLegacyLights);
      const ce = /* @__PURE__ */ new Set();
      return k.traverse(function(oe) {
        const Fe = oe.material;
        if (Fe) if (Array.isArray(Fe)) for (let Je = 0; Je < Fe.length; Je++) {
          const rt = Fe[Je];
          Ut(rt, le, oe), ce.add(rt);
        }
        else Ut(Fe, le, oe), ce.add(Fe);
      }), w.pop(), M = null, ce;
    }, this.compileAsync = function(k, re, le = null) {
      const ce = this.compile(k, re, le);
      return new Promise((oe) => {
        function Fe() {
          if (ce.forEach(function(Je) {
            Ne.get(Je).currentProgram.isReady() && ce.delete(Je);
          }), ce.size === 0) {
            oe(k);
            return;
          }
          setTimeout(Fe, 10);
        }
        pe.get("KHR_parallel_shader_compile") !== null ? Fe() : setTimeout(Fe, 10);
      });
    };
    let Vt = null;
    function Dn(k) {
      Vt && Vt(k);
    }
    function Ni() {
      oi.stop();
    }
    function jt() {
      oi.start();
    }
    const oi = new xI();
    oi.setAnimationLoop(Dn), typeof self < "u" && oi.setContext(self), this.setAnimationLoop = function(k) {
      Vt = k, Tt.setAnimationLoop(k), k === null ? oi.stop() : oi.start();
    }, Tt.addEventListener("sessionstart", Ni), Tt.addEventListener("sessionend", jt), this.render = function(k, re) {
      if (re !== void 0 && re.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (A === true) return;
      k.matrixWorldAutoUpdate === true && k.updateMatrixWorld(), re.parent === null && re.matrixWorldAutoUpdate === true && re.updateMatrixWorld(), Tt.enabled === true && Tt.isPresenting === true && (Tt.cameraAutoUpdate === true && Tt.updateCamera(re), re = Tt.getCamera()), k.isScene === true && k.onBeforeRender(E, k, re, L), M = et.get(k, w.length), M.init(), w.push(M), Ie.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse), Ae.setFromProjectionMatrix(Ie), de = this.localClippingEnabled, te = Re.init(this.clippingPlanes, de), S = ke.get(k, m.length), S.init(), m.push(S), kr(k, re, 0, E.sortObjects), S.finish(), E.sortObjects === true && S.sort(B, Y), this.info.render.frame++, te === true && Re.beginShadows();
      const le = M.state.shadowsArray;
      if (ye.render(le, k, re), te === true && Re.endShadows(), this.info.autoReset === true && this.info.reset(), (Tt.enabled === false || Tt.isPresenting === false || Tt.hasDepthSensing() === false) && bt.render(S, k), M.setupLights(E._useLegacyLights), re.isArrayCamera) {
        const ce = re.cameras;
        for (let oe = 0, Fe = ce.length; oe < Fe; oe++) {
          const Je = ce[oe];
          df(S, k, Je, Je.viewport);
        }
      } else df(S, k, re);
      L !== null && (U.updateMultisampleRenderTarget(L), U.updateRenderTargetMipmap(L)), k.isScene === true && k.onAfterRender(E, k, re), _t.resetDefaultState(), D = -1, F = null, w.pop(), w.length > 0 ? M = w[w.length - 1] : M = null, m.pop(), m.length > 0 ? S = m[m.length - 1] : S = null;
    };
    function kr(k, re, le, ce) {
      if (k.visible === false) return;
      if (k.layers.test(re.layers)) {
        if (k.isGroup) le = k.renderOrder;
        else if (k.isLOD) k.autoUpdate === true && k.update(re);
        else if (k.isLight) M.pushLight(k), k.castShadow && M.pushShadow(k);
        else if (k.isSprite) {
          if (!k.frustumCulled || Ae.intersectsSprite(k)) {
            ce && Oe.setFromMatrixPosition(k.matrixWorld).applyMatrix4(Ie);
            const Je = ge.update(k), rt = k.material;
            rt.visible && S.push(k, Je, rt, le, Oe.z, null);
          }
        } else if ((k.isMesh || k.isLine || k.isPoints) && (!k.frustumCulled || Ae.intersectsObject(k))) {
          const Je = ge.update(k), rt = k.material;
          if (ce && (k.boundingSphere !== void 0 ? (k.boundingSphere === null && k.computeBoundingSphere(), Oe.copy(k.boundingSphere.center)) : (Je.boundingSphere === null && Je.computeBoundingSphere(), Oe.copy(Je.boundingSphere.center)), Oe.applyMatrix4(k.matrixWorld).applyMatrix4(Ie)), Array.isArray(rt)) {
            const st = Je.groups;
            for (let ft = 0, ct = st.length; ft < ct; ft++) {
              const ht = st[ft], ln = rt[ht.materialIndex];
              ln && ln.visible && S.push(k, Je, ln, le, Oe.z, ht);
            }
          } else rt.visible && S.push(k, Je, rt, le, Oe.z, null);
        }
      }
      const Fe = k.children;
      for (let Je = 0, rt = Fe.length; Je < rt; Je++) kr(Fe[Je], re, le, ce);
    }
    function df(k, re, le, ce) {
      const oe = k.opaque, Fe = k.transmissive, Je = k.transparent;
      M.setupLightsView(le), te === true && Re.setGlobalState(E.clippingPlanes, le), Fe.length > 0 && pf(oe, Fe, re, le), ce && me.viewport(C.copy(ce)), oe.length > 0 && lu(oe, re, le), Fe.length > 0 && lu(Fe, re, le), Je.length > 0 && lu(Je, re, le), me.buffers.depth.setTest(true), me.buffers.depth.setMask(true), me.buffers.color.setMask(true), me.setPolygonOffset(false);
    }
    function pf(k, re, le, ce) {
      if ((le.isScene === true ? le.overrideMaterial : null) !== null) return;
      const Fe = we.isWebGL2;
      Ee === null && (Ee = new As(1, 1, { generateMipmaps: true, type: pe.has("EXT_color_buffer_half_float") ? Hc : to, minFilter: $s, samples: Fe ? 4 : 0 })), E.getDrawingBufferSize(Ze), Fe ? Ee.setSize(Ze.x, Ze.y) : Ee.setSize(m0(Ze.x), m0(Ze.y));
      const Je = E.getRenderTarget();
      E.setRenderTarget(Ee), E.getClearColor(Z), G = E.getClearAlpha(), G < 1 && E.setClearColor(16777215, 0.5), E.clear();
      const rt = E.toneMapping;
      E.toneMapping = eo, lu(k, le, ce), U.updateMultisampleRenderTarget(Ee), U.updateRenderTargetMipmap(Ee);
      let st = false;
      for (let ft = 0, ct = re.length; ft < ct; ft++) {
        const ht = re[ft], ln = ht.object, ai = ht.geometry, Qt = ht.material, qn = ht.group;
        if (Qt.side === Xs && ln.layers.test(ce.layers)) {
          const ot = Qt.side;
          Qt.side = Gi, Qt.needsUpdate = true, Wo(ln, le, ce, ai, Qt, qn), Qt.side = ot, Qt.needsUpdate = true, st = true;
        }
      }
      st === true && (U.updateMultisampleRenderTarget(Ee), U.updateRenderTargetMipmap(Ee)), E.setRenderTarget(Je), E.setClearColor(Z, G), E.toneMapping = rt;
    }
    function lu(k, re, le) {
      const ce = re.isScene === true ? re.overrideMaterial : null;
      for (let oe = 0, Fe = k.length; oe < Fe; oe++) {
        const Je = k[oe], rt = Je.object, st = Je.geometry, ft = ce === null ? Je.material : ce, ct = Je.group;
        rt.layers.test(le.layers) && Wo(rt, re, le, st, ft, ct);
      }
    }
    function Wo(k, re, le, ce, oe, Fe) {
      k.onBeforeRender(E, re, le, ce, oe, Fe), k.modelViewMatrix.multiplyMatrices(le.matrixWorldInverse, k.matrixWorld), k.normalMatrix.getNormalMatrix(k.modelViewMatrix), oe.onBeforeRender(E, re, le, ce, k, Fe), oe.transparent === true && oe.side === Xs && oe.forceSinglePass === false ? (oe.side = Gi, oe.needsUpdate = true, E.renderBufferDirect(le, re, ce, oe, k, Fe), oe.side = ko, oe.needsUpdate = true, E.renderBufferDirect(le, re, ce, oe, k, Fe), oe.side = Xs) : E.renderBufferDirect(le, re, ce, oe, k, Fe), k.onAfterRender(E, re, le, ce, oe, Fe);
    }
    function uu(k, re, le) {
      re.isScene !== true && (re = at);
      const ce = Ne.get(k), oe = M.state.lights, Fe = M.state.shadowsArray, Je = oe.state.version, rt = ze.getParameters(k, oe.state, Fe, re, le), st = ze.getProgramCacheKey(rt);
      let ft = ce.programs;
      ce.environment = k.isMeshStandardMaterial ? re.environment : null, ce.fog = re.fog, ce.envMap = (k.isMeshStandardMaterial ? ie : O).get(k.envMap || ce.environment), ft === void 0 && (k.addEventListener("dispose", Ce), ft = /* @__PURE__ */ new Map(), ce.programs = ft);
      let ct = ft.get(st);
      if (ct !== void 0) {
        if (ce.currentProgram === ct && ce.lightsStateVersion === Je) return Qd(k, rt), ct;
      } else rt.uniforms = ze.getUniforms(k), k.onBuild(le, rt, E), k.onBeforeCompile(rt, E), ct = ze.acquireProgram(rt, st), ft.set(st, ct), ce.uniforms = rt.uniforms;
      const ht = ce.uniforms;
      return (!k.isShaderMaterial && !k.isRawShaderMaterial || k.clipping === true) && (ht.clippingPlanes = Re.uniform), Qd(k, rt), ce.needsLights = rv(k), ce.lightsStateVersion = Je, ce.needsLights && (ht.ambientLightColor.value = oe.state.ambient, ht.lightProbe.value = oe.state.probe, ht.directionalLights.value = oe.state.directional, ht.directionalLightShadows.value = oe.state.directionalShadow, ht.spotLights.value = oe.state.spot, ht.spotLightShadows.value = oe.state.spotShadow, ht.rectAreaLights.value = oe.state.rectArea, ht.ltc_1.value = oe.state.rectAreaLTC1, ht.ltc_2.value = oe.state.rectAreaLTC2, ht.pointLights.value = oe.state.point, ht.pointLightShadows.value = oe.state.pointShadow, ht.hemisphereLights.value = oe.state.hemi, ht.directionalShadowMap.value = oe.state.directionalShadowMap, ht.directionalShadowMatrix.value = oe.state.directionalShadowMatrix, ht.spotShadowMap.value = oe.state.spotShadowMap, ht.spotLightMatrix.value = oe.state.spotLightMatrix, ht.spotLightMap.value = oe.state.spotLightMap, ht.pointShadowMap.value = oe.state.pointShadowMap, ht.pointShadowMatrix.value = oe.state.pointShadowMatrix), ce.currentProgram = ct, ce.uniformsList = null, ct;
    }
    function Jd(k) {
      if (k.uniformsList === null) {
        const re = k.currentProgram.getUniforms();
        k.uniformsList = Lg.seqWithValue(re.seq, k.uniforms);
      }
      return k.uniformsList;
    }
    function Qd(k, re) {
      const le = Ne.get(k);
      le.outputColorSpace = re.outputColorSpace, le.batching = re.batching, le.instancing = re.instancing, le.instancingColor = re.instancingColor, le.skinning = re.skinning, le.morphTargets = re.morphTargets, le.morphNormals = re.morphNormals, le.morphColors = re.morphColors, le.morphTargetsCount = re.morphTargetsCount, le.numClippingPlanes = re.numClippingPlanes, le.numIntersection = re.numClipIntersection, le.vertexAlphas = re.vertexAlphas, le.vertexTangents = re.vertexTangents, le.toneMapping = re.toneMapping;
    }
    function nv(k, re, le, ce, oe) {
      re.isScene !== true && (re = at), U.resetTextureUnits();
      const Fe = re.fog, Je = ce.isMeshStandardMaterial ? re.environment : null, rt = L === null ? E.outputColorSpace : L.isXRRenderTarget === true ? L.texture.colorSpace : so, st = (ce.isMeshStandardMaterial ? ie : O).get(ce.envMap || Je), ft = ce.vertexColors === true && !!le.attributes.color && le.attributes.color.itemSize === 4, ct = !!le.attributes.tangent && (!!ce.normalMap || ce.anisotropy > 0), ht = !!le.morphAttributes.position, ln = !!le.morphAttributes.normal, ai = !!le.morphAttributes.color;
      let Qt = eo;
      ce.toneMapped && (L === null || L.isXRRenderTarget === true) && (Qt = E.toneMapping);
      const qn = le.morphAttributes.position || le.morphAttributes.normal || le.morphAttributes.color, ot = qn !== void 0 ? qn.length : 0, We = Ne.get(ce), Fr = M.state.lights;
      if (te === true && (de === true || k !== F)) {
        const li = k === F && ce.id === D;
        Re.setState(ce, k, li);
      }
      let wt = false;
      ce.version === We.__version ? (We.needsLights && We.lightsStateVersion !== Fr.state.version || We.outputColorSpace !== rt || oe.isBatchedMesh && We.batching === false || !oe.isBatchedMesh && We.batching === true || oe.isInstancedMesh && We.instancing === false || !oe.isInstancedMesh && We.instancing === true || oe.isSkinnedMesh && We.skinning === false || !oe.isSkinnedMesh && We.skinning === true || oe.isInstancedMesh && We.instancingColor === true && oe.instanceColor === null || oe.isInstancedMesh && We.instancingColor === false && oe.instanceColor !== null || We.envMap !== st || ce.fog === true && We.fog !== Fe || We.numClippingPlanes !== void 0 && (We.numClippingPlanes !== Re.numPlanes || We.numIntersection !== Re.numIntersection) || We.vertexAlphas !== ft || We.vertexTangents !== ct || We.morphTargets !== ht || We.morphNormals !== ln || We.morphColors !== ai || We.toneMapping !== Qt || we.isWebGL2 === true && We.morphTargetsCount !== ot) && (wt = true) : (wt = true, We.__version = ce.version);
      let _n = We.currentProgram;
      wt === true && (_n = uu(ce, re, oe));
      let Ps = false, zr = false, Kn = false;
      const An = _n.getUniforms(), Ls = We.uniforms;
      if (me.useProgram(_n.program) && (Ps = true, zr = true, Kn = true), ce.id !== D && (D = ce.id, zr = true), Ps || F !== k) {
        An.setValue(X, "projectionMatrix", k.projectionMatrix), An.setValue(X, "viewMatrix", k.matrixWorldInverse);
        const li = An.map.cameraPosition;
        li !== void 0 && li.setValue(X, Oe.setFromMatrixPosition(k.matrixWorld)), we.logarithmicDepthBuffer && An.setValue(X, "logDepthBufFC", 2 / (Math.log(k.far + 1) / Math.LN2)), (ce.isMeshPhongMaterial || ce.isMeshToonMaterial || ce.isMeshLambertMaterial || ce.isMeshBasicMaterial || ce.isMeshStandardMaterial || ce.isShaderMaterial) && An.setValue(X, "isOrthographic", k.isOrthographicCamera === true), F !== k && (F = k, zr = true, Kn = true);
      }
      if (oe.isSkinnedMesh) {
        An.setOptional(X, oe, "bindMatrix"), An.setOptional(X, oe, "bindMatrixInverse");
        const li = oe.skeleton;
        li && (we.floatVertexTextures ? (li.boneTexture === null && li.computeBoneTexture(), An.setValue(X, "boneTexture", li.boneTexture, U)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));
      }
      oe.isBatchedMesh && (An.setOptional(X, oe, "batchingTexture"), An.setValue(X, "batchingTexture", oe._matricesTexture, U));
      const cu = le.morphAttributes;
      if ((cu.position !== void 0 || cu.normal !== void 0 || cu.color !== void 0 && we.isWebGL2 === true) && gt.update(oe, le, _n), (zr || We.receiveShadow !== oe.receiveShadow) && (We.receiveShadow = oe.receiveShadow, An.setValue(X, "receiveShadow", oe.receiveShadow)), ce.isMeshGouraudMaterial && ce.envMap !== null && (Ls.envMap.value = st, Ls.flipEnvMap.value = st.isCubeTexture && st.isRenderTargetTexture === false ? -1 : 1), zr && (An.setValue(X, "toneMappingExposure", E.toneMappingExposure), We.needsLights && iv(Ls, Kn), Fe && ce.fog === true && Le.refreshFogUniforms(Ls, Fe), Le.refreshMaterialUniforms(Ls, ce, ae, q, Ee), Lg.upload(X, Jd(We), Ls, U)), ce.isShaderMaterial && ce.uniformsNeedUpdate === true && (Lg.upload(X, Jd(We), Ls, U), ce.uniformsNeedUpdate = false), ce.isSpriteMaterial && An.setValue(X, "center", oe.center), An.setValue(X, "modelViewMatrix", oe.modelViewMatrix), An.setValue(X, "normalMatrix", oe.normalMatrix), An.setValue(X, "modelMatrix", oe.matrixWorld), ce.isShaderMaterial || ce.isRawShaderMaterial) {
        const li = ce.uniformsGroups;
        for (let fu = 0, hr = li.length; fu < hr; fu++) if (we.isWebGL2) {
          const ep = li[fu];
          Lt.update(ep, _n), Lt.bind(ep, _n);
        } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
      }
      return _n;
    }
    function iv(k, re) {
      k.ambientLightColor.needsUpdate = re, k.lightProbe.needsUpdate = re, k.directionalLights.needsUpdate = re, k.directionalLightShadows.needsUpdate = re, k.pointLights.needsUpdate = re, k.pointLightShadows.needsUpdate = re, k.spotLights.needsUpdate = re, k.spotLightShadows.needsUpdate = re, k.rectAreaLights.needsUpdate = re, k.hemisphereLights.needsUpdate = re;
    }
    function rv(k) {
      return k.isMeshLambertMaterial || k.isMeshToonMaterial || k.isMeshPhongMaterial || k.isMeshStandardMaterial || k.isShadowMaterial || k.isShaderMaterial && k.lights === true;
    }
    this.getActiveCubeFace = function() {
      return P;
    }, this.getActiveMipmapLevel = function() {
      return R;
    }, this.getRenderTarget = function() {
      return L;
    }, this.setRenderTargetTextures = function(k, re, le) {
      Ne.get(k.texture).__webglTexture = re, Ne.get(k.depthTexture).__webglTexture = le;
      const ce = Ne.get(k);
      ce.__hasExternalTextures = true, ce.__hasExternalTextures && (ce.__autoAllocateDepthBuffer = le === void 0, ce.__autoAllocateDepthBuffer || pe.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ce.__useRenderToTexture = false));
    }, this.setRenderTargetFramebuffer = function(k, re) {
      const le = Ne.get(k);
      le.__webglFramebuffer = re, le.__useDefaultFramebuffer = re === void 0;
    }, this.setRenderTarget = function(k, re = 0, le = 0) {
      L = k, P = re, R = le;
      let ce = true, oe = null, Fe = false, Je = false;
      if (k) {
        const st = Ne.get(k);
        st.__useDefaultFramebuffer !== void 0 ? (me.bindFramebuffer(X.FRAMEBUFFER, null), ce = false) : st.__webglFramebuffer === void 0 ? U.setupRenderTarget(k) : st.__hasExternalTextures && U.rebindTextures(k, Ne.get(k.texture).__webglTexture, Ne.get(k.depthTexture).__webglTexture);
        const ft = k.texture;
        (ft.isData3DTexture || ft.isDataArrayTexture || ft.isCompressedArrayTexture) && (Je = true);
        const ct = Ne.get(k).__webglFramebuffer;
        k.isWebGLCubeRenderTarget ? (Array.isArray(ct[re]) ? oe = ct[re][le] : oe = ct[re], Fe = true) : we.isWebGL2 && k.samples > 0 && U.useMultisampledRTT(k) === false ? oe = Ne.get(k).__webglMultisampledFramebuffer : Array.isArray(ct) ? oe = ct[le] : oe = ct, C.copy(k.viewport), N.copy(k.scissor), j = k.scissorTest;
      } else C.copy($).multiplyScalar(ae).floor(), N.copy(ee).multiplyScalar(ae).floor(), j = ue;
      if (me.bindFramebuffer(X.FRAMEBUFFER, oe) && we.drawBuffers && ce && me.drawBuffers(k, oe), me.viewport(C), me.scissor(N), me.setScissorTest(j), Fe) {
        const st = Ne.get(k.texture);
        X.framebufferTexture2D(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, X.TEXTURE_CUBE_MAP_POSITIVE_X + re, st.__webglTexture, le);
      } else if (Je) {
        const st = Ne.get(k.texture), ft = re || 0;
        X.framebufferTextureLayer(X.FRAMEBUFFER, X.COLOR_ATTACHMENT0, st.__webglTexture, le || 0, ft);
      }
      D = -1;
    }, this.readRenderTargetPixels = function(k, re, le, ce, oe, Fe, Je) {
      if (!(k && k.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let rt = Ne.get(k).__webglFramebuffer;
      if (k.isWebGLCubeRenderTarget && Je !== void 0 && (rt = rt[Je]), rt) {
        me.bindFramebuffer(X.FRAMEBUFFER, rt);
        try {
          const st = k.texture, ft = st.format, ct = st.type;
          if (ft !== zi && je.convert(ft) !== X.getParameter(X.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const ht = ct === Hc && (pe.has("EXT_color_buffer_half_float") || we.isWebGL2 && pe.has("EXT_color_buffer_float"));
          if (ct !== to && je.convert(ct) !== X.getParameter(X.IMPLEMENTATION_COLOR_READ_TYPE) && !(ct === ns && (we.isWebGL2 || pe.has("OES_texture_float") || pe.has("WEBGL_color_buffer_float"))) && !ht) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          re >= 0 && re <= k.width - ce && le >= 0 && le <= k.height - oe && X.readPixels(re, le, ce, oe, je.convert(ft), je.convert(ct), Fe);
        } finally {
          const st = L !== null ? Ne.get(L).__webglFramebuffer : null;
          me.bindFramebuffer(X.FRAMEBUFFER, st);
        }
      }
    }, this.copyFramebufferToTexture = function(k, re, le = 0) {
      const ce = Math.pow(2, -le), oe = Math.floor(re.image.width * ce), Fe = Math.floor(re.image.height * ce);
      U.setTexture2D(re, 0), X.copyTexSubImage2D(X.TEXTURE_2D, le, 0, 0, k.x, k.y, oe, Fe), me.unbindTexture();
    }, this.copyTextureToTexture = function(k, re, le, ce = 0) {
      const oe = re.image.width, Fe = re.image.height, Je = je.convert(le.format), rt = je.convert(le.type);
      U.setTexture2D(le, 0), X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL, le.flipY), X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL, le.premultiplyAlpha), X.pixelStorei(X.UNPACK_ALIGNMENT, le.unpackAlignment), re.isDataTexture ? X.texSubImage2D(X.TEXTURE_2D, ce, k.x, k.y, oe, Fe, Je, rt, re.image.data) : re.isCompressedTexture ? X.compressedTexSubImage2D(X.TEXTURE_2D, ce, k.x, k.y, re.mipmaps[0].width, re.mipmaps[0].height, Je, re.mipmaps[0].data) : X.texSubImage2D(X.TEXTURE_2D, ce, k.x, k.y, Je, rt, re.image), ce === 0 && le.generateMipmaps && X.generateMipmap(X.TEXTURE_2D), me.unbindTexture();
    }, this.copyTextureToTexture3D = function(k, re, le, ce, oe = 0) {
      if (E.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const Fe = k.max.x - k.min.x + 1, Je = k.max.y - k.min.y + 1, rt = k.max.z - k.min.z + 1, st = je.convert(ce.format), ft = je.convert(ce.type);
      let ct;
      if (ce.isData3DTexture) U.setTexture3D(ce, 0), ct = X.TEXTURE_3D;
      else if (ce.isDataArrayTexture || ce.isCompressedArrayTexture) U.setTexture2DArray(ce, 0), ct = X.TEXTURE_2D_ARRAY;
      else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      X.pixelStorei(X.UNPACK_FLIP_Y_WEBGL, ce.flipY), X.pixelStorei(X.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ce.premultiplyAlpha), X.pixelStorei(X.UNPACK_ALIGNMENT, ce.unpackAlignment);
      const ht = X.getParameter(X.UNPACK_ROW_LENGTH), ln = X.getParameter(X.UNPACK_IMAGE_HEIGHT), ai = X.getParameter(X.UNPACK_SKIP_PIXELS), Qt = X.getParameter(X.UNPACK_SKIP_ROWS), qn = X.getParameter(X.UNPACK_SKIP_IMAGES), ot = le.isCompressedTexture ? le.mipmaps[oe] : le.image;
      X.pixelStorei(X.UNPACK_ROW_LENGTH, ot.width), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, ot.height), X.pixelStorei(X.UNPACK_SKIP_PIXELS, k.min.x), X.pixelStorei(X.UNPACK_SKIP_ROWS, k.min.y), X.pixelStorei(X.UNPACK_SKIP_IMAGES, k.min.z), le.isDataTexture || le.isData3DTexture ? X.texSubImage3D(ct, oe, re.x, re.y, re.z, Fe, Je, rt, st, ft, ot.data) : le.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), X.compressedTexSubImage3D(ct, oe, re.x, re.y, re.z, Fe, Je, rt, st, ot.data)) : X.texSubImage3D(ct, oe, re.x, re.y, re.z, Fe, Je, rt, st, ft, ot), X.pixelStorei(X.UNPACK_ROW_LENGTH, ht), X.pixelStorei(X.UNPACK_IMAGE_HEIGHT, ln), X.pixelStorei(X.UNPACK_SKIP_PIXELS, ai), X.pixelStorei(X.UNPACK_SKIP_ROWS, Qt), X.pixelStorei(X.UNPACK_SKIP_IMAGES, qn), oe === 0 && ce.generateMipmaps && X.generateMipmap(ct), me.unbindTexture();
    }, this.initTexture = function(k) {
      k.isCubeTexture ? U.setTextureCube(k, 0) : k.isData3DTexture ? U.setTexture3D(k, 0) : k.isDataArrayTexture || k.isCompressedArrayTexture ? U.setTexture2DArray(k, 0) : U.setTexture2D(k, 0), me.unbindTexture();
    }, this.resetState = function() {
      P = 0, R = 0, L = null, me.reset(), _t.reset();
    }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  get coordinateSystem() {
    return Ys;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const t = this.getContext();
    t.drawingBufferColorSpace = e === C_ ? "display-p3" : "srgb", t.unpackColorSpace = Ht.workingColorSpace === Bd ? "display-p3" : "srgb";
  }
  get outputEncoding() {
    return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace === Xn ? Pa : Ew;
  }
  set outputEncoding(e) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."), this.outputColorSpace = e === Pa ? Xn : so;
  }
  get useLegacyLights() {
    return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights;
  }
  set useLegacyLights(e) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."), this._useLegacyLights = e;
  }
}
class CI extends Ow {
}
CI.prototype.isWebGL1Renderer = true;
class L_ {
  constructor(e, t = 25e-5) {
    this.isFogExp2 = true, this.name = "", this.color = new Ve(e), this.density = t;
  }
  clone() {
    return new L_(this.color, this.density);
  }
  toJSON() {
    return { type: "FogExp2", name: this.name, color: this.color.getHex(), density: this.density };
  }
}
class I_ {
  constructor(e, t = 1, i = 1e3) {
    this.isFog = true, this.name = "", this.color = new Ve(e), this.near = t, this.far = i;
  }
  clone() {
    return new I_(this.color, this.near, this.far);
  }
  toJSON() {
    return { type: "Fog", name: this.name, color: this.color.getHex(), near: this.near, far: this.far };
  }
}
class Uw extends Ot {
  constructor() {
    super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t;
  }
}
class N_ {
  constructor(e, t) {
    this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = ud, this._updateRange = { offset: 0, count: -1 }, this.updateRanges = [], this.version = 0, this.uuid = Rr();
  }
  onUploadCallback() {
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  get updateRange() {
    return Ul("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."), this._updateRange;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  copyAt(e, t, i) {
    e *= this.stride, i *= t.stride;
    for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Rr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Rr()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride };
  }
}
const Ui = new V();
class Zl {
  constructor(e, t, i, r = false) {
    this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r;
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++) Ui.fromBufferAttribute(this, t), Ui.applyMatrix4(e), this.setXYZ(t, Ui.x, Ui.y, Ui.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++) Ui.fromBufferAttribute(this, t), Ui.applyNormalMatrix(e), this.setXYZ(t, Ui.x, Ui.y, Ui.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++) Ui.fromBufferAttribute(this, t), Ui.transformDirection(e), this.setXYZ(t, Ui.x, Ui.y, Ui.z);
    return this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (i = Bi(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return this.normalized && (i = vt(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
  }
  setX(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  setY(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  setZ(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  setW(e, t) {
    return this.normalized && (t = vt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Bi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
  }
  setXYZ(e, t, i, r) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
  }
  setXYZW(e, t, i, r, s) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = vt(t, this.array), i = vt(i, this.array), r = vt(r, this.array), s = vt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
  }
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new zt(new this.array.constructor(t), this.itemSize, this.normalized);
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Zl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return { itemSize: this.itemSize, type: this.array.constructor.name, array: t, normalized: this.normalized };
    } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), { isInterleavedBufferAttribute: true, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized };
  }
}
class kw extends Ii {
  constructor(e) {
    super(), this.isSpriteMaterial = true, this.type = "SpriteMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = true, this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
let Xu;
const Yf = new V(), ju = new V(), $u = new V(), Yu = new _e(), qf = new _e(), RI = new lt(), Om = new V(), Kf = new V(), Um = new V(), AC = new _e(), ux = new _e(), bC = new _e();
class PI extends Ot {
  constructor(e = new kw()) {
    if (super(), this.isSprite = true, this.type = "Sprite", Xu === void 0) {
      Xu = new xt();
      const t = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]), i = new N_(t, 5);
      Xu.setIndex([0, 1, 2, 0, 2, 3]), Xu.setAttribute("position", new Zl(i, 3, 0, false)), Xu.setAttribute("uv", new Zl(i, 2, 3, false));
    }
    this.geometry = Xu, this.material = e, this.center = new _e(0.5, 0.5);
  }
  raycast(e, t) {
    e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), ju.setFromMatrixScale(this.matrixWorld), RI.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), $u.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === false && ju.multiplyScalar(-$u.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && (s = Math.cos(i), r = Math.sin(i));
    const o = this.center;
    km(Om.set(-0.5, -0.5, 0), $u, o, ju, r, s), km(Kf.set(0.5, -0.5, 0), $u, o, ju, r, s), km(Um.set(0.5, 0.5, 0), $u, o, ju, r, s), AC.set(0, 0), ux.set(1, 0), bC.set(1, 1);
    let a = e.ray.intersectTriangle(Om, Kf, Um, false, Yf);
    if (a === null && (km(Kf.set(-0.5, 0.5, 0), $u, o, ju, r, s), ux.set(0, 1), a = e.ray.intersectTriangle(Om, Um, Kf, false, Yf), a === null)) return;
    const l = e.ray.origin.distanceTo(Yf);
    l < e.near || l > e.far || t.push({ distance: l, point: Yf.clone(), uv: wr.getInterpolation(Yf, Om, Kf, Um, AC, ux, bC, new _e()), face: null, object: this });
  }
  copy(e, t) {
    return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this;
  }
}
function km(n24, e, t, i, r, s) {
  Yu.subVectors(n24, t).addScalar(0.5).multiply(i), r !== void 0 ? (qf.x = s * Yu.x - r * Yu.y, qf.y = r * Yu.x + s * Yu.y) : qf.copy(Yu), n24.copy(e), n24.x += qf.x, n24.y += qf.y, n24.applyMatrix4(RI);
}
const Fm = new V(), CC = new V();
class LI extends Ot {
  constructor() {
    super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: true, value: [] }, isLOD: { value: true } }), this.autoUpdate = true;
  }
  copy(e) {
    super.copy(e, false);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return this.autoUpdate = e.autoUpdate, this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++) ;
    return r.splice(s, 0, { distance: t, hysteresis: i, object: e }), this.add(e), this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if (t[i].object.visible && (s -= s * t[i].hysteresis), e < s) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      Fm.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(Fm);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      Fm.setFromMatrixPosition(e.matrixWorld), CC.setFromMatrixPosition(this.matrixWorld);
      const i = Fm.distanceTo(CC) / e.zoom;
      t[0].object.visible = true;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if (t[r].object.visible && (o -= o * t[r].hysteresis), i >= o) t[r - 1].object.visible = false, t[r].object.visible = true;
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = false;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === false && (t.object.autoUpdate = false), t.object.levels = [];
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({ object: o.object.uuid, distance: o.distance, hysteresis: o.hysteresis });
    }
    return t;
  }
}
const RC = new V(), PC = new Gt(), LC = new Gt(), xW = new V(), IC = new lt(), zm = new V(), cx = new Ri(), NC = new lt(), fx = new uf();
class II extends Hn {
  constructor(e, t) {
    super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = j1, this.bindMatrix = new lt(), this.bindMatrixInverse = new lt(), this.boundingBox = null, this.boundingSphere = null;
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Wi()), this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++) this.getVertexPosition(i, zm), this.boundingBox.expandByPoint(zm);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Ri()), this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++) this.getVertexPosition(i, zm), this.boundingSphere.expandByPoint(zm);
  }
  copy(e, t) {
    return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  raycast(e, t) {
    const i = this.material, r = this.matrixWorld;
    i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), cx.copy(this.boundingSphere), cx.applyMatrix4(r), e.ray.intersectsSphere(cx) !== false && (NC.copy(r).invert(), fx.copy(e.ray).applyMatrix4(NC), !(this.boundingBox !== null && fx.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, fx)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Gt(), t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.bindMode === j1 ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === WL ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton, r = this.geometry;
    PC.fromBufferAttribute(r.attributes.skinIndex, e), LC.fromBufferAttribute(r.attributes.skinWeight, e), RC.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = LC.getComponent(s);
      if (o !== 0) {
        const a = PC.getComponent(s);
        IC.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]), t.addScaledVector(xW.copy(RC).applyMatrix4(IC), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
}
class Fw extends Ot {
  constructor() {
    super(), this.isBone = true, this.type = "Bone";
  }
}
class Fl extends Tn {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, f = Pn, h = Pn, d, p) {
    super(null, o, a, l, f, h, r, s, d, p), this.isDataTexture = true, this.image = { data: e, width: t, height: i }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
  }
}
const DC = new lt(), SW = new lt();
class D_ {
  constructor(e = [], t = []) {
    this.uuid = Rr(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
  }
  init() {
    const e = this.bones, t = this.boneInverses;
    if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
      for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new lt());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new lt();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : SW;
      DC.multiplyMatrices(a, t[s]), DC.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = true);
  }
  clone() {
    return new D_(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Fl(t, e, e, zi, ns);
    return i.needsUpdate = true, this.boneMatrices = t, this.boneTexture = i, this;
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new Fw()), this.bones.push(o), this.boneInverses.push(new lt().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] };
    e.uuid = this.uuid;
    const t = this.bones, i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Xc extends zt {
  constructor(e, t, i, r = 1) {
    super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = r;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
  }
}
const qu = new lt(), OC = new lt(), Bm = [], UC = new Wi(), MW = new lt(), Zf = new Hn(), Jf = new Ri();
class NI extends Hn {
  constructor(e, t, i) {
    super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new Xc(new Float32Array(i * 16), 16), this.instanceColor = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
    for (let r = 0; r < i; r++) this.setMatrixAt(r, MW);
  }
  computeBoundingBox() {
    const e = this.geometry, t = this.count;
    this.boundingBox === null && (this.boundingBox = new Wi()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++) this.getMatrixAt(i, qu), UC.copy(e.boundingBox).applyMatrix4(qu), this.boundingBox.union(UC);
  }
  computeBoundingSphere() {
    const e = this.geometry, t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Ri()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++) this.getMatrixAt(i, qu), Jf.copy(e.boundingSphere).applyMatrix4(qu), this.boundingSphere.union(Jf);
  }
  copy(e, t) {
    return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld, r = this.count;
    if (Zf.geometry = this.geometry, Zf.material = this.material, Zf.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Jf.copy(this.boundingSphere), Jf.applyMatrix4(i), e.ray.intersectsSphere(Jf) !== false)) for (let s = 0; s < r; s++) {
      this.getMatrixAt(s, qu), OC.multiplyMatrices(i, qu), Zf.matrixWorld = OC, Zf.raycast(e, Bm);
      for (let o = 0, a = Bm.length; o < a; o++) {
        const l = Bm[o];
        l.instanceId = s, l.object = this, t.push(l);
      }
      Bm.length = 0;
    }
  }
  setColorAt(e, t) {
    this.instanceColor === null && (this.instanceColor = new Xc(new Float32Array(this.instanceMatrix.count * 3), 3)), t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
function wW(n24, e) {
  return n24.z - e.z;
}
function EW(n24, e) {
  return e.z - n24.z;
}
class TW {
  constructor() {
    this.index = 0, this.pool = [], this.list = [];
  }
  push(e, t) {
    const i = this.pool, r = this.list;
    this.index >= i.length && i.push({ start: -1, count: -1, z: -1 });
    const s = i[this.index];
    r.push(s), this.index++, s.start = e.start, s.count = e.count, s.z = t;
  }
  reset() {
    this.list.length = 0, this.index = 0;
  }
}
const Ku = "batchId", oa = new lt(), kC = new lt(), AW = new lt(), FC = new lt(), hx = new Wd(), Vm = new Wi(), al = new Ri(), Qf = new V(), dx = new TW(), wi = new Hn(), Hm = [];
function bW(n24, e, t = 0) {
  const i = e.itemSize;
  if (n24.isInterleavedBufferAttribute || n24.array.constructor !== e.array.constructor) {
    const r = n24.count;
    for (let s = 0; s < r; s++) for (let o = 0; o < i; o++) e.setComponent(s + t, o, n24.getComponent(s, o));
  } else e.array.set(n24.array, t * i);
  e.needsUpdate = true;
}
class DI extends Hn {
  get maxGeometryCount() {
    return this._maxGeometryCount;
  }
  constructor(e, t, i = t * 2, r) {
    super(new xt(), r), this.isBatchedMesh = true, this.perObjectFrustumCulled = true, this.sortObjects = true, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._drawRanges = [], this._reservedRanges = [], this._visibility = [], this._active = [], this._bounds = [], this._maxGeometryCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._geometryInitialized = false, this._geometryCount = 0, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._visibilityChanged = true, this._matricesTexture = null, this._initMatricesTexture();
  }
  _initMatricesTexture() {
    let e = Math.sqrt(this._maxGeometryCount * 4);
    e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
    const t = new Float32Array(e * e * 4), i = new Fl(t, e, e, zi, ns);
    this._matricesTexture = i;
  }
  _initializeGeometry(e) {
    const t = this.geometry, i = this._maxVertexCount, r = this._maxGeometryCount, s = this._maxIndexCount;
    if (this._geometryInitialized === false) {
      for (const a in e.attributes) {
        const l = e.getAttribute(a), { array: f, itemSize: h, normalized: d } = l, p = new f.constructor(i * h), g = new l.constructor(p, h, d);
        g.setUsage(l.usage), t.setAttribute(a, g);
      }
      if (e.getIndex() !== null) {
        const a = i > 65536 ? new Uint32Array(s) : new Uint16Array(s);
        t.setIndex(new zt(a, 1));
      }
      const o = r > 65536 ? new Uint32Array(i) : new Uint16Array(i);
      t.setAttribute(Ku, new zt(o, 1)), this._geometryInitialized = true;
    }
  }
  _validateGeometry(e) {
    if (e.getAttribute(Ku)) throw new Error(`BatchedMesh: Geometry cannot use attribute "${Ku}"`);
    const t = this.geometry;
    if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
    for (const i in t.attributes) {
      if (i === Ku) continue;
      if (!e.hasAttribute(i)) throw new Error(`BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
      const r = e.getAttribute(i), s = t.getAttribute(i);
      if (r.itemSize !== s.itemSize || r.normalized !== s.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.");
    }
  }
  setCustomSort(e) {
    return this.customSort = e, this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Wi());
    const e = this._geometryCount, t = this.boundingBox, i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++) i[r] !== false && (this.getMatrixAt(r, oa), this.getBoundingBoxAt(r, Vm).applyMatrix4(oa), t.union(Vm));
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Ri());
    const e = this._geometryCount, t = this.boundingSphere, i = this._active;
    t.makeEmpty();
    for (let r = 0; r < e; r++) i[r] !== false && (this.getMatrixAt(r, oa), this.getBoundingSphereAt(r, al).applyMatrix4(oa), t.union(al));
  }
  addGeometry(e, t = -1, i = -1) {
    if (this._initializeGeometry(e), this._validateGeometry(e), this._geometryCount >= this._maxGeometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
    const r = { vertexStart: -1, vertexCount: -1, indexStart: -1, indexCount: -1 };
    let s = null;
    const o = this._reservedRanges, a = this._drawRanges, l = this._bounds;
    this._geometryCount !== 0 && (s = o[o.length - 1]), t === -1 ? r.vertexCount = e.getAttribute("position").count : r.vertexCount = t, s === null ? r.vertexStart = 0 : r.vertexStart = s.vertexStart + s.vertexCount;
    const f = e.getIndex(), h = f !== null;
    if (h && (i === -1 ? r.indexCount = f.count : r.indexCount = i, s === null ? r.indexStart = 0 : r.indexStart = s.indexStart + s.indexCount), r.indexStart !== -1 && r.indexStart + r.indexCount > this._maxIndexCount || r.vertexStart + r.vertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
    const d = this._visibility, p = this._active, g = this._matricesTexture, v = this._matricesTexture.image.data;
    d.push(true), p.push(true);
    const S = this._geometryCount;
    this._geometryCount++, AW.toArray(v, S * 16), g.needsUpdate = true, o.push(r), a.push({ start: h ? r.indexStart : r.vertexStart, count: -1 }), l.push({ boxInitialized: false, box: new Wi(), sphereInitialized: false, sphere: new Ri() });
    const M = this.geometry.getAttribute(Ku);
    for (let m = 0; m < r.vertexCount; m++) M.setX(r.vertexStart + m, S);
    return M.needsUpdate = true, this.setGeometryAt(S, e), S;
  }
  setGeometryAt(e, t) {
    if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
    this._validateGeometry(t);
    const i = this.geometry, r = i.getIndex() !== null, s = i.getIndex(), o = t.getIndex(), a = this._reservedRanges[e];
    if (r && o.count > a.indexCount || t.attributes.position.count > a.vertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
    const l = a.vertexStart, f = a.vertexCount;
    for (const g in i.attributes) {
      if (g === Ku) continue;
      const v = t.getAttribute(g), S = i.getAttribute(g);
      bW(v, S, l);
      const M = v.itemSize;
      for (let m = v.count, w = f; m < w; m++) {
        const E = l + m;
        for (let A = 0; A < M; A++) S.setComponent(E, A, 0);
      }
      S.needsUpdate = true;
    }
    if (r) {
      const g = a.indexStart;
      for (let v = 0; v < o.count; v++) s.setX(g + v, l + o.getX(v));
      for (let v = o.count, S = a.indexCount; v < S; v++) s.setX(g + v, l);
      s.needsUpdate = true;
    }
    const h = this._bounds[e];
    t.boundingBox !== null ? (h.box.copy(t.boundingBox), h.boxInitialized = true) : h.boxInitialized = false, t.boundingSphere !== null ? (h.sphere.copy(t.boundingSphere), h.sphereInitialized = true) : h.sphereInitialized = false;
    const d = this._drawRanges[e], p = t.getAttribute("position");
    return d.count = r ? o.count : p.count, this._visibilityChanged = true, e;
  }
  deleteGeometry(e) {
    const t = this._active;
    return e >= t.length || t[e] === false ? this : (t[e] = false, this._visibilityChanged = true, this);
  }
  getBoundingBoxAt(e, t) {
    if (this._active[e] === false) return null;
    const r = this._bounds[e], s = r.box, o = this.geometry;
    if (r.boxInitialized === false) {
      s.makeEmpty();
      const a = o.index, l = o.attributes.position, f = this._drawRanges[e];
      for (let h = f.start, d = f.start + f.count; h < d; h++) {
        let p = h;
        a && (p = a.getX(p)), s.expandByPoint(Qf.fromBufferAttribute(l, p));
      }
      r.boxInitialized = true;
    }
    return t.copy(s), t;
  }
  getBoundingSphereAt(e, t) {
    if (this._active[e] === false) return null;
    const r = this._bounds[e], s = r.sphere, o = this.geometry;
    if (r.sphereInitialized === false) {
      s.makeEmpty(), this.getBoundingBoxAt(e, Vm), Vm.getCenter(s.center);
      const a = o.index, l = o.attributes.position, f = this._drawRanges[e];
      let h = 0;
      for (let d = f.start, p = f.start + f.count; d < p; d++) {
        let g = d;
        a && (g = a.getX(g)), Qf.fromBufferAttribute(l, g), h = Math.max(h, s.center.distanceToSquared(Qf));
      }
      s.radius = Math.sqrt(h), r.sphereInitialized = true;
    }
    return t.copy(s), t;
  }
  setMatrixAt(e, t) {
    const i = this._active, r = this._matricesTexture, s = this._matricesTexture.image.data, o = this._geometryCount;
    return e >= o || i[e] === false ? this : (t.toArray(s, e * 16), r.needsUpdate = true, this);
  }
  getMatrixAt(e, t) {
    const i = this._active, r = this._matricesTexture.image.data, s = this._geometryCount;
    return e >= s || i[e] === false ? null : t.fromArray(r, e * 16);
  }
  setVisibleAt(e, t) {
    const i = this._visibility, r = this._active, s = this._geometryCount;
    return e >= s || r[e] === false || i[e] === t ? this : (i[e] = t, this._visibilityChanged = true, this);
  }
  getVisibleAt(e) {
    const t = this._visibility, i = this._active, r = this._geometryCount;
    return e >= r || i[e] === false ? false : t[e];
  }
  raycast(e, t) {
    const i = this._visibility, r = this._active, s = this._drawRanges, o = this._geometryCount, a = this.matrixWorld, l = this.geometry;
    wi.material = this.material, wi.geometry.index = l.index, wi.geometry.attributes = l.attributes, wi.geometry.boundingBox === null && (wi.geometry.boundingBox = new Wi()), wi.geometry.boundingSphere === null && (wi.geometry.boundingSphere = new Ri());
    for (let f = 0; f < o; f++) {
      if (!i[f] || !r[f]) continue;
      const h = s[f];
      wi.geometry.setDrawRange(h.start, h.count), this.getMatrixAt(f, wi.matrixWorld).premultiply(a), this.getBoundingBoxAt(f, wi.geometry.boundingBox), this.getBoundingSphereAt(f, wi.geometry.boundingSphere), wi.raycast(e, Hm);
      for (let d = 0, p = Hm.length; d < p; d++) {
        const g = Hm[d];
        g.object = this, g.batchId = f, t.push(g);
      }
      Hm.length = 0;
    }
    wi.material = null, wi.geometry.index = null, wi.geometry.attributes = {}, wi.geometry.setDrawRange(0, 1 / 0);
  }
  copy(e) {
    return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._drawRanges = e._drawRanges.map((t) => ({ ...t })), this._reservedRanges = e._reservedRanges.map((t) => ({ ...t })), this._visibility = e._visibility.slice(), this._active = e._active.slice(), this._bounds = e._bounds.map((t) => ({ boxInitialized: t.boxInitialized, box: t.box.clone(), sphereInitialized: t.sphereInitialized, sphere: t.sphere.clone() })), this._maxGeometryCount = e._maxGeometryCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.slice(), this;
  }
  dispose() {
    return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this;
  }
  onBeforeRender(e, t, i, r, s) {
    if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
    const o = r.getIndex(), a = o === null ? 1 : o.array.BYTES_PER_ELEMENT, l = this._active, f = this._visibility, h = this._multiDrawStarts, d = this._multiDrawCounts, p = this._drawRanges, g = this.perObjectFrustumCulled;
    g && (FC.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), hx.setFromProjectionMatrix(FC, e.coordinateSystem));
    let v = 0;
    if (this.sortObjects) {
      kC.copy(this.matrixWorld).invert(), Qf.setFromMatrixPosition(i.matrixWorld).applyMatrix4(kC);
      for (let m = 0, w = f.length; m < w; m++) if (f[m] && l[m]) {
        this.getMatrixAt(m, oa), this.getBoundingSphereAt(m, al).applyMatrix4(oa);
        let E = false;
        if (g && (E = !hx.intersectsSphere(al)), !E) {
          const A = Qf.distanceTo(al.center);
          dx.push(p[m], A);
        }
      }
      const S = dx.list, M = this.customSort;
      M === null ? S.sort(s.transparent ? EW : wW) : M.call(this, S, i);
      for (let m = 0, w = S.length; m < w; m++) {
        const E = S[m];
        h[v] = E.start * a, d[v] = E.count, v++;
      }
      dx.reset();
    } else for (let S = 0, M = f.length; S < M; S++) if (f[S] && l[S]) {
      let m = false;
      if (g && (this.getMatrixAt(S, oa), this.getBoundingSphereAt(S, al).applyMatrix4(oa), m = !hx.intersectsSphere(al)), !m) {
        const w = p[S];
        h[v] = w.start * a, d[v] = w.count, v++;
      }
    }
    this._multiDrawCount = v, this._visibilityChanged = false;
  }
  onBeforeShadow(e, t, i, r, s, o) {
    this.onBeforeRender(e, null, r, s, o);
  }
}
class Yi extends Ii {
  constructor(e) {
    super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Ve(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const zC = new V(), BC = new V(), VC = new lt(), px = new uf(), Gm = new Ri();
class Ua extends Ot {
  constructor(e = new xt(), t = new Yi()) {
    super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [0];
      for (let r = 1, s = t.count; r < s; r++) zC.fromBufferAttribute(t, r - 1), BC.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += zC.distanceTo(BC);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Gm.copy(i.boundingSphere), Gm.applyMatrix4(r), Gm.radius += s, e.ray.intersectsSphere(Gm) === false) return;
    VC.copy(r).invert(), px.copy(e.ray).applyMatrix4(VC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, f = new V(), h = new V(), d = new V(), p = new V(), g = this.isLineSegments ? 2 : 1, v = i.index, M = i.attributes.position;
    if (v !== null) {
      const m = Math.max(0, o.start), w = Math.min(v.count, o.start + o.count);
      for (let E = m, A = w - 1; E < A; E += g) {
        const P = v.getX(E), R = v.getX(E + 1);
        if (f.fromBufferAttribute(M, P), h.fromBufferAttribute(M, R), px.distanceSqToSegment(f, h, p, d) > l) continue;
        p.applyMatrix4(this.matrixWorld);
        const D = e.ray.origin.distanceTo(p);
        D < e.near || D > e.far || t.push({ distance: D, point: d.clone().applyMatrix4(this.matrixWorld), index: E, face: null, faceIndex: null, object: this });
      }
    } else {
      const m = Math.max(0, o.start), w = Math.min(M.count, o.start + o.count);
      for (let E = m, A = w - 1; E < A; E += g) {
        if (f.fromBufferAttribute(M, E), h.fromBufferAttribute(M, E + 1), px.distanceSqToSegment(f, h, p, d) > l) continue;
        p.applyMatrix4(this.matrixWorld);
        const R = e.ray.origin.distanceTo(p);
        R < e.near || R > e.far || t.push({ distance: R, point: d.clone().applyMatrix4(this.matrixWorld), index: E, face: null, faceIndex: null, object: this });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
const HC = new V(), GC = new V();
class ao extends Ua {
  constructor(e, t) {
    super(e, t), this.isLineSegments = true, this.type = "LineSegments";
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position, i = [];
      for (let r = 0, s = t.count; r < s; r += 2) HC.fromBufferAttribute(t, r), GC.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + HC.distanceTo(GC);
      e.setAttribute("lineDistance", new Ye(i, 1));
    } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    return this;
  }
}
class OI extends Ua {
  constructor(e, t) {
    super(e, t), this.isLineLoop = true, this.type = "LineLoop";
  }
}
class zw extends Ii {
  constructor(e) {
    super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Ve(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const WC = new lt(), ES = new uf(), Wm = new Ri(), Xm = new V();
class UI extends Ot {
  constructor(e = new xt(), t = new zw()) {
    super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  raycast(e, t) {
    const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, o = i.drawRange;
    if (i.boundingSphere === null && i.computeBoundingSphere(), Wm.copy(i.boundingSphere), Wm.applyMatrix4(r), Wm.radius += s, e.ray.intersectsSphere(Wm) === false) return;
    WC.copy(r).invert(), ES.copy(e.ray).applyMatrix4(WC);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, f = i.index, d = i.attributes.position;
    if (f !== null) {
      const p = Math.max(0, o.start), g = Math.min(f.count, o.start + o.count);
      for (let v = p, S = g; v < S; v++) {
        const M = f.getX(v);
        Xm.fromBufferAttribute(d, M), XC(Xm, M, l, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start), g = Math.min(d.count, o.start + o.count);
      for (let v = p, S = g; v < S; v++) Xm.fromBufferAttribute(d, v), XC(Xm, v, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s;
        }
      }
    }
  }
}
function XC(n24, e, t, i, r, s, o) {
  const a = ES.distanceSqToPoint(n24);
  if (a < t) {
    const l = new V();
    ES.closestPointToPoint(n24, l), l.applyMatrix4(i);
    const f = r.ray.origin.distanceTo(l);
    if (f < r.near || f > r.far) return;
    s.push({ distance: f, distanceToRay: Math.sqrt(a), point: l, index: e, face: null, object: o });
  }
}
class CW extends Tn {
  constructor(e, t, i, r, s, o, a, l, f) {
    super(e, t, i, r, s, o, a, l, f), this.isVideoTexture = true, this.minFilter = o !== void 0 ? o : fn, this.magFilter = s !== void 0 ? s : fn, this.generateMipmaps = false;
    const h = this;
    function d() {
      h.needsUpdate = true, e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === false && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = true);
  }
}
class RW extends Tn {
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = true, this.magFilter = Pn, this.minFilter = Pn, this.generateMipmaps = false, this.needsUpdate = true;
  }
}
class O_ extends Tn {
  constructor(e, t, i, r, s, o, a, l, f, h, d, p) {
    super(null, o, a, l, f, h, r, s, d, p), this.isCompressedTexture = true, this.image = { width: t, height: i }, this.mipmaps = e, this.flipY = false, this.generateMipmaps = false;
  }
}
class PW extends O_ {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o), this.isCompressedArrayTexture = true, this.image.depth = r, this.wrapR = Ai;
  }
}
class LW extends O_ {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, Fo), this.isCompressedCubeTexture = true, this.isCubeTexture = true, this.image = e;
  }
}
class IW extends Tn {
  constructor(e, t, i, r, s, o, a, l, f) {
    super(e, t, i, r, s, o, a, l, f), this.isCanvasTexture = true, this.needsUpdate = true;
  }
}
class Cs {
  constructor() {
    this.type = "Curve", this.arcLengthDivisions = 200;
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
    this.needsUpdate = false;
    const t = [];
    let i, r = this.getPoint(0), s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++) i = this.getPoint(o / e), s += i.distanceTo(r), t.push(s), r = i;
    return this.cacheArcLengths = t, t;
  }
  updateArcLengths() {
    this.needsUpdate = true, this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? o = t : o = e * i[s - 1];
    let a = 0, l = s - 1, f;
    for (; a <= l; ) if (r = Math.floor(a + (l - a) / 2), f = i[r] - o, f < 0) a = r + 1;
    else if (f > 0) l = r - 1;
    else {
      l = r;
      break;
    }
    if (r = l, i[r] === o) return r / (s - 1);
    const h = i[r], p = i[r + 1] - h, g = (o - h) / p;
    return (r + g) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4, s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r), a = this.getPoint(s), l = t || (o.isVector2 ? new _e() : new V());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new V(), r = [], s = [], o = [], a = new V(), l = new lt();
    for (let g = 0; g <= e; g++) {
      const v = g / e;
      r[g] = this.getTangentAt(v, new V());
    }
    s[0] = new V(), o[0] = new V();
    let f = Number.MAX_VALUE;
    const h = Math.abs(r[0].x), d = Math.abs(r[0].y), p = Math.abs(r[0].z);
    h <= f && (f = h, i.set(1, 0, 0)), d <= f && (f = d, i.set(0, 1, 0)), p <= f && i.set(0, 0, 1), a.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]);
    for (let g = 1; g <= e; g++) {
      if (s[g] = s[g - 1].clone(), o[g] = o[g - 1].clone(), a.crossVectors(r[g - 1], r[g]), a.length() > Number.EPSILON) {
        a.normalize();
        const v = Math.acos(wn(r[g - 1].dot(r[g]), -1, 1));
        s[g].applyMatrix4(l.makeRotationAxis(a, v));
      }
      o[g].crossVectors(r[g], s[g]);
    }
    if (t === true) {
      let g = Math.acos(wn(s[0].dot(s[e]), -1, 1));
      g /= e, r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (g = -g);
      for (let v = 1; v <= e; v++) s[v].applyMatrix4(l.makeRotationAxis(r[v], g * v)), o[v].crossVectors(r[v], s[v]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
  toJSON() {
    const e = { metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" } };
    return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
  }
  fromJSON(e) {
    return this.arcLengthDivisions = e.arcLengthDivisions, this;
  }
}
class U_ extends Cs {
  constructor(e = 0, t = 0, i = 1, r = 1, s = 0, o = Math.PI * 2, a = false, l = 0) {
    super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l;
  }
  getPoint(e, t) {
    const i = t || new _e(), r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === true && !o && (s === r ? s = -r : s = s - r);
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a), f = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation), d = Math.sin(this.aRotation), p = l - this.aX, g = f - this.aY;
      l = p * h - g * d + this.aX, f = p * d + g * h + this.aY;
    }
    return i.set(l, f);
  }
  copy(e) {
    return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
  }
}
class kI extends U_ {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o), this.isArcCurve = true, this.type = "ArcCurve";
  }
}
function Bw() {
  let n24 = 0, e = 0, t = 0, i = 0;
  function r(s, o, a, l) {
    n24 = s, e = a, t = -3 * s + 3 * o - 2 * a - l, i = 2 * s - 2 * o + a + l;
  }
  return { initCatmullRom: function(s, o, a, l, f) {
    r(o, a, f * (a - s), f * (l - o));
  }, initNonuniformCatmullRom: function(s, o, a, l, f, h, d) {
    let p = (o - s) / f - (a - s) / (f + h) + (a - o) / h, g = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
    p *= h, g *= h, r(o, a, p, g);
  }, calc: function(s) {
    const o = s * s, a = o * s;
    return n24 + e * s + t * o + i * a;
  } };
}
const jm = new V(), mx = new Bw(), gx = new Bw(), _x = new Bw();
class FI extends Cs {
  constructor(e = [], t = false, i = "centripetal", r = 0.5) {
    super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
  }
  getPoint(e, t = new V()) {
    const i = t, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o), l = o - a;
    this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
    let f, h;
    this.closed || a > 0 ? f = r[(a - 1) % s] : (jm.subVectors(r[0], r[1]).add(r[0]), f = jm);
    const d = r[a % s], p = r[(a + 1) % s];
    if (this.closed || a + 2 < s ? h = r[(a + 2) % s] : (jm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), h = jm), this.curveType === "centripetal" || this.curveType === "chordal") {
      const g = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(f.distanceToSquared(d), g), S = Math.pow(d.distanceToSquared(p), g), M = Math.pow(p.distanceToSquared(h), g);
      S < 1e-4 && (S = 1), v < 1e-4 && (v = S), M < 1e-4 && (M = S), mx.initNonuniformCatmullRom(f.x, d.x, p.x, h.x, v, S, M), gx.initNonuniformCatmullRom(f.y, d.y, p.y, h.y, v, S, M), _x.initNonuniformCatmullRom(f.z, d.z, p.z, h.z, v, S, M);
    } else this.curveType === "catmullrom" && (mx.initCatmullRom(f.x, d.x, p.x, h.x, this.tension), gx.initCatmullRom(f.y, d.y, p.y, h.y, this.tension), _x.initCatmullRom(f.z, d.z, p.z, h.z, this.tension));
    return i.set(mx.calc(l), gx.calc(l), _x.calc(l)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new V().fromArray(r));
    }
    return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
  }
}
function jC(n24, e, t, i, r) {
  const s = (i - e) * 0.5, o = (r - t) * 0.5, a = n24 * n24, l = n24 * a;
  return (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n24 + t;
}
function NW(n24, e) {
  const t = 1 - n24;
  return t * t * e;
}
function DW(n24, e) {
  return 2 * (1 - n24) * n24 * e;
}
function OW(n24, e) {
  return n24 * n24 * e;
}
function Ah(n24, e, t, i) {
  return NW(n24, e) + DW(n24, t) + OW(n24, i);
}
function UW(n24, e) {
  const t = 1 - n24;
  return t * t * t * e;
}
function kW(n24, e) {
  const t = 1 - n24;
  return 3 * t * t * n24 * e;
}
function FW(n24, e) {
  return 3 * (1 - n24) * n24 * n24 * e;
}
function zW(n24, e) {
  return n24 * n24 * n24 * e;
}
function bh(n24, e, t, i, r) {
  return UW(n24, e) + kW(n24, t) + FW(n24, i) + zW(n24, r);
}
class Vw extends Cs {
  constructor(e = new _e(), t = new _e(), i = new _e(), r = new _e()) {
    super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new _e()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(bh(e, r.x, s.x, o.x, a.x), bh(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class zI extends Cs {
  constructor(e = new V(), t = new V(), i = new V(), r = new V()) {
    super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
  }
  getPoint(e, t = new V()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2, a = this.v3;
    return i.set(bh(e, r.x, s.x, o.x, a.x), bh(e, r.y, s.y, o.y, a.y), bh(e, r.z, s.z, o.z, a.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
  }
}
class Hw extends Cs {
  constructor(e = new _e(), t = new _e()) {
    super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new _e()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new _e()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class BI extends Cs {
  constructor(e = new V(), t = new V()) {
    super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
  }
  getPoint(e, t = new V()) {
    const i = t;
    return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new V()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Gw extends Cs {
  constructor(e = new _e(), t = new _e(), i = new _e()) {
    super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new _e()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(Ah(e, r.x, s.x, o.x), Ah(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Ww extends Cs {
  constructor(e = new V(), t = new V(), i = new V()) {
    super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
  }
  getPoint(e, t = new V()) {
    const i = t, r = this.v0, s = this.v1, o = this.v2;
    return i.set(Ah(e, r.x, s.x, o.x), Ah(e, r.y, s.y, o.y), Ah(e, r.z, s.z, o.z)), i;
  }
  copy(e) {
    return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
  }
}
class Xw extends Cs {
  constructor(e = []) {
    super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
  }
  getPoint(e, t = new _e()) {
    const i = t, r = this.points, s = (r.length - 1) * e, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], f = r[o], h = r[o > r.length - 2 ? r.length - 1 : o + 1], d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(jC(a, l.x, f.x, h.x, d.x), jC(a, l.y, f.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.points = [];
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new _e().fromArray(r));
    }
    return this;
  }
}
var g0 = Object.freeze({ __proto__: null, ArcCurve: kI, CatmullRomCurve3: FI, CubicBezierCurve: Vw, CubicBezierCurve3: zI, EllipseCurve: U_, LineCurve: Hw, LineCurve3: BI, QuadraticBezierCurve: Gw, QuadraticBezierCurve3: Ww, SplineCurve: Xw });
class VI extends Cs {
  constructor() {
    super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
    if (!e.equals(t)) {
      const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new g0[i](t, e));
    }
    return this;
  }
  getPoint(e, t) {
    const i = e * this.getLength(), r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i, a = this.curves[s], l = a.getLength(), f = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(f, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++) t += this.curves[i].getLength(), e.push(t);
    return this.cacheLengths = e, e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r], a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e, l = o.getPoints(a);
      for (let f = 0; f < l.length; f++) {
        const h = l[f];
        i && i.equals(h) || (t.push(h), i = h);
      }
    }
    return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
  }
  copy(e) {
    super.copy(e), this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return this.autoClose = e.autoClose, this;
  }
  toJSON() {
    const e = super.toJSON();
    e.autoClose = this.autoClose, e.curves = [];
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new g0[r.type]().fromJSON(r));
    }
    return this;
  }
}
class hd extends VI {
  constructor(e) {
    super(), this.type = "Path", this.currentPoint = new _e(), e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Hw(this.currentPoint.clone(), new _e(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new Gw(this.currentPoint.clone(), new _e(e, t), new _e(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new Vw(this.currentPoint.clone(), new _e(e, t), new _e(i, r), new _e(s, o));
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e), i = new Xw(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x, l = this.currentPoint.y;
    return this.absarc(e + a, t + l, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const f = this.currentPoint.x, h = this.currentPoint.y;
    return this.absellipse(e + f, t + h, i, r, s, o, a, l), this;
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const f = new U_(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = f.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(f);
    const h = f.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.currentPoint = this.currentPoint.toArray(), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class jd extends xt {
  constructor(e = [new _e(0, -0.5), new _e(0.5, 0), new _e(0, 0.5)], t = 12, i = 0, r = Math.PI * 2) {
    super(), this.type = "LatheGeometry", this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }, t = Math.floor(t), r = wn(r, 0, Math.PI * 2);
    const s = [], o = [], a = [], l = [], f = [], h = 1 / t, d = new V(), p = new _e(), g = new V(), v = new V(), S = new V();
    let M = 0, m = 0;
    for (let w = 0; w <= e.length - 1; w++) switch (w) {
      case 0:
        M = e[w + 1].x - e[w].x, m = e[w + 1].y - e[w].y, g.x = m * 1, g.y = -M, g.z = m * 0, S.copy(g), g.normalize(), l.push(g.x, g.y, g.z);
        break;
      case e.length - 1:
        l.push(S.x, S.y, S.z);
        break;
      default:
        M = e[w + 1].x - e[w].x, m = e[w + 1].y - e[w].y, g.x = m * 1, g.y = -M, g.z = m * 0, v.copy(g), g.x += S.x, g.y += S.y, g.z += S.z, g.normalize(), l.push(g.x, g.y, g.z), S.copy(v);
    }
    for (let w = 0; w <= t; w++) {
      const E = i + w * h * r, A = Math.sin(E), P = Math.cos(E);
      for (let R = 0; R <= e.length - 1; R++) {
        d.x = e[R].x * A, d.y = e[R].y, d.z = e[R].x * P, o.push(d.x, d.y, d.z), p.x = w / t, p.y = R / (e.length - 1), a.push(p.x, p.y);
        const L = l[3 * R + 0] * A, D = l[3 * R + 1], F = l[3 * R + 0] * P;
        f.push(L, D, F);
      }
    }
    for (let w = 0; w < t; w++) for (let E = 0; E < e.length - 1; E++) {
      const A = E + w * e.length, P = A, R = A + e.length, L = A + e.length + 1, D = A + 1;
      s.push(P, R, D), s.push(L, D, R);
    }
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("uv", new Ye(a, 2)), this.setAttribute("normal", new Ye(f, 3));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new jd(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class k_ extends jd {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new hd();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * 0.5), super(s.getPoints(i), r), this.type = "CapsuleGeometry", this.parameters = { radius: e, length: t, capSegments: i, radialSegments: r };
  }
  static fromJSON(e) {
    return new k_(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class F_ extends xt {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(), this.type = "CircleGeometry", this.parameters = { radius: e, segments: t, thetaStart: i, thetaLength: r }, t = Math.max(3, t);
    const s = [], o = [], a = [], l = [], f = new V(), h = new _e();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const g = i + d / t * r;
      f.x = e * Math.cos(g), f.y = e * Math.sin(g), o.push(f.x, f.y, f.z), a.push(0, 0, 1), h.x = (o[p] / e + 1) / 2, h.y = (o[p + 1] / e + 1) / 2, l.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s), this.setAttribute("position", new Ye(o, 3)), this.setAttribute("normal", new Ye(a, 3)), this.setAttribute("uv", new Ye(l, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new F_(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class ff extends xt {
  constructor(e = 1, t = 1, i = 1, r = 32, s = 1, o = false, a = 0, l = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: e, radiusBottom: t, height: i, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l };
    const f = this;
    r = Math.floor(r), s = Math.floor(s);
    const h = [], d = [], p = [], g = [];
    let v = 0;
    const S = [], M = i / 2;
    let m = 0;
    w(), o === false && (e > 0 && E(true), t > 0 && E(false)), this.setIndex(h), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(p, 3)), this.setAttribute("uv", new Ye(g, 2));
    function w() {
      const A = new V(), P = new V();
      let R = 0;
      const L = (t - e) / i;
      for (let D = 0; D <= s; D++) {
        const F = [], C = D / s, N = C * (t - e) + e;
        for (let j = 0; j <= r; j++) {
          const Z = j / r, G = Z * l + a, J = Math.sin(G), q = Math.cos(G);
          P.x = N * J, P.y = -C * i + M, P.z = N * q, d.push(P.x, P.y, P.z), A.set(J, L, q).normalize(), p.push(A.x, A.y, A.z), g.push(Z, 1 - C), F.push(v++);
        }
        S.push(F);
      }
      for (let D = 0; D < r; D++) for (let F = 0; F < s; F++) {
        const C = S[F][D], N = S[F + 1][D], j = S[F + 1][D + 1], Z = S[F][D + 1];
        h.push(C, N, Z), h.push(N, j, Z), R += 6;
      }
      f.addGroup(m, R, 0), m += R;
    }
    function E(A) {
      const P = v, R = new _e(), L = new V();
      let D = 0;
      const F = A === true ? e : t, C = A === true ? 1 : -1;
      for (let j = 1; j <= r; j++) d.push(0, M * C, 0), p.push(0, C, 0), g.push(0.5, 0.5), v++;
      const N = v;
      for (let j = 0; j <= r; j++) {
        const G = j / r * l + a, J = Math.cos(G), q = Math.sin(G);
        L.x = F * q, L.y = M * C, L.z = F * J, d.push(L.x, L.y, L.z), p.push(0, C, 0), R.x = J * 0.5 + 0.5, R.y = q * 0.5 * C + 0.5, g.push(R.x, R.y), v++;
      }
      for (let j = 0; j < r; j++) {
        const Z = P + j, G = N + j;
        A === true ? h.push(G, G + 1, Z) : h.push(G + 1, G, Z), D += 3;
      }
      f.addGroup(m, D, A === true ? 1 : 2), m += D;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new ff(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class z_ extends ff {
  constructor(e = 1, t = 1, i = 32, r = 1, s = false, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: e, height: t, radialSegments: i, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a };
  }
  static fromJSON(e) {
    return new z_(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class Xa extends xt {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: e, indices: t, radius: i, detail: r };
    const s = [], o = [];
    a(r), f(i), h(), this.setAttribute("position", new Ye(s, 3)), this.setAttribute("normal", new Ye(s.slice(), 3)), this.setAttribute("uv", new Ye(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(w) {
      const E = new V(), A = new V(), P = new V();
      for (let R = 0; R < t.length; R += 3) g(t[R + 0], E), g(t[R + 1], A), g(t[R + 2], P), l(E, A, P, w);
    }
    function l(w, E, A, P) {
      const R = P + 1, L = [];
      for (let D = 0; D <= R; D++) {
        L[D] = [];
        const F = w.clone().lerp(A, D / R), C = E.clone().lerp(A, D / R), N = R - D;
        for (let j = 0; j <= N; j++) j === 0 && D === R ? L[D][j] = F : L[D][j] = F.clone().lerp(C, j / N);
      }
      for (let D = 0; D < R; D++) for (let F = 0; F < 2 * (R - D) - 1; F++) {
        const C = Math.floor(F / 2);
        F % 2 === 0 ? (p(L[D][C + 1]), p(L[D + 1][C]), p(L[D][C])) : (p(L[D][C + 1]), p(L[D + 1][C + 1]), p(L[D + 1][C]));
      }
    }
    function f(w) {
      const E = new V();
      for (let A = 0; A < s.length; A += 3) E.x = s[A + 0], E.y = s[A + 1], E.z = s[A + 2], E.normalize().multiplyScalar(w), s[A + 0] = E.x, s[A + 1] = E.y, s[A + 2] = E.z;
    }
    function h() {
      const w = new V();
      for (let E = 0; E < s.length; E += 3) {
        w.x = s[E + 0], w.y = s[E + 1], w.z = s[E + 2];
        const A = M(w) / 2 / Math.PI + 0.5, P = m(w) / Math.PI + 0.5;
        o.push(A, 1 - P);
      }
      v(), d();
    }
    function d() {
      for (let w = 0; w < o.length; w += 6) {
        const E = o[w + 0], A = o[w + 2], P = o[w + 4], R = Math.max(E, A, P), L = Math.min(E, A, P);
        R > 0.9 && L < 0.1 && (E < 0.2 && (o[w + 0] += 1), A < 0.2 && (o[w + 2] += 1), P < 0.2 && (o[w + 4] += 1));
      }
    }
    function p(w) {
      s.push(w.x, w.y, w.z);
    }
    function g(w, E) {
      const A = w * 3;
      E.x = e[A + 0], E.y = e[A + 1], E.z = e[A + 2];
    }
    function v() {
      const w = new V(), E = new V(), A = new V(), P = new V(), R = new _e(), L = new _e(), D = new _e();
      for (let F = 0, C = 0; F < s.length; F += 9, C += 6) {
        w.set(s[F + 0], s[F + 1], s[F + 2]), E.set(s[F + 3], s[F + 4], s[F + 5]), A.set(s[F + 6], s[F + 7], s[F + 8]), R.set(o[C + 0], o[C + 1]), L.set(o[C + 2], o[C + 3]), D.set(o[C + 4], o[C + 5]), P.copy(w).add(E).add(A).divideScalar(3);
        const N = M(P);
        S(R, C + 0, w, N), S(L, C + 2, E, N), S(D, C + 4, A, N);
      }
    }
    function S(w, E, A, P) {
      P < 0 && w.x === 1 && (o[E] = w.x - 1), A.x === 0 && A.z === 0 && (o[E] = P / 2 / Math.PI + 0.5);
    }
    function M(w) {
      return Math.atan2(w.z, -w.x);
    }
    function m(w) {
      return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Xa(e.vertices, e.indices, e.radius, e.details);
  }
}
class B_ extends Xa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = 1 / i, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, -r, -i, 0, -r, i, 0, r, -i, 0, r, i, 0, -i, 0, -r, i, 0, -r, -i, 0, r, i, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
    super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new B_(e.radius, e.detail);
  }
}
const $m = new V(), Ym = new V(), vx = new V(), qm = new wr();
class HI extends xt {
  constructor(e = null, t = 1) {
    if (super(), this.type = "EdgesGeometry", this.parameters = { geometry: e, thresholdAngle: t }, e !== null) {
      const r = Math.pow(10, 4), s = Math.cos(Ol * t), o = e.getIndex(), a = e.getAttribute("position"), l = o ? o.count : a.count, f = [0, 0, 0], h = ["a", "b", "c"], d = new Array(3), p = {}, g = [];
      for (let v = 0; v < l; v += 3) {
        o ? (f[0] = o.getX(v), f[1] = o.getX(v + 1), f[2] = o.getX(v + 2)) : (f[0] = v, f[1] = v + 1, f[2] = v + 2);
        const { a: S, b: M, c: m } = qm;
        if (S.fromBufferAttribute(a, f[0]), M.fromBufferAttribute(a, f[1]), m.fromBufferAttribute(a, f[2]), qm.getNormal(vx), d[0] = `${Math.round(S.x * r)},${Math.round(S.y * r)},${Math.round(S.z * r)}`, d[1] = `${Math.round(M.x * r)},${Math.round(M.y * r)},${Math.round(M.z * r)}`, d[2] = `${Math.round(m.x * r)},${Math.round(m.y * r)},${Math.round(m.z * r)}`, !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0])) for (let w = 0; w < 3; w++) {
          const E = (w + 1) % 3, A = d[w], P = d[E], R = qm[h[w]], L = qm[h[E]], D = `${A}_${P}`, F = `${P}_${A}`;
          F in p && p[F] ? (vx.dot(p[F].normal) <= s && (g.push(R.x, R.y, R.z), g.push(L.x, L.y, L.z)), p[F] = null) : D in p || (p[D] = { index0: f[w], index1: f[E], normal: vx.clone() });
        }
      }
      for (const v in p) if (p[v]) {
        const { index0: S, index1: M } = p[v];
        $m.fromBufferAttribute(a, S), Ym.fromBufferAttribute(a, M), g.push($m.x, $m.y, $m.z), g.push(Ym.x, Ym.y, Ym.z);
      }
      this.setAttribute("position", new Ye(g, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
class zl extends hd {
  constructor(e) {
    super(e), this.uuid = Rr(), this.type = "Shape", this.holes = [];
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.uuid = this.uuid, e.holes = [];
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new hd().fromJSON(r));
    }
    return this;
  }
}
const BW = { triangulate: function(n24, e, t = 2) {
  const i = e && e.length, r = i ? e[0] * t : n24.length;
  let s = GI(n24, 0, r, t, true);
  const o = [];
  if (!s || s.next === s.prev) return o;
  let a, l, f, h, d, p, g;
  if (i && (s = XW(n24, e, s, t)), n24.length > 80 * t) {
    a = f = n24[0], l = h = n24[1];
    for (let v = t; v < r; v += t) d = n24[v], p = n24[v + 1], d < a && (a = d), p < l && (l = p), d > f && (f = d), p > h && (h = p);
    g = Math.max(f - a, h - l), g = g !== 0 ? 32767 / g : 0;
  }
  return dd(s, o, t, a, l, g, 0), o;
} };
function GI(n24, e, t, i, r) {
  let s, o;
  if (r === n9(n24, e, t, i) > 0) for (s = e; s < t; s += i) o = $C(s, n24[s], n24[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = $C(s, n24[s], n24[s + 1], o);
  return o && V_(o, o.next) && (md(o), o = o.next), o;
}
function Jl(n24, e) {
  if (!n24) return n24;
  e || (e = n24);
  let t = n24, i;
  do
    if (i = false, !t.steiner && (V_(t, t.next) || dn(t.prev, t, t.next) === 0)) {
      if (md(t), t = e = t.prev, t === t.next) break;
      i = true;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function dd(n24, e, t, i, r, s, o) {
  if (!n24) return;
  !o && s && KW(n24, i, r, s);
  let a = n24, l, f;
  for (; n24.prev !== n24.next; ) {
    if (l = n24.prev, f = n24.next, s ? HW(n24, i, r, s) : VW(n24)) {
      e.push(l.i / t | 0), e.push(n24.i / t | 0), e.push(f.i / t | 0), md(n24), n24 = f.next, a = f.next;
      continue;
    }
    if (n24 = f, n24 === a) {
      o ? o === 1 ? (n24 = GW(Jl(n24), e, t), dd(n24, e, t, i, r, s, 2)) : o === 2 && WW(n24, e, t, i, r, s) : dd(Jl(n24), e, t, i, r, s, 1);
      break;
    }
  }
}
function VW(n24) {
  const e = n24.prev, t = n24, i = n24.next;
  if (dn(e, t, i) >= 0) return false;
  const r = e.x, s = t.x, o = i.x, a = e.y, l = t.y, f = i.y, h = r < s ? r < o ? r : o : s < o ? s : o, d = a < l ? a < f ? a : f : l < f ? l : f, p = r > s ? r > o ? r : o : s > o ? s : o, g = a > l ? a > f ? a : f : l > f ? l : f;
  let v = i.next;
  for (; v !== e; ) {
    if (v.x >= h && v.x <= p && v.y >= d && v.y <= g && vc(r, a, s, l, o, f, v.x, v.y) && dn(v.prev, v, v.next) >= 0) return false;
    v = v.next;
  }
  return true;
}
function HW(n24, e, t, i) {
  const r = n24.prev, s = n24, o = n24.next;
  if (dn(r, s, o) >= 0) return false;
  const a = r.x, l = s.x, f = o.x, h = r.y, d = s.y, p = o.y, g = a < l ? a < f ? a : f : l < f ? l : f, v = h < d ? h < p ? h : p : d < p ? d : p, S = a > l ? a > f ? a : f : l > f ? l : f, M = h > d ? h > p ? h : p : d > p ? d : p, m = TS(g, v, e, t, i), w = TS(S, M, e, t, i);
  let E = n24.prevZ, A = n24.nextZ;
  for (; E && E.z >= m && A && A.z <= w; ) {
    if (E.x >= g && E.x <= S && E.y >= v && E.y <= M && E !== r && E !== o && vc(a, h, l, d, f, p, E.x, E.y) && dn(E.prev, E, E.next) >= 0 || (E = E.prevZ, A.x >= g && A.x <= S && A.y >= v && A.y <= M && A !== r && A !== o && vc(a, h, l, d, f, p, A.x, A.y) && dn(A.prev, A, A.next) >= 0)) return false;
    A = A.nextZ;
  }
  for (; E && E.z >= m; ) {
    if (E.x >= g && E.x <= S && E.y >= v && E.y <= M && E !== r && E !== o && vc(a, h, l, d, f, p, E.x, E.y) && dn(E.prev, E, E.next) >= 0) return false;
    E = E.prevZ;
  }
  for (; A && A.z <= w; ) {
    if (A.x >= g && A.x <= S && A.y >= v && A.y <= M && A !== r && A !== o && vc(a, h, l, d, f, p, A.x, A.y) && dn(A.prev, A, A.next) >= 0) return false;
    A = A.nextZ;
  }
  return true;
}
function GW(n24, e, t) {
  let i = n24;
  do {
    const r = i.prev, s = i.next.next;
    !V_(r, s) && WI(r, i, i.next, s) && pd(r, s) && pd(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), md(i), md(i.next), i = n24 = s), i = i.next;
  } while (i !== n24);
  return Jl(i);
}
function WW(n24, e, t, i, r, s) {
  let o = n24;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && QW(o, a)) {
        let l = XI(o, a);
        o = Jl(o, o.next), l = Jl(l, l.next), dd(o, e, t, i, r, s, 0), dd(l, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n24);
}
function XW(n24, e, t, i) {
  const r = [];
  let s, o, a, l, f;
  for (s = 0, o = e.length; s < o; s++) a = e[s] * i, l = s < o - 1 ? e[s + 1] * i : n24.length, f = GI(n24, a, l, i, false), f === f.next && (f.steiner = true), r.push(JW(f));
  for (r.sort(jW), s = 0; s < r.length; s++) t = $W(r[s], t);
  return t;
}
function jW(n24, e) {
  return n24.x - e.x;
}
function $W(n24, e) {
  const t = YW(n24, e);
  if (!t) return e;
  const i = XI(t, n24);
  return Jl(i, i.next), Jl(t, t.next);
}
function YW(n24, e) {
  let t = e, i = -1 / 0, r;
  const s = n24.x, o = n24.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
      if (p <= s && p > i && (i = p, r = t.x < t.next.x ? t : t.next, p === s)) return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r, l = r.x, f = r.y;
  let h = 1 / 0, d;
  t = r;
  do
    s >= t.x && t.x >= l && s !== t.x && vc(o < f ? s : i, o, l, f, o < f ? i : s, o, t.x, t.y) && (d = Math.abs(o - t.y) / (s - t.x), pd(t, n24) && (d < h || d === h && (t.x > r.x || t.x === r.x && qW(r, t))) && (r = t, h = d)), t = t.next;
  while (t !== a);
  return r;
}
function qW(n24, e) {
  return dn(n24.prev, n24, e.prev) < 0 && dn(e.next, n24, n24.next) < 0;
}
function KW(n24, e, t, i) {
  let r = n24;
  do
    r.z === 0 && (r.z = TS(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
  while (r !== n24);
  r.prevZ.nextZ = null, r.prevZ = null, ZW(r);
}
function ZW(n24) {
  let e, t, i, r, s, o, a, l, f = 1;
  do {
    for (t = n24, n24 = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < f && (a++, i = i.nextZ, !!i); e++) ;
      for (l = f; a > 0 || l > 0 && i; ) a !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, a--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n24 = r, r.prevZ = s, s = r;
      t = i;
    }
    s.nextZ = null, f *= 2;
  } while (o > 1);
  return n24;
}
function TS(n24, e, t, i, r) {
  return n24 = (n24 - t) * r | 0, e = (e - i) * r | 0, n24 = (n24 | n24 << 8) & 16711935, n24 = (n24 | n24 << 4) & 252645135, n24 = (n24 | n24 << 2) & 858993459, n24 = (n24 | n24 << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n24 | e << 1;
}
function JW(n24) {
  let e = n24, t = n24;
  do
    (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
  while (e !== n24);
  return t;
}
function vc(n24, e, t, i, r, s, o, a) {
  return (r - o) * (e - a) >= (n24 - o) * (s - a) && (n24 - o) * (i - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (r - o) * (i - a);
}
function QW(n24, e) {
  return n24.next.i !== e.i && n24.prev.i !== e.i && !e9(n24, e) && (pd(n24, e) && pd(e, n24) && t9(n24, e) && (dn(n24.prev, n24, e.prev) || dn(n24, e.prev, e)) || V_(n24, e) && dn(n24.prev, n24, n24.next) > 0 && dn(e.prev, e, e.next) > 0);
}
function dn(n24, e, t) {
  return (e.y - n24.y) * (t.x - e.x) - (e.x - n24.x) * (t.y - e.y);
}
function V_(n24, e) {
  return n24.x === e.x && n24.y === e.y;
}
function WI(n24, e, t, i) {
  const r = Zm(dn(n24, e, t)), s = Zm(dn(n24, e, i)), o = Zm(dn(t, i, n24)), a = Zm(dn(t, i, e));
  return !!(r !== s && o !== a || r === 0 && Km(n24, t, e) || s === 0 && Km(n24, i, e) || o === 0 && Km(t, n24, i) || a === 0 && Km(t, e, i));
}
function Km(n24, e, t) {
  return e.x <= Math.max(n24.x, t.x) && e.x >= Math.min(n24.x, t.x) && e.y <= Math.max(n24.y, t.y) && e.y >= Math.min(n24.y, t.y);
}
function Zm(n24) {
  return n24 > 0 ? 1 : n24 < 0 ? -1 : 0;
}
function e9(n24, e) {
  let t = n24;
  do {
    if (t.i !== n24.i && t.next.i !== n24.i && t.i !== e.i && t.next.i !== e.i && WI(t, t.next, n24, e)) return true;
    t = t.next;
  } while (t !== n24);
  return false;
}
function pd(n24, e) {
  return dn(n24.prev, n24, n24.next) < 0 ? dn(n24, e, n24.next) >= 0 && dn(n24, n24.prev, e) >= 0 : dn(n24, e, n24.prev) < 0 || dn(n24, n24.next, e) < 0;
}
function t9(n24, e) {
  let t = n24, i = false;
  const r = (n24.x + e.x) / 2, s = (n24.y + e.y) / 2;
  do
    t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
  while (t !== n24);
  return i;
}
function XI(n24, e) {
  const t = new AS(n24.i, n24.x, n24.y), i = new AS(e.i, e.x, e.y), r = n24.next, s = e.prev;
  return n24.next = e, e.prev = n24, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
}
function $C(n24, e, t, i) {
  const r = new AS(n24, e, t);
  return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
}
function md(n24) {
  n24.next.prev = n24.prev, n24.prev.next = n24.next, n24.prevZ && (n24.prevZ.nextZ = n24.nextZ), n24.nextZ && (n24.nextZ.prevZ = n24.prevZ);
}
function AS(n24, e, t) {
  this.i = n24, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
}
function n9(n24, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i) r += (n24[o] - n24[s]) * (n24[s + 1] + n24[o + 1]), o = s;
  return r;
}
class no {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return no.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [], r = [], s = [];
    YC(e), qC(i, e);
    let o = e.length;
    t.forEach(YC);
    for (let l = 0; l < t.length; l++) r.push(o), o += t[l].length, qC(i, t[l]);
    const a = BW.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function YC(n24) {
  const e = n24.length;
  e > 2 && n24[e - 1].equals(n24[0]) && n24.pop();
}
function qC(n24, e) {
  for (let t = 0; t < e.length; t++) n24.push(e[t].x), n24.push(e[t].y);
}
class H_ extends xt {
  constructor(e = new zl([new _e(0.5, 0.5), new _e(-0.5, 0.5), new _e(-0.5, -0.5), new _e(0.5, -0.5)]), t = {}) {
    super(), this.type = "ExtrudeGeometry", this.parameters = { shapes: e, options: t }, e = Array.isArray(e) ? e : [e];
    const i = this, r = [], s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const f = e[a];
      o(f);
    }
    this.setAttribute("position", new Ye(r, 3)), this.setAttribute("uv", new Ye(s, 2)), this.computeVertexNormals();
    function o(a) {
      const l = [], f = t.curveSegments !== void 0 ? t.curveSegments : 12, h = t.steps !== void 0 ? t.steps : 1, d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, g = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, v = t.bevelSize !== void 0 ? t.bevelSize : g - 0.1, S = t.bevelOffset !== void 0 ? t.bevelOffset : 0, M = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const m = t.extrudePath, w = t.UVGenerator !== void 0 ? t.UVGenerator : i9;
      let E, A = false, P, R, L, D;
      m && (E = m.getSpacedPoints(h), A = true, p = false, P = m.computeFrenetFrames(h, false), R = new V(), L = new V(), D = new V()), p || (M = 0, g = 0, v = 0, S = 0);
      const F = a.extractPoints(f);
      let C = F.shape;
      const N = F.holes;
      if (!no.isClockWise(C)) {
        C = C.reverse();
        for (let X = 0, Se = N.length; X < Se; X++) {
          const pe = N[X];
          no.isClockWise(pe) && (N[X] = pe.reverse());
        }
      }
      const Z = no.triangulateShape(C, N), G = C;
      for (let X = 0, Se = N.length; X < Se; X++) {
        const pe = N[X];
        C = C.concat(pe);
      }
      function J(X, Se, pe) {
        return Se || console.error("THREE.ExtrudeGeometry: vec does not exist"), X.clone().addScaledVector(Se, pe);
      }
      const q = C.length, ae = Z.length;
      function B(X, Se, pe) {
        let we, me, qe;
        const Ne = X.x - Se.x, U = X.y - Se.y, O = pe.x - X.x, ie = pe.y - X.y, xe = Ne * Ne + U * U, ve = Ne * ie - U * O;
        if (Math.abs(ve) > Number.EPSILON) {
          const ge = Math.sqrt(xe), ze = Math.sqrt(O * O + ie * ie), Le = Se.x - U / ge, ke = Se.y + Ne / ge, et = pe.x - ie / ze, Re = pe.y + O / ze, ye = ((et - Le) * ie - (Re - ke) * O) / (Ne * ie - U * O);
          we = Le + Ne * ye - X.x, me = ke + U * ye - X.y;
          const bt = we * we + me * me;
          if (bt <= 2) return new _e(we, me);
          qe = Math.sqrt(bt / 2);
        } else {
          let ge = false;
          Ne > Number.EPSILON ? O > Number.EPSILON && (ge = true) : Ne < -Number.EPSILON ? O < -Number.EPSILON && (ge = true) : Math.sign(U) === Math.sign(ie) && (ge = true), ge ? (we = -U, me = Ne, qe = Math.sqrt(xe)) : (we = Ne, me = U, qe = Math.sqrt(xe / 2));
        }
        return new _e(we / qe, me / qe);
      }
      const Y = [];
      for (let X = 0, Se = G.length, pe = Se - 1, we = X + 1; X < Se; X++, pe++, we++) pe === Se && (pe = 0), we === Se && (we = 0), Y[X] = B(G[X], G[pe], G[we]);
      const $ = [];
      let ee, ue = Y.concat();
      for (let X = 0, Se = N.length; X < Se; X++) {
        const pe = N[X];
        ee = [];
        for (let we = 0, me = pe.length, qe = me - 1, Ne = we + 1; we < me; we++, qe++, Ne++) qe === me && (qe = 0), Ne === me && (Ne = 0), ee[we] = B(pe[we], pe[qe], pe[Ne]);
        $.push(ee), ue = ue.concat(ee);
      }
      for (let X = 0; X < M; X++) {
        const Se = X / M, pe = g * Math.cos(Se * Math.PI / 2), we = v * Math.sin(Se * Math.PI / 2) + S;
        for (let me = 0, qe = G.length; me < qe; me++) {
          const Ne = J(G[me], Y[me], we);
          Ie(Ne.x, Ne.y, -pe);
        }
        for (let me = 0, qe = N.length; me < qe; me++) {
          const Ne = N[me];
          ee = $[me];
          for (let U = 0, O = Ne.length; U < O; U++) {
            const ie = J(Ne[U], ee[U], we);
            Ie(ie.x, ie.y, -pe);
          }
        }
      }
      const Ae = v + S;
      for (let X = 0; X < q; X++) {
        const Se = p ? J(C[X], ue[X], Ae) : C[X];
        A ? (L.copy(P.normals[0]).multiplyScalar(Se.x), R.copy(P.binormals[0]).multiplyScalar(Se.y), D.copy(E[0]).add(L).add(R), Ie(D.x, D.y, D.z)) : Ie(Se.x, Se.y, 0);
      }
      for (let X = 1; X <= h; X++) for (let Se = 0; Se < q; Se++) {
        const pe = p ? J(C[Se], ue[Se], Ae) : C[Se];
        A ? (L.copy(P.normals[X]).multiplyScalar(pe.x), R.copy(P.binormals[X]).multiplyScalar(pe.y), D.copy(E[X]).add(L).add(R), Ie(D.x, D.y, D.z)) : Ie(pe.x, pe.y, d / h * X);
      }
      for (let X = M - 1; X >= 0; X--) {
        const Se = X / M, pe = g * Math.cos(Se * Math.PI / 2), we = v * Math.sin(Se * Math.PI / 2) + S;
        for (let me = 0, qe = G.length; me < qe; me++) {
          const Ne = J(G[me], Y[me], we);
          Ie(Ne.x, Ne.y, d + pe);
        }
        for (let me = 0, qe = N.length; me < qe; me++) {
          const Ne = N[me];
          ee = $[me];
          for (let U = 0, O = Ne.length; U < O; U++) {
            const ie = J(Ne[U], ee[U], we);
            A ? Ie(ie.x, ie.y + E[h - 1].y, E[h - 1].x + pe) : Ie(ie.x, ie.y, d + pe);
          }
        }
      }
      te(), de();
      function te() {
        const X = r.length / 3;
        if (p) {
          let Se = 0, pe = q * Se;
          for (let we = 0; we < ae; we++) {
            const me = Z[we];
            Ze(me[2] + pe, me[1] + pe, me[0] + pe);
          }
          Se = h + M * 2, pe = q * Se;
          for (let we = 0; we < ae; we++) {
            const me = Z[we];
            Ze(me[0] + pe, me[1] + pe, me[2] + pe);
          }
        } else {
          for (let Se = 0; Se < ae; Se++) {
            const pe = Z[Se];
            Ze(pe[2], pe[1], pe[0]);
          }
          for (let Se = 0; Se < ae; Se++) {
            const pe = Z[Se];
            Ze(pe[0] + q * h, pe[1] + q * h, pe[2] + q * h);
          }
        }
        i.addGroup(X, r.length / 3 - X, 0);
      }
      function de() {
        const X = r.length / 3;
        let Se = 0;
        Ee(G, Se), Se += G.length;
        for (let pe = 0, we = N.length; pe < we; pe++) {
          const me = N[pe];
          Ee(me, Se), Se += me.length;
        }
        i.addGroup(X, r.length / 3 - X, 1);
      }
      function Ee(X, Se) {
        let pe = X.length;
        for (; --pe >= 0; ) {
          const we = pe;
          let me = pe - 1;
          me < 0 && (me = X.length - 1);
          for (let qe = 0, Ne = h + M * 2; qe < Ne; qe++) {
            const U = q * qe, O = q * (qe + 1), ie = Se + we + U, xe = Se + me + U, ve = Se + me + O, ge = Se + we + O;
            Oe(ie, xe, ve, ge);
          }
        }
      }
      function Ie(X, Se, pe) {
        l.push(X), l.push(Se), l.push(pe);
      }
      function Ze(X, Se, pe) {
        at(X), at(Se), at(pe);
        const we = r.length / 3, me = w.generateTopUV(i, r, we - 3, we - 2, we - 1);
        Ge(me[0]), Ge(me[1]), Ge(me[2]);
      }
      function Oe(X, Se, pe, we) {
        at(X), at(Se), at(we), at(Se), at(pe), at(we);
        const me = r.length / 3, qe = w.generateSideWallUV(i, r, me - 6, me - 3, me - 2, me - 1);
        Ge(qe[0]), Ge(qe[1]), Ge(qe[3]), Ge(qe[1]), Ge(qe[2]), Ge(qe[3]);
      }
      function at(X) {
        r.push(l[X * 3 + 0]), r.push(l[X * 3 + 1]), r.push(l[X * 3 + 2]);
      }
      function Ge(X) {
        s.push(X.x), s.push(X.y);
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
    return r9(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return r !== void 0 && (e.options.extrudePath = new g0[r.type]().fromJSON(r)), new H_(i, e.options);
  }
}
const i9 = { generateTopUV: function(n24, e, t, i, r) {
  const s = e[t * 3], o = e[t * 3 + 1], a = e[i * 3], l = e[i * 3 + 1], f = e[r * 3], h = e[r * 3 + 1];
  return [new _e(s, o), new _e(a, l), new _e(f, h)];
}, generateSideWallUV: function(n24, e, t, i, r, s) {
  const o = e[t * 3], a = e[t * 3 + 1], l = e[t * 3 + 2], f = e[i * 3], h = e[i * 3 + 1], d = e[i * 3 + 2], p = e[r * 3], g = e[r * 3 + 1], v = e[r * 3 + 2], S = e[s * 3], M = e[s * 3 + 1], m = e[s * 3 + 2];
  return Math.abs(a - h) < Math.abs(o - f) ? [new _e(o, 1 - l), new _e(f, 1 - d), new _e(p, 1 - v), new _e(S, 1 - m)] : [new _e(a, 1 - l), new _e(h, 1 - d), new _e(g, 1 - v), new _e(M, 1 - m)];
} };
function r9(n24, e, t) {
  if (t.shapes = [], Array.isArray(n24)) for (let i = 0, r = n24.length; i < r; i++) {
    const s = n24[i];
    t.shapes.push(s.uuid);
  }
  else t.shapes.push(n24.uuid);
  return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
}
class G_ extends Xa {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2, r = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
    super(r, s, e, t), this.type = "IcosahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new G_(e.radius, e.detail);
  }
}
class $d extends Xa {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], r = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
    super(i, r, e, t), this.type = "OctahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new $d(e.radius, e.detail);
  }
}
class W_ extends xt {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(), this.type = "RingGeometry", this.parameters = { innerRadius: e, outerRadius: t, thetaSegments: i, phiSegments: r, thetaStart: s, thetaLength: o }, i = Math.max(3, i), r = Math.max(1, r);
    const a = [], l = [], f = [], h = [];
    let d = e;
    const p = (t - e) / r, g = new V(), v = new _e();
    for (let S = 0; S <= r; S++) {
      for (let M = 0; M <= i; M++) {
        const m = s + M / i * o;
        g.x = d * Math.cos(m), g.y = d * Math.sin(m), l.push(g.x, g.y, g.z), f.push(0, 0, 1), v.x = (g.x / t + 1) / 2, v.y = (g.y / t + 1) / 2, h.push(v.x, v.y);
      }
      d += p;
    }
    for (let S = 0; S < r; S++) {
      const M = S * (i + 1);
      for (let m = 0; m < i; m++) {
        const w = m + M, E = w, A = w + i + 1, P = w + i + 2, R = w + 1;
        a.push(E, A, R), a.push(A, P, R);
      }
    }
    this.setIndex(a), this.setAttribute("position", new Ye(l, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new W_(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength);
  }
}
class X_ extends xt {
  constructor(e = new zl([new _e(0, 0.5), new _e(-0.5, -0.5), new _e(0.5, -0.5)]), t = 12) {
    super(), this.type = "ShapeGeometry", this.parameters = { shapes: e, curveSegments: t };
    const i = [], r = [], s = [], o = [];
    let a = 0, l = 0;
    if (Array.isArray(e) === false) f(e);
    else for (let h = 0; h < e.length; h++) f(e[h]), this.addGroup(a, l, h), a += l, l = 0;
    this.setIndex(i), this.setAttribute("position", new Ye(r, 3)), this.setAttribute("normal", new Ye(s, 3)), this.setAttribute("uv", new Ye(o, 2));
    function f(h) {
      const d = r.length / 3, p = h.extractPoints(t);
      let g = p.shape;
      const v = p.holes;
      no.isClockWise(g) === false && (g = g.reverse());
      for (let M = 0, m = v.length; M < m; M++) {
        const w = v[M];
        no.isClockWise(w) === true && (v[M] = w.reverse());
      }
      const S = no.triangulateShape(g, v);
      for (let M = 0, m = v.length; M < m; M++) {
        const w = v[M];
        g = g.concat(w);
      }
      for (let M = 0, m = g.length; M < m; M++) {
        const w = g[M];
        r.push(w.x, w.y, 0), s.push(0, 0, 1), o.push(w.x, w.y);
      }
      for (let M = 0, m = S.length; M < m; M++) {
        const w = S[M], E = w[0] + d, A = w[1] + d, P = w[2] + d;
        i.push(E, A, P), l += 3;
      }
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON(), t = this.parameters.shapes;
    return s9(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new X_(i, e.curveSegments);
  }
}
function s9(n24, e) {
  if (e.shapes = [], Array.isArray(n24)) for (let t = 0, i = n24.length; t < i; t++) {
    const r = n24[t];
    e.shapes.push(r.uuid);
  }
  else e.shapes.push(n24.uuid);
  return e;
}
class Yd extends xt {
  constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = { radius: e, widthSegments: t, heightSegments: i, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
    const l = Math.min(o + a, Math.PI);
    let f = 0;
    const h = [], d = new V(), p = new V(), g = [], v = [], S = [], M = [];
    for (let m = 0; m <= i; m++) {
      const w = [], E = m / i;
      let A = 0;
      m === 0 && o === 0 ? A = 0.5 / t : m === i && l === Math.PI && (A = -0.5 / t);
      for (let P = 0; P <= t; P++) {
        const R = P / t;
        d.x = -e * Math.cos(r + R * s) * Math.sin(o + E * a), d.y = e * Math.cos(o + E * a), d.z = e * Math.sin(r + R * s) * Math.sin(o + E * a), v.push(d.x, d.y, d.z), p.copy(d).normalize(), S.push(p.x, p.y, p.z), M.push(R + A, 1 - E), w.push(f++);
      }
      h.push(w);
    }
    for (let m = 0; m < i; m++) for (let w = 0; w < t; w++) {
      const E = h[m][w + 1], A = h[m][w], P = h[m + 1][w], R = h[m + 1][w + 1];
      (m !== 0 || o > 0) && g.push(E, A, R), (m !== i - 1 || l < Math.PI) && g.push(A, P, R);
    }
    this.setIndex(g), this.setAttribute("position", new Ye(v, 3)), this.setAttribute("normal", new Ye(S, 3)), this.setAttribute("uv", new Ye(M, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Yd(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
class j_ extends Xa {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t), this.type = "TetrahedronGeometry", this.parameters = { radius: e, detail: t };
  }
  static fromJSON(e) {
    return new j_(e.radius, e.detail);
  }
}
class $_ extends xt {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(), this.type = "TorusGeometry", this.parameters = { radius: e, tube: t, radialSegments: i, tubularSegments: r, arc: s }, i = Math.floor(i), r = Math.floor(r);
    const o = [], a = [], l = [], f = [], h = new V(), d = new V(), p = new V();
    for (let g = 0; g <= i; g++) for (let v = 0; v <= r; v++) {
      const S = v / r * s, M = g / i * Math.PI * 2;
      d.x = (e + t * Math.cos(M)) * Math.cos(S), d.y = (e + t * Math.cos(M)) * Math.sin(S), d.z = t * Math.sin(M), a.push(d.x, d.y, d.z), h.x = e * Math.cos(S), h.y = e * Math.sin(S), p.subVectors(d, h).normalize(), l.push(p.x, p.y, p.z), f.push(v / r), f.push(g / i);
    }
    for (let g = 1; g <= i; g++) for (let v = 1; v <= r; v++) {
      const S = (r + 1) * g + v - 1, M = (r + 1) * (g - 1) + v - 1, m = (r + 1) * (g - 1) + v, w = (r + 1) * g + v;
      o.push(S, M, w), o.push(M, m, w);
    }
    this.setIndex(o), this.setAttribute("position", new Ye(a, 3)), this.setAttribute("normal", new Ye(l, 3)), this.setAttribute("uv", new Ye(f, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new $_(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Y_ extends xt {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(), this.type = "TorusKnotGeometry", this.parameters = { radius: e, tube: t, tubularSegments: i, radialSegments: r, p: s, q: o }, i = Math.floor(i), r = Math.floor(r);
    const a = [], l = [], f = [], h = [], d = new V(), p = new V(), g = new V(), v = new V(), S = new V(), M = new V(), m = new V();
    for (let E = 0; E <= i; ++E) {
      const A = E / i * s * Math.PI * 2;
      w(A, s, o, e, g), w(A + 0.01, s, o, e, v), M.subVectors(v, g), m.addVectors(v, g), S.crossVectors(M, m), m.crossVectors(S, M), S.normalize(), m.normalize();
      for (let P = 0; P <= r; ++P) {
        const R = P / r * Math.PI * 2, L = -t * Math.cos(R), D = t * Math.sin(R);
        d.x = g.x + (L * m.x + D * S.x), d.y = g.y + (L * m.y + D * S.y), d.z = g.z + (L * m.z + D * S.z), l.push(d.x, d.y, d.z), p.subVectors(d, g).normalize(), f.push(p.x, p.y, p.z), h.push(E / i), h.push(P / r);
      }
    }
    for (let E = 1; E <= i; E++) for (let A = 1; A <= r; A++) {
      const P = (r + 1) * (E - 1) + (A - 1), R = (r + 1) * E + (A - 1), L = (r + 1) * E + A, D = (r + 1) * (E - 1) + A;
      a.push(P, R, D), a.push(R, L, D);
    }
    this.setIndex(a), this.setAttribute("position", new Ye(l, 3)), this.setAttribute("normal", new Ye(f, 3)), this.setAttribute("uv", new Ye(h, 2));
    function w(E, A, P, R, L) {
      const D = Math.cos(E), F = Math.sin(E), C = P / A * E, N = Math.cos(C);
      L.x = R * (2 + N) * 0.5 * D, L.y = R * (2 + N) * F * 0.5, L.z = R * Math.sin(C) * 0.5;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  static fromJSON(e) {
    return new Y_(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q);
  }
}
class q_ extends xt {
  constructor(e = new Ww(new V(-1, -1, 0), new V(-1, 1, 0), new V(1, 1, 0)), t = 64, i = 1, r = 8, s = false) {
    super(), this.type = "TubeGeometry", this.parameters = { path: e, tubularSegments: t, radius: i, radialSegments: r, closed: s };
    const o = e.computeFrenetFrames(t, s);
    this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
    const a = new V(), l = new V(), f = new _e();
    let h = new V();
    const d = [], p = [], g = [], v = [];
    S(), this.setIndex(v), this.setAttribute("position", new Ye(d, 3)), this.setAttribute("normal", new Ye(p, 3)), this.setAttribute("uv", new Ye(g, 2));
    function S() {
      for (let E = 0; E < t; E++) M(E);
      M(s === false ? t : 0), w(), m();
    }
    function M(E) {
      h = e.getPointAt(E / t, h);
      const A = o.normals[E], P = o.binormals[E];
      for (let R = 0; R <= r; R++) {
        const L = R / r * Math.PI * 2, D = Math.sin(L), F = -Math.cos(L);
        l.x = F * A.x + D * P.x, l.y = F * A.y + D * P.y, l.z = F * A.z + D * P.z, l.normalize(), p.push(l.x, l.y, l.z), a.x = h.x + i * l.x, a.y = h.y + i * l.y, a.z = h.z + i * l.z, d.push(a.x, a.y, a.z);
      }
    }
    function m() {
      for (let E = 1; E <= t; E++) for (let A = 1; A <= r; A++) {
        const P = (r + 1) * (E - 1) + (A - 1), R = (r + 1) * E + (A - 1), L = (r + 1) * E + A, D = (r + 1) * (E - 1) + A;
        v.push(P, R, D), v.push(R, L, D);
      }
    }
    function w() {
      for (let E = 0; E <= t; E++) for (let A = 0; A <= r; A++) f.x = E / t, f.y = A / r, g.push(f.x, f.y);
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.path = this.parameters.path.toJSON(), e;
  }
  static fromJSON(e) {
    return new q_(new g0[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed);
  }
}
class jI extends xt {
  constructor(e = null) {
    if (super(), this.type = "WireframeGeometry", this.parameters = { geometry: e }, e !== null) {
      const t = [], i = /* @__PURE__ */ new Set(), r = new V(), s = new V();
      if (e.index !== null) {
        const o = e.attributes.position, a = e.index;
        let l = e.groups;
        l.length === 0 && (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let f = 0, h = l.length; f < h; ++f) {
          const d = l[f], p = d.start, g = d.count;
          for (let v = p, S = p + g; v < S; v += 3) for (let M = 0; M < 3; M++) {
            const m = a.getX(v + M), w = a.getX(v + (M + 1) % 3);
            r.fromBufferAttribute(o, m), s.fromBufferAttribute(o, w), KC(r, s, i) === true && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++) for (let f = 0; f < 3; f++) {
          const h = 3 * a + f, d = 3 * a + (f + 1) % 3;
          r.fromBufferAttribute(o, h), s.fromBufferAttribute(o, d), KC(r, s, i) === true && (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
        }
      }
      this.setAttribute("position", new Ye(t, 3));
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
}
function KC(n24, e, t) {
  const i = `${n24.x},${n24.y},${n24.z}-${e.x},${e.y},${e.z}`, r = `${e.x},${e.y},${e.z}-${n24.x},${n24.y},${n24.z}`;
  return t.has(i) === true || t.has(r) === true ? false : (t.add(i), t.add(r), true);
}
var ZC = Object.freeze({ __proto__: null, BoxGeometry: nu, CapsuleGeometry: k_, CircleGeometry: F_, ConeGeometry: z_, CylinderGeometry: ff, DodecahedronGeometry: B_, EdgesGeometry: HI, ExtrudeGeometry: H_, IcosahedronGeometry: G_, LatheGeometry: jd, OctahedronGeometry: $d, PlaneGeometry: iu, PolyhedronGeometry: Xa, RingGeometry: W_, ShapeGeometry: X_, SphereGeometry: Yd, TetrahedronGeometry: j_, TorusGeometry: $_, TorusKnotGeometry: Y_, TubeGeometry: q_, WireframeGeometry: jI });
class $I extends Ii {
  constructor(e) {
    super(), this.isShadowMaterial = true, this.type = "ShadowMaterial", this.color = new Ve(0), this.transparent = true, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
class YI extends bs {
  constructor(e) {
    super(e), this.isRawShaderMaterial = true, this.type = "RawShaderMaterial";
  }
}
class jw extends Ii {
  constructor(e) {
    super(), this.isMeshStandardMaterial = true, this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new Ve(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class qI extends jw {
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = true, this.defines = { STANDARD: "", PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new _e(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", { get: function() {
      return wn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
    }, set: function(t) {
      this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
    } }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new Ve(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ve(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ve(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "", PHYSICAL: "" }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
class KI extends Ii {
  constructor(e) {
    super(), this.isMeshPhongMaterial = true, this.type = "MeshPhongMaterial", this.color = new Ve(16777215), this.specular = new Ve(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class ZI extends Ii {
  constructor(e) {
    super(), this.isMeshToonMaterial = true, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new Ve(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
class JI extends Ii {
  constructor(e) {
    super(), this.isMeshNormalMaterial = true, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.flatShading = false, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
class QI extends Ii {
  constructor(e) {
    super(), this.isMeshLambertMaterial = true, this.type = "MeshLambertMaterial", this.color = new Ve(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ve(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = zd, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class eN extends Ii {
  constructor(e) {
    super(), this.isMeshMatcapMaterial = true, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new Ve(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ga, this.normalScale = new _e(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = false, this.fog = true, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
class tN extends Yi {
  constructor(e) {
    super(), this.isLineDashedMaterial = true, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
function Rl(n24, e, t) {
  return !n24 || !t && n24.constructor === e ? n24 : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n24) : Array.prototype.slice.call(n24);
}
function nN(n24) {
  return ArrayBuffer.isView(n24) && !(n24 instanceof DataView);
}
function iN(n24) {
  function e(r, s) {
    return n24[r] - n24[s];
  }
  const t = n24.length, i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function bS(n24, e, t) {
  const i = n24.length, r = new n24.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n24[a + l];
  }
  return r;
}
function $w(n24, e, t, i) {
  let r = 1, s = n24[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n24[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0) if (Array.isArray(o)) do
    o = s[i], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = n24[r++];
  while (s !== void 0);
  else if (o.toArray !== void 0) do
    o = s[i], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = n24[r++];
  while (s !== void 0);
  else do
    o = s[i], o !== void 0 && (e.push(s.time), t.push(o)), s = n24[r++];
  while (s !== void 0);
}
function o9(n24, e, t, i, r = 30) {
  const s = n24.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const f = s.tracks[l], h = f.getValueSize(), d = [], p = [];
    for (let g = 0; g < f.times.length; ++g) {
      const v = f.times[g] * r;
      if (!(v < t || v >= i)) {
        d.push(f.times[g]);
        for (let S = 0; S < h; ++S) p.push(f.values[g * h + S]);
      }
    }
    d.length !== 0 && (f.times = Rl(d, f.times.constructor), f.values = Rl(p, f.values.constructor), o.push(f));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function a9(n24, e = 0, t = n24, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length, s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o], l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const f = n24.tracks.find(function(m) {
      return m.name === a.name && m.ValueTypeName === l;
    });
    if (f === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (h = d / 3);
    let p = 0;
    const g = f.getValueSize();
    f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (p = g / 3);
    const v = a.times.length - 1;
    let S;
    if (s <= a.times[0]) {
      const m = h, w = d - h;
      S = a.values.slice(m, w);
    } else if (s >= a.times[v]) {
      const m = v * d + h, w = m + d - h;
      S = a.values.slice(m, w);
    } else {
      const m = a.createInterpolant(), w = h, E = d - h;
      m.evaluate(s), S = m.resultBuffer.slice(w, E);
    }
    l === "quaternion" && new rr().fromArray(S).normalize().conjugate().toArray(S);
    const M = f.times.length;
    for (let m = 0; m < M; ++m) {
      const w = m * g + p;
      if (l === "quaternion") rr.multiplyQuaternionsFlat(f.values, w, S, 0, f.values, w);
      else {
        const E = g - p * 2;
        for (let A = 0; A < E; ++A) f.values[w + A] -= S[A];
      }
    }
  }
  return n24.blendMode = ww, n24;
}
const l9 = { convertArray: Rl, isTypedArray: nN, getKeyframeOrder: iN, sortedArray: bS, flattenJSON: $w, subclip: o9, makeClipAdditive: a9 };
class qd {
  constructor(e, t, i, r) {
    this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex, r = t[i], s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
              }
              if (i === a) break;
              if (s = r, r = t[++i], e < r) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && (i = 2, s = a);
            for (let l = i - 2; ; ) {
              if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (i === l) break;
              if (r = s, s = t[--i - 1], e >= s) break t;
            }
            o = i, i = 0;
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = i + o >>> 1;
          e < t[a] ? o = a : i = a + 1;
        }
        if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
        if (r === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
      }
      this._cachedIndex = i, this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
}
class rN extends qd {
  constructor(e, t, i, r) {
    super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: Al, endingEnd: Al };
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2, o = e + 1, a = r[s], l = r[o];
    if (a === void 0) switch (this.getSettings_().endingStart) {
      case bl:
        s = e, a = 2 * t - i;
        break;
      case sd:
        s = r.length - 2, a = t + r[s] - r[s + 1];
        break;
      default:
        s = e, a = i;
    }
    if (l === void 0) switch (this.getSettings_().endingEnd) {
      case bl:
        o = e, l = 2 * i - t;
        break;
      case sd:
        o = 1, l = i + r[1] - r[0];
        break;
      default:
        o = e - 1, l = t;
    }
    const f = (i - t) * 0.5, h = this.valueSize;
    this._weightPrev = f / (t - a), this._weightNext = f / (l - i), this._offsetPrev = s * h, this._offsetNext = o * h;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, f = l - a, h = this._offsetPrev, d = this._offsetNext, p = this._weightPrev, g = this._weightNext, v = (i - t) / (r - t), S = v * v, M = S * v, m = -p * M + 2 * p * S - p * v, w = (1 + p) * M + (-1.5 - 2 * p) * S + (-0.5 + p) * v + 1, E = (-1 - g) * M + (1.5 + g) * S + 0.5 * v, A = g * M - g * S;
    for (let P = 0; P !== a; ++P) s[P] = m * o[h + P] + w * o[f + P] + E * o[l + P] + A * o[d + P];
    return s;
  }
}
class Yw extends qd {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = e * a, f = l - a, h = (i - t) / (r - t), d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[f + p] * d + o[l + p] * h;
    return s;
  }
}
class sN extends qd {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class Rs {
  constructor(e, t, i, r) {
    if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    this.name = e, this.times = Rl(t, this.TimeBufferType), this.values = Rl(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = { name: e.name, times: Rl(e.times, Array), values: Rl(e.values, Array) };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return i.type = e.ValueTypeName, i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new sN(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Yw(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new rN(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case id:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case rd:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Pg:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
      else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return this.createInterpolant = t, this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return id;
      case this.InterpolantFactoryMethodLinear:
        return rd;
      case this.InterpolantFactoryMethodSmooth:
        return Pg;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times, r = i.length;
    let s = 0, o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if (++o, s !== 0 || o !== r) {
      s >= o && (o = Math.max(o, 1), s = o - 1);
      const a = this.getValueSize();
      this.times = i.slice(s, o), this.values = this.values.slice(s * a, o * a);
    }
    return this;
  }
  validate() {
    let e = true;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
    const i = this.times, r = this.values, s = i.length;
    s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = false;
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = false;
        break;
      }
      o = l;
    }
    if (r !== void 0 && nN(r)) for (let a = 0, l = r.length; a !== l; ++a) {
      const f = r[a];
      if (isNaN(f)) {
        console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, f), e = false;
        break;
      }
    }
    return e;
  }
  optimize() {
    const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), r = this.getInterpolation() === Pg, s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = false;
      const f = e[a], h = e[a + 1];
      if (f !== h && (a !== 1 || f !== e[0])) if (r) l = true;
      else {
        const d = a * i, p = d - i, g = d + i;
        for (let v = 0; v !== i; ++v) {
          const S = t[d + v];
          if (S !== t[p + v] || S !== t[g + v]) {
            l = true;
            break;
          }
        }
      }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i, p = o * i;
          for (let g = 0; g !== i; ++g) t[p + g] = t[d + g];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, f = 0; f !== i; ++f) t[l + f] = t[a + f];
      ++o;
    }
    return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * i)) : (this.times = e, this.values = t), this;
  }
  clone() {
    const e = this.times.slice(), t = this.values.slice(), i = this.constructor, r = new i(this.name, e, t);
    return r.createInterpolant = this.createInterpolant, r;
  }
}
Rs.prototype.TimeBufferType = Float32Array;
Rs.prototype.ValueBufferType = Float32Array;
Rs.prototype.DefaultInterpolation = rd;
class ru extends Rs {
}
ru.prototype.ValueTypeName = "bool";
ru.prototype.ValueBufferType = Array;
ru.prototype.DefaultInterpolation = id;
ru.prototype.InterpolantFactoryMethodLinear = void 0;
ru.prototype.InterpolantFactoryMethodSmooth = void 0;
class qw extends Rs {
}
qw.prototype.ValueTypeName = "color";
class gd extends Rs {
}
gd.prototype.ValueTypeName = "number";
class oN extends qd {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (i - t) / (r - t);
    let f = e * a;
    for (let h = f + a; f !== h; f += 4) rr.slerpFlat(s, 0, o, f - a, o, f, l);
    return s;
  }
}
class hf extends Rs {
  InterpolantFactoryMethodLinear(e) {
    return new oN(this.times, this.values, this.getValueSize(), e);
  }
}
hf.prototype.ValueTypeName = "quaternion";
hf.prototype.DefaultInterpolation = rd;
hf.prototype.InterpolantFactoryMethodSmooth = void 0;
class su extends Rs {
}
su.prototype.ValueTypeName = "string";
su.prototype.ValueBufferType = Array;
su.prototype.DefaultInterpolation = id;
su.prototype.InterpolantFactoryMethodLinear = void 0;
su.prototype.InterpolantFactoryMethodSmooth = void 0;
class _d extends Rs {
}
_d.prototype.ValueTypeName = "vector";
class vd {
  constructor(e, t = -1, i, r = b_) {
    this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Rr(), this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [], i = e.tracks, r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(c9(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return s.uuid = e.uuid, s;
  }
  static toJSON(e) {
    const t = [], i = e.tracks, r = { name: e.name, duration: e.duration, tracks: t, uuid: e.uuid, blendMode: e.blendMode };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(Rs.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length, o = [];
    for (let a = 0; a < s; a++) {
      let l = [], f = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), f.push(0, 1, 0);
      const h = iN(l);
      l = bS(l, 1, h), f = bS(f, 1, h), !r && l[0] === 0 && (l.push(s), f.push(f[0])), o.push(new gd(".morphTargetInfluences[" + t[a].name + "]", l, f).scale(1 / i));
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = r.geometry && r.geometry.animations || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {}, s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const f = e[a], h = f.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(f);
      }
    }
    const o = [];
    for (const a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
    const i = function(d, p, g, v, S) {
      if (g.length !== 0) {
        const M = [], m = [];
        $w(g, M, m, v), M.length !== 0 && S.push(new d(p, M, m));
      }
    }, r = [], s = e.name || "default", o = e.fps || 30, a = e.blendMode;
    let l = e.length || -1;
    const f = e.hierarchy || [];
    for (let d = 0; d < f.length; d++) {
      const p = f[d].keys;
      if (!(!p || p.length === 0)) if (p[0].morphTargets) {
        const g = {};
        let v;
        for (v = 0; v < p.length; v++) if (p[v].morphTargets) for (let S = 0; S < p[v].morphTargets.length; S++) g[p[v].morphTargets[S]] = -1;
        for (const S in g) {
          const M = [], m = [];
          for (let w = 0; w !== p[v].morphTargets.length; ++w) {
            const E = p[v];
            M.push(E.time), m.push(E.morphTarget === S ? 1 : 0);
          }
          r.push(new gd(".morphTargetInfluence[" + S + "]", M, m));
        }
        l = g.length * o;
      } else {
        const g = ".bones[" + t[d].name + "]";
        i(_d, g + ".position", p, "pos", r), i(hf, g + ".quaternion", p, "rot", r), i(_d, g + ".scale", p, "scl", r);
      }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return this.duration = t, this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = true;
    for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function u9(n24) {
  switch (n24.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return gd;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return _d;
    case "color":
      return qw;
    case "quaternion":
      return hf;
    case "bool":
    case "boolean":
      return ru;
    case "string":
      return su;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n24);
}
function c9(n24) {
  if (n24.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = u9(n24.type);
  if (n24.times === void 0) {
    const t = [], i = [];
    $w(n24.keys, t, i, "value"), n24.times = t, n24.values = i;
  }
  return e.parse !== void 0 ? e.parse(n24) : new e(n24.name, n24.times, n24.values, n24.interpolation);
}
const Ro = { enabled: false, files: {}, add: function(n24, e) {
  this.enabled !== false && (this.files[n24] = e);
}, get: function(n24) {
  if (this.enabled !== false) return this.files[n24];
}, remove: function(n24) {
  delete this.files[n24];
}, clear: function() {
  this.files = {};
} };
class Kw {
  constructor(e, t, i) {
    const r = this;
    let s = false, o = 0, a = 0, l;
    const f = [];
    this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(h) {
      a++, s === false && r.onStart !== void 0 && r.onStart(h, o, a), s = true;
    }, this.itemEnd = function(h) {
      o++, r.onProgress !== void 0 && r.onProgress(h, o, a), o === a && (s = false, r.onLoad !== void 0 && r.onLoad());
    }, this.itemError = function(h) {
      r.onError !== void 0 && r.onError(h);
    }, this.resolveURL = function(h) {
      return l ? l(h) : h;
    }, this.setURLModifier = function(h) {
      return l = h, this;
    }, this.addHandler = function(h, d) {
      return f.push(h, d), this;
    }, this.removeHandler = function(h) {
      const d = f.indexOf(h);
      return d !== -1 && f.splice(d, 2), this;
    }, this.getHandler = function(h) {
      for (let d = 0, p = f.length; d < p; d += 2) {
        const g = f[d], v = f[d + 1];
        if (g.global && (g.lastIndex = 0), g.test(h)) return v;
      }
      return null;
    };
  }
}
const aN = new Kw();
class fr {
  constructor(e) {
    this.manager = e !== void 0 ? e : aN, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
  }
  load() {
  }
  loadAsync(e, t) {
    const i = this;
    return new Promise(function(r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {
  }
  setCrossOrigin(e) {
    return this.crossOrigin = e, this;
  }
  setWithCredentials(e) {
    return this.withCredentials = e, this;
  }
  setPath(e) {
    return this.path = e, this;
  }
  setResourcePath(e) {
    return this.resourcePath = e, this;
  }
  setRequestHeader(e) {
    return this.requestHeader = e, this;
  }
}
fr.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const xo = {};
class f9 extends Error {
  constructor(e, t) {
    super(e), this.response = t;
  }
}
class zo extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = Ro.get(e);
    if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
      t && t(s), this.manager.itemEnd(e);
    }, 0), s;
    if (xo[e] !== void 0) {
      xo[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    xo[e] = [], xo[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType;
    fetch(o).then((f) => {
      if (f.status === 200 || f.status === 0) {
        if (f.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || f.body === void 0 || f.body.getReader === void 0) return f;
        const h = xo[e], d = f.body.getReader(), p = f.headers.get("Content-Length") || f.headers.get("X-File-Size"), g = p ? parseInt(p) : 0, v = g !== 0;
        let S = 0;
        const M = new ReadableStream({ start(m) {
          w();
          function w() {
            d.read().then(({ done: E, value: A }) => {
              if (E) m.close();
              else {
                S += A.byteLength;
                const P = new ProgressEvent("progress", { lengthComputable: v, loaded: S, total: g });
                for (let R = 0, L = h.length; R < L; R++) {
                  const D = h[R];
                  D.onProgress && D.onProgress(P);
                }
                m.enqueue(A), w();
              }
            });
          }
        } });
        return new Response(M);
      } else throw new f9(`fetch for "${f.url}" responded with ${f.status}: ${f.statusText}`, f);
    }).then((f) => {
      switch (l) {
        case "arraybuffer":
          return f.arrayBuffer();
        case "blob":
          return f.blob();
        case "document":
          return f.text().then((h) => new DOMParser().parseFromString(h, a));
        case "json":
          return f.json();
        default:
          if (a === void 0) return f.text();
          {
            const d = /charset="?([^;"\s]*)"?/i.exec(a), p = d && d[1] ? d[1].toLowerCase() : void 0, g = new TextDecoder(p);
            return f.arrayBuffer().then((v) => g.decode(v));
          }
      }
    }).then((f) => {
      Ro.add(e, f);
      const h = xo[e];
      delete xo[e];
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        g.onLoad && g.onLoad(f);
      }
    }).catch((f) => {
      const h = xo[e];
      if (h === void 0) throw this.manager.itemError(e), f;
      delete xo[e];
      for (let d = 0, p = h.length; d < p; d++) {
        const g = h[d];
        g.onError && g.onError(f);
      }
      this.manager.itemError(e);
    }).finally(() => {
      this.manager.itemEnd(e);
    }), this.manager.itemStart(e);
  }
  setResponseType(e) {
    return this.responseType = e, this;
  }
  setMimeType(e) {
    return this.mimeType = e, this;
  }
}
class h9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new zo(this.manager);
    o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = vd.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class d9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = [], a = new O_(), l = new zo(this.manager);
    l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
    let f = 0;
    function h(d) {
      l.load(e[d], function(p) {
        const g = s.parse(p, true);
        o[d] = { width: g.width, height: g.height, format: g.format, mipmaps: g.mipmaps }, f += 1, f === 6 && (g.mipmapCount === 1 && (a.minFilter = fn), a.image = o, a.format = g.format, a.needsUpdate = true, t && t(a));
      }, i, r);
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else l.load(e, function(d) {
      const p = s.parse(d, true);
      if (p.isCubemap) {
        const g = p.mipmaps.length / p.mipmapCount;
        for (let v = 0; v < g; v++) {
          o[v] = { mipmaps: [] };
          for (let S = 0; S < p.mipmapCount; S++) o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + S]), o[v].format = p.format, o[v].width = p.width, o[v].height = p.height;
        }
        a.image = o;
      } else a.image.width = p.width, a.image.height = p.height, a.mipmaps = p.mipmaps;
      p.mipmapCount === 1 && (a.minFilter = fn), a.format = p.format, a.needsUpdate = true, t && t(a);
    }, i, r);
    return a;
  }
}
class yd extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = Ro.get(e);
    if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
      t && t(o), s.manager.itemEnd(e);
    }, 0), o;
    const a = fd("img");
    function l() {
      h(), Ro.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function f(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, false), a.removeEventListener("error", f, false);
    }
    return a.addEventListener("load", l, false), a.addEventListener("error", f, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a;
  }
}
class p9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Gd();
    s.colorSpace = Xn;
    const o = new yd(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(f) {
      o.load(e[f], function(h) {
        s.images[f] = h, a++, a === 6 && (s.needsUpdate = true, t && t(s));
      }, void 0, r);
    }
    for (let f = 0; f < e.length; ++f) l(f);
    return s;
  }
}
class m9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new Fl(), a = new zo(this.manager);
    return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
      let f;
      try {
        f = s.parse(l);
      } catch (h) {
        if (r !== void 0) r(h);
        else {
          console.error(h);
          return;
        }
      }
      f.image !== void 0 ? o.image = f.image : f.data !== void 0 && (o.image.width = f.width, o.image.height = f.height, o.image.data = f.data), o.wrapS = f.wrapS !== void 0 ? f.wrapS : Ai, o.wrapT = f.wrapT !== void 0 ? f.wrapT : Ai, o.magFilter = f.magFilter !== void 0 ? f.magFilter : fn, o.minFilter = f.minFilter !== void 0 ? f.minFilter : fn, o.anisotropy = f.anisotropy !== void 0 ? f.anisotropy : 1, f.colorSpace !== void 0 ? o.colorSpace = f.colorSpace : f.encoding !== void 0 && (o.encoding = f.encoding), f.flipY !== void 0 && (o.flipY = f.flipY), f.format !== void 0 && (o.format = f.format), f.type !== void 0 && (o.type = f.type), f.mipmaps !== void 0 && (o.mipmaps = f.mipmaps, o.minFilter = $s), f.mipmapCount === 1 && (o.minFilter = fn), f.generateMipmaps !== void 0 && (o.generateMipmaps = f.generateMipmaps), o.needsUpdate = true, t && t(o, f);
    }, i, r), o;
  }
}
class g9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Tn(), o = new yd(this.manager);
    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
      s.image = a, s.needsUpdate = true, t !== void 0 && t(s);
    }, i, r), s;
  }
}
class ja extends Ot {
  constructor(e, t = 1) {
    super(), this.isLight = true, this.type = "Light", this.color = new Ve(e), this.intensity = t;
  }
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), t;
  }
}
class lN extends ja {
  constructor(e, t, i) {
    super(e, i), this.isHemisphereLight = true, this.type = "HemisphereLight", this.position.copy(Ot.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Ve(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const yx = new lt(), JC = new V(), QC = new V();
class Zw {
  constructor(e) {
    this.camera = e, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new _e(512, 512), this.map = null, this.mapPass = null, this.matrix = new lt(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Wd(), this._frameExtents = new _e(1, 1), this._viewportCount = 1, this._viewports = [new Gt(0, 0, 1, 1)];
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera, i = this.matrix;
    JC.setFromMatrixPosition(e.matrixWorld), t.position.copy(JC), QC.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(QC), t.updateMatrixWorld(), yx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(yx), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(yx);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return this.camera = e.camera.clone(), this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
  }
}
class _9 extends Zw {
  constructor() {
    super(new ni(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
  }
  updateMatrices(e) {
    const t = this.camera, i = Gc * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class uN extends ja {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Ot.DEFAULT_UP), this.updateMatrix(), this.target = new Ot(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new _9();
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
const e2 = new lt(), eh = new V(), xx = new V();
class v9 extends Zw {
  constructor() {
    super(new ni(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new _e(4, 2), this._viewportCount = 6, this._viewports = [new Gt(2, 1, 1, 1), new Gt(0, 1, 1, 1), new Gt(3, 1, 1, 1), new Gt(1, 1, 1, 1), new Gt(3, 0, 1, 1), new Gt(1, 0, 1, 1)], this._cubeDirections = [new V(1, 0, 0), new V(-1, 0, 0), new V(0, 0, 1), new V(0, 0, -1), new V(0, 1, 0), new V(0, -1, 0)], this._cubeUps = [new V(0, 1, 0), new V(0, 1, 0), new V(0, 1, 0), new V(0, 1, 0), new V(0, 0, 1), new V(0, 0, -1)];
  }
  updateMatrices(e, t = 0) {
    const i = this.camera, r = this.matrix, s = e.distance || i.far;
    s !== i.far && (i.far = s, i.updateProjectionMatrix()), eh.setFromMatrixPosition(e.matrixWorld), i.position.copy(eh), xx.copy(i.position), xx.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(xx), i.updateMatrixWorld(), r.makeTranslation(-eh.x, -eh.y, -eh.z), e2.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(e2);
  }
}
class cN extends ja {
  constructor(e, t, i = 0, r = 2) {
    super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new v9();
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class y9 extends Zw {
  constructor() {
    super(new Xd(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
  }
}
class fN extends ja {
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Ot.DEFAULT_UP), this.updateMatrix(), this.target = new Ot(), this.shadow = new y9();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class hN extends ja {
  constructor(e, t) {
    super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
  }
}
class dN extends ja {
  constructor(e, t, i = 10, r = 10) {
    super(e, t), this.isRectAreaLight = true, this.type = "RectAreaLight", this.width = i, this.height = r;
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class pN {
  constructor() {
    this.isSphericalHarmonics3 = true, this.coefficients = [];
    for (let e = 0; e < 9; e++) this.coefficients.push(new V());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.282095), t.addScaledVector(o[1], 0.488603 * r), t.addScaledVector(o[2], 0.488603 * s), t.addScaledVector(o[3], 0.488603 * i), t.addScaledVector(o[4], 1.092548 * (i * r)), t.addScaledVector(o[5], 1.092548 * (r * s)), t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (i * s)), t.addScaledVector(o[8], 0.546274 * (i * i - r * r)), t;
  }
  getIrradianceAt(e, t) {
    const i = e.x, r = e.y, s = e.z, o = this.coefficients;
    return t.copy(o[0]).multiplyScalar(0.886227), t.addScaledVector(o[1], 2 * 0.511664 * r), t.addScaledVector(o[2], 2 * 0.511664 * s), t.addScaledVector(o[3], 2 * 0.511664 * i), t.addScaledVector(o[4], 2 * 0.429043 * i * r), t.addScaledVector(o[5], 2 * 0.429043 * r * s), t.addScaledVector(o[6], 0.743125 * s * s - 0.247708), t.addScaledVector(o[7], 2 * 0.429043 * i * s), t.addScaledVector(o[8], 0.429043 * (i * i - r * r)), t;
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++) if (!this.coefficients[t].equals(e.coefficients[t])) return false;
    return true;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x, r = e.y, s = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * r, t[2] = 0.488603 * s, t[3] = 0.488603 * i, t[4] = 1.092548 * i * r, t[5] = 1.092548 * r * s, t[6] = 0.315392 * (3 * s * s - 1), t[7] = 1.092548 * i * s, t[8] = 0.546274 * (i * i - r * r);
  }
}
class mN extends ja {
  constructor(e = new pN(), t = 1) {
    super(void 0, t), this.isLightProbe = true, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class K_ extends fr {
  constructor(e) {
    super(e), this.textures = {};
  }
  load(e, t, i, r) {
    const s = this, o = new zo(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s];
    }
    const r = K_.createMaterialFromType(e.type);
    if (e.uuid !== void 0 && (r.uuid = e.uuid), e.name !== void 0 && (r.name = e.name), e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color), e.roughness !== void 0 && (r.roughness = e.roughness), e.metalness !== void 0 && (r.metalness = e.metalness), e.sheen !== void 0 && (r.sheen = e.sheen), e.sheenColor !== void 0 && (r.sheenColor = new Ve().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && r.emissive !== void 0 && r.emissive.setHex(e.emissive), e.specular !== void 0 && r.specular !== void 0 && r.specular.setHex(e.specular), e.specularIntensity !== void 0 && (r.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && r.specularColor !== void 0 && r.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (r.shininess = e.shininess), e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (r.clearcoatRoughness = e.clearcoatRoughness), e.iridescence !== void 0 && (r.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (r.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (r.transmission = e.transmission), e.thickness !== void 0 && (r.thickness = e.thickness), e.attenuationDistance !== void 0 && (r.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && r.attenuationColor !== void 0 && r.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (r.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (r.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (r.fog = e.fog), e.flatShading !== void 0 && (r.flatShading = e.flatShading), e.blending !== void 0 && (r.blending = e.blending), e.combine !== void 0 && (r.combine = e.combine), e.side !== void 0 && (r.side = e.side), e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide), e.opacity !== void 0 && (r.opacity = e.opacity), e.transparent !== void 0 && (r.transparent = e.transparent), e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (r.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (r.depthFunc = e.depthFunc), e.depthTest !== void 0 && (r.depthTest = e.depthTest), e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (r.blendSrc = e.blendSrc), e.blendDst !== void 0 && (r.blendDst = e.blendDst), e.blendEquation !== void 0 && (r.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (r.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (r.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (r.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && r.blendColor !== void 0 && r.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (r.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (r.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (r.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (r.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (r.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (r.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (r.rotation = e.rotation), e.linewidth !== void 0 && (r.linewidth = e.linewidth), e.dashSize !== void 0 && (r.dashSize = e.dashSize), e.gapSize !== void 0 && (r.gapSize = e.gapSize), e.scale !== void 0 && (r.scale = e.scale), e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (r.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (r.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (r.dithering = e.dithering), e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (r.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (r.visible = e.visible), e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped), e.userData !== void 0 && (r.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? r.vertexColors = e.vertexColors > 0 : r.vertexColors = e.vertexColors), e.uniforms !== void 0) for (const s in e.uniforms) {
      const o = e.uniforms[s];
      switch (r.uniforms[s] = {}, o.type) {
        case "t":
          r.uniforms[s].value = i(o.value);
          break;
        case "c":
          r.uniforms[s].value = new Ve().setHex(o.value);
          break;
        case "v2":
          r.uniforms[s].value = new _e().fromArray(o.value);
          break;
        case "v3":
          r.uniforms[s].value = new V().fromArray(o.value);
          break;
        case "v4":
          r.uniforms[s].value = new Gt().fromArray(o.value);
          break;
        case "m3":
          r.uniforms[s].value = new Mt().fromArray(o.value);
          break;
        case "m4":
          r.uniforms[s].value = new lt().fromArray(o.value);
          break;
        default:
          r.uniforms[s].value = o.value;
      }
    }
    if (e.defines !== void 0 && (r.defines = e.defines), e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion), e.extensions !== void 0) for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (e.lights !== void 0 && (r.lights = e.lights), e.clipping !== void 0 && (r.clipping = e.clipping), e.size !== void 0 && (r.size = e.size), e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (r.map = i(e.map)), e.matcap !== void 0 && (r.matcap = i(e.matcap)), e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale), e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType), e.normalScale !== void 0) {
      let s = e.normalScale;
      Array.isArray(s) === false && (s = [s, s]), r.normalScale = new _e().fromArray(s);
    }
    return e.displacementMap !== void 0 && (r.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (r.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (r.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (r.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (r.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (r.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (r.envMap = i(e.envMap)), e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (r.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (r.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (r.clearcoatNormalScale = new _e().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (r.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (r.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (r.sheenRoughnessMap = i(e.sheenRoughnessMap)), r;
  }
  setTextures(e) {
    return this.textures = e, this;
  }
  static createMaterialFromType(e) {
    const t = { ShadowMaterial: $I, SpriteMaterial: kw, RawShaderMaterial: YI, ShaderMaterial: bs, PointsMaterial: zw, MeshPhysicalMaterial: qI, MeshStandardMaterial: jw, MeshPhongMaterial: KI, MeshToonMaterial: ZI, MeshNormalMaterial: JI, MeshLambertMaterial: QI, MeshDepthMaterial: Nw, MeshDistanceMaterial: Dw, MeshBasicMaterial: Wa, MeshMatcapMaterial: eN, LineDashedMaterial: tN, LineBasicMaterial: Yi, Material: Ii };
    return new t[e]();
  }
}
class CS {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
  }
}
class gN extends xt {
  constructor() {
    super(), this.isInstancedBufferGeometry = true, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0;
  }
  copy(e) {
    return super.copy(e), this.instanceCount = e.instanceCount, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = true, e;
  }
}
class _N extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new zo(s.manager);
    o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
      try {
        t(s.parse(JSON.parse(a)));
      } catch (l) {
        r ? r(l) : console.error(l), s.manager.itemError(e);
      }
    }, i, r);
  }
  parse(e) {
    const t = {}, i = {};
    function r(g, v) {
      if (t[v] !== void 0) return t[v];
      const M = g.interleavedBuffers[v], m = s(g, M.buffer), w = pc(M.type, m), E = new N_(w, M.stride);
      return E.uuid = M.uuid, t[v] = E, E;
    }
    function s(g, v) {
      if (i[v] !== void 0) return i[v];
      const M = g.arrayBuffers[v], m = new Uint32Array(M).buffer;
      return i[v] = m, m;
    }
    const o = e.isInstancedBufferGeometry ? new gN() : new xt(), a = e.data.index;
    if (a !== void 0) {
      const g = pc(a.type, a.array);
      o.setIndex(new zt(g, 1));
    }
    const l = e.data.attributes;
    for (const g in l) {
      const v = l[g];
      let S;
      if (v.isInterleavedBufferAttribute) {
        const M = r(e.data, v.data);
        S = new Zl(M, v.itemSize, v.offset, v.normalized);
      } else {
        const M = pc(v.type, v.array), m = v.isInstancedBufferAttribute ? Xc : zt;
        S = new m(M, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (S.name = v.name), v.usage !== void 0 && S.setUsage(v.usage), o.setAttribute(g, S);
    }
    const f = e.data.morphAttributes;
    if (f) for (const g in f) {
      const v = f[g], S = [];
      for (let M = 0, m = v.length; M < m; M++) {
        const w = v[M];
        let E;
        if (w.isInterleavedBufferAttribute) {
          const A = r(e.data, w.data);
          E = new Zl(A, w.itemSize, w.offset, w.normalized);
        } else {
          const A = pc(w.type, w.array);
          E = new zt(A, w.itemSize, w.normalized);
        }
        w.name !== void 0 && (E.name = w.name), S.push(E);
      }
      o.morphAttributes[g] = S;
    }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = true);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0) for (let g = 0, v = d.length; g !== v; ++g) {
      const S = d[g];
      o.addGroup(S.start, S.count, S.materialIndex);
    }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const g = new V();
      p.center !== void 0 && g.fromArray(p.center), o.boundingSphere = new Ri(g, p.radius);
    }
    return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o;
  }
}
class x9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = this.path === "" ? CS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new zo(this.manager);
    a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
      let f = null;
      try {
        f = JSON.parse(l);
      } catch (d) {
        r !== void 0 && r(d), console.error("THREE:ObjectLoader: Can't parse " + e + ".", d.message);
        return;
      }
      const h = f.metadata;
      if (h === void 0 || h.type === void 0 || h.type.toLowerCase() === "geometry") {
        r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
        return;
      }
      s.parse(f, t);
    }, i, r);
  }
  async loadAsync(e, t) {
    const i = this, r = this.path === "" ? CS.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new zo(this.manager);
    s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t), a = JSON.parse(o), l = a.metadata;
    if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations), r = this.parseShapes(e.shapes), s = this.parseGeometries(e.geometries, r), o = this.parseImages(e.images, function() {
      t !== void 0 && t(f);
    }), a = this.parseTextures(e.textures, o), l = this.parseMaterials(e.materials, a), f = this.parseObject(e.object, s, l, a, i), h = this.parseSkeletons(e.skeletons, f);
    if (this.bindSkeletons(f, h), t !== void 0) {
      let d = false;
      for (const p in o) if (o[p].data instanceof HTMLImageElement) {
        d = true;
        break;
      }
      d === false && t(f);
    }
    return f;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations), i = this.parseShapes(e.shapes), r = this.parseGeometries(e.geometries, i), s = await this.parseImagesAsync(e.images), o = this.parseTextures(e.textures, s), a = this.parseMaterials(e.materials, o), l = this.parseObject(e.object, r, a, o, t), f = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, f), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0) for (let i = 0, r = e.length; i < r; i++) {
      const s = new zl().fromJSON(e[i]);
      t[s.uuid] = s;
    }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {}, r = {};
    if (t.traverse(function(s) {
      s.isBone && (r[s.uuid] = s);
    }), e !== void 0) for (let s = 0, o = e.length; s < o; s++) {
      const a = new D_().fromJSON(e[s], r);
      i[a.uuid] = a;
    }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new _N();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in ZC ? a = ZC[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`);
        }
        a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), i[l.uuid] = a;
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {}, r = {};
    if (e !== void 0) {
      const s = new K_();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)), r[l.uuid] = i[l.uuid];
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0) for (let i = 0; i < e.length; i++) {
      const r = e[i], s = vd.parse(r);
      t[s.uuid] = s;
    }
    return t;
  }
  parseImages(e, t) {
    const i = this, r = {};
    let s;
    function o(l) {
      return i.manager.itemStart(l), s.load(l, function() {
        i.manager.itemEnd(l);
      }, void 0, function() {
        i.manager.itemError(l), i.manager.itemEnd(l);
      });
    }
    function a(l) {
      if (typeof l == "string") {
        const f = l, h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(f) ? f : i.resourcePath + f;
        return o(h);
      } else return l.data ? { data: pc(l.type, l.data), width: l.width, height: l.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new Kw(t);
      s = new yd(l), s.setCrossOrigin(this.crossOrigin);
      for (let f = 0, h = e.length; f < h; f++) {
        const d = e[f], p = d.url;
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, S = p.length; v < S; v++) {
            const M = p[v], m = a(M);
            m !== null && (m instanceof HTMLImageElement ? g.push(m) : g.push(new Fl(m.data, m.width, m.height)));
          }
          r[d.uuid] = new Cl(g);
        } else {
          const g = a(d.url);
          r[d.uuid] = new Cl(g);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this, i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o, l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else return o.data ? { data: pc(o.type, o.data), width: o.width, height: o.height } : null;
    }
    if (e !== void 0 && e.length > 0) {
      r = new yd(this.manager), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o], f = l.url;
        if (Array.isArray(f)) {
          const h = [];
          for (let d = 0, p = f.length; d < p; d++) {
            const g = f[d], v = await s(g);
            v !== null && (v instanceof HTMLImageElement ? h.push(v) : h.push(new Fl(v.data, v.width, v.height)));
          }
          i[l.uuid] = new Cl(h);
        } else {
          const h = await s(l.url);
          i[l.uuid] = new Cl(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s]);
    }
    const r = {};
    if (e !== void 0) for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s];
      a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
      const l = t[a.image], f = l.data;
      let h;
      Array.isArray(f) ? (h = new Gd(), f.length === 6 && (h.needsUpdate = true)) : (f && f.data ? h = new Fl() : h = new Tn(), f && (h.needsUpdate = true)), h.source = l, h.uuid = a.uuid, a.name !== void 0 && (h.name = a.name), a.mapping !== void 0 && (h.mapping = i(a.mapping, S9)), a.channel !== void 0 && (h.channel = a.channel), a.offset !== void 0 && h.offset.fromArray(a.offset), a.repeat !== void 0 && h.repeat.fromArray(a.repeat), a.center !== void 0 && h.center.fromArray(a.center), a.rotation !== void 0 && (h.rotation = a.rotation), a.wrap !== void 0 && (h.wrapS = i(a.wrap[0], t2), h.wrapT = i(a.wrap[1], t2)), a.format !== void 0 && (h.format = a.format), a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat), a.type !== void 0 && (h.type = a.type), a.colorSpace !== void 0 && (h.colorSpace = a.colorSpace), a.encoding !== void 0 && (h.encoding = a.encoding), a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, n2)), a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, n2)), a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy), a.flipY !== void 0 && (h.flipY = a.flipY), a.generateMipmaps !== void 0 && (h.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (h.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (h.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (h.compareFunction = a.compareFunction), a.userData !== void 0 && (h.userData = a.userData), r[a.uuid] = h;
    }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return t[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", p), t[p];
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const g = [];
          for (let v = 0, S = p.length; v < S; v++) {
            const M = p[v];
            i[M] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", M), g.push(i[M]);
          }
          return g;
        }
        return i[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", p), i[p];
      }
    }
    function f(p) {
      return r[p] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", p), r[p];
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        o = new Uw(), e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new Ve(e.background) : o.background = f(e.background)), e.environment !== void 0 && (o.environment = f(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new I_(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new L_(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        o = new ni(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        o = new Xd(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new hN(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new fN(e.color, e.intensity);
        break;
      case "PointLight":
        o = new cN(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new dN(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new uN(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay);
        break;
      case "HemisphereLight":
        o = new lN(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new mN().fromJSON(e);
        break;
      case "SkinnedMesh":
        h = a(e.geometry), d = l(e.material), o = new II(h, d), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        h = a(e.geometry), d = l(e.material), o = new Hn(h, d);
        break;
      case "InstancedMesh":
        h = a(e.geometry), d = l(e.material);
        const p = e.count, g = e.instanceMatrix, v = e.instanceColor;
        o = new NI(h, d, p), o.instanceMatrix = new Xc(new Float32Array(g.array), 16), v !== void 0 && (o.instanceColor = new Xc(new Float32Array(v.array), v.itemSize));
        break;
      case "BatchedMesh":
        h = a(e.geometry), d = l(e.material), o = new DI(e.maxGeometryCount, e.maxVertexCount, e.maxIndexCount, d), o.geometry = h, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map((S) => {
          const M = new Wi();
          M.min.fromArray(S.boxMin), M.max.fromArray(S.boxMax);
          const m = new Ri();
          return m.radius = S.sphereRadius, m.center.fromArray(S.sphereCenter), { boxInitialized: S.boxInitialized, box: M, sphereInitialized: S.sphereInitialized, sphere: m };
        }), o._maxGeometryCount = e.maxGeometryCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = f(e.matricesTexture.uuid);
        break;
      case "LOD":
        o = new LI();
        break;
      case "Line":
        o = new Ua(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new OI(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new ao(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new UI(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new PI(l(e.material));
        break;
      case "Group":
        o = new _c();
        break;
      case "Bone":
        o = new Fw();
        break;
      default:
        o = new Ot();
    }
    if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
      const p = e.children;
      for (let g = 0; g < p.length; g++) o.add(this.parseObject(p[g], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let g = 0; g < p.length; g++) {
        const v = p[g];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let g = 0; g < p.length; g++) {
        const v = p[g], S = o.getObjectByProperty("uuid", v.object);
        S !== void 0 && o.addLevel(S, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 && e.traverse(function(i) {
      if (i.isSkinnedMesh === true && i.skeleton !== void 0) {
        const r = t[i.skeleton];
        r === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(r, i.bindMatrix);
      }
    });
  }
}
const S9 = { UVMapping: T_, CubeReflectionMapping: Fo, CubeRefractionMapping: Oa, EquirectangularReflectionMapping: Qh, EquirectangularRefractionMapping: ed, CubeUVReflectionMapping: lf }, t2 = { RepeatWrapping: td, ClampToEdgeWrapping: Ai, MirroredRepeatWrapping: nd }, n2 = { NearestFilter: Pn, NearestMipmapNearestFilter: d0, NearestMipmapLinearFilter: xl, LinearFilter: fn, LinearMipmapNearestFilter: Eh, LinearMipmapLinearFilter: $s };
class M9 extends fr {
  constructor(e) {
    super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = { premultiplyAlpha: "none" };
  }
  setOptions(e) {
    return this.options = e, this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
    const s = this, o = Ro.get(e);
    if (o !== void 0) {
      if (s.manager.itemStart(e), o.then) {
        o.then((f) => {
          t && t(f), s.manager.itemEnd(e);
        }).catch((f) => {
          r && r(f);
        });
        return;
      }
      return setTimeout(function() {
        t && t(o), s.manager.itemEnd(e);
      }, 0), o;
    }
    const a = {};
    a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
    const l = fetch(e, a).then(function(f) {
      return f.blob();
    }).then(function(f) {
      return createImageBitmap(f, Object.assign(s.options, { colorSpaceConversion: "none" }));
    }).then(function(f) {
      return Ro.add(e, f), t && t(f), s.manager.itemEnd(e), f;
    }).catch(function(f) {
      r && r(f), Ro.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
    });
    Ro.add(e, l), s.manager.itemStart(e);
  }
}
let Jm;
class Jw {
  static getContext() {
    return Jm === void 0 && (Jm = new (window.AudioContext || window.webkitAudioContext)()), Jm;
  }
  static setContext(e) {
    Jm = e;
  }
}
class w9 extends fr {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this, o = new zo(this.manager);
    o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
      try {
        const f = l.slice(0);
        Jw.getContext().decodeAudioData(f, function(d) {
          t(d);
        }).catch(a);
      } catch (f) {
        a(f);
      }
    }, i, r);
    function a(l) {
      r ? r(l) : console.error(l), s.manager.itemError(e);
    }
  }
}
const i2 = new lt(), r2 = new lt(), ll = new lt();
class E9 {
  constructor() {
    this.type = "StereoCamera", this.aspect = 1, this.eyeSep = 0.064, this.cameraL = new ni(), this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = false, this.cameraR = new ni(), this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = false, this._cache = { focus: null, fov: null, aspect: null, near: null, far: null, zoom: null, eyeSep: null };
  }
  update(e) {
    const t = this._cache;
    if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
      t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, ll.copy(e.projectionMatrix);
      const r = t.eyeSep / 2, s = r * t.near / t.focus, o = t.near * Math.tan(Ol * t.fov * 0.5) / t.zoom;
      let a, l;
      r2.elements[12] = -r, i2.elements[12] = r, a = -o * t.aspect + s, l = o * t.aspect + s, ll.elements[0] = 2 * t.near / (l - a), ll.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(ll), a = -o * t.aspect - s, l = o * t.aspect - s, ll.elements[0] = 2 * t.near / (l - a), ll.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(ll);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(r2), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(i2);
  }
}
class Qw {
  constructor(e = true) {
    this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
  }
  start() {
    this.startTime = s2(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
  }
  stop() {
    this.getElapsedTime(), this.running = false, this.autoStart = false;
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = s2();
      e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
    }
    return e;
  }
}
function s2() {
  return (typeof performance > "u" ? Date : performance).now();
}
const ul = new V(), o2 = new rr(), T9 = new V(), cl = new V();
class A9 extends Ot {
  constructor() {
    super(), this.type = "AudioListener", this.context = Jw.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Qw();
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this;
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this;
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener, i = this.up;
    if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(ul, o2, T9), cl.set(0, 0, -1).applyQuaternion(o2), t.positionX) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(ul.x, r), t.positionY.linearRampToValueAtTime(ul.y, r), t.positionZ.linearRampToValueAtTime(ul.z, r), t.forwardX.linearRampToValueAtTime(cl.x, r), t.forwardY.linearRampToValueAtTime(cl.y, r), t.forwardZ.linearRampToValueAtTime(cl.z, r), t.upX.linearRampToValueAtTime(i.x, r), t.upY.linearRampToValueAtTime(i.y, r), t.upZ.linearRampToValueAtTime(i.z, r);
    } else t.setPosition(ul.x, ul.y, ul.z), t.setOrientation(cl.x, cl.y, cl.z, i.x, i.y, i.z);
  }
}
class vN extends Ot {
  constructor(e) {
    super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = false, this.buffer = null, this.detune = 0, this.loop = false, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = false, this.hasPlaybackControl = true, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = false, this.filters = [];
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "audioNode", this.source = e, this.connect(), this;
  }
  setMediaElementSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this;
  }
  setMediaStreamSource(e) {
    return this.hasPlaybackControl = false, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this;
  }
  setBuffer(e) {
    return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this;
  }
  play(e = 0) {
    if (this.isPlaying === true) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = true, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect();
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.isPlaying === true && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === true && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = false), this;
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this._progress = 0, this.source !== null && (this.source.stop(), this.source.onended = null), this.isPlaying = false, this;
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return this._connected = true, this;
  }
  disconnect() {
    if (this._connected !== false) {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else this.source.disconnect(this.getOutput());
      return this._connected = false, this;
    }
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return e || (e = []), this._connected === true ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this;
  }
  setDetune(e) {
    return this.detune = e, this.isPlaying === true && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01), this;
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.playbackRate = e, this.isPlaying === true && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01), this;
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = false;
  }
  getLoop() {
    return this.hasPlaybackControl === false ? (console.warn("THREE.Audio: this Audio has no playback control."), false) : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === false) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return this.loop = e, this.isPlaying === true && (this.source.loop = this.loop), this;
  }
  setLoopStart(e) {
    return this.loopStart = e, this;
  }
  setLoopEnd(e) {
    return this.loopEnd = e, this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this;
  }
}
const fl = new V(), a2 = new rr(), b9 = new V(), hl = new V();
class C9 extends vN {
  constructor(e) {
    super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain);
  }
  connect() {
    super.connect(), this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return this.panner.refDistance = e, this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return this.panner.rolloffFactor = e, this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return this.panner.distanceModel = e, this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return this.panner.maxDistance = e, this;
  }
  setDirectionalCone(e, t, i) {
    return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this;
  }
  updateMatrixWorld(e) {
    if (super.updateMatrixWorld(e), this.hasPlaybackControl === true && this.isPlaying === false) return;
    this.matrixWorld.decompose(fl, a2, b9), hl.set(0, 0, 1).applyQuaternion(a2);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(fl.x, i), t.positionY.linearRampToValueAtTime(fl.y, i), t.positionZ.linearRampToValueAtTime(fl.z, i), t.orientationX.linearRampToValueAtTime(hl.x, i), t.orientationY.linearRampToValueAtTime(hl.y, i), t.orientationZ.linearRampToValueAtTime(hl.z, i);
    } else t.setPosition(fl.x, fl.y, fl.z), t.setOrientation(hl.x, hl.y, hl.z);
  }
}
class R9 {
  constructor(e, t = 2048) {
    this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class yN {
  constructor(e, t, i) {
    this.binding = e, this.valueSize = i;
    let r, s, o;
    switch (t) {
      case "quaternion":
        r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
        break;
      case "string":
      case "bool":
        r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
        break;
      default:
        r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5);
    }
    this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0;
  }
  accumulate(e, t) {
    const i = this.buffer, r = this.valueSize, s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer, i = this.valueSize, r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, r, 0, e, i), this.cumulativeWeightAdditive += e;
  }
  apply(e) {
    const t = this.valueSize, i = this.buffer, r = e * t + t, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding;
    if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, f = t + t; l !== f; ++l) if (i[l] !== i[l + t]) {
      a.setValue(i, r);
      break;
    }
  }
  saveOriginalState() {
    const e = this.binding, t = this.buffer, i = this.valueSize, r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + s % i];
    this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0;
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize, t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1;
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize, t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    rr.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    rr.multiplyQuaternionsFlat(e, o, e, t, e, i), rr.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const eE = "\\[\\]\\.:\\/", P9 = new RegExp("[" + eE + "]", "g"), tE = "[^" + eE + "]", L9 = "[^" + eE.replace("\\.", "") + "]", I9 = /((?:WC+[\/:])*)/.source.replace("WC", tE), N9 = /(WCOD+)?/.source.replace("WCOD", L9), D9 = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", tE), O9 = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", tE), U9 = new RegExp("^" + I9 + N9 + D9 + O9 + "$"), k9 = ["material", "materials", "bones", "map"];
class F9 {
  constructor(e, t, i) {
    const r = i || Rt.parseTrackName(t);
    this._targetGroup = e, this._bindings = e.subscribe_(t, r);
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
  }
}
class Rt {
  constructor(e, t, i) {
    this.path = t, this.parsedPath = i || Rt.parseTrackName(t), this.node = Rt.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup ? new Rt.Composite(e, t, i) : new Rt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(P9, "");
  }
  static parseTrackName(e) {
    const t = U9.exec(e);
    if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = { nodeName: t[2], objectName: t[3], objectIndex: t[4], propertyName: t[5], propertyIndex: t[6] }, r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      k9.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
    }
    if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
    return i;
  }
  static findNode(e, t) {
    if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function(s) {
        for (let o = 0; o < s.length; o++) {
          const a = s[o];
          if (a.name === t || a.uuid === t) return a;
          const l = i(a.children);
          if (l) return l;
        }
        return null;
      }, r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath, i = t.objectName, r = t.propertyName;
    let s = t.propertyIndex;
    if (e || (e = Rt.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (i) {
      let f = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++) if (e[h].name === f) {
            f = h;
            break;
          }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!e.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          e = e[i];
      }
      if (f !== void 0) {
        if (e[f] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
          return;
        }
        e = e[f];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const f = t.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + f + "." + r + " but it wasn't found.", e);
      return;
    }
    let a = this.Versioning.None;
    this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
      }
      l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s;
    } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r;
    this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a];
  }
  unbind() {
    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
  }
}
Rt.Composite = F9;
Rt.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 };
Rt.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 };
Rt.prototype.GetterByBindingType = [Rt.prototype._getValue_direct, Rt.prototype._getValue_array, Rt.prototype._getValue_arrayElement, Rt.prototype._getValue_toArray];
Rt.prototype.SetterByBindingTypeAndVersioning = [[Rt.prototype._setValue_direct, Rt.prototype._setValue_direct_setNeedsUpdate, Rt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_array, Rt.prototype._setValue_array_setNeedsUpdate, Rt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_arrayElement, Rt.prototype._setValue_arrayElement_setNeedsUpdate, Rt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [Rt.prototype._setValue_fromArray, Rt.prototype._setValue_fromArray_setNeedsUpdate, Rt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class z9 {
  constructor() {
    this.isAnimationObjectGroup = true, this.uuid = Rr(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i) e[arguments[i].uuid] = i;
    this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
    const t = this;
    this.stats = { objects: { get total() {
      return t._objects.length;
    }, get inUse() {
      return this.total - t.nCachedObjects_;
    } }, get bindingsPerObject() {
      return t._bindings.length;
    } };
  }
  add() {
    const e = this._objects, t = this._indicesByUUID, i = this._paths, r = this._parsedPaths, s = this._bindings, o = s.length;
    let a, l = e.length, f = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h], g = p.uuid;
      let v = t[g];
      if (v === void 0) {
        v = l++, t[g] = v, e.push(p);
        for (let S = 0, M = o; S !== M; ++S) s[S].push(new Rt(p, i[S], r[S]));
      } else if (v < f) {
        a = e[v];
        const S = --f, M = e[S];
        t[M.uuid] = v, e[v] = M, t[g] = S, e[S] = p;
        for (let m = 0, w = o; m !== w; ++m) {
          const E = s[m], A = E[S];
          let P = E[v];
          E[v] = A, P === void 0 && (P = new Rt(p, i[m], r[m])), E[S] = P;
        }
      } else e[v] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
    }
    this.nCachedObjects_ = f;
  }
  remove() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o], f = l.uuid, h = t[f];
      if (h !== void 0 && h >= s) {
        const d = s++, p = e[d];
        t[p.uuid] = h, e[h] = p, t[f] = d, e[d] = l;
        for (let g = 0, v = r; g !== v; ++g) {
          const S = i[g], M = S[d], m = S[h];
          S[h] = M, S[d] = m;
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects, t = this._indicesByUUID, i = this._bindings, r = i.length;
    let s = this.nCachedObjects_, o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const f = arguments[a], h = f.uuid, d = t[h];
      if (d !== void 0) if (delete t[h], d < s) {
        const p = --s, g = e[p], v = --o, S = e[v];
        t[g.uuid] = d, e[d] = g, t[S.uuid] = p, e[p] = S, e.pop();
        for (let M = 0, m = r; M !== m; ++M) {
          const w = i[M], E = w[p], A = w[v];
          w[d] = E, w[p] = A, w.pop();
        }
      } else {
        const p = --o, g = e[p];
        p > 0 && (t[g.uuid] = d), e[d] = g, e.pop();
        for (let v = 0, S = r; v !== S; ++v) {
          const M = i[v];
          M[d] = M[p], M.pop();
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths, a = this._parsedPaths, l = this._objects, f = l.length, h = this.nCachedObjects_, d = new Array(f);
    r = s.length, i[e] = r, o.push(e), a.push(t), s.push(d);
    for (let p = h, g = l.length; p !== g; ++p) {
      const v = l[p];
      d[p] = new Rt(v, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath, i = t[e];
    if (i !== void 0) {
      const r = this._paths, s = this._parsedPaths, o = this._bindings, a = o.length - 1, l = o[a], f = e[a];
      t[f] = i, o[i] = l, o.pop(), s[i] = s[a], s.pop(), r[i] = r[a], r.pop();
    }
  }
}
class xN {
  constructor(e, t, i = null, r = t.blendMode) {
    this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = r;
    const s = t.tracks, o = s.length, a = new Array(o), l = { endingStart: Al, endingEnd: Al };
    for (let f = 0; f !== o; ++f) {
      const h = s[f].createInterpolant(null);
      a[f] = h, h.settings = l;
    }
    this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = eI, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = false, this.enabled = true, this.clampWhenFinished = false, this.zeroSlopeAtStart = true, this.zeroSlopeAtEnd = true;
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return this.paused = false, this.enabled = true, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping();
  }
  isRunning() {
    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return this._startTime = e, this;
  }
  setLoop(e, t) {
    return this.loop = e, this.repetitions = t, this;
  }
  setEffectiveWeight(e) {
    return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading();
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if (e.fadeOut(t), this.fadeIn(t), i) {
      const r = this._clip.duration, s = e._clip.duration, o = s / r, a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  setEffectiveTimeScale(e) {
    return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping();
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return this.timeScale = this._clip.duration / e, this.stopWarping();
  }
  syncWith(e) {
    return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping();
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer, s = r.time, o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a);
    const l = a.parameterPositions, f = a.sampleValues;
    return l[0] = s, l[1] = s + i, f[0] = e / o, f[1] = t / o, this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this;
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * l);
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t), a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants, f = this._propertyBindings;
      switch (this.blendMode) {
        case ww:
          for (let h = 0, d = l.length; h !== d; ++h) l[h].evaluate(o), f[h].accumulateAdditive(a);
          break;
        case b_:
        default:
          for (let h = 0, d = l.length; h !== d; ++h) l[h].evaluate(o), f[h].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = false));
      }
    }
    return this._effectiveWeight = t, t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        t *= r, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = true : this.timeScale = t);
      }
    }
    return this._effectiveTimeScale = t, t;
  }
  _updateTime(e) {
    const t = this._clip.duration, i = this.loop;
    let r = this.time + e, s = this._loopCount;
    const o = i === tI;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === QL) {
      s === -1 && (this._loopCount = 0, this._setEndings(true, true, false));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? this.paused = true : this.enabled = false, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e < 0 ? -1 : 1 });
      }
    } else {
      if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(true, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, true, o)), r >= t || r < 0) {
        const a = Math.floor(r / t);
        r -= t * a, s += Math.abs(a);
        const l = this.repetitions - s;
        if (l <= 0) this.clampWhenFinished ? this.paused = true : this.enabled = false, r = e > 0 ? t : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: e > 0 ? 1 : -1 });
        else {
          if (l === 1) {
            const f = e < 0;
            this._setEndings(f, !f, o);
          } else this._setEndings(false, false, o);
          this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i ? (r.endingStart = bl, r.endingEnd = bl) : (e ? r.endingStart = this.zeroSlopeAtStart ? bl : Al : r.endingStart = sd, t ? r.endingEnd = this.zeroSlopeAtEnd ? bl : Al : r.endingEnd = sd);
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer, s = r.time;
    let o = this._weightInterpolant;
    o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
    const a = o.parameterPositions, l = o.sampleValues;
    return a[0] = s, l[0] = t, a[1] = s + e, l[1] = i, this;
  }
}
const B9 = new Float32Array(1);
class V9 extends Go {
  constructor(e) {
    super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1;
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root, r = e._clip.tracks, s = r.length, o = e._propertyBindings, a = e._interpolants, l = i.uuid, f = this._bindingsByRootAndName;
    let h = f[l];
    h === void 0 && (h = {}, f[l] = h);
    for (let d = 0; d !== s; ++d) {
      const p = r[d], g = p.name;
      let v = h[g];
      if (v !== void 0) ++v.referenceCount, o[d] = v;
      else {
        if (v = o[d], v !== void 0) {
          v._cacheIndex === null && (++v.referenceCount, this._addInactiveBinding(v, l, g));
          continue;
        }
        const S = t && t._propertyBindings[d].binding.parsedPath;
        v = new yN(Rt.create(i, g, S), p.ValueTypeName, p.getValueSize()), ++v.referenceCount, this._addInactiveBinding(v, l, g), o[d] = v;
      }
      a[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid, r = e._clip.uuid, s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
    const e = this;
    this.stats = { actions: { get total() {
      return e._actions.length;
    }, get inUse() {
      return e._nActiveActions;
    } }, bindings: { get total() {
      return e._bindings.length;
    }, get inUse() {
      return e._nActiveBindings;
    } }, controlInterpolants: { get total() {
      return e._controlInterpolants.length;
    }, get inUse() {
      return e._nActiveControlInterpolants;
    } } };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions, s = this._actionsByClip;
    let o = s[t];
    if (o === void 0) o = { knownActions: [e], actionByRoot: {} }, e._byClipCacheIndex = 0, s[t] = o;
    else {
      const a = o.knownActions;
      e._byClipCacheIndex = a.length, a.push(e);
    }
    e._cacheIndex = r.length, r.push(e), o.actionByRoot[i] = e;
  }
  _removeInactiveAction(e) {
    const t = this._actions, i = t[t.length - 1], r = e._cacheIndex;
    i._cacheIndex = r, t[r] = i, t.pop(), e._cacheIndex = null;
    const s = e._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, f = l[l.length - 1], h = e._byClipCacheIndex;
    f._byClipCacheIndex = h, l[h] = f, l.pop(), e._byClipCacheIndex = null;
    const d = a.actionByRoot, p = (e._localRoot || this._root).uuid;
    delete d[p], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions, i = e._cacheIndex, r = this._nActiveActions++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackAction(e) {
    const t = this._actions, i = e._cacheIndex, r = --this._nActiveActions, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName, s = this._bindings;
    let o = r[t];
    o === void 0 && (o = {}, r[t] = o), o[i] = e, e._cacheIndex = s.length, s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings, i = e.binding, r = i.rootNode.uuid, s = i.path, o = this._bindingsByRootAndName, a = o[r], l = t[t.length - 1], f = e._cacheIndex;
    l._cacheIndex = f, t[f] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = this._nActiveBindings++, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _takeBackBinding(e) {
    const t = this._bindings, i = e._cacheIndex, r = --this._nActiveBindings, s = t[r];
    e._cacheIndex = r, t[r] = e, s._cacheIndex = i, t[i] = s;
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants, t = this._nActiveControlInterpolants++;
    let i = e[t];
    return i === void 0 && (i = new Yw(new Float32Array(2), new Float32Array(2), 1, B9), i.__cacheIndex = t, e[t] = i), i;
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants, i = e.__cacheIndex, r = --this._nActiveControlInterpolants, s = t[r];
    e.__cacheIndex = r, t[r] = e, s.__cacheIndex = i, t[i] = s;
  }
  clipAction(e, t, i) {
    const r = t || this._root, s = r.uuid;
    let o = typeof e == "string" ? vd.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e, l = this._actionsByClip[a];
    let f = null;
    if (i === void 0 && (o !== null ? i = o.blendMode : i = b_), l !== void 0) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      f = l.knownActions[0], o === null && (o = f._clip);
    }
    if (o === null) return null;
    const h = new xN(this, o, t, i);
    return this._bindAction(h, f), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root, r = i.uuid, s = typeof e == "string" ? vd.findByName(i, e) : e, o = s ? s.uuid : e, a = this._actionsByClip[o];
    return a !== void 0 && a.actionByRoot[r] || null;
  }
  stopAllAction() {
    const e = this._actions, t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions, i = this._nActiveActions, r = this.time += e, s = Math.sign(e), o = this._accuIndex ^= 1;
    for (let f = 0; f !== i; ++f) t[f]._update(r, e, s, o);
    const a = this._bindings, l = this._nActiveBindings;
    for (let f = 0; f !== l; ++f) a[f].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions, i = e.uuid, r = this._actionsByClip, s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const f = o[a];
        this._deactivateAction(f);
        const h = f._cacheIndex, d = t[t.length - 1];
        f._cacheIndex = null, f._byClipCacheIndex = null, d._cacheIndex = h, t[h] = d, t.pop(), this._removeInactiveBindingsForAction(f);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid, i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot, l = a[t];
      l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName, s = r[t];
    if (s !== void 0) for (const o in s) {
      const a = s[o];
      a.restoreOriginalState(), this._removeInactiveBinding(a);
    }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class nE {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new nE(this.value.clone === void 0 ? this.value : this.value.clone());
  }
}
let H9 = 0;
class G9 extends Go {
  constructor() {
    super(), this.isUniformsGroup = true, Object.defineProperty(this, "id", { value: H9++ }), this.name = "", this.usage = ud, this.uniforms = [];
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return this.name = e, this;
  }
  setUsage(e) {
    return this.usage = e, this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    this.name = e.name, this.usage = e.usage;
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = Array.isArray(t[i]) ? t[i] : [t[i]];
      for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone());
    }
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class W9 extends N_ {
  constructor(e, t, i = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = true, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = true, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class X9 {
  constructor(e, t, i, r, s) {
    this.isGLBufferAttribute = true, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = r, this.count = s, this.version = 0;
  }
  set needsUpdate(e) {
    e === true && this.version++;
  }
  setBuffer(e) {
    return this.buffer = e, this;
  }
  setType(e, t) {
    return this.type = e, this.elementSize = t, this;
  }
  setItemSize(e) {
    return this.itemSize = e, this;
  }
  setCount(e) {
    return this.count = e, this;
  }
}
class SN {
  constructor(e, t, i = 0, r = 1 / 0) {
    this.ray = new uf(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new kl(), this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} };
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = true, i = []) {
    return RS(e, this, i, t), i.sort(l2), i;
  }
  intersectObjects(e, t = true, i = []) {
    for (let r = 0, s = e.length; r < s; r++) RS(e[r], this, i, t);
    return i.sort(l2), i;
  }
}
function l2(n24, e) {
  return n24.distance - e.distance;
}
function RS(n24, e, t, i) {
  if (n24.layers.test(e.layers) && n24.raycast(e, t), i === true) {
    const r = n24.children;
    for (let s = 0, o = r.length; s < o; s++) RS(r[s], e, t, true);
  }
}
class j9 {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.phi = t, this.theta = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this;
  }
  makeSafe() {
    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(wn(t / this.radius, -1, 1))), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class $9 {
  constructor(e = 1, t = 0, i = 0) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  set(e, t, i) {
    return this.radius = e, this.theta = t, this.y = i, this;
  }
  copy(e) {
    return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this;
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const u2 = new _e();
class Y9 {
  constructor(e = new _e(1 / 0, 1 / 0), t = new _e(-1 / 0, -1 / 0)) {
    this.isBox2 = true, this.min = e, this.max = t;
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = u2.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y);
  }
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y;
  }
  getParameter(e, t) {
    return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y));
  }
  intersectsBox(e) {
    return !(e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y);
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, u2).distanceTo(e);
  }
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const c2 = new V(), Qm = new V();
class q9 {
  constructor(e = new V(), t = new V()) {
    this.start = e, this.end = t;
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    c2.subVectors(e, this.start), Qm.subVectors(this.end, this.start);
    const i = Qm.dot(Qm);
    let s = Qm.dot(c2) / i;
    return t && (s = wn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const f2 = new V();
class K9 extends Ot {
  constructor(e, t) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = t, this.type = "SpotLightHelper";
    const i = new xt(), r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const f = o / l * Math.PI * 2, h = a / l * Math.PI * 2;
      r.push(Math.cos(f), Math.sin(f), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ye(r, 3));
    const s = new Yi({ fog: false, toneMapped: false });
    this.cone = new ao(i, s), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false);
    const e = this.light.distance ? this.light.distance : 1e3, t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e), f2.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(f2), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color);
  }
}
const aa = new V(), eg = new lt(), Sx = new lt();
class Z9 extends ao {
  constructor(e) {
    const t = MN(e), i = new xt(), r = [], s = [], o = new Ve(0, 0, 1), a = new Ve(0, 1, 0);
    for (let f = 0; f < t.length; f++) {
      const h = t[f];
      h.parent && h.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Ye(r, 3)), i.setAttribute("color", new Ye(s, 3));
    const l = new Yi({ vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true });
    super(i, l), this.isSkeletonHelper = true, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false;
  }
  updateMatrixWorld(e) {
    const t = this.bones, i = this.geometry, r = i.getAttribute("position");
    Sx.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent && a.parent.isBone && (eg.multiplyMatrices(Sx, a.matrixWorld), aa.setFromMatrixPosition(eg), r.setXYZ(o, aa.x, aa.y, aa.z), eg.multiplyMatrices(Sx, a.parent.matrixWorld), aa.setFromMatrixPosition(eg), r.setXYZ(o + 1, aa.x, aa.y, aa.z), o += 2);
    }
    i.getAttribute("position").needsUpdate = true, super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function MN(n24) {
  const e = [];
  n24.isBone === true && e.push(n24);
  for (let t = 0; t < n24.children.length; t++) e.push.apply(e, MN(n24.children[t]));
  return e;
}
class J9 extends Hn {
  constructor(e, t, i) {
    const r = new Yd(t, 4, 2), s = new Wa({ wireframe: true, fog: false, toneMapped: false });
    super(r, s), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = false, this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color);
  }
}
const Q9 = new V(), h2 = new Ve(), d2 = new Ve();
class e7 extends Ot {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "HemisphereLightHelper";
    const r = new $d(t);
    r.rotateY(Math.PI * 0.5), this.material = new Wa({ wireframe: true, fog: false, toneMapped: false }), this.color === void 0 && (this.material.vertexColors = true);
    const s = r.getAttribute("position"), o = new Float32Array(s.count * 3);
    r.setAttribute("color", new zt(o, 3)), this.add(new Hn(r, this.material)), this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      h2.copy(this.light.color), d2.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? h2 : d2;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = true;
    }
    this.light.updateWorldMatrix(true, false), e.lookAt(Q9.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class t7 extends ao {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    i = new Ve(i), r = new Ve(r);
    const s = t / 2, o = e / t, a = e / 2, l = [], f = [];
    for (let p = 0, g = 0, v = -a; p <= t; p++, v += o) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const S = p === s ? i : r;
      S.toArray(f, g), g += 3, S.toArray(f, g), g += 3, S.toArray(f, g), g += 3, S.toArray(f, g), g += 3;
    }
    const h = new xt();
    h.setAttribute("position", new Ye(l, 3)), h.setAttribute("color", new Ye(f, 3));
    const d = new Yi({ vertexColors: true, toneMapped: false });
    super(h, d), this.type = "GridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class n7 extends ao {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    s = new Ve(s), o = new Ve(o);
    const a = [], l = [];
    if (t > 1) for (let d = 0; d < t; d++) {
      const p = d / t * (Math.PI * 2), g = Math.sin(p) * e, v = Math.cos(p) * e;
      a.push(0, 0, 0), a.push(g, 0, v);
      const S = d & 1 ? s : o;
      l.push(S.r, S.g, S.b), l.push(S.r, S.g, S.b);
    }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o, g = e - e / i * d;
      for (let v = 0; v < r; v++) {
        let S = v / r * (Math.PI * 2), M = Math.sin(S) * g, m = Math.cos(S) * g;
        a.push(M, 0, m), l.push(p.r, p.g, p.b), S = (v + 1) / r * (Math.PI * 2), M = Math.sin(S) * g, m = Math.cos(S) * g, a.push(M, 0, m), l.push(p.r, p.g, p.b);
      }
    }
    const f = new xt();
    f.setAttribute("position", new Ye(a, 3)), f.setAttribute("color", new Ye(l, 3));
    const h = new Yi({ vertexColors: true, toneMapped: false });
    super(f, h), this.type = "PolarGridHelper";
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const p2 = new V(), tg = new V(), m2 = new V();
class i7 extends Ot {
  constructor(e, t, i) {
    super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
    let r = new xt();
    r.setAttribute("position", new Ye([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
    const s = new Yi({ fog: false, toneMapped: false });
    this.lightPlane = new Ua(r, s), this.add(this.lightPlane), r = new xt(), r.setAttribute("position", new Ye([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ua(r, s), this.add(this.targetLine), this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(true, false), this.light.target.updateWorldMatrix(true, false), p2.setFromMatrixPosition(this.light.matrixWorld), tg.setFromMatrixPosition(this.light.target.matrixWorld), m2.subVectors(tg, p2), this.lightPlane.lookAt(tg), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(tg), this.targetLine.scale.z = m2.length();
  }
}
const ng = new V(), yn = new Hd();
class r7 extends ao {
  constructor(e) {
    const t = new xt(), i = new Yi({ color: 16777215, vertexColors: true, toneMapped: false }), r = [], s = [], o = {};
    a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");
    function a(v, S) {
      l(v), l(S);
    }
    function l(v) {
      r.push(0, 0, 0), s.push(0, 0, 0), o[v] === void 0 && (o[v] = []), o[v].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ye(r, 3)), t.setAttribute("color", new Ye(s, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = false, this.pointMap = o, this.update();
    const f = new Ve(16755200), h = new Ve(16711680), d = new Ve(43775), p = new Ve(16777215), g = new Ve(3355443);
    this.setColors(f, h, d, p, g);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, i.r, i.g, i.b), a.setXYZ(33, i.r, i.g, i.b), a.setXYZ(34, i.r, i.g, i.b), a.setXYZ(35, i.r, i.g, i.b), a.setXYZ(36, i.r, i.g, i.b), a.setXYZ(37, i.r, i.g, i.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = true;
  }
  update() {
    const e = this.geometry, t = this.pointMap, i = 1, r = 1;
    yn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), Cn("c", t, e, yn, 0, 0, -1), Cn("t", t, e, yn, 0, 0, 1), Cn("n1", t, e, yn, -1, -1, -1), Cn("n2", t, e, yn, i, -1, -1), Cn("n3", t, e, yn, -1, r, -1), Cn("n4", t, e, yn, i, r, -1), Cn("f1", t, e, yn, -1, -1, 1), Cn("f2", t, e, yn, i, -1, 1), Cn("f3", t, e, yn, -1, r, 1), Cn("f4", t, e, yn, i, r, 1), Cn("u1", t, e, yn, i * 0.7, r * 1.1, -1), Cn("u2", t, e, yn, -1 * 0.7, r * 1.1, -1), Cn("u3", t, e, yn, 0, r * 2, -1), Cn("cf1", t, e, yn, -1, 0, 1), Cn("cf2", t, e, yn, i, 0, 1), Cn("cf3", t, e, yn, 0, -1, 1), Cn("cf4", t, e, yn, 0, r, 1), Cn("cn1", t, e, yn, -1, 0, -1), Cn("cn2", t, e, yn, i, 0, -1), Cn("cn3", t, e, yn, 0, -1, -1), Cn("cn4", t, e, yn, 0, r, -1), e.getAttribute("position").needsUpdate = true;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function Cn(n24, e, t, i, r, s, o) {
  ng.set(r, s, o).unproject(i);
  const a = e[n24];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let f = 0, h = a.length; f < h; f++) l.setXYZ(a[f], ng.x, ng.y, ng.z);
  }
}
const ig = new Wi();
class s7 extends ao {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = new Float32Array(8 * 3), s = new xt();
    s.setIndex(new zt(i, 1)), s.setAttribute("position", new zt(r, 3)), super(s, new Yi({ color: t, toneMapped: false })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = false, this.update();
  }
  update(e) {
    if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && ig.setFromObject(this.object), ig.isEmpty()) return;
    const t = ig.min, i = ig.max, r = this.geometry.attributes.position, s = r.array;
    s[0] = i.x, s[1] = i.y, s[2] = i.z, s[3] = t.x, s[4] = i.y, s[5] = i.z, s[6] = t.x, s[7] = t.y, s[8] = i.z, s[9] = i.x, s[10] = t.y, s[11] = i.z, s[12] = i.x, s[13] = i.y, s[14] = t.z, s[15] = t.x, s[16] = i.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = i.x, s[22] = t.y, s[23] = t.z, r.needsUpdate = true, this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return this.object = e, this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), this.object = e.object, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class o7 extends ao {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new xt();
    s.setIndex(new zt(i, 1)), s.setAttribute("position", new Ye(r, 3)), super(s, new Yi({ color: t, toneMapped: false })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(0.5), super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class a7 extends Ua {
  constructor(e, t = 1, i = 16776960) {
    const r = i, s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], o = new xt();
    o.setAttribute("position", new Ye(s, 3)), o.computeBoundingSphere(), super(o, new Yi({ color: r, toneMapped: false })), this.type = "PlaneHelper", this.plane = e, this.size = t;
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], l = new xt();
    l.setAttribute("position", new Ye(a, 3)), l.computeBoundingSphere(), this.add(new Hn(l, new Wa({ color: r, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false })));
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0), this.scale.set(0.5 * this.size, 0.5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const g2 = new V();
let rg, Mx;
class l7 extends Ot {
  constructor(e = new V(0, 0, 1), t = new V(0, 0, 0), i = 1, r = 16776960, s = i * 0.2, o = s * 0.2) {
    super(), this.type = "ArrowHelper", rg === void 0 && (rg = new xt(), rg.setAttribute("position", new Ye([0, 0, 0, 0, 1, 0], 3)), Mx = new ff(0, 0.5, 1, 5, 1), Mx.translate(0, -0.5, 0)), this.position.copy(t), this.line = new Ua(rg, new Yi({ color: r, toneMapped: false })), this.line.matrixAutoUpdate = false, this.add(this.line), this.cone = new Hn(Mx, new Wa({ color: r, toneMapped: false })), this.cone.matrixAutoUpdate = false, this.add(this.cone), this.setDirection(e), this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      g2.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(g2, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return super.copy(e, false), this.line.copy(e.line), this.cone.copy(e.cone), this;
  }
  dispose() {
    this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose();
  }
}
class u7 extends ao {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e], i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], r = new xt();
    r.setAttribute("position", new Ye(t, 3)), r.setAttribute("color", new Ye(i, 3));
    const s = new Yi({ vertexColors: true, toneMapped: false });
    super(r, s), this.type = "AxesHelper";
  }
  setColors(e, t, i) {
    const r = new Ve(), s = this.geometry.attributes.color.array;
    return r.set(e), r.toArray(s, 0), r.toArray(s, 3), r.set(t), r.toArray(s, 6), r.toArray(s, 9), r.set(i), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = true, this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class c7 {
  constructor() {
    this.type = "ShapePath", this.color = new Ve(), this.subPaths = [], this.currentPath = null;
  }
  moveTo(e, t) {
    return this.currentPath = new hd(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(m) {
      const w = [];
      for (let E = 0, A = m.length; E < A; E++) {
        const P = m[E], R = new zl();
        R.curves = P.curves, w.push(R);
      }
      return w;
    }
    function i(m, w) {
      const E = w.length;
      let A = false;
      for (let P = E - 1, R = 0; R < E; P = R++) {
        let L = w[P], D = w[R], F = D.x - L.x, C = D.y - L.y;
        if (Math.abs(C) > Number.EPSILON) {
          if (C < 0 && (L = w[R], F = -F, D = w[P], C = -C), m.y < L.y || m.y > D.y) continue;
          if (m.y === L.y) {
            if (m.x === L.x) return true;
          } else {
            const N = C * (m.x - L.x) - F * (m.y - L.y);
            if (N === 0) return true;
            if (N < 0) continue;
            A = !A;
          }
        } else {
          if (m.y !== L.y) continue;
          if (D.x <= m.x && m.x <= L.x || L.x <= m.x && m.x <= D.x) return true;
        }
      }
      return A;
    }
    const r = no.isClockWise, s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const f = [];
    if (s.length === 1) return a = s[0], l = new zl(), l.curves = a.curves, f.push(l), f;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [], p = [];
    let g = [], v = 0, S;
    p[v] = void 0, g[v] = [];
    for (let m = 0, w = s.length; m < w; m++) a = s[m], S = a.getPoints(), o = r(S), o = e ? !o : o, o ? (!h && p[v] && v++, p[v] = { s: new zl(), p: S }, p[v].s.curves = a.curves, h && v++, g[v] = []) : g[v].push({ h: a, p: S[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let m = false, w = 0;
      for (let E = 0, A = p.length; E < A; E++) d[E] = [];
      for (let E = 0, A = p.length; E < A; E++) {
        const P = g[E];
        for (let R = 0; R < P.length; R++) {
          const L = P[R];
          let D = true;
          for (let F = 0; F < p.length; F++) i(L.p, p[F].p) && (E !== F && w++, D ? (D = false, d[F].push(L)) : m = true);
          D && d[E].push(L);
        }
      }
      w > 0 && m === false && (g = d);
    }
    let M;
    for (let m = 0, w = p.length; m < w; m++) {
      l = p[m].s, f.push(l), M = g[m];
      for (let E = 0, A = M.length; E < A; E++) l.holes.push(M[E].h);
    }
    return f;
  }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: w_ } }));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = w_);
const f7 = Object.freeze(Object.defineProperty({ __proto__: null, ACESFilmicToneMapping: mw, AddEquation: pa, AddOperation: FL, AdditiveAnimationBlendMode: ww, AdditiveBlending: V1, AgXToneMapping: GL, AlphaFormat: $L, AlwaysCompare: fI, AlwaysDepth: LL, AlwaysStencilFunc: vS, AmbientLight: hN, AnimationAction: xN, AnimationClip: vd, AnimationLoader: h9, AnimationMixer: V9, AnimationObjectGroup: z9, AnimationUtils: l9, ArcCurve: kI, ArrayCamera: bI, ArrowHelper: l7, AttachedBindMode: j1, Audio: vN, AudioAnalyser: R9, AudioContext: Jw, AudioListener: A9, AudioLoader: w9, AxesHelper: u7, BackSide: Gi, BasicDepthPacking: nI, BasicShadowMap: dL, BatchedMesh: DI, Bone: Fw, BooleanKeyframeTrack: ru, Box2: Y9, Box3: Wi, Box3Helper: o7, BoxGeometry: nu, BoxHelper: s7, BufferAttribute: zt, BufferGeometry: xt, BufferGeometryLoader: _N, ByteType: XL, Cache: Ro, Camera: Hd, CameraHelper: r7, CanvasTexture: IW, CapsuleGeometry: k_, CatmullRomCurve3: FI, CineonToneMapping: VL, CircleGeometry: F_, ClampToEdgeWrapping: Ai, Clock: Qw, Color: Ve, ColorKeyframeTrack: qw, ColorManagement: Ht, CompressedArrayTexture: PW, CompressedCubeTexture: LW, CompressedTexture: O_, CompressedTextureLoader: d9, ConeGeometry: z_, ConstantAlphaFactor: CL, ConstantColorFactor: AL, CubeCamera: vI, CubeReflectionMapping: Fo, CubeRefractionMapping: Oa, CubeTexture: Gd, CubeTextureLoader: p9, CubeUVReflectionMapping: lf, CubicBezierCurve: Vw, CubicBezierCurve3: zI, CubicInterpolant: rN, CullFaceBack: B1, CullFaceFront: hL, CullFaceFrontBack: v5, CullFaceNone: fL, Curve: Cs, CurvePath: VI, CustomBlending: pL, CustomToneMapping: HL, CylinderGeometry: ff, Cylindrical: $9, Data3DTexture: Cw, DataArrayTexture: R_, DataTexture: Fl, DataTextureLoader: m9, DataUtils: AV, DecrementStencilOp: R5, DecrementWrapStencilOp: L5, DefaultLoadingManager: aN, DepthFormat: Ra, DepthStencilFormat: Kl, DepthTexture: Iw, DetachedBindMode: WL, DirectionalLight: fN, DirectionalLightHelper: i7, DiscreteInterpolant: sN, DisplayP3ColorSpace: C_, DodecahedronGeometry: B_, DoubleSide: Xs, DstAlphaFactor: SL, DstColorFactor: wL, DynamicCopyUsage: j5, DynamicDrawUsage: B5, DynamicReadUsage: G5, EdgesGeometry: HI, EllipseCurve: U_, EqualCompare: aI, EqualDepth: NL, EqualStencilFunc: O5, EquirectangularReflectionMapping: Qh, EquirectangularRefractionMapping: ed, Euler: Vd, EventDispatcher: Go, ExtrudeGeometry: H_, FileLoader: zo, Float16BufferAttribute: IV, Float32BufferAttribute: Ye, Float64BufferAttribute: NV, FloatType: ns, Fog: I_, FogExp2: L_, FramebufferTexture: RW, FrontSide: ko, Frustum: Wd, GLBufferAttribute: X9, GLSL1: Y5, GLSL3: yS, GreaterCompare: lI, GreaterDepth: OL, GreaterEqualCompare: cI, GreaterEqualDepth: DL, GreaterEqualStencilFunc: z5, GreaterStencilFunc: k5, GridHelper: t7, Group: _c, HalfFloatType: Hc, HemisphereLight: lN, HemisphereLightHelper: e7, IcosahedronGeometry: G_, ImageBitmapLoader: M9, ImageLoader: yd, ImageUtils: bw, IncrementStencilOp: C5, IncrementWrapStencilOp: P5, InstancedBufferAttribute: Xc, InstancedBufferGeometry: gN, InstancedInterleavedBuffer: W9, InstancedMesh: NI, Int16BufferAttribute: PV, Int32BufferAttribute: LV, Int8BufferAttribute: bV, IntType: gw, InterleavedBuffer: N_, InterleavedBufferAttribute: Zl, Interpolant: qd, InterpolateDiscrete: id, InterpolateLinear: rd, InterpolateSmooth: Pg, InvertStencilOp: I5, KeepStencilOp: _l, KeyframeTrack: Rs, LOD: LI, LatheGeometry: jd, Layers: kl, LessCompare: oI, LessDepth: IL, LessEqualCompare: Tw, LessEqualDepth: Jh, LessEqualStencilFunc: U5, LessStencilFunc: D5, Light: ja, LightProbe: mN, Line: Ua, Line3: q9, LineBasicMaterial: Yi, LineCurve: Hw, LineCurve3: BI, LineDashedMaterial: tN, LineLoop: OI, LineSegments: ao, LinearDisplayP3ColorSpace: Bd, LinearEncoding: Ew, LinearFilter: fn, LinearInterpolant: Yw, LinearMipMapLinearFilter: M5, LinearMipMapNearestFilter: S5, LinearMipmapLinearFilter: $s, LinearMipmapNearestFilter: Eh, LinearSRGBColorSpace: so, LinearToneMapping: zL, LinearTransfer: od, Loader: fr, LoaderUtils: CS, LoadingManager: Kw, LoopOnce: QL, LoopPingPong: tI, LoopRepeat: eI, LuminanceAlphaFormat: qL, LuminanceFormat: YL, MOUSE: g5, Material: Ii, MaterialLoader: K_, MathUtils: SS, Matrix3: Mt, Matrix4: lt, MaxEquation: X1, Mesh: Hn, MeshBasicMaterial: Wa, MeshDepthMaterial: Nw, MeshDistanceMaterial: Dw, MeshLambertMaterial: QI, MeshMatcapMaterial: eN, MeshNormalMaterial: JI, MeshPhongMaterial: KI, MeshPhysicalMaterial: qI, MeshStandardMaterial: jw, MeshToonMaterial: ZI, MinEquation: W1, MirroredRepeatWrapping: nd, MixOperation: kL, MultiplyBlending: G1, MultiplyOperation: zd, NearestFilter: Pn, NearestMipMapLinearFilter: x5, NearestMipMapNearestFilter: y5, NearestMipmapLinearFilter: xl, NearestMipmapNearestFilter: d0, NeverCompare: sI, NeverDepth: PL, NeverStencilFunc: N5, NoBlending: Lo, NoColorSpace: Mr, NoToneMapping: eo, NormalAnimationBlendMode: b_, NormalBlending: Dl, NotEqualCompare: uI, NotEqualDepth: UL, NotEqualStencilFunc: F5, NumberKeyframeTrack: gd, Object3D: Ot, ObjectLoader: x9, ObjectSpaceNormalMap: rI, OctahedronGeometry: $d, OneFactor: vL, OneMinusConstantAlphaFactor: RL, OneMinusConstantColorFactor: bL, OneMinusDstAlphaFactor: ML, OneMinusDstColorFactor: EL, OneMinusSrcAlphaFactor: h0, OneMinusSrcColorFactor: xL, OrthographicCamera: Xd, P3Primaries: ld, PCFShadowMap: E_, PCFSoftShadowMap: wh, PMREMGenerator: MS, Path: hd, PerspectiveCamera: ni, Plane: ca, PlaneGeometry: iu, PlaneHelper: a7, PointLight: cN, PointLightHelper: J9, Points: UI, PointsMaterial: zw, PolarGridHelper: n7, PolyhedronGeometry: Xa, PositionalAudio: C9, PropertyBinding: Rt, PropertyMixer: yN, QuadraticBezierCurve: Gw, QuadraticBezierCurve3: Ww, Quaternion: rr, QuaternionKeyframeTrack: hf, QuaternionLinearInterpolant: oN, RED_GREEN_RGTC2_Format: gS, RED_RGTC1_Format: JL, REVISION: w_, RGBADepthPacking: iI, RGBAFormat: zi, RGBAIntegerFormat: Sw, RGBA_ASTC_10x10_Format: cS, RGBA_ASTC_10x5_Format: aS, RGBA_ASTC_10x6_Format: lS, RGBA_ASTC_10x8_Format: uS, RGBA_ASTC_12x10_Format: fS, RGBA_ASTC_12x12_Format: hS, RGBA_ASTC_4x4_Format: Q1, RGBA_ASTC_5x4_Format: eS, RGBA_ASTC_5x5_Format: tS, RGBA_ASTC_6x5_Format: nS, RGBA_ASTC_6x6_Format: iS, RGBA_ASTC_8x5_Format: rS, RGBA_ASTC_8x6_Format: sS, RGBA_ASTC_8x8_Format: oS, RGBA_BPTC_Format: Rg, RGBA_ETC2_EAC_Format: J1, RGBA_PVRTC_2BPPV1_Format: K1, RGBA_PVRTC_4BPPV1_Format: q1, RGBA_S3TC_DXT1_Format: Ag, RGBA_S3TC_DXT3_Format: bg, RGBA_S3TC_DXT5_Format: Cg, RGB_BPTC_SIGNED_Format: dS, RGB_BPTC_UNSIGNED_Format: pS, RGB_ETC1_Format: Mw, RGB_ETC2_Format: Z1, RGB_PVRTC_2BPPV1_Format: Y1, RGB_PVRTC_4BPPV1_Format: $1, RGB_S3TC_DXT1_Format: Tg, RGFormat: ZL, RGIntegerFormat: xw, RawShaderMaterial: YI, Ray: uf, Raycaster: SN, Rec709Primaries: ad, RectAreaLight: dN, RedFormat: KL, RedIntegerFormat: yw, ReinhardToneMapping: BL, RenderTarget: pI, RepeatWrapping: td, ReplaceStencilOp: b5, ReverseSubtractEquation: gL, RingGeometry: W_, SIGNED_RED_GREEN_RGTC2_Format: _S, SIGNED_RED_RGTC1_Format: mS, SRGBColorSpace: Xn, SRGBTransfer: Zt, Scene: Uw, ShaderChunk: yt, ShaderLib: Ss, ShaderMaterial: bs, ShadowMaterial: $I, Shape: zl, ShapeGeometry: X_, ShapePath: c7, ShapeUtils: no, ShortType: jL, Skeleton: D_, SkeletonHelper: Z9, SkinnedMesh: II, Source: Cl, Sphere: Ri, SphereGeometry: Yd, Spherical: j9, SphericalHarmonics3: pN, SplineCurve: Xw, SpotLight: uN, SpotLightHelper: K9, Sprite: PI, SpriteMaterial: kw, SrcAlphaFactor: f0, SrcAlphaSaturateFactor: TL, SrcColorFactor: yL, StaticCopyUsage: X5, StaticDrawUsage: ud, StaticReadUsage: H5, StereoCamera: E9, StreamCopyUsage: $5, StreamDrawUsage: V5, StreamReadUsage: W5, StringKeyframeTrack: su, SubtractEquation: mL, SubtractiveBlending: H1, TOUCH: _5, TangentSpaceNormalMap: Ga, TetrahedronGeometry: j_, Texture: Tn, TextureLoader: g9, TorusGeometry: $_, TorusKnotGeometry: Y_, Triangle: wr, TriangleFanDrawMode: T5, TriangleStripDrawMode: E5, TrianglesDrawMode: w5, TubeGeometry: q_, UVMapping: T_, Uint16BufferAttribute: Rw, Uint32BufferAttribute: Pw, Uint8BufferAttribute: CV, Uint8ClampedBufferAttribute: RV, Uniform: nE, UniformsGroup: G9, UniformsLib: Pe, UniformsUtils: _I, UnsignedByteType: to, UnsignedInt248Type: Ca, UnsignedIntType: Co, UnsignedShort4444Type: _w, UnsignedShort5551Type: vw, UnsignedShortType: A_, VSMShadowMap: vs, Vector2: _e, Vector3: V, Vector4: Gt, VectorKeyframeTrack: _d, VideoTexture: CW, WebGL1Renderer: CI, WebGL3DRenderTarget: pV, WebGLArrayRenderTarget: dV, WebGLCoordinateSystem: Ys, WebGLCubeRenderTarget: yI, WebGLMultipleRenderTargets: mV, WebGLRenderTarget: As, WebGLRenderer: Ow, WebGLUtils: AI, WebGPUCoordinateSystem: cd, WireframeGeometry: jI, WrapAroundEnding: sd, ZeroCurvatureEnding: Al, ZeroFactor: _L, ZeroSlopeEnding: bl, ZeroStencilOp: A5, _SRGBAFormat: p0, createCanvasElement: dI, sRGBEncoding: Pa }, Symbol.toStringTag, { value: "Module" }));
var wN = { exports: {} }, ou = {};
/**
* @license React
* react-reconciler-constants.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
ou.ConcurrentRoot = 1;
ou.ContinuousEventPriority = 4;
ou.DefaultEventPriority = 16;
ou.DiscreteEventPriority = 1;
ou.IdleEventPriority = 536870912;
ou.LegacyRoot = 0;
wN.exports = ou;
var yc = wN.exports;
function h7(n24) {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (f, h) => {
    const d = typeof f == "function" ? f(e) : f;
    if (d !== e) {
      const p = e;
      e = h ? d : Object.assign({}, e, d), t.forEach((g) => g(e, p));
    }
  }, r = () => e, s = (f, h = r, d = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let p = h(e);
    function g() {
      const v = h(e);
      if (!d(p, v)) {
        const S = p;
        f(p = v, S);
      }
    }
    return t.add(g), () => t.delete(g);
  }, l = { setState: i, getState: r, subscribe: (f, h, d) => h || d ? s(f, h, d) : (t.add(f), () => t.delete(f)), destroy: () => t.clear() };
  return e = n24(i, r, l), l;
}
const d7 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent), _2 = d7 ? ne.useEffect : ne.useLayoutEffect;
function p7(n24) {
  const e = typeof n24 == "function" ? h7(n24) : n24, t = (i = e.getState, r = Object.is) => {
    const [, s] = ne.useReducer((M) => M + 1, 0), o = e.getState(), a = ne.useRef(o), l = ne.useRef(i), f = ne.useRef(r), h = ne.useRef(false), d = ne.useRef();
    d.current === void 0 && (d.current = i(o));
    let p, g = false;
    (a.current !== o || l.current !== i || f.current !== r || h.current) && (p = i(o), g = !r(d.current, p)), _2(() => {
      g && (d.current = p), a.current = o, l.current = i, f.current = r, h.current = false;
    });
    const v = ne.useRef(o);
    _2(() => {
      const M = () => {
        try {
          const w = e.getState(), E = l.current(w);
          f.current(d.current, E) || (a.current = w, d.current = E, s());
        } catch {
          h.current = true, s();
        }
      }, m = e.subscribe(M);
      return e.getState() !== v.current && M(), m;
    }, []);
    const S = g ? p : d.current;
    return ne.useDebugValue(S), S;
  };
  return Object.assign(t, e), t[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const i = [t, e];
    return { next() {
      const r = i.length <= 0;
      return { value: i.shift(), done: r };
    } };
  }, t;
}
var EN = { exports: {} }, TN = { exports: {} }, AN = {};
/**
* @license React
* scheduler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
(function(n24) {
  function e(B, Y) {
    var $ = B.length;
    B.push(Y);
    e: for (; 0 < $; ) {
      var ee = $ - 1 >>> 1, ue = B[ee];
      if (0 < r(ue, Y)) B[ee] = Y, B[$] = ue, $ = ee;
      else break e;
    }
  }
  function t(B) {
    return B.length === 0 ? null : B[0];
  }
  function i(B) {
    if (B.length === 0) return null;
    var Y = B[0], $ = B.pop();
    if ($ !== Y) {
      B[0] = $;
      e: for (var ee = 0, ue = B.length, Ae = ue >>> 1; ee < Ae; ) {
        var te = 2 * (ee + 1) - 1, de = B[te], Ee = te + 1, Ie = B[Ee];
        if (0 > r(de, $)) Ee < ue && 0 > r(Ie, de) ? (B[ee] = Ie, B[Ee] = $, ee = Ee) : (B[ee] = de, B[te] = $, ee = te);
        else if (Ee < ue && 0 > r(Ie, $)) B[ee] = Ie, B[Ee] = $, ee = Ee;
        else break e;
      }
    }
    return Y;
  }
  function r(B, Y) {
    var $ = B.sortIndex - Y.sortIndex;
    return $ !== 0 ? $ : B.id - Y.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n24.unstable_now = function() {
      return s.now();
    };
  } else {
    var o = Date, a = o.now();
    n24.unstable_now = function() {
      return o.now() - a;
    };
  }
  var l = [], f = [], h = 1, d = null, p = 3, g = false, v = false, S = false, M = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, w = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function E(B) {
    for (var Y = t(f); Y !== null; ) {
      if (Y.callback === null) i(f);
      else if (Y.startTime <= B) i(f), Y.sortIndex = Y.expirationTime, e(l, Y);
      else break;
      Y = t(f);
    }
  }
  function A(B) {
    if (S = false, E(B), !v) if (t(l) !== null) v = true, q(P);
    else {
      var Y = t(f);
      Y !== null && ae(A, Y.startTime - B);
    }
  }
  function P(B, Y) {
    v = false, S && (S = false, m(D), D = -1), g = true;
    var $ = p;
    try {
      for (E(Y), d = t(l); d !== null && (!(d.expirationTime > Y) || B && !N()); ) {
        var ee = d.callback;
        if (typeof ee == "function") {
          d.callback = null, p = d.priorityLevel;
          var ue = ee(d.expirationTime <= Y);
          Y = n24.unstable_now(), typeof ue == "function" ? d.callback = ue : d === t(l) && i(l), E(Y);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var Ae = true;
      else {
        var te = t(f);
        te !== null && ae(A, te.startTime - Y), Ae = false;
      }
      return Ae;
    } finally {
      d = null, p = $, g = false;
    }
  }
  var R = false, L = null, D = -1, F = 5, C = -1;
  function N() {
    return !(n24.unstable_now() - C < F);
  }
  function j() {
    if (L !== null) {
      var B = n24.unstable_now();
      C = B;
      var Y = true;
      try {
        Y = L(true, B);
      } finally {
        Y ? Z() : (R = false, L = null);
      }
    } else R = false;
  }
  var Z;
  if (typeof w == "function") Z = function() {
    w(j);
  };
  else if (typeof MessageChannel < "u") {
    var G = new MessageChannel(), J = G.port2;
    G.port1.onmessage = j, Z = function() {
      J.postMessage(null);
    };
  } else Z = function() {
    M(j, 0);
  };
  function q(B) {
    L = B, R || (R = true, Z());
  }
  function ae(B, Y) {
    D = M(function() {
      B(n24.unstable_now());
    }, Y);
  }
  n24.unstable_IdlePriority = 5, n24.unstable_ImmediatePriority = 1, n24.unstable_LowPriority = 4, n24.unstable_NormalPriority = 3, n24.unstable_Profiling = null, n24.unstable_UserBlockingPriority = 2, n24.unstable_cancelCallback = function(B) {
    B.callback = null;
  }, n24.unstable_continueExecution = function() {
    v || g || (v = true, q(P));
  }, n24.unstable_forceFrameRate = function(B) {
    0 > B || 125 < B ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : F = 0 < B ? Math.floor(1e3 / B) : 5;
  }, n24.unstable_getCurrentPriorityLevel = function() {
    return p;
  }, n24.unstable_getFirstCallbackNode = function() {
    return t(l);
  }, n24.unstable_next = function(B) {
    switch (p) {
      case 1:
      case 2:
      case 3:
        var Y = 3;
        break;
      default:
        Y = p;
    }
    var $ = p;
    p = Y;
    try {
      return B();
    } finally {
      p = $;
    }
  }, n24.unstable_pauseExecution = function() {
  }, n24.unstable_requestPaint = function() {
  }, n24.unstable_runWithPriority = function(B, Y) {
    switch (B) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        B = 3;
    }
    var $ = p;
    p = B;
    try {
      return Y();
    } finally {
      p = $;
    }
  }, n24.unstable_scheduleCallback = function(B, Y, $) {
    var ee = n24.unstable_now();
    switch (typeof $ == "object" && $ !== null ? ($ = $.delay, $ = typeof $ == "number" && 0 < $ ? ee + $ : ee) : $ = ee, B) {
      case 1:
        var ue = -1;
        break;
      case 2:
        ue = 250;
        break;
      case 5:
        ue = 1073741823;
        break;
      case 4:
        ue = 1e4;
        break;
      default:
        ue = 5e3;
    }
    return ue = $ + ue, B = { id: h++, callback: Y, priorityLevel: B, startTime: $, expirationTime: ue, sortIndex: -1 }, $ > ee ? (B.sortIndex = $, e(f, B), t(l) === null && B === t(f) && (S ? (m(D), D = -1) : S = true, ae(A, $ - ee))) : (B.sortIndex = ue, e(l, B), v || g || (v = true, q(P))), B;
  }, n24.unstable_shouldYield = N, n24.unstable_wrapCallback = function(B) {
    var Y = p;
    return function() {
      var $ = p;
      p = Y;
      try {
        return B.apply(this, arguments);
      } finally {
        p = $;
      }
    };
  };
})(AN);
TN.exports = AN;
var PS = TN.exports;
/**
* @license React
* react-reconciler.production.min.js
*
* Copyright (c) Facebook, Inc. and its affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var m7 = function(e) {
  var t = {}, i = ne, r = PS, s = Object.assign;
  function o(u) {
    for (var c = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, _ = 1; _ < arguments.length; _++) c += "&args[]=" + encodeURIComponent(arguments[_]);
    return "Minified React error #" + u + "; visit " + c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, l = Symbol.for("react.element"), f = Symbol.for("react.portal"), h = Symbol.for("react.fragment"), d = Symbol.for("react.strict_mode"), p = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), v = Symbol.for("react.context"), S = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), m = Symbol.for("react.suspense_list"), w = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), A = Symbol.for("react.offscreen"), P = Symbol.iterator;
  function R(u) {
    return u === null || typeof u != "object" ? null : (u = P && u[P] || u["@@iterator"], typeof u == "function" ? u : null);
  }
  function L(u) {
    if (u == null) return null;
    if (typeof u == "function") return u.displayName || u.name || null;
    if (typeof u == "string") return u;
    switch (u) {
      case h:
        return "Fragment";
      case f:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case M:
        return "Suspense";
      case m:
        return "SuspenseList";
    }
    if (typeof u == "object") switch (u.$$typeof) {
      case v:
        return (u.displayName || "Context") + ".Consumer";
      case g:
        return (u._context.displayName || "Context") + ".Provider";
      case S:
        var c = u.render;
        return u = u.displayName, u || (u = c.displayName || c.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u;
      case w:
        return c = u.displayName || null, c !== null ? c : L(u.type) || "Memo";
      case E:
        c = u._payload, u = u._init;
        try {
          return L(u(c));
        } catch {
        }
    }
    return null;
  }
  function D(u) {
    var c = u.type;
    switch (u.tag) {
      case 24:
        return "Cache";
      case 9:
        return (c.displayName || "Context") + ".Consumer";
      case 10:
        return (c._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return u = c.render, u = u.displayName || u.name || "", c.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return c;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return L(c);
      case 8:
        return c === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof c == "function") return c.displayName || c.name || null;
        if (typeof c == "string") return c;
    }
    return null;
  }
  function F(u) {
    var c = u, _ = u;
    if (u.alternate) for (; c.return; ) c = c.return;
    else {
      u = c;
      do
        c = u, c.flags & 4098 && (_ = c.return), u = c.return;
      while (u);
    }
    return c.tag === 3 ? _ : null;
  }
  function C(u) {
    if (F(u) !== u) throw Error(o(188));
  }
  function N(u) {
    var c = u.alternate;
    if (!c) {
      if (c = F(u), c === null) throw Error(o(188));
      return c !== u ? null : u;
    }
    for (var _ = u, T = c; ; ) {
      var b = _.return;
      if (b === null) break;
      var I = b.alternate;
      if (I === null) {
        if (T = b.return, T !== null) {
          _ = T;
          continue;
        }
        break;
      }
      if (b.child === I.child) {
        for (I = b.child; I; ) {
          if (I === _) return C(b), u;
          if (I === T) return C(b), c;
          I = I.sibling;
        }
        throw Error(o(188));
      }
      if (_.return !== T.return) _ = b, T = I;
      else {
        for (var H = false, K = b.child; K; ) {
          if (K === _) {
            H = true, _ = b, T = I;
            break;
          }
          if (K === T) {
            H = true, T = b, _ = I;
            break;
          }
          K = K.sibling;
        }
        if (!H) {
          for (K = I.child; K; ) {
            if (K === _) {
              H = true, _ = I, T = b;
              break;
            }
            if (K === T) {
              H = true, T = I, _ = b;
              break;
            }
            K = K.sibling;
          }
          if (!H) throw Error(o(189));
        }
      }
      if (_.alternate !== T) throw Error(o(190));
    }
    if (_.tag !== 3) throw Error(o(188));
    return _.stateNode.current === _ ? u : c;
  }
  function j(u) {
    return u = N(u), u !== null ? Z(u) : null;
  }
  function Z(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      var c = Z(u);
      if (c !== null) return c;
      u = u.sibling;
    }
    return null;
  }
  function G(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      if (u.tag !== 4) {
        var c = G(u);
        if (c !== null) return c;
      }
      u = u.sibling;
    }
    return null;
  }
  var J = Array.isArray, q = e.getPublicInstance, ae = e.getRootHostContext, B = e.getChildHostContext, Y = e.prepareForCommit, $ = e.resetAfterCommit, ee = e.createInstance, ue = e.appendInitialChild, Ae = e.finalizeInitialChildren, te = e.prepareUpdate, de = e.shouldSetTextContent, Ee = e.createTextInstance, Ie = e.scheduleTimeout, Ze = e.cancelTimeout, Oe = e.noTimeout, at = e.isPrimaryRenderer, Ge = e.supportsMutation, X = e.supportsPersistence, Se = e.supportsHydration, pe = e.getInstanceFromNode, we = e.preparePortalMount, me = e.getCurrentEventPriority, qe = e.detachDeletedInstance, Ne = e.supportsMicrotasks, U = e.scheduleMicrotask, O = e.supportsTestSelectors, ie = e.findFiberRoot, xe = e.getBoundingRect, ve = e.getTextContent, ge = e.isHiddenSubtree, ze = e.matchAccessibilityRole, Le = e.setFocusIfFocusable, ke = e.setupIntersectionObserver, et = e.appendChild, Re = e.appendChildToContainer, ye = e.commitTextUpdate, bt = e.commitMount, gt = e.commitUpdate, ut = e.insertBefore, tt = e.insertInContainerBefore, je = e.removeChild, _t = e.removeChildFromContainer, Lt = e.resetTextContent, $t = e.hideInstance, Tt = e.hideTextInstance, Bt = e.unhideInstance, W = e.unhideTextInstance, be = e.clearContainer, Ce = e.cloneInstance, $e = e.createContainerChildSet, nt = e.appendChildToContainerChildSet, Ut = e.finalizeContainerChildren, Vt = e.replaceContainerChildren, Dn = e.cloneHiddenInstance, Ni = e.cloneHiddenTextInstance, jt = e.canHydrateInstance, oi = e.canHydrateTextInstance, kr = e.canHydrateSuspenseInstance, df = e.isSuspenseInstancePending, pf = e.isSuspenseInstanceFallback, lu = e.registerSuspenseInstanceRetry, Wo = e.getNextHydratableSibling, uu = e.getFirstHydratableChild, Jd = e.getFirstHydratableChildWithinContainer, Qd = e.getFirstHydratableChildWithinSuspenseInstance, nv = e.hydrateInstance, iv = e.hydrateTextInstance, rv = e.hydrateSuspenseInstance, k = e.getNextHydratableInstanceAfterSuspenseInstance, re = e.commitHydratedContainer, le = e.commitHydratedSuspenseInstance, ce = e.clearSuspenseBoundary, oe = e.clearSuspenseBoundaryFromContainer, Fe = e.shouldDeleteUnhydratedTailInstances, Je = e.didNotMatchHydratedContainerTextInstance, rt = e.didNotMatchHydratedTextInstance, st;
  function ft(u) {
    if (st === void 0) try {
      throw Error();
    } catch (_) {
      var c = _.stack.trim().match(/\n( *(at )?)/);
      st = c && c[1] || "";
    }
    return `
` + st + u;
  }
  var ct = false;
  function ht(u, c) {
    if (!u || ct) return "";
    ct = true;
    var _ = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (c) if (c = function() {
        throw Error();
      }, Object.defineProperty(c.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(c, []);
        } catch (Te) {
          var T = Te;
        }
        Reflect.construct(u, [], c);
      } else {
        try {
          c.call();
        } catch (Te) {
          T = Te;
        }
        u.call(c.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Te) {
          T = Te;
        }
        u();
      }
    } catch (Te) {
      if (Te && T && typeof Te.stack == "string") {
        for (var b = Te.stack.split(`
`), I = T.stack.split(`
`), H = b.length - 1, K = I.length - 1; 1 <= H && 0 <= K && b[H] !== I[K]; ) K--;
        for (; 1 <= H && 0 <= K; H--, K--) if (b[H] !== I[K]) {
          if (H !== 1 || K !== 1) do
            if (H--, K--, 0 > K || b[H] !== I[K]) {
              var he = `
` + b[H].replace(" at new ", " at ");
              return u.displayName && he.includes("<anonymous>") && (he = he.replace("<anonymous>", u.displayName)), he;
            }
          while (1 <= H && 0 <= K);
          break;
        }
      }
    } finally {
      ct = false, Error.prepareStackTrace = _;
    }
    return (u = u ? u.displayName || u.name : "") ? ft(u) : "";
  }
  var ln = Object.prototype.hasOwnProperty, ai = [], Qt = -1;
  function qn(u) {
    return { current: u };
  }
  function ot(u) {
    0 > Qt || (u.current = ai[Qt], ai[Qt] = null, Qt--);
  }
  function We(u, c) {
    Qt++, ai[Qt] = u.current, u.current = c;
  }
  var Fr = {}, wt = qn(Fr), _n = qn(false), Ps = Fr;
  function zr(u, c) {
    var _ = u.type.contextTypes;
    if (!_) return Fr;
    var T = u.stateNode;
    if (T && T.__reactInternalMemoizedUnmaskedChildContext === c) return T.__reactInternalMemoizedMaskedChildContext;
    var b = {}, I;
    for (I in _) b[I] = c[I];
    return T && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = c, u.__reactInternalMemoizedMaskedChildContext = b), b;
  }
  function Kn(u) {
    return u = u.childContextTypes, u != null;
  }
  function An() {
    ot(_n), ot(wt);
  }
  function Ls(u, c, _) {
    if (wt.current !== Fr) throw Error(o(168));
    We(wt, c), We(_n, _);
  }
  function cu(u, c, _) {
    var T = u.stateNode;
    if (c = c.childContextTypes, typeof T.getChildContext != "function") return _;
    T = T.getChildContext();
    for (var b in T) if (!(b in c)) throw Error(o(108, D(u) || "Unknown", b));
    return s({}, _, T);
  }
  function li(u) {
    return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || Fr, Ps = wt.current, We(wt, u), We(_n, _n.current), true;
  }
  function fu(u, c, _) {
    var T = u.stateNode;
    if (!T) throw Error(o(169));
    _ ? (u = cu(u, c, Ps), T.__reactInternalMemoizedMergedChildContext = u, ot(_n), ot(wt), We(wt, u)) : ot(_n), We(_n, _);
  }
  var hr = Math.clz32 ? Math.clz32 : KD, ep = Math.log, qD = Math.LN2;
  function KD(u) {
    return u >>>= 0, u === 0 ? 32 : 31 - (ep(u) / qD | 0) | 0;
  }
  var tp = 64, np = 4194304;
  function mf(u) {
    switch (u & -u) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return u & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return u;
    }
  }
  function ip(u, c) {
    var _ = u.pendingLanes;
    if (_ === 0) return 0;
    var T = 0, b = u.suspendedLanes, I = u.pingedLanes, H = _ & 268435455;
    if (H !== 0) {
      var K = H & ~b;
      K !== 0 ? T = mf(K) : (I &= H, I !== 0 && (T = mf(I)));
    } else H = _ & ~b, H !== 0 ? T = mf(H) : I !== 0 && (T = mf(I));
    if (T === 0) return 0;
    if (c !== 0 && c !== T && !(c & b) && (b = T & -T, I = c & -c, b >= I || b === 16 && (I & 4194240) !== 0)) return c;
    if (T & 4 && (T |= _ & 16), c = u.entangledLanes, c !== 0) for (u = u.entanglements, c &= T; 0 < c; ) _ = 31 - hr(c), b = 1 << _, T |= u[_], c &= ~b;
    return T;
  }
  function ZD(u, c) {
    switch (u) {
      case 1:
      case 2:
      case 4:
        return c + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return c + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function JD(u, c) {
    for (var _ = u.suspendedLanes, T = u.pingedLanes, b = u.expirationTimes, I = u.pendingLanes; 0 < I; ) {
      var H = 31 - hr(I), K = 1 << H, he = b[H];
      he === -1 ? (!(K & _) || K & T) && (b[H] = ZD(K, c)) : he <= c && (u.expiredLanes |= K), I &= ~K;
    }
  }
  function sv(u) {
    return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0;
  }
  function ov(u) {
    for (var c = [], _ = 0; 31 > _; _++) c.push(u);
    return c;
  }
  function gf(u, c, _) {
    u.pendingLanes |= c, c !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, c = 31 - hr(c), u[c] = _;
  }
  function QD(u, c) {
    var _ = u.pendingLanes & ~c;
    u.pendingLanes = c, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= c, u.mutableReadLanes &= c, u.entangledLanes &= c, c = u.entanglements;
    var T = u.eventTimes;
    for (u = u.expirationTimes; 0 < _; ) {
      var b = 31 - hr(_), I = 1 << b;
      c[b] = 0, T[b] = -1, u[b] = -1, _ &= ~I;
    }
  }
  function av(u, c) {
    var _ = u.entangledLanes |= c;
    for (u = u.entanglements; _; ) {
      var T = 31 - hr(_), b = 1 << T;
      b & c | u[T] & c && (u[T] |= c), _ &= ~b;
    }
  }
  var It = 0;
  function TE(u) {
    return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var lv = r.unstable_scheduleCallback, AE = r.unstable_cancelCallback, eO = r.unstable_shouldYield, tO = r.unstable_requestPaint, Zn = r.unstable_now, uv = r.unstable_ImmediatePriority, nO = r.unstable_UserBlockingPriority, cv = r.unstable_NormalPriority, iO = r.unstable_IdlePriority, rp = null, Is = null;
  function rO(u) {
    if (Is && typeof Is.onCommitFiberRoot == "function") try {
      Is.onCommitFiberRoot(rp, u, void 0, (u.current.flags & 128) === 128);
    } catch {
    }
  }
  function sO(u, c) {
    return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c;
  }
  var Ns = typeof Object.is == "function" ? Object.is : sO, lo = null, sp = false, fv = false;
  function bE(u) {
    lo === null ? lo = [u] : lo.push(u);
  }
  function oO(u) {
    sp = true, bE(u);
  }
  function Ds() {
    if (!fv && lo !== null) {
      fv = true;
      var u = 0, c = It;
      try {
        var _ = lo;
        for (It = 1; u < _.length; u++) {
          var T = _[u];
          do
            T = T(true);
          while (T !== null);
        }
        lo = null, sp = false;
      } catch (b) {
        throw lo !== null && (lo = lo.slice(u + 1)), lv(uv, Ds), b;
      } finally {
        It = c, fv = false;
      }
    }
    return null;
  }
  var aO = a.ReactCurrentBatchConfig;
  function op(u, c) {
    if (Ns(u, c)) return true;
    if (typeof u != "object" || u === null || typeof c != "object" || c === null) return false;
    var _ = Object.keys(u), T = Object.keys(c);
    if (_.length !== T.length) return false;
    for (T = 0; T < _.length; T++) {
      var b = _[T];
      if (!ln.call(c, b) || !Ns(u[b], c[b])) return false;
    }
    return true;
  }
  function lO(u) {
    switch (u.tag) {
      case 5:
        return ft(u.type);
      case 16:
        return ft("Lazy");
      case 13:
        return ft("Suspense");
      case 19:
        return ft("SuspenseList");
      case 0:
      case 2:
      case 15:
        return u = ht(u.type, false), u;
      case 11:
        return u = ht(u.type.render, false), u;
      case 1:
        return u = ht(u.type, true), u;
      default:
        return "";
    }
  }
  function fs(u, c) {
    if (u && u.defaultProps) {
      c = s({}, c), u = u.defaultProps;
      for (var _ in u) c[_] === void 0 && (c[_] = u[_]);
      return c;
    }
    return c;
  }
  var ap = qn(null), lp = null, hu = null, hv = null;
  function dv() {
    hv = hu = lp = null;
  }
  function CE(u, c, _) {
    at ? (We(ap, c._currentValue), c._currentValue = _) : (We(ap, c._currentValue2), c._currentValue2 = _);
  }
  function pv(u) {
    var c = ap.current;
    ot(ap), at ? u._currentValue = c : u._currentValue2 = c;
  }
  function mv(u, c, _) {
    for (; u !== null; ) {
      var T = u.alternate;
      if ((u.childLanes & c) !== c ? (u.childLanes |= c, T !== null && (T.childLanes |= c)) : T !== null && (T.childLanes & c) !== c && (T.childLanes |= c), u === _) break;
      u = u.return;
    }
  }
  function du(u, c) {
    lp = u, hv = hu = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & c && (mr = true), u.firstContext = null);
  }
  function Br(u) {
    var c = at ? u._currentValue : u._currentValue2;
    if (hv !== u) if (u = { context: u, memoizedValue: c, next: null }, hu === null) {
      if (lp === null) throw Error(o(308));
      hu = u, lp.dependencies = { lanes: 0, firstContext: u };
    } else hu = hu.next = u;
    return c;
  }
  var Os = null, Xo = false;
  function gv(u) {
    u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function RE(u, c) {
    u = u.updateQueue, c.updateQueue === u && (c.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects });
  }
  function uo(u, c) {
    return { eventTime: u, lane: c, tag: 0, payload: null, callback: null, next: null };
  }
  function jo(u, c) {
    var _ = u.updateQueue;
    _ !== null && (_ = _.shared, On !== null && u.mode & 1 && !(Et & 2) ? (u = _.interleaved, u === null ? (c.next = c, Os === null ? Os = [_] : Os.push(_)) : (c.next = u.next, u.next = c), _.interleaved = c) : (u = _.pending, u === null ? c.next = c : (c.next = u.next, u.next = c), _.pending = c));
  }
  function up(u, c, _) {
    if (c = c.updateQueue, c !== null && (c = c.shared, (_ & 4194240) !== 0)) {
      var T = c.lanes;
      T &= u.pendingLanes, _ |= T, c.lanes = _, av(u, _);
    }
  }
  function PE(u, c) {
    var _ = u.updateQueue, T = u.alternate;
    if (T !== null && (T = T.updateQueue, _ === T)) {
      var b = null, I = null;
      if (_ = _.firstBaseUpdate, _ !== null) {
        do {
          var H = { eventTime: _.eventTime, lane: _.lane, tag: _.tag, payload: _.payload, callback: _.callback, next: null };
          I === null ? b = I = H : I = I.next = H, _ = _.next;
        } while (_ !== null);
        I === null ? b = I = c : I = I.next = c;
      } else b = I = c;
      _ = { baseState: T.baseState, firstBaseUpdate: b, lastBaseUpdate: I, shared: T.shared, effects: T.effects }, u.updateQueue = _;
      return;
    }
    u = _.lastBaseUpdate, u === null ? _.firstBaseUpdate = c : u.next = c, _.lastBaseUpdate = c;
  }
  function cp(u, c, _, T) {
    var b = u.updateQueue;
    Xo = false;
    var I = b.firstBaseUpdate, H = b.lastBaseUpdate, K = b.shared.pending;
    if (K !== null) {
      b.shared.pending = null;
      var he = K, Te = he.next;
      he.next = null, H === null ? I = Te : H.next = Te, H = he;
      var Xe = u.alternate;
      Xe !== null && (Xe = Xe.updateQueue, K = Xe.lastBaseUpdate, K !== H && (K === null ? Xe.firstBaseUpdate = Te : K.next = Te, Xe.lastBaseUpdate = he));
    }
    if (I !== null) {
      var pt = b.baseState;
      H = 0, Xe = Te = he = null, K = I;
      do {
        var it = K.lane, Yt = K.eventTime;
        if ((T & it) === it) {
          Xe !== null && (Xe = Xe.next = { eventTime: Yt, lane: 0, tag: K.tag, payload: K.payload, callback: K.callback, next: null });
          e: {
            var Qe = u, vi = K;
            switch (it = c, Yt = _, vi.tag) {
              case 1:
                if (Qe = vi.payload, typeof Qe == "function") {
                  pt = Qe.call(Yt, pt, it);
                  break e;
                }
                pt = Qe;
                break e;
              case 3:
                Qe.flags = Qe.flags & -65537 | 128;
              case 0:
                if (Qe = vi.payload, it = typeof Qe == "function" ? Qe.call(Yt, pt, it) : Qe, it == null) break e;
                pt = s({}, pt, it);
                break e;
              case 2:
                Xo = true;
            }
          }
          K.callback !== null && K.lane !== 0 && (u.flags |= 64, it = b.effects, it === null ? b.effects = [K] : it.push(K));
        } else Yt = { eventTime: Yt, lane: it, tag: K.tag, payload: K.payload, callback: K.callback, next: null }, Xe === null ? (Te = Xe = Yt, he = pt) : Xe = Xe.next = Yt, H |= it;
        if (K = K.next, K === null) {
          if (K = b.shared.pending, K === null) break;
          it = K, K = it.next, it.next = null, b.lastBaseUpdate = it, b.shared.pending = null;
        }
      } while (true);
      if (Xe === null && (he = pt), b.baseState = he, b.firstBaseUpdate = Te, b.lastBaseUpdate = Xe, c = b.shared.interleaved, c !== null) {
        b = c;
        do
          H |= b.lane, b = b.next;
        while (b !== c);
      } else I === null && (b.shared.lanes = 0);
      Mu |= H, u.lanes = H, u.memoizedState = pt;
    }
  }
  function LE(u, c, _) {
    if (u = c.effects, c.effects = null, u !== null) for (c = 0; c < u.length; c++) {
      var T = u[c], b = T.callback;
      if (b !== null) {
        if (T.callback = null, T = _, typeof b != "function") throw Error(o(191, b));
        b.call(T);
      }
    }
  }
  var IE = new i.Component().refs;
  function _v(u, c, _, T) {
    c = u.memoizedState, _ = _(T, c), _ = _ == null ? c : s({}, c, _), u.memoizedState = _, u.lanes === 0 && (u.updateQueue.baseState = _);
  }
  var fp = { isMounted: function(u) {
    return (u = u._reactInternals) ? F(u) === u : false;
  }, enqueueSetState: function(u, c, _) {
    u = u._reactInternals;
    var T = Oi(), b = qo(u), I = uo(T, b);
    I.payload = c, _ != null && (I.callback = _), jo(u, I), c = Xr(u, b, T), c !== null && up(c, u, b);
  }, enqueueReplaceState: function(u, c, _) {
    u = u._reactInternals;
    var T = Oi(), b = qo(u), I = uo(T, b);
    I.tag = 1, I.payload = c, _ != null && (I.callback = _), jo(u, I), c = Xr(u, b, T), c !== null && up(c, u, b);
  }, enqueueForceUpdate: function(u, c) {
    u = u._reactInternals;
    var _ = Oi(), T = qo(u), b = uo(_, T);
    b.tag = 2, c != null && (b.callback = c), jo(u, b), c = Xr(u, T, _), c !== null && up(c, u, T);
  } };
  function NE(u, c, _, T, b, I, H) {
    return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(T, I, H) : c.prototype && c.prototype.isPureReactComponent ? !op(_, T) || !op(b, I) : true;
  }
  function DE(u, c, _) {
    var T = false, b = Fr, I = c.contextType;
    return typeof I == "object" && I !== null ? I = Br(I) : (b = Kn(c) ? Ps : wt.current, T = c.contextTypes, I = (T = T != null) ? zr(u, b) : Fr), c = new c(_, I), u.memoizedState = c.state !== null && c.state !== void 0 ? c.state : null, c.updater = fp, u.stateNode = c, c._reactInternals = u, T && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = b, u.__reactInternalMemoizedMaskedChildContext = I), c;
  }
  function OE(u, c, _, T) {
    u = c.state, typeof c.componentWillReceiveProps == "function" && c.componentWillReceiveProps(_, T), typeof c.UNSAFE_componentWillReceiveProps == "function" && c.UNSAFE_componentWillReceiveProps(_, T), c.state !== u && fp.enqueueReplaceState(c, c.state, null);
  }
  function vv(u, c, _, T) {
    var b = u.stateNode;
    b.props = _, b.state = u.memoizedState, b.refs = IE, gv(u);
    var I = c.contextType;
    typeof I == "object" && I !== null ? b.context = Br(I) : (I = Kn(c) ? Ps : wt.current, b.context = zr(u, I)), b.state = u.memoizedState, I = c.getDerivedStateFromProps, typeof I == "function" && (_v(u, c, I, _), b.state = u.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof b.getSnapshotBeforeUpdate == "function" || typeof b.UNSAFE_componentWillMount != "function" && typeof b.componentWillMount != "function" || (c = b.state, typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount(), c !== b.state && fp.enqueueReplaceState(b, b.state, null), cp(u, _, b, T), b.state = u.memoizedState), typeof b.componentDidMount == "function" && (u.flags |= 4194308);
  }
  var pu = [], mu = 0, hp = null, dp = 0, Vr = [], Hr = 0, Ya = null, co = 1, fo = "";
  function qa(u, c) {
    pu[mu++] = dp, pu[mu++] = hp, hp = u, dp = c;
  }
  function UE(u, c, _) {
    Vr[Hr++] = co, Vr[Hr++] = fo, Vr[Hr++] = Ya, Ya = u;
    var T = co;
    u = fo;
    var b = 32 - hr(T) - 1;
    T &= ~(1 << b), _ += 1;
    var I = 32 - hr(c) + b;
    if (30 < I) {
      var H = b - b % 5;
      I = (T & (1 << H) - 1).toString(32), T >>= H, b -= H, co = 1 << 32 - hr(c) + b | _ << b | T, fo = I + u;
    } else co = 1 << I | _ << b | T, fo = u;
  }
  function yv(u) {
    u.return !== null && (qa(u, 1), UE(u, 1, 0));
  }
  function xv(u) {
    for (; u === hp; ) hp = pu[--mu], pu[mu] = null, dp = pu[--mu], pu[mu] = null;
    for (; u === Ya; ) Ya = Vr[--Hr], Vr[Hr] = null, fo = Vr[--Hr], Vr[Hr] = null, co = Vr[--Hr], Vr[Hr] = null;
  }
  var dr = null, pr = null, rn = false, _f = false, hs = null;
  function kE(u, c) {
    var _ = jr(5, null, null, 0);
    _.elementType = "DELETED", _.stateNode = c, _.return = u, c = u.deletions, c === null ? (u.deletions = [_], u.flags |= 16) : c.push(_);
  }
  function FE(u, c) {
    switch (u.tag) {
      case 5:
        return c = jt(c, u.type, u.pendingProps), c !== null ? (u.stateNode = c, dr = u, pr = uu(c), true) : false;
      case 6:
        return c = oi(c, u.pendingProps), c !== null ? (u.stateNode = c, dr = u, pr = null, true) : false;
      case 13:
        if (c = kr(c), c !== null) {
          var _ = Ya !== null ? { id: co, overflow: fo } : null;
          return u.memoizedState = { dehydrated: c, treeContext: _, retryLane: 1073741824 }, _ = jr(18, null, null, 0), _.stateNode = c, _.return = u, u.child = _, dr = u, pr = null, true;
        }
        return false;
      default:
        return false;
    }
  }
  function Sv(u) {
    return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
  }
  function Mv(u) {
    if (rn) {
      var c = pr;
      if (c) {
        var _ = c;
        if (!FE(u, c)) {
          if (Sv(u)) throw Error(o(418));
          c = Wo(_);
          var T = dr;
          c && FE(u, c) ? kE(T, _) : (u.flags = u.flags & -4097 | 2, rn = false, dr = u);
        }
      } else {
        if (Sv(u)) throw Error(o(418));
        u.flags = u.flags & -4097 | 2, rn = false, dr = u;
      }
    }
  }
  function zE(u) {
    for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; ) u = u.return;
    dr = u;
  }
  function vf(u) {
    if (!Se || u !== dr) return false;
    if (!rn) return zE(u), rn = true, false;
    if (u.tag !== 3 && (u.tag !== 5 || Fe(u.type) && !de(u.type, u.memoizedProps))) {
      var c = pr;
      if (c) {
        if (Sv(u)) {
          for (u = pr; u; ) u = Wo(u);
          throw Error(o(418));
        }
        for (; c; ) kE(u, c), c = Wo(c);
      }
    }
    if (zE(u), u.tag === 13) {
      if (!Se) throw Error(o(316));
      if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317));
      pr = k(u);
    } else pr = dr ? Wo(u.stateNode) : null;
    return true;
  }
  function gu() {
    Se && (pr = dr = null, _f = rn = false);
  }
  function wv(u) {
    hs === null ? hs = [u] : hs.push(u);
  }
  function yf(u, c, _) {
    if (u = _.ref, u !== null && typeof u != "function" && typeof u != "object") {
      if (_._owner) {
        if (_ = _._owner, _) {
          if (_.tag !== 1) throw Error(o(309));
          var T = _.stateNode;
        }
        if (!T) throw Error(o(147, u));
        var b = T, I = "" + u;
        return c !== null && c.ref !== null && typeof c.ref == "function" && c.ref._stringRef === I ? c.ref : (c = function(H) {
          var K = b.refs;
          K === IE && (K = b.refs = {}), H === null ? delete K[I] : K[I] = H;
        }, c._stringRef = I, c);
      }
      if (typeof u != "string") throw Error(o(284));
      if (!_._owner) throw Error(o(290, u));
    }
    return u;
  }
  function pp(u, c) {
    throw u = Object.prototype.toString.call(c), Error(o(31, u === "[object Object]" ? "object with keys {" + Object.keys(c).join(", ") + "}" : u));
  }
  function BE(u) {
    var c = u._init;
    return c(u._payload);
  }
  function VE(u) {
    function c(se, Q) {
      if (u) {
        var fe = se.deletions;
        fe === null ? (se.deletions = [Q], se.flags |= 16) : fe.push(Q);
      }
    }
    function _(se, Q) {
      if (!u) return null;
      for (; Q !== null; ) c(se, Q), Q = Q.sibling;
      return null;
    }
    function T(se, Q) {
      for (se = /* @__PURE__ */ new Map(); Q !== null; ) Q.key !== null ? se.set(Q.key, Q) : se.set(Q.index, Q), Q = Q.sibling;
      return se;
    }
    function b(se, Q) {
      return se = Zo(se, Q), se.index = 0, se.sibling = null, se;
    }
    function I(se, Q, fe) {
      return se.index = fe, u ? (fe = se.alternate, fe !== null ? (fe = fe.index, fe < Q ? (se.flags |= 2, Q) : fe) : (se.flags |= 2, Q)) : (se.flags |= 1048576, Q);
    }
    function H(se) {
      return u && se.alternate === null && (se.flags |= 2), se;
    }
    function K(se, Q, fe, Ue) {
      return Q === null || Q.tag !== 6 ? (Q = oy(fe, se.mode, Ue), Q.return = se, Q) : (Q = b(Q, fe), Q.return = se, Q);
    }
    function he(se, Q, fe, Ue) {
      var Ke = fe.type;
      return Ke === h ? Xe(se, Q, fe.props.children, Ue, fe.key) : Q !== null && (Q.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === E && BE(Ke) === Q.type) ? (Ue = b(Q, fe.props), Ue.ref = yf(se, Q, fe), Ue.return = se, Ue) : (Ue = Xp(fe.type, fe.key, fe.props, null, se.mode, Ue), Ue.ref = yf(se, Q, fe), Ue.return = se, Ue);
    }
    function Te(se, Q, fe, Ue) {
      return Q === null || Q.tag !== 4 || Q.stateNode.containerInfo !== fe.containerInfo || Q.stateNode.implementation !== fe.implementation ? (Q = ay(fe, se.mode, Ue), Q.return = se, Q) : (Q = b(Q, fe.children || []), Q.return = se, Q);
    }
    function Xe(se, Q, fe, Ue, Ke) {
      return Q === null || Q.tag !== 7 ? (Q = nl(fe, se.mode, Ue, Ke), Q.return = se, Q) : (Q = b(Q, fe), Q.return = se, Q);
    }
    function pt(se, Q, fe) {
      if (typeof Q == "string" && Q !== "" || typeof Q == "number") return Q = oy("" + Q, se.mode, fe), Q.return = se, Q;
      if (typeof Q == "object" && Q !== null) {
        switch (Q.$$typeof) {
          case l:
            return fe = Xp(Q.type, Q.key, Q.props, null, se.mode, fe), fe.ref = yf(se, null, Q), fe.return = se, fe;
          case f:
            return Q = ay(Q, se.mode, fe), Q.return = se, Q;
          case E:
            var Ue = Q._init;
            return pt(se, Ue(Q._payload), fe);
        }
        if (J(Q) || R(Q)) return Q = nl(Q, se.mode, fe, null), Q.return = se, Q;
        pp(se, Q);
      }
      return null;
    }
    function it(se, Q, fe, Ue) {
      var Ke = Q !== null ? Q.key : null;
      if (typeof fe == "string" && fe !== "" || typeof fe == "number") return Ke !== null ? null : K(se, Q, "" + fe, Ue);
      if (typeof fe == "object" && fe !== null) {
        switch (fe.$$typeof) {
          case l:
            return fe.key === Ke ? he(se, Q, fe, Ue) : null;
          case f:
            return fe.key === Ke ? Te(se, Q, fe, Ue) : null;
          case E:
            return Ke = fe._init, it(se, Q, Ke(fe._payload), Ue);
        }
        if (J(fe) || R(fe)) return Ke !== null ? null : Xe(se, Q, fe, Ue, null);
        pp(se, fe);
      }
      return null;
    }
    function Yt(se, Q, fe, Ue, Ke) {
      if (typeof Ue == "string" && Ue !== "" || typeof Ue == "number") return se = se.get(fe) || null, K(Q, se, "" + Ue, Ke);
      if (typeof Ue == "object" && Ue !== null) {
        switch (Ue.$$typeof) {
          case l:
            return se = se.get(Ue.key === null ? fe : Ue.key) || null, he(Q, se, Ue, Ke);
          case f:
            return se = se.get(Ue.key === null ? fe : Ue.key) || null, Te(Q, se, Ue, Ke);
          case E:
            var St = Ue._init;
            return Yt(se, Q, fe, St(Ue._payload), Ke);
        }
        if (J(Ue) || R(Ue)) return se = se.get(fe) || null, Xe(Q, se, Ue, Ke, null);
        pp(Q, Ue);
      }
      return null;
    }
    function Qe(se, Q, fe, Ue) {
      for (var Ke = null, St = null, mt = Q, Nt = Q = 0, Qn = null; mt !== null && Nt < fe.length; Nt++) {
        mt.index > Nt ? (Qn = mt, mt = null) : Qn = mt.sibling;
        var Dt = it(se, mt, fe[Nt], Ue);
        if (Dt === null) {
          mt === null && (mt = Qn);
          break;
        }
        u && mt && Dt.alternate === null && c(se, mt), Q = I(Dt, Q, Nt), St === null ? Ke = Dt : St.sibling = Dt, St = Dt, mt = Qn;
      }
      if (Nt === fe.length) return _(se, mt), rn && qa(se, Nt), Ke;
      if (mt === null) {
        for (; Nt < fe.length; Nt++) mt = pt(se, fe[Nt], Ue), mt !== null && (Q = I(mt, Q, Nt), St === null ? Ke = mt : St.sibling = mt, St = mt);
        return rn && qa(se, Nt), Ke;
      }
      for (mt = T(se, mt); Nt < fe.length; Nt++) Qn = Yt(mt, se, Nt, fe[Nt], Ue), Qn !== null && (u && Qn.alternate !== null && mt.delete(Qn.key === null ? Nt : Qn.key), Q = I(Qn, Q, Nt), St === null ? Ke = Qn : St.sibling = Qn, St = Qn);
      return u && mt.forEach(function(Jo) {
        return c(se, Jo);
      }), rn && qa(se, Nt), Ke;
    }
    function vi(se, Q, fe, Ue) {
      var Ke = R(fe);
      if (typeof Ke != "function") throw Error(o(150));
      if (fe = Ke.call(fe), fe == null) throw Error(o(151));
      for (var St = Ke = null, mt = Q, Nt = Q = 0, Qn = null, Dt = fe.next(); mt !== null && !Dt.done; Nt++, Dt = fe.next()) {
        mt.index > Nt ? (Qn = mt, mt = null) : Qn = mt.sibling;
        var Jo = it(se, mt, Dt.value, Ue);
        if (Jo === null) {
          mt === null && (mt = Qn);
          break;
        }
        u && mt && Jo.alternate === null && c(se, mt), Q = I(Jo, Q, Nt), St === null ? Ke = Jo : St.sibling = Jo, St = Jo, mt = Qn;
      }
      if (Dt.done) return _(se, mt), rn && qa(se, Nt), Ke;
      if (mt === null) {
        for (; !Dt.done; Nt++, Dt = fe.next()) Dt = pt(se, Dt.value, Ue), Dt !== null && (Q = I(Dt, Q, Nt), St === null ? Ke = Dt : St.sibling = Dt, St = Dt);
        return rn && qa(se, Nt), Ke;
      }
      for (mt = T(se, mt); !Dt.done; Nt++, Dt = fe.next()) Dt = Yt(mt, se, Nt, Dt.value, Ue), Dt !== null && (u && Dt.alternate !== null && mt.delete(Dt.key === null ? Nt : Dt.key), Q = I(Dt, Q, Nt), St === null ? Ke = Dt : St.sibling = Dt, St = Dt);
      return u && mt.forEach(function(FO) {
        return c(se, FO);
      }), rn && qa(se, Nt), Ke;
    }
    function $r(se, Q, fe, Ue) {
      if (typeof fe == "object" && fe !== null && fe.type === h && fe.key === null && (fe = fe.props.children), typeof fe == "object" && fe !== null) {
        switch (fe.$$typeof) {
          case l:
            e: {
              for (var Ke = fe.key, St = Q; St !== null; ) {
                if (St.key === Ke) {
                  if (Ke = fe.type, Ke === h) {
                    if (St.tag === 7) {
                      _(se, St.sibling), Q = b(St, fe.props.children), Q.return = se, se = Q;
                      break e;
                    }
                  } else if (St.elementType === Ke || typeof Ke == "object" && Ke !== null && Ke.$$typeof === E && BE(Ke) === St.type) {
                    _(se, St.sibling), Q = b(St, fe.props), Q.ref = yf(se, St, fe), Q.return = se, se = Q;
                    break e;
                  }
                  _(se, St);
                  break;
                } else c(se, St);
                St = St.sibling;
              }
              fe.type === h ? (Q = nl(fe.props.children, se.mode, Ue, fe.key), Q.return = se, se = Q) : (Ue = Xp(fe.type, fe.key, fe.props, null, se.mode, Ue), Ue.ref = yf(se, Q, fe), Ue.return = se, se = Ue);
            }
            return H(se);
          case f:
            e: {
              for (St = fe.key; Q !== null; ) {
                if (Q.key === St) if (Q.tag === 4 && Q.stateNode.containerInfo === fe.containerInfo && Q.stateNode.implementation === fe.implementation) {
                  _(se, Q.sibling), Q = b(Q, fe.children || []), Q.return = se, se = Q;
                  break e;
                } else {
                  _(se, Q);
                  break;
                }
                else c(se, Q);
                Q = Q.sibling;
              }
              Q = ay(fe, se.mode, Ue), Q.return = se, se = Q;
            }
            return H(se);
          case E:
            return St = fe._init, $r(se, Q, St(fe._payload), Ue);
        }
        if (J(fe)) return Qe(se, Q, fe, Ue);
        if (R(fe)) return vi(se, Q, fe, Ue);
        pp(se, fe);
      }
      return typeof fe == "string" && fe !== "" || typeof fe == "number" ? (fe = "" + fe, Q !== null && Q.tag === 6 ? (_(se, Q.sibling), Q = b(Q, fe), Q.return = se, se = Q) : (_(se, Q), Q = oy(fe, se.mode, Ue), Q.return = se, se = Q), H(se)) : _(se, Q);
    }
    return $r;
  }
  var _u = VE(true), HE = VE(false), xf = {}, Gr = qn(xf), Sf = qn(xf), vu = qn(xf);
  function Us(u) {
    if (u === xf) throw Error(o(174));
    return u;
  }
  function Ev(u, c) {
    We(vu, c), We(Sf, u), We(Gr, xf), u = ae(c), ot(Gr), We(Gr, u);
  }
  function yu() {
    ot(Gr), ot(Sf), ot(vu);
  }
  function GE(u) {
    var c = Us(vu.current), _ = Us(Gr.current);
    c = B(_, u.type, c), _ !== c && (We(Sf, u), We(Gr, c));
  }
  function Tv(u) {
    Sf.current === u && (ot(Gr), ot(Sf));
  }
  var un = qn(0);
  function mp(u) {
    for (var c = u; c !== null; ) {
      if (c.tag === 13) {
        var _ = c.memoizedState;
        if (_ !== null && (_ = _.dehydrated, _ === null || df(_) || pf(_))) return c;
      } else if (c.tag === 19 && c.memoizedProps.revealOrder !== void 0) {
        if (c.flags & 128) return c;
      } else if (c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === u) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === u) return null;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
    return null;
  }
  var Av = [];
  function bv() {
    for (var u = 0; u < Av.length; u++) {
      var c = Av[u];
      at ? c._workInProgressVersionPrimary = null : c._workInProgressVersionSecondary = null;
    }
    Av.length = 0;
  }
  var gp = a.ReactCurrentDispatcher, Wr = a.ReactCurrentBatchConfig, xu = 0, vn = null, mi = null, Jn = null, _p = false, Mf = false, wf = 0, uO = 0;
  function gi() {
    throw Error(o(321));
  }
  function Cv(u, c) {
    if (c === null) return false;
    for (var _ = 0; _ < c.length && _ < u.length; _++) if (!Ns(u[_], c[_])) return false;
    return true;
  }
  function Rv(u, c, _, T, b, I) {
    if (xu = I, vn = c, c.memoizedState = null, c.updateQueue = null, c.lanes = 0, gp.current = u === null || u.memoizedState === null ? dO : pO, u = _(T, b), Mf) {
      I = 0;
      do {
        if (Mf = false, wf = 0, 25 <= I) throw Error(o(301));
        I += 1, Jn = mi = null, c.updateQueue = null, gp.current = mO, u = _(T, b);
      } while (Mf);
    }
    if (gp.current = Mp, c = mi !== null && mi.next !== null, xu = 0, Jn = mi = vn = null, _p = false, c) throw Error(o(300));
    return u;
  }
  function Pv() {
    var u = wf !== 0;
    return wf = 0, u;
  }
  function ho() {
    var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Jn === null ? vn.memoizedState = Jn = u : Jn = Jn.next = u, Jn;
  }
  function ks() {
    if (mi === null) {
      var u = vn.alternate;
      u = u !== null ? u.memoizedState : null;
    } else u = mi.next;
    var c = Jn === null ? vn.memoizedState : Jn.next;
    if (c !== null) Jn = c, mi = u;
    else {
      if (u === null) throw Error(o(310));
      mi = u, u = { memoizedState: mi.memoizedState, baseState: mi.baseState, baseQueue: mi.baseQueue, queue: mi.queue, next: null }, Jn === null ? vn.memoizedState = Jn = u : Jn = Jn.next = u;
    }
    return Jn;
  }
  function Ka(u, c) {
    return typeof c == "function" ? c(u) : c;
  }
  function vp(u) {
    var c = ks(), _ = c.queue;
    if (_ === null) throw Error(o(311));
    _.lastRenderedReducer = u;
    var T = mi, b = T.baseQueue, I = _.pending;
    if (I !== null) {
      if (b !== null) {
        var H = b.next;
        b.next = I.next, I.next = H;
      }
      T.baseQueue = b = I, _.pending = null;
    }
    if (b !== null) {
      I = b.next, T = T.baseState;
      var K = H = null, he = null, Te = I;
      do {
        var Xe = Te.lane;
        if ((xu & Xe) === Xe) he !== null && (he = he.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), T = Te.hasEagerState ? Te.eagerState : u(T, Te.action);
        else {
          var pt = { lane: Xe, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null };
          he === null ? (K = he = pt, H = T) : he = he.next = pt, vn.lanes |= Xe, Mu |= Xe;
        }
        Te = Te.next;
      } while (Te !== null && Te !== I);
      he === null ? H = T : he.next = K, Ns(T, c.memoizedState) || (mr = true), c.memoizedState = T, c.baseState = H, c.baseQueue = he, _.lastRenderedState = T;
    }
    if (u = _.interleaved, u !== null) {
      b = u;
      do
        I = b.lane, vn.lanes |= I, Mu |= I, b = b.next;
      while (b !== u);
    } else b === null && (_.lanes = 0);
    return [c.memoizedState, _.dispatch];
  }
  function yp(u) {
    var c = ks(), _ = c.queue;
    if (_ === null) throw Error(o(311));
    _.lastRenderedReducer = u;
    var T = _.dispatch, b = _.pending, I = c.memoizedState;
    if (b !== null) {
      _.pending = null;
      var H = b = b.next;
      do
        I = u(I, H.action), H = H.next;
      while (H !== b);
      Ns(I, c.memoizedState) || (mr = true), c.memoizedState = I, c.baseQueue === null && (c.baseState = I), _.lastRenderedState = I;
    }
    return [I, T];
  }
  function WE() {
  }
  function XE(u, c) {
    var _ = vn, T = ks(), b = c(), I = !Ns(T.memoizedState, b);
    if (I && (T.memoizedState = b, mr = true), T = T.queue, Tf(YE.bind(null, _, T, u), [u]), T.getSnapshot !== c || I || Jn !== null && Jn.memoizedState.tag & 1) {
      if (_.flags |= 2048, Ef(9, $E.bind(null, _, T, b, c), void 0, null), On === null) throw Error(o(349));
      xu & 30 || jE(_, c, b);
    }
    return b;
  }
  function jE(u, c, _) {
    u.flags |= 16384, u = { getSnapshot: c, value: _ }, c = vn.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, vn.updateQueue = c, c.stores = [u]) : (_ = c.stores, _ === null ? c.stores = [u] : _.push(u));
  }
  function $E(u, c, _, T) {
    c.value = _, c.getSnapshot = T, qE(c) && Xr(u, 1, -1);
  }
  function YE(u, c, _) {
    return _(function() {
      qE(c) && Xr(u, 1, -1);
    });
  }
  function qE(u) {
    var c = u.getSnapshot;
    u = u.value;
    try {
      var _ = c();
      return !Ns(u, _);
    } catch {
      return true;
    }
  }
  function Lv(u) {
    var c = ho();
    return typeof u == "function" && (u = u()), c.memoizedState = c.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Ka, lastRenderedState: u }, c.queue = u, u = u.dispatch = hO.bind(null, vn, u), [c.memoizedState, u];
  }
  function Ef(u, c, _, T) {
    return u = { tag: u, create: c, destroy: _, deps: T, next: null }, c = vn.updateQueue, c === null ? (c = { lastEffect: null, stores: null }, vn.updateQueue = c, c.lastEffect = u.next = u) : (_ = c.lastEffect, _ === null ? c.lastEffect = u.next = u : (T = _.next, _.next = u, u.next = T, c.lastEffect = u)), u;
  }
  function KE() {
    return ks().memoizedState;
  }
  function xp(u, c, _, T) {
    var b = ho();
    vn.flags |= u, b.memoizedState = Ef(1 | c, _, void 0, T === void 0 ? null : T);
  }
  function Sp(u, c, _, T) {
    var b = ks();
    T = T === void 0 ? null : T;
    var I = void 0;
    if (mi !== null) {
      var H = mi.memoizedState;
      if (I = H.destroy, T !== null && Cv(T, H.deps)) {
        b.memoizedState = Ef(c, _, I, T);
        return;
      }
    }
    vn.flags |= u, b.memoizedState = Ef(1 | c, _, I, T);
  }
  function Iv(u, c) {
    return xp(8390656, 8, u, c);
  }
  function Tf(u, c) {
    return Sp(2048, 8, u, c);
  }
  function ZE(u, c) {
    return Sp(4, 2, u, c);
  }
  function JE(u, c) {
    return Sp(4, 4, u, c);
  }
  function QE(u, c) {
    if (typeof c == "function") return u = u(), c(u), function() {
      c(null);
    };
    if (c != null) return u = u(), c.current = u, function() {
      c.current = null;
    };
  }
  function eT(u, c, _) {
    return _ = _ != null ? _.concat([u]) : null, Sp(4, 4, QE.bind(null, c, u), _);
  }
  function Nv() {
  }
  function tT(u, c) {
    var _ = ks();
    c = c === void 0 ? null : c;
    var T = _.memoizedState;
    return T !== null && c !== null && Cv(c, T[1]) ? T[0] : (_.memoizedState = [u, c], u);
  }
  function nT(u, c) {
    var _ = ks();
    c = c === void 0 ? null : c;
    var T = _.memoizedState;
    return T !== null && c !== null && Cv(c, T[1]) ? T[0] : (u = u(), _.memoizedState = [u, c], u);
  }
  function cO(u, c) {
    var _ = It;
    It = _ !== 0 && 4 > _ ? _ : 4, u(true);
    var T = Wr.transition;
    Wr.transition = {};
    try {
      u(false), c();
    } finally {
      It = _, Wr.transition = T;
    }
  }
  function iT() {
    return ks().memoizedState;
  }
  function fO(u, c, _) {
    var T = qo(u);
    _ = { lane: T, action: _, hasEagerState: false, eagerState: null, next: null }, rT(u) ? sT(c, _) : (oT(u, c, _), _ = Oi(), u = Xr(u, T, _), u !== null && aT(u, c, T));
  }
  function hO(u, c, _) {
    var T = qo(u), b = { lane: T, action: _, hasEagerState: false, eagerState: null, next: null };
    if (rT(u)) sT(c, b);
    else {
      oT(u, c, b);
      var I = u.alternate;
      if (u.lanes === 0 && (I === null || I.lanes === 0) && (I = c.lastRenderedReducer, I !== null)) try {
        var H = c.lastRenderedState, K = I(H, _);
        if (b.hasEagerState = true, b.eagerState = K, Ns(K, H)) return;
      } catch {
      } finally {
      }
      _ = Oi(), u = Xr(u, T, _), u !== null && aT(u, c, T);
    }
  }
  function rT(u) {
    var c = u.alternate;
    return u === vn || c !== null && c === vn;
  }
  function sT(u, c) {
    Mf = _p = true;
    var _ = u.pending;
    _ === null ? c.next = c : (c.next = _.next, _.next = c), u.pending = c;
  }
  function oT(u, c, _) {
    On !== null && u.mode & 1 && !(Et & 2) ? (u = c.interleaved, u === null ? (_.next = _, Os === null ? Os = [c] : Os.push(c)) : (_.next = u.next, u.next = _), c.interleaved = _) : (u = c.pending, u === null ? _.next = _ : (_.next = u.next, u.next = _), c.pending = _);
  }
  function aT(u, c, _) {
    if (_ & 4194240) {
      var T = c.lanes;
      T &= u.pendingLanes, _ |= T, c.lanes = _, av(u, _);
    }
  }
  var Mp = { readContext: Br, useCallback: gi, useContext: gi, useEffect: gi, useImperativeHandle: gi, useInsertionEffect: gi, useLayoutEffect: gi, useMemo: gi, useReducer: gi, useRef: gi, useState: gi, useDebugValue: gi, useDeferredValue: gi, useTransition: gi, useMutableSource: gi, useSyncExternalStore: gi, useId: gi, unstable_isNewReconciler: false }, dO = { readContext: Br, useCallback: function(u, c) {
    return ho().memoizedState = [u, c === void 0 ? null : c], u;
  }, useContext: Br, useEffect: Iv, useImperativeHandle: function(u, c, _) {
    return _ = _ != null ? _.concat([u]) : null, xp(4194308, 4, QE.bind(null, c, u), _);
  }, useLayoutEffect: function(u, c) {
    return xp(4194308, 4, u, c);
  }, useInsertionEffect: function(u, c) {
    return xp(4, 2, u, c);
  }, useMemo: function(u, c) {
    var _ = ho();
    return c = c === void 0 ? null : c, u = u(), _.memoizedState = [u, c], u;
  }, useReducer: function(u, c, _) {
    var T = ho();
    return c = _ !== void 0 ? _(c) : c, T.memoizedState = T.baseState = c, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: c }, T.queue = u, u = u.dispatch = fO.bind(null, vn, u), [T.memoizedState, u];
  }, useRef: function(u) {
    var c = ho();
    return u = { current: u }, c.memoizedState = u;
  }, useState: Lv, useDebugValue: Nv, useDeferredValue: function(u) {
    var c = Lv(u), _ = c[0], T = c[1];
    return Iv(function() {
      var b = Wr.transition;
      Wr.transition = {};
      try {
        T(u);
      } finally {
        Wr.transition = b;
      }
    }, [u]), _;
  }, useTransition: function() {
    var u = Lv(false), c = u[0];
    return u = cO.bind(null, u[1]), ho().memoizedState = u, [c, u];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(u, c, _) {
    var T = vn, b = ho();
    if (rn) {
      if (_ === void 0) throw Error(o(407));
      _ = _();
    } else {
      if (_ = c(), On === null) throw Error(o(349));
      xu & 30 || jE(T, c, _);
    }
    b.memoizedState = _;
    var I = { value: _, getSnapshot: c };
    return b.queue = I, Iv(YE.bind(null, T, I, u), [u]), T.flags |= 2048, Ef(9, $E.bind(null, T, I, _, c), void 0, null), _;
  }, useId: function() {
    var u = ho(), c = On.identifierPrefix;
    if (rn) {
      var _ = fo, T = co;
      _ = (T & ~(1 << 32 - hr(T) - 1)).toString(32) + _, c = ":" + c + "R" + _, _ = wf++, 0 < _ && (c += "H" + _.toString(32)), c += ":";
    } else _ = uO++, c = ":" + c + "r" + _.toString(32) + ":";
    return u.memoizedState = c;
  }, unstable_isNewReconciler: false }, pO = { readContext: Br, useCallback: tT, useContext: Br, useEffect: Tf, useImperativeHandle: eT, useInsertionEffect: ZE, useLayoutEffect: JE, useMemo: nT, useReducer: vp, useRef: KE, useState: function() {
    return vp(Ka);
  }, useDebugValue: Nv, useDeferredValue: function(u) {
    var c = vp(Ka), _ = c[0], T = c[1];
    return Tf(function() {
      var b = Wr.transition;
      Wr.transition = {};
      try {
        T(u);
      } finally {
        Wr.transition = b;
      }
    }, [u]), _;
  }, useTransition: function() {
    var u = vp(Ka)[0], c = ks().memoizedState;
    return [u, c];
  }, useMutableSource: WE, useSyncExternalStore: XE, useId: iT, unstable_isNewReconciler: false }, mO = { readContext: Br, useCallback: tT, useContext: Br, useEffect: Tf, useImperativeHandle: eT, useInsertionEffect: ZE, useLayoutEffect: JE, useMemo: nT, useReducer: yp, useRef: KE, useState: function() {
    return yp(Ka);
  }, useDebugValue: Nv, useDeferredValue: function(u) {
    var c = yp(Ka), _ = c[0], T = c[1];
    return Tf(function() {
      var b = Wr.transition;
      Wr.transition = {};
      try {
        T(u);
      } finally {
        Wr.transition = b;
      }
    }, [u]), _;
  }, useTransition: function() {
    var u = yp(Ka)[0], c = ks().memoizedState;
    return [u, c];
  }, useMutableSource: WE, useSyncExternalStore: XE, useId: iT, unstable_isNewReconciler: false };
  function Dv(u, c) {
    try {
      var _ = "", T = c;
      do
        _ += lO(T), T = T.return;
      while (T);
      var b = _;
    } catch (I) {
      b = `
Error generating stack: ` + I.message + `
` + I.stack;
    }
    return { value: u, source: c, stack: b };
  }
  function Ov(u, c) {
    try {
      console.error(c.value);
    } catch (_) {
      setTimeout(function() {
        throw _;
      });
    }
  }
  var gO = typeof WeakMap == "function" ? WeakMap : Map;
  function lT(u, c, _) {
    _ = uo(-1, _), _.tag = 3, _.payload = { element: null };
    var T = c.value;
    return _.callback = function() {
      Fp || (Fp = true, Qv = T), Ov(u, c);
    }, _;
  }
  function uT(u, c, _) {
    _ = uo(-1, _), _.tag = 3;
    var T = u.type.getDerivedStateFromError;
    if (typeof T == "function") {
      var b = c.value;
      _.payload = function() {
        return T(b);
      }, _.callback = function() {
        Ov(u, c);
      };
    }
    var I = u.stateNode;
    return I !== null && typeof I.componentDidCatch == "function" && (_.callback = function() {
      Ov(u, c), typeof T != "function" && ($o === null ? $o = /* @__PURE__ */ new Set([this]) : $o.add(this));
      var H = c.stack;
      this.componentDidCatch(c.value, { componentStack: H !== null ? H : "" });
    }), _;
  }
  function cT(u, c, _) {
    var T = u.pingCache;
    if (T === null) {
      T = u.pingCache = new gO();
      var b = /* @__PURE__ */ new Set();
      T.set(c, b);
    } else b = T.get(c), b === void 0 && (b = /* @__PURE__ */ new Set(), T.set(c, b));
    b.has(_) || (b.add(_), u = PO.bind(null, u, c, _), c.then(u, u));
  }
  function fT(u) {
    do {
      var c;
      if ((c = u.tag === 13) && (c = u.memoizedState, c = c !== null ? c.dehydrated !== null : true), c) return u;
      u = u.return;
    } while (u !== null);
    return null;
  }
  function hT(u, c, _, T, b) {
    return u.mode & 1 ? (u.flags |= 65536, u.lanes = b, u) : (u === c ? u.flags |= 65536 : (u.flags |= 128, _.flags |= 131072, _.flags &= -52805, _.tag === 1 && (_.alternate === null ? _.tag = 17 : (c = uo(-1, 1), c.tag = 2, jo(_, c))), _.lanes |= 1), u);
  }
  function Fs(u) {
    u.flags |= 4;
  }
  function dT(u, c) {
    if (u !== null && u.child === c.child) return true;
    if (c.flags & 16) return false;
    for (u = c.child; u !== null; ) {
      if (u.flags & 12854 || u.subtreeFlags & 12854) return false;
      u = u.sibling;
    }
    return true;
  }
  var Af, bf, wp, Ep;
  if (Ge) Af = function(u, c) {
    for (var _ = c.child; _ !== null; ) {
      if (_.tag === 5 || _.tag === 6) ue(u, _.stateNode);
      else if (_.tag !== 4 && _.child !== null) {
        _.child.return = _, _ = _.child;
        continue;
      }
      if (_ === c) break;
      for (; _.sibling === null; ) {
        if (_.return === null || _.return === c) return;
        _ = _.return;
      }
      _.sibling.return = _.return, _ = _.sibling;
    }
  }, bf = function() {
  }, wp = function(u, c, _, T, b) {
    if (u = u.memoizedProps, u !== T) {
      var I = c.stateNode, H = Us(Gr.current);
      _ = te(I, _, u, T, b, H), (c.updateQueue = _) && Fs(c);
    }
  }, Ep = function(u, c, _, T) {
    _ !== T && Fs(c);
  };
  else if (X) {
    Af = function(u, c, _, T) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var I = b.stateNode;
          _ && T && (I = Dn(I, b.type, b.memoizedProps, b)), ue(u, I);
        } else if (b.tag === 6) I = b.stateNode, _ && T && (I = Ni(I, b.memoizedProps, b)), ue(u, I);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null) I = b.child, I !== null && (I.return = b), Af(u, b, true, true);
          else if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    };
    var pT = function(u, c, _, T) {
      for (var b = c.child; b !== null; ) {
        if (b.tag === 5) {
          var I = b.stateNode;
          _ && T && (I = Dn(I, b.type, b.memoizedProps, b)), nt(u, I);
        } else if (b.tag === 6) I = b.stateNode, _ && T && (I = Ni(I, b.memoizedProps, b)), nt(u, I);
        else if (b.tag !== 4) {
          if (b.tag === 22 && b.memoizedState !== null) I = b.child, I !== null && (I.return = b), pT(u, b, true, true);
          else if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === c) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === c) return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    };
    bf = function(u, c) {
      var _ = c.stateNode;
      if (!dT(u, c)) {
        u = _.containerInfo;
        var T = $e(u);
        pT(T, c, false, false), _.pendingChildren = T, Fs(c), Ut(u, T);
      }
    }, wp = function(u, c, _, T, b) {
      var I = u.stateNode, H = u.memoizedProps;
      if ((u = dT(u, c)) && H === T) c.stateNode = I;
      else {
        var K = c.stateNode, he = Us(Gr.current), Te = null;
        H !== T && (Te = te(K, _, H, T, b, he)), u && Te === null ? c.stateNode = I : (I = Ce(I, Te, _, H, T, c, u, K), Ae(I, _, T, b, he) && Fs(c), c.stateNode = I, u ? Fs(c) : Af(I, c, false, false));
      }
    }, Ep = function(u, c, _, T) {
      _ !== T ? (u = Us(vu.current), _ = Us(Gr.current), c.stateNode = Ee(T, u, _, c), Fs(c)) : c.stateNode = u.stateNode;
    };
  } else bf = function() {
  }, wp = function() {
  }, Ep = function() {
  };
  function Cf(u, c) {
    if (!rn) switch (u.tailMode) {
      case "hidden":
        c = u.tail;
        for (var _ = null; c !== null; ) c.alternate !== null && (_ = c), c = c.sibling;
        _ === null ? u.tail = null : _.sibling = null;
        break;
      case "collapsed":
        _ = u.tail;
        for (var T = null; _ !== null; ) _.alternate !== null && (T = _), _ = _.sibling;
        T === null ? c || u.tail === null ? u.tail = null : u.tail.sibling = null : T.sibling = null;
    }
  }
  function _i(u) {
    var c = u.alternate !== null && u.alternate.child === u.child, _ = 0, T = 0;
    if (c) for (var b = u.child; b !== null; ) _ |= b.lanes | b.childLanes, T |= b.subtreeFlags & 14680064, T |= b.flags & 14680064, b.return = u, b = b.sibling;
    else for (b = u.child; b !== null; ) _ |= b.lanes | b.childLanes, T |= b.subtreeFlags, T |= b.flags, b.return = u, b = b.sibling;
    return u.subtreeFlags |= T, u.childLanes = _, c;
  }
  function _O(u, c, _) {
    var T = c.pendingProps;
    switch (xv(c), c.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return _i(c), null;
      case 1:
        return Kn(c.type) && An(), _i(c), null;
      case 3:
        return T = c.stateNode, yu(), ot(_n), ot(wt), bv(), T.pendingContext && (T.context = T.pendingContext, T.pendingContext = null), (u === null || u.child === null) && (vf(c) ? Fs(c) : u === null || u.memoizedState.isDehydrated && !(c.flags & 256) || (c.flags |= 1024, hs !== null && (ny(hs), hs = null))), bf(u, c), _i(c), null;
      case 5:
        Tv(c), _ = Us(vu.current);
        var b = c.type;
        if (u !== null && c.stateNode != null) wp(u, c, b, T, _), u.ref !== c.ref && (c.flags |= 512, c.flags |= 2097152);
        else {
          if (!T) {
            if (c.stateNode === null) throw Error(o(166));
            return _i(c), null;
          }
          if (u = Us(Gr.current), vf(c)) {
            if (!Se) throw Error(o(175));
            u = nv(c.stateNode, c.type, c.memoizedProps, _, u, c, !_f), c.updateQueue = u, u !== null && Fs(c);
          } else {
            var I = ee(b, T, _, u, c);
            Af(I, c, false, false), c.stateNode = I, Ae(I, b, T, _, u) && Fs(c);
          }
          c.ref !== null && (c.flags |= 512, c.flags |= 2097152);
        }
        return _i(c), null;
      case 6:
        if (u && c.stateNode != null) Ep(u, c, u.memoizedProps, T);
        else {
          if (typeof T != "string" && c.stateNode === null) throw Error(o(166));
          if (u = Us(vu.current), _ = Us(Gr.current), vf(c)) {
            if (!Se) throw Error(o(176));
            if (u = c.stateNode, T = c.memoizedProps, (_ = iv(u, T, c, !_f)) && (b = dr, b !== null)) switch (I = (b.mode & 1) !== 0, b.tag) {
              case 3:
                Je(b.stateNode.containerInfo, u, T, I);
                break;
              case 5:
                rt(b.type, b.memoizedProps, b.stateNode, u, T, I);
            }
            _ && Fs(c);
          } else c.stateNode = Ee(T, u, _, c);
        }
        return _i(c), null;
      case 13:
        if (ot(un), T = c.memoizedState, rn && pr !== null && c.mode & 1 && !(c.flags & 128)) {
          for (u = pr; u; ) u = Wo(u);
          return gu(), c.flags |= 98560, c;
        }
        if (T !== null && T.dehydrated !== null) {
          if (T = vf(c), u === null) {
            if (!T) throw Error(o(318));
            if (!Se) throw Error(o(344));
            if (u = c.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(o(317));
            rv(u, c);
          } else gu(), !(c.flags & 128) && (c.memoizedState = null), c.flags |= 4;
          return _i(c), null;
        }
        return hs !== null && (ny(hs), hs = null), c.flags & 128 ? (c.lanes = _, c) : (T = T !== null, _ = false, u === null ? vf(c) : _ = u.memoizedState !== null, T && !_ && (c.child.flags |= 8192, c.mode & 1 && (u === null || un.current & 1 ? Gn === 0 && (Gn = 3) : ry())), c.updateQueue !== null && (c.flags |= 4), _i(c), null);
      case 4:
        return yu(), bf(u, c), u === null && we(c.stateNode.containerInfo), _i(c), null;
      case 10:
        return pv(c.type._context), _i(c), null;
      case 17:
        return Kn(c.type) && An(), _i(c), null;
      case 19:
        if (ot(un), b = c.memoizedState, b === null) return _i(c), null;
        if (T = (c.flags & 128) !== 0, I = b.rendering, I === null) if (T) Cf(b, false);
        else {
          if (Gn !== 0 || u !== null && u.flags & 128) for (u = c.child; u !== null; ) {
            if (I = mp(u), I !== null) {
              for (c.flags |= 128, Cf(b, false), u = I.updateQueue, u !== null && (c.updateQueue = u, c.flags |= 4), c.subtreeFlags = 0, u = _, T = c.child; T !== null; ) _ = T, b = u, _.flags &= 14680066, I = _.alternate, I === null ? (_.childLanes = 0, _.lanes = b, _.child = null, _.subtreeFlags = 0, _.memoizedProps = null, _.memoizedState = null, _.updateQueue = null, _.dependencies = null, _.stateNode = null) : (_.childLanes = I.childLanes, _.lanes = I.lanes, _.child = I.child, _.subtreeFlags = 0, _.deletions = null, _.memoizedProps = I.memoizedProps, _.memoizedState = I.memoizedState, _.updateQueue = I.updateQueue, _.type = I.type, b = I.dependencies, _.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext }), T = T.sibling;
              return We(un, un.current & 1 | 2), c.child;
            }
            u = u.sibling;
          }
          b.tail !== null && Zn() > Jv && (c.flags |= 128, T = true, Cf(b, false), c.lanes = 4194304);
        }
        else {
          if (!T) if (u = mp(I), u !== null) {
            if (c.flags |= 128, T = true, u = u.updateQueue, u !== null && (c.updateQueue = u, c.flags |= 4), Cf(b, true), b.tail === null && b.tailMode === "hidden" && !I.alternate && !rn) return _i(c), null;
          } else 2 * Zn() - b.renderingStartTime > Jv && _ !== 1073741824 && (c.flags |= 128, T = true, Cf(b, false), c.lanes = 4194304);
          b.isBackwards ? (I.sibling = c.child, c.child = I) : (u = b.last, u !== null ? u.sibling = I : c.child = I, b.last = I);
        }
        return b.tail !== null ? (c = b.tail, b.rendering = c, b.tail = c.sibling, b.renderingStartTime = Zn(), c.sibling = null, u = un.current, We(un, T ? u & 1 | 2 : u & 1), c) : (_i(c), null);
      case 22:
      case 23:
        return iy(), T = c.memoizedState !== null, u !== null && u.memoizedState !== null !== T && (c.flags |= 8192), T && c.mode & 1 ? gr & 1073741824 && (_i(c), Ge && c.subtreeFlags & 6 && (c.flags |= 8192)) : _i(c), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, c.tag));
  }
  var vO = a.ReactCurrentOwner, mr = false;
  function Di(u, c, _, T) {
    c.child = u === null ? HE(c, null, _, T) : _u(c, u.child, _, T);
  }
  function mT(u, c, _, T, b) {
    _ = _.render;
    var I = c.ref;
    return du(c, b), T = Rv(u, c, _, T, I, b), _ = Pv(), u !== null && !mr ? (c.updateQueue = u.updateQueue, c.flags &= -2053, u.lanes &= ~b, po(u, c, b)) : (rn && _ && yv(c), c.flags |= 1, Di(u, c, T, b), c.child);
  }
  function gT(u, c, _, T, b) {
    if (u === null) {
      var I = _.type;
      return typeof I == "function" && !sy(I) && I.defaultProps === void 0 && _.compare === null && _.defaultProps === void 0 ? (c.tag = 15, c.type = I, _T(u, c, I, T, b)) : (u = Xp(_.type, null, T, c, c.mode, b), u.ref = c.ref, u.return = c, c.child = u);
    }
    if (I = u.child, !(u.lanes & b)) {
      var H = I.memoizedProps;
      if (_ = _.compare, _ = _ !== null ? _ : op, _(H, T) && u.ref === c.ref) return po(u, c, b);
    }
    return c.flags |= 1, u = Zo(I, T), u.ref = c.ref, u.return = c, c.child = u;
  }
  function _T(u, c, _, T, b) {
    if (u !== null && op(u.memoizedProps, T) && u.ref === c.ref) if (mr = false, (u.lanes & b) !== 0) u.flags & 131072 && (mr = true);
    else return c.lanes = u.lanes, po(u, c, b);
    return Uv(u, c, _, T, b);
  }
  function vT(u, c, _) {
    var T = c.pendingProps, b = T.children, I = u !== null ? u.memoizedState : null;
    if (T.mode === "hidden") if (!(c.mode & 1)) c.memoizedState = { baseLanes: 0, cachePool: null }, We(Su, gr), gr |= _;
    else if (_ & 1073741824) c.memoizedState = { baseLanes: 0, cachePool: null }, T = I !== null ? I.baseLanes : _, We(Su, gr), gr |= T;
    else return u = I !== null ? I.baseLanes | _ : _, c.lanes = c.childLanes = 1073741824, c.memoizedState = { baseLanes: u, cachePool: null }, c.updateQueue = null, We(Su, gr), gr |= u, null;
    else I !== null ? (T = I.baseLanes | _, c.memoizedState = null) : T = _, We(Su, gr), gr |= T;
    return Di(u, c, b, _), c.child;
  }
  function yT(u, c) {
    var _ = c.ref;
    (u === null && _ !== null || u !== null && u.ref !== _) && (c.flags |= 512, c.flags |= 2097152);
  }
  function Uv(u, c, _, T, b) {
    var I = Kn(_) ? Ps : wt.current;
    return I = zr(c, I), du(c, b), _ = Rv(u, c, _, T, I, b), T = Pv(), u !== null && !mr ? (c.updateQueue = u.updateQueue, c.flags &= -2053, u.lanes &= ~b, po(u, c, b)) : (rn && T && yv(c), c.flags |= 1, Di(u, c, _, b), c.child);
  }
  function xT(u, c, _, T, b) {
    if (Kn(_)) {
      var I = true;
      li(c);
    } else I = false;
    if (du(c, b), c.stateNode === null) u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), DE(c, _, T), vv(c, _, T, b), T = true;
    else if (u === null) {
      var H = c.stateNode, K = c.memoizedProps;
      H.props = K;
      var he = H.context, Te = _.contextType;
      typeof Te == "object" && Te !== null ? Te = Br(Te) : (Te = Kn(_) ? Ps : wt.current, Te = zr(c, Te));
      var Xe = _.getDerivedStateFromProps, pt = typeof Xe == "function" || typeof H.getSnapshotBeforeUpdate == "function";
      pt || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (K !== T || he !== Te) && OE(c, H, T, Te), Xo = false;
      var it = c.memoizedState;
      H.state = it, cp(c, T, H, b), he = c.memoizedState, K !== T || it !== he || _n.current || Xo ? (typeof Xe == "function" && (_v(c, _, Xe, T), he = c.memoizedState), (K = Xo || NE(c, _, K, T, it, he, Te)) ? (pt || typeof H.UNSAFE_componentWillMount != "function" && typeof H.componentWillMount != "function" || (typeof H.componentWillMount == "function" && H.componentWillMount(), typeof H.UNSAFE_componentWillMount == "function" && H.UNSAFE_componentWillMount()), typeof H.componentDidMount == "function" && (c.flags |= 4194308)) : (typeof H.componentDidMount == "function" && (c.flags |= 4194308), c.memoizedProps = T, c.memoizedState = he), H.props = T, H.state = he, H.context = Te, T = K) : (typeof H.componentDidMount == "function" && (c.flags |= 4194308), T = false);
    } else {
      H = c.stateNode, RE(u, c), K = c.memoizedProps, Te = c.type === c.elementType ? K : fs(c.type, K), H.props = Te, pt = c.pendingProps, it = H.context, he = _.contextType, typeof he == "object" && he !== null ? he = Br(he) : (he = Kn(_) ? Ps : wt.current, he = zr(c, he));
      var Yt = _.getDerivedStateFromProps;
      (Xe = typeof Yt == "function" || typeof H.getSnapshotBeforeUpdate == "function") || typeof H.UNSAFE_componentWillReceiveProps != "function" && typeof H.componentWillReceiveProps != "function" || (K !== pt || it !== he) && OE(c, H, T, he), Xo = false, it = c.memoizedState, H.state = it, cp(c, T, H, b);
      var Qe = c.memoizedState;
      K !== pt || it !== Qe || _n.current || Xo ? (typeof Yt == "function" && (_v(c, _, Yt, T), Qe = c.memoizedState), (Te = Xo || NE(c, _, Te, T, it, Qe, he) || false) ? (Xe || typeof H.UNSAFE_componentWillUpdate != "function" && typeof H.componentWillUpdate != "function" || (typeof H.componentWillUpdate == "function" && H.componentWillUpdate(T, Qe, he), typeof H.UNSAFE_componentWillUpdate == "function" && H.UNSAFE_componentWillUpdate(T, Qe, he)), typeof H.componentDidUpdate == "function" && (c.flags |= 4), typeof H.getSnapshotBeforeUpdate == "function" && (c.flags |= 1024)) : (typeof H.componentDidUpdate != "function" || K === u.memoizedProps && it === u.memoizedState || (c.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || K === u.memoizedProps && it === u.memoizedState || (c.flags |= 1024), c.memoizedProps = T, c.memoizedState = Qe), H.props = T, H.state = Qe, H.context = he, T = Te) : (typeof H.componentDidUpdate != "function" || K === u.memoizedProps && it === u.memoizedState || (c.flags |= 4), typeof H.getSnapshotBeforeUpdate != "function" || K === u.memoizedProps && it === u.memoizedState || (c.flags |= 1024), T = false);
    }
    return kv(u, c, _, T, I, b);
  }
  function kv(u, c, _, T, b, I) {
    yT(u, c);
    var H = (c.flags & 128) !== 0;
    if (!T && !H) return b && fu(c, _, false), po(u, c, I);
    T = c.stateNode, vO.current = c;
    var K = H && typeof _.getDerivedStateFromError != "function" ? null : T.render();
    return c.flags |= 1, u !== null && H ? (c.child = _u(c, u.child, null, I), c.child = _u(c, null, K, I)) : Di(u, c, K, I), c.memoizedState = T.state, b && fu(c, _, true), c.child;
  }
  function ST(u) {
    var c = u.stateNode;
    c.pendingContext ? Ls(u, c.pendingContext, c.pendingContext !== c.context) : c.context && Ls(u, c.context, false), Ev(u, c.containerInfo);
  }
  function MT(u, c, _, T, b) {
    return gu(), wv(b), c.flags |= 256, Di(u, c, _, T), c.child;
  }
  var Tp = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ap(u) {
    return { baseLanes: u, cachePool: null };
  }
  function wT(u, c, _) {
    var T = c.pendingProps, b = un.current, I = false, H = (c.flags & 128) !== 0, K;
    if ((K = H) || (K = u !== null && u.memoizedState === null ? false : (b & 2) !== 0), K ? (I = true, c.flags &= -129) : (u === null || u.memoizedState !== null) && (b |= 1), We(un, b & 1), u === null) return Mv(c), u = c.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (c.mode & 1 ? pf(u) ? c.lanes = 8 : c.lanes = 1073741824 : c.lanes = 1, null) : (b = T.children, u = T.fallback, I ? (T = c.mode, I = c.child, b = { mode: "hidden", children: b }, !(T & 1) && I !== null ? (I.childLanes = 0, I.pendingProps = b) : I = jp(b, T, 0, null), u = nl(u, T, _, null), I.return = c, u.return = c, I.sibling = u, c.child = I, c.child.memoizedState = Ap(_), c.memoizedState = Tp, u) : Fv(c, b));
    if (b = u.memoizedState, b !== null) {
      if (K = b.dehydrated, K !== null) {
        if (H) return c.flags & 256 ? (c.flags &= -257, bp(u, c, _, Error(o(422)))) : c.memoizedState !== null ? (c.child = u.child, c.flags |= 128, null) : (I = T.fallback, b = c.mode, T = jp({ mode: "visible", children: T.children }, b, 0, null), I = nl(I, b, _, null), I.flags |= 2, T.return = c, I.return = c, T.sibling = I, c.child = T, c.mode & 1 && _u(c, u.child, null, _), c.child.memoizedState = Ap(_), c.memoizedState = Tp, I);
        if (!(c.mode & 1)) c = bp(u, c, _, null);
        else if (pf(K)) c = bp(u, c, _, Error(o(419)));
        else if (T = (_ & u.childLanes) !== 0, mr || T) {
          if (T = On, T !== null) {
            switch (_ & -_) {
              case 4:
                I = 2;
                break;
              case 16:
                I = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                I = 32;
                break;
              case 536870912:
                I = 268435456;
                break;
              default:
                I = 0;
            }
            T = I & (T.suspendedLanes | _) ? 0 : I, T !== 0 && T !== b.retryLane && (b.retryLane = T, Xr(u, T, -1));
          }
          ry(), c = bp(u, c, _, Error(o(421)));
        } else df(K) ? (c.flags |= 128, c.child = u.child, c = LO.bind(null, u), lu(K, c), c = null) : (_ = b.treeContext, Se && (pr = Qd(K), dr = c, rn = true, hs = null, _f = false, _ !== null && (Vr[Hr++] = co, Vr[Hr++] = fo, Vr[Hr++] = Ya, co = _.id, fo = _.overflow, Ya = c)), c = Fv(c, c.pendingProps.children), c.flags |= 4096);
        return c;
      }
      return I ? (T = TT(u, c, T.children, T.fallback, _), I = c.child, b = u.child.memoizedState, I.memoizedState = b === null ? Ap(_) : { baseLanes: b.baseLanes | _, cachePool: null }, I.childLanes = u.childLanes & ~_, c.memoizedState = Tp, T) : (_ = ET(u, c, T.children, _), c.memoizedState = null, _);
    }
    return I ? (T = TT(u, c, T.children, T.fallback, _), I = c.child, b = u.child.memoizedState, I.memoizedState = b === null ? Ap(_) : { baseLanes: b.baseLanes | _, cachePool: null }, I.childLanes = u.childLanes & ~_, c.memoizedState = Tp, T) : (_ = ET(u, c, T.children, _), c.memoizedState = null, _);
  }
  function Fv(u, c) {
    return c = jp({ mode: "visible", children: c }, u.mode, 0, null), c.return = u, u.child = c;
  }
  function ET(u, c, _, T) {
    var b = u.child;
    return u = b.sibling, _ = Zo(b, { mode: "visible", children: _ }), !(c.mode & 1) && (_.lanes = T), _.return = c, _.sibling = null, u !== null && (T = c.deletions, T === null ? (c.deletions = [u], c.flags |= 16) : T.push(u)), c.child = _;
  }
  function TT(u, c, _, T, b) {
    var I = c.mode;
    u = u.child;
    var H = u.sibling, K = { mode: "hidden", children: _ };
    return !(I & 1) && c.child !== u ? (_ = c.child, _.childLanes = 0, _.pendingProps = K, c.deletions = null) : (_ = Zo(u, K), _.subtreeFlags = u.subtreeFlags & 14680064), H !== null ? T = Zo(H, T) : (T = nl(T, I, b, null), T.flags |= 2), T.return = c, _.return = c, _.sibling = T, c.child = _, T;
  }
  function bp(u, c, _, T) {
    return T !== null && wv(T), _u(c, u.child, null, _), u = Fv(c, c.pendingProps.children), u.flags |= 2, c.memoizedState = null, u;
  }
  function AT(u, c, _) {
    u.lanes |= c;
    var T = u.alternate;
    T !== null && (T.lanes |= c), mv(u.return, c, _);
  }
  function zv(u, c, _, T, b) {
    var I = u.memoizedState;
    I === null ? u.memoizedState = { isBackwards: c, rendering: null, renderingStartTime: 0, last: T, tail: _, tailMode: b } : (I.isBackwards = c, I.rendering = null, I.renderingStartTime = 0, I.last = T, I.tail = _, I.tailMode = b);
  }
  function bT(u, c, _) {
    var T = c.pendingProps, b = T.revealOrder, I = T.tail;
    if (Di(u, c, T.children, _), T = un.current, T & 2) T = T & 1 | 2, c.flags |= 128;
    else {
      if (u !== null && u.flags & 128) e: for (u = c.child; u !== null; ) {
        if (u.tag === 13) u.memoizedState !== null && AT(u, _, c);
        else if (u.tag === 19) AT(u, _, c);
        else if (u.child !== null) {
          u.child.return = u, u = u.child;
          continue;
        }
        if (u === c) break e;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === c) break e;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
      T &= 1;
    }
    if (We(un, T), !(c.mode & 1)) c.memoizedState = null;
    else switch (b) {
      case "forwards":
        for (_ = c.child, b = null; _ !== null; ) u = _.alternate, u !== null && mp(u) === null && (b = _), _ = _.sibling;
        _ = b, _ === null ? (b = c.child, c.child = null) : (b = _.sibling, _.sibling = null), zv(c, false, b, _, I);
        break;
      case "backwards":
        for (_ = null, b = c.child, c.child = null; b !== null; ) {
          if (u = b.alternate, u !== null && mp(u) === null) {
            c.child = b;
            break;
          }
          u = b.sibling, b.sibling = _, _ = b, b = u;
        }
        zv(c, true, _, null, I);
        break;
      case "together":
        zv(c, false, null, null, void 0);
        break;
      default:
        c.memoizedState = null;
    }
    return c.child;
  }
  function po(u, c, _) {
    if (u !== null && (c.dependencies = u.dependencies), Mu |= c.lanes, !(_ & c.childLanes)) return null;
    if (u !== null && c.child !== u.child) throw Error(o(153));
    if (c.child !== null) {
      for (u = c.child, _ = Zo(u, u.pendingProps), c.child = _, _.return = c; u.sibling !== null; ) u = u.sibling, _ = _.sibling = Zo(u, u.pendingProps), _.return = c;
      _.sibling = null;
    }
    return c.child;
  }
  function yO(u, c, _) {
    switch (c.tag) {
      case 3:
        ST(c), gu();
        break;
      case 5:
        GE(c);
        break;
      case 1:
        Kn(c.type) && li(c);
        break;
      case 4:
        Ev(c, c.stateNode.containerInfo);
        break;
      case 10:
        CE(c, c.type._context, c.memoizedProps.value);
        break;
      case 13:
        var T = c.memoizedState;
        if (T !== null) return T.dehydrated !== null ? (We(un, un.current & 1), c.flags |= 128, null) : _ & c.child.childLanes ? wT(u, c, _) : (We(un, un.current & 1), u = po(u, c, _), u !== null ? u.sibling : null);
        We(un, un.current & 1);
        break;
      case 19:
        if (T = (_ & c.childLanes) !== 0, u.flags & 128) {
          if (T) return bT(u, c, _);
          c.flags |= 128;
        }
        var b = c.memoizedState;
        if (b !== null && (b.rendering = null, b.tail = null, b.lastEffect = null), We(un, un.current), T) break;
        return null;
      case 22:
      case 23:
        return c.lanes = 0, vT(u, c, _);
    }
    return po(u, c, _);
  }
  function xO(u, c) {
    switch (xv(c), c.tag) {
      case 1:
        return Kn(c.type) && An(), u = c.flags, u & 65536 ? (c.flags = u & -65537 | 128, c) : null;
      case 3:
        return yu(), ot(_n), ot(wt), bv(), u = c.flags, u & 65536 && !(u & 128) ? (c.flags = u & -65537 | 128, c) : null;
      case 5:
        return Tv(c), null;
      case 13:
        if (ot(un), u = c.memoizedState, u !== null && u.dehydrated !== null) {
          if (c.alternate === null) throw Error(o(340));
          gu();
        }
        return u = c.flags, u & 65536 ? (c.flags = u & -65537 | 128, c) : null;
      case 19:
        return ot(un), null;
      case 4:
        return yu(), null;
      case 10:
        return pv(c.type._context), null;
      case 22:
      case 23:
        return iy(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Cp = false, Za = false, SO = typeof WeakSet == "function" ? WeakSet : Set, De = null;
  function Rp(u, c) {
    var _ = u.ref;
    if (_ !== null) if (typeof _ == "function") try {
      _(null);
    } catch (T) {
      Zi(u, c, T);
    }
    else _.current = null;
  }
  function Bv(u, c, _) {
    try {
      _();
    } catch (T) {
      Zi(u, c, T);
    }
  }
  var CT = false;
  function MO(u, c) {
    for (Y(u.containerInfo), De = c; De !== null; ) if (u = De, c = u.child, (u.subtreeFlags & 1028) !== 0 && c !== null) c.return = u, De = c;
    else for (; De !== null; ) {
      u = De;
      try {
        var _ = u.alternate;
        if (u.flags & 1024) switch (u.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (_ !== null) {
              var T = _.memoizedProps, b = _.memoizedState, I = u.stateNode, H = I.getSnapshotBeforeUpdate(u.elementType === u.type ? T : fs(u.type, T), b);
              I.__reactInternalSnapshotBeforeUpdate = H;
            }
            break;
          case 3:
            Ge && be(u.stateNode.containerInfo);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(o(163));
        }
      } catch (K) {
        Zi(u, u.return, K);
      }
      if (c = u.sibling, c !== null) {
        c.return = u.return, De = c;
        break;
      }
      De = u.return;
    }
    return _ = CT, CT = false, _;
  }
  function Ja(u, c, _) {
    var T = c.updateQueue;
    if (T = T !== null ? T.lastEffect : null, T !== null) {
      var b = T = T.next;
      do {
        if ((b.tag & u) === u) {
          var I = b.destroy;
          b.destroy = void 0, I !== void 0 && Bv(c, _, I);
        }
        b = b.next;
      } while (b !== T);
    }
  }
  function Rf(u, c) {
    if (c = c.updateQueue, c = c !== null ? c.lastEffect : null, c !== null) {
      var _ = c = c.next;
      do {
        if ((_.tag & u) === u) {
          var T = _.create;
          _.destroy = T();
        }
        _ = _.next;
      } while (_ !== c);
    }
  }
  function Vv(u) {
    var c = u.ref;
    if (c !== null) {
      var _ = u.stateNode;
      switch (u.tag) {
        case 5:
          u = q(_);
          break;
        default:
          u = _;
      }
      typeof c == "function" ? c(u) : c.current = u;
    }
  }
  function RT(u, c, _) {
    if (Is && typeof Is.onCommitFiberUnmount == "function") try {
      Is.onCommitFiberUnmount(rp, c);
    } catch {
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (u = c.updateQueue, u !== null && (u = u.lastEffect, u !== null)) {
          var T = u = u.next;
          do {
            var b = T, I = b.destroy;
            b = b.tag, I !== void 0 && (b & 2 || b & 4) && Bv(c, _, I), T = T.next;
          } while (T !== u);
        }
        break;
      case 1:
        if (Rp(c, _), u = c.stateNode, typeof u.componentWillUnmount == "function") try {
          u.props = c.memoizedProps, u.state = c.memoizedState, u.componentWillUnmount();
        } catch (H) {
          Zi(c, _, H);
        }
        break;
      case 5:
        Rp(c, _);
        break;
      case 4:
        Ge ? OT(u, c, _) : X && X && (c = c.stateNode.containerInfo, _ = $e(c), Vt(c, _));
    }
  }
  function PT(u, c, _) {
    for (var T = c; ; ) if (RT(u, T, _), T.child === null || Ge && T.tag === 4) {
      if (T === c) break;
      for (; T.sibling === null; ) {
        if (T.return === null || T.return === c) return;
        T = T.return;
      }
      T.sibling.return = T.return, T = T.sibling;
    } else T.child.return = T, T = T.child;
  }
  function LT(u) {
    var c = u.alternate;
    c !== null && (u.alternate = null, LT(c)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (c = u.stateNode, c !== null && qe(c)), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
  }
  function IT(u) {
    return u.tag === 5 || u.tag === 3 || u.tag === 4;
  }
  function NT(u) {
    e: for (; ; ) {
      for (; u.sibling === null; ) {
        if (u.return === null || IT(u.return)) return null;
        u = u.return;
      }
      for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
        if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
        u.child.return = u, u = u.child;
      }
      if (!(u.flags & 2)) return u.stateNode;
    }
  }
  function DT(u) {
    if (Ge) {
      e: {
        for (var c = u.return; c !== null; ) {
          if (IT(c)) break e;
          c = c.return;
        }
        throw Error(o(160));
      }
      var _ = c;
      switch (_.tag) {
        case 5:
          c = _.stateNode, _.flags & 32 && (Lt(c), _.flags &= -33), _ = NT(u), Gv(u, _, c);
          break;
        case 3:
        case 4:
          c = _.stateNode.containerInfo, _ = NT(u), Hv(u, _, c);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function Hv(u, c, _) {
    var T = u.tag;
    if (T === 5 || T === 6) u = u.stateNode, c ? tt(_, u, c) : Re(_, u);
    else if (T !== 4 && (u = u.child, u !== null)) for (Hv(u, c, _), u = u.sibling; u !== null; ) Hv(u, c, _), u = u.sibling;
  }
  function Gv(u, c, _) {
    var T = u.tag;
    if (T === 5 || T === 6) u = u.stateNode, c ? ut(_, u, c) : et(_, u);
    else if (T !== 4 && (u = u.child, u !== null)) for (Gv(u, c, _), u = u.sibling; u !== null; ) Gv(u, c, _), u = u.sibling;
  }
  function OT(u, c, _) {
    for (var T = c, b = false, I, H; ; ) {
      if (!b) {
        b = T.return;
        e: for (; ; ) {
          if (b === null) throw Error(o(160));
          switch (I = b.stateNode, b.tag) {
            case 5:
              H = false;
              break e;
            case 3:
              I = I.containerInfo, H = true;
              break e;
            case 4:
              I = I.containerInfo, H = true;
              break e;
          }
          b = b.return;
        }
        b = true;
      }
      if (T.tag === 5 || T.tag === 6) PT(u, T, _), H ? _t(I, T.stateNode) : je(I, T.stateNode);
      else if (T.tag === 18) H ? oe(I, T.stateNode) : ce(I, T.stateNode);
      else if (T.tag === 4) {
        if (T.child !== null) {
          I = T.stateNode.containerInfo, H = true, T.child.return = T, T = T.child;
          continue;
        }
      } else if (RT(u, T, _), T.child !== null) {
        T.child.return = T, T = T.child;
        continue;
      }
      if (T === c) break;
      for (; T.sibling === null; ) {
        if (T.return === null || T.return === c) return;
        T = T.return, T.tag === 4 && (b = false);
      }
      T.sibling.return = T.return, T = T.sibling;
    }
  }
  function Wv(u, c) {
    if (Ge) {
      switch (c.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Ja(3, c, c.return), Rf(3, c), Ja(5, c, c.return);
          return;
        case 1:
          return;
        case 5:
          var _ = c.stateNode;
          if (_ != null) {
            var T = c.memoizedProps;
            u = u !== null ? u.memoizedProps : T;
            var b = c.type, I = c.updateQueue;
            c.updateQueue = null, I !== null && gt(_, I, b, u, T, c);
          }
          return;
        case 6:
          if (c.stateNode === null) throw Error(o(162));
          _ = c.memoizedProps, ye(c.stateNode, u !== null ? u.memoizedProps : _, _);
          return;
        case 3:
          Se && u !== null && u.memoizedState.isDehydrated && re(c.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Pp(c);
          return;
        case 19:
          Pp(c);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (c.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        Ja(3, c, c.return), Rf(3, c), Ja(5, c, c.return);
        return;
      case 12:
        return;
      case 13:
        Pp(c);
        return;
      case 19:
        Pp(c);
        return;
      case 3:
        Se && u !== null && u.memoizedState.isDehydrated && re(c.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (X) {
      switch (c.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          c = c.stateNode, Vt(c.containerInfo, c.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Pp(u) {
    var c = u.updateQueue;
    if (c !== null) {
      u.updateQueue = null;
      var _ = u.stateNode;
      _ === null && (_ = u.stateNode = new SO()), c.forEach(function(T) {
        var b = IO.bind(null, u, T);
        _.has(T) || (_.add(T), T.then(b, b));
      });
    }
  }
  function wO(u, c) {
    for (De = c; De !== null; ) {
      c = De;
      var _ = c.deletions;
      if (_ !== null) for (var T = 0; T < _.length; T++) {
        var b = _[T];
        try {
          var I = u;
          Ge ? OT(I, b, c) : PT(I, b, c);
          var H = b.alternate;
          H !== null && (H.return = null), b.return = null;
        } catch (Ke) {
          Zi(b, c, Ke);
        }
      }
      if (_ = c.child, c.subtreeFlags & 12854 && _ !== null) _.return = c, De = _;
      else for (; De !== null; ) {
        c = De;
        try {
          var K = c.flags;
          if (K & 32 && Ge && Lt(c.stateNode), K & 512) {
            var he = c.alternate;
            if (he !== null) {
              var Te = he.ref;
              Te !== null && (typeof Te == "function" ? Te(null) : Te.current = null);
            }
          }
          if (K & 8192) switch (c.tag) {
            case 13:
              if (c.memoizedState !== null) {
                var Xe = c.alternate;
                (Xe === null || Xe.memoizedState === null) && (Zv = Zn());
              }
              break;
            case 22:
              var pt = c.memoizedState !== null, it = c.alternate, Yt = it !== null && it.memoizedState !== null;
              if (_ = c, Ge) {
                e: if (T = _, b = pt, I = null, Ge) for (var Qe = T; ; ) {
                  if (Qe.tag === 5) {
                    if (I === null) {
                      I = Qe;
                      var vi = Qe.stateNode;
                      b ? $t(vi) : Bt(Qe.stateNode, Qe.memoizedProps);
                    }
                  } else if (Qe.tag === 6) {
                    if (I === null) {
                      var $r = Qe.stateNode;
                      b ? Tt($r) : W($r, Qe.memoizedProps);
                    }
                  } else if ((Qe.tag !== 22 && Qe.tag !== 23 || Qe.memoizedState === null || Qe === T) && Qe.child !== null) {
                    Qe.child.return = Qe, Qe = Qe.child;
                    continue;
                  }
                  if (Qe === T) break;
                  for (; Qe.sibling === null; ) {
                    if (Qe.return === null || Qe.return === T) break e;
                    I === Qe && (I = null), Qe = Qe.return;
                  }
                  I === Qe && (I = null), Qe.sibling.return = Qe.return, Qe = Qe.sibling;
                }
              }
              if (pt && !Yt && _.mode & 1) {
                De = _;
                for (var se = _.child; se !== null; ) {
                  for (_ = De = se; De !== null; ) {
                    T = De;
                    var Q = T.child;
                    switch (T.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Ja(4, T, T.return);
                        break;
                      case 1:
                        Rp(T, T.return);
                        var fe = T.stateNode;
                        if (typeof fe.componentWillUnmount == "function") {
                          var Ue = T.return;
                          try {
                            fe.props = T.memoizedProps, fe.state = T.memoizedState, fe.componentWillUnmount();
                          } catch (Ke) {
                            Zi(T, Ue, Ke);
                          }
                        }
                        break;
                      case 5:
                        Rp(T, T.return);
                        break;
                      case 22:
                        if (T.memoizedState !== null) {
                          FT(_);
                          continue;
                        }
                    }
                    Q !== null ? (Q.return = T, De = Q) : FT(_);
                  }
                  se = se.sibling;
                }
              }
          }
          switch (K & 4102) {
            case 2:
              DT(c), c.flags &= -3;
              break;
            case 6:
              DT(c), c.flags &= -3, Wv(c.alternate, c);
              break;
            case 4096:
              c.flags &= -4097;
              break;
            case 4100:
              c.flags &= -4097, Wv(c.alternate, c);
              break;
            case 4:
              Wv(c.alternate, c);
          }
        } catch (Ke) {
          Zi(c, c.return, Ke);
        }
        if (_ = c.sibling, _ !== null) {
          _.return = c.return, De = _;
          break;
        }
        De = c.return;
      }
    }
  }
  function EO(u, c, _) {
    De = u, UT(u);
  }
  function UT(u, c, _) {
    for (var T = (u.mode & 1) !== 0; De !== null; ) {
      var b = De, I = b.child;
      if (b.tag === 22 && T) {
        var H = b.memoizedState !== null || Cp;
        if (!H) {
          var K = b.alternate, he = K !== null && K.memoizedState !== null || Za;
          K = Cp;
          var Te = Za;
          if (Cp = H, (Za = he) && !Te) for (De = b; De !== null; ) H = De, he = H.child, H.tag === 22 && H.memoizedState !== null ? zT(b) : he !== null ? (he.return = H, De = he) : zT(b);
          for (; I !== null; ) De = I, UT(I), I = I.sibling;
          De = b, Cp = K, Za = Te;
        }
        kT(u);
      } else b.subtreeFlags & 8772 && I !== null ? (I.return = b, De = I) : kT(u);
    }
  }
  function kT(u) {
    for (; De !== null; ) {
      var c = De;
      if (c.flags & 8772) {
        var _ = c.alternate;
        try {
          if (c.flags & 8772) switch (c.tag) {
            case 0:
            case 11:
            case 15:
              Za || Rf(5, c);
              break;
            case 1:
              var T = c.stateNode;
              if (c.flags & 4 && !Za) if (_ === null) T.componentDidMount();
              else {
                var b = c.elementType === c.type ? _.memoizedProps : fs(c.type, _.memoizedProps);
                T.componentDidUpdate(b, _.memoizedState, T.__reactInternalSnapshotBeforeUpdate);
              }
              var I = c.updateQueue;
              I !== null && LE(c, I, T);
              break;
            case 3:
              var H = c.updateQueue;
              if (H !== null) {
                if (_ = null, c.child !== null) switch (c.child.tag) {
                  case 5:
                    _ = q(c.child.stateNode);
                    break;
                  case 1:
                    _ = c.child.stateNode;
                }
                LE(c, H, _);
              }
              break;
            case 5:
              var K = c.stateNode;
              _ === null && c.flags & 4 && bt(K, c.type, c.memoizedProps, c);
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (Se && c.memoizedState === null) {
                var he = c.alternate;
                if (he !== null) {
                  var Te = he.memoizedState;
                  if (Te !== null) {
                    var Xe = Te.dehydrated;
                    Xe !== null && le(Xe);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
              break;
            default:
              throw Error(o(163));
          }
          Za || c.flags & 512 && Vv(c);
        } catch (pt) {
          Zi(c, c.return, pt);
        }
      }
      if (c === u) {
        De = null;
        break;
      }
      if (_ = c.sibling, _ !== null) {
        _.return = c.return, De = _;
        break;
      }
      De = c.return;
    }
  }
  function FT(u) {
    for (; De !== null; ) {
      var c = De;
      if (c === u) {
        De = null;
        break;
      }
      var _ = c.sibling;
      if (_ !== null) {
        _.return = c.return, De = _;
        break;
      }
      De = c.return;
    }
  }
  function zT(u) {
    for (; De !== null; ) {
      var c = De;
      try {
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            var _ = c.return;
            try {
              Rf(4, c);
            } catch (he) {
              Zi(c, _, he);
            }
            break;
          case 1:
            var T = c.stateNode;
            if (typeof T.componentDidMount == "function") {
              var b = c.return;
              try {
                T.componentDidMount();
              } catch (he) {
                Zi(c, b, he);
              }
            }
            var I = c.return;
            try {
              Vv(c);
            } catch (he) {
              Zi(c, I, he);
            }
            break;
          case 5:
            var H = c.return;
            try {
              Vv(c);
            } catch (he) {
              Zi(c, H, he);
            }
        }
      } catch (he) {
        Zi(c, c.return, he);
      }
      if (c === u) {
        De = null;
        break;
      }
      var K = c.sibling;
      if (K !== null) {
        K.return = c.return, De = K;
        break;
      }
      De = c.return;
    }
  }
  var Lp = 0, Ip = 1, Np = 2, Dp = 3, Op = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Pf = Symbol.for;
    Lp = Pf("selector.component"), Ip = Pf("selector.has_pseudo_class"), Np = Pf("selector.role"), Dp = Pf("selector.test_id"), Op = Pf("selector.text");
  }
  function Xv(u) {
    var c = pe(u);
    if (c != null) {
      if (typeof c.memoizedProps["data-testname"] != "string") throw Error(o(364));
      return c;
    }
    if (u = ie(u), u === null) throw Error(o(362));
    return u.stateNode.current;
  }
  function jv(u, c) {
    switch (c.$$typeof) {
      case Lp:
        if (u.type === c.value) return true;
        break;
      case Ip:
        e: {
          c = c.value, u = [u, 0];
          for (var _ = 0; _ < u.length; ) {
            var T = u[_++], b = u[_++], I = c[b];
            if (T.tag !== 5 || !ge(T)) {
              for (; I != null && jv(T, I); ) b++, I = c[b];
              if (b === c.length) {
                c = true;
                break e;
              } else for (T = T.child; T !== null; ) u.push(T, b), T = T.sibling;
            }
          }
          c = false;
        }
        return c;
      case Np:
        if (u.tag === 5 && ze(u.stateNode, c.value)) return true;
        break;
      case Op:
        if ((u.tag === 5 || u.tag === 6) && (u = ve(u), u !== null && 0 <= u.indexOf(c.value))) return true;
        break;
      case Dp:
        if (u.tag === 5 && (u = u.memoizedProps["data-testname"], typeof u == "string" && u.toLowerCase() === c.value.toLowerCase())) return true;
        break;
      default:
        throw Error(o(365));
    }
    return false;
  }
  function $v(u) {
    switch (u.$$typeof) {
      case Lp:
        return "<" + (L(u.value) || "Unknown") + ">";
      case Ip:
        return ":has(" + ($v(u) || "") + ")";
      case Np:
        return '[role="' + u.value + '"]';
      case Op:
        return '"' + u.value + '"';
      case Dp:
        return '[data-testname="' + u.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function BT(u, c) {
    var _ = [];
    u = [u, 0];
    for (var T = 0; T < u.length; ) {
      var b = u[T++], I = u[T++], H = c[I];
      if (b.tag !== 5 || !ge(b)) {
        for (; H != null && jv(b, H); ) I++, H = c[I];
        if (I === c.length) _.push(b);
        else for (b = b.child; b !== null; ) u.push(b, I), b = b.sibling;
      }
    }
    return _;
  }
  function Yv(u, c) {
    if (!O) throw Error(o(363));
    u = Xv(u), u = BT(u, c), c = [], u = Array.from(u);
    for (var _ = 0; _ < u.length; ) {
      var T = u[_++];
      if (T.tag === 5) ge(T) || c.push(T.stateNode);
      else for (T = T.child; T !== null; ) u.push(T), T = T.sibling;
    }
    return c;
  }
  var TO = Math.ceil, Up = a.ReactCurrentDispatcher, qv = a.ReactCurrentOwner, bn = a.ReactCurrentBatchConfig, Et = 0, On = null, Un = null, ui = 0, gr = 0, Su = qn(0), Gn = 0, Lf = null, Mu = 0, kp = 0, Kv = 0, If = null, qi = null, Zv = 0, Jv = 1 / 0;
  function wu() {
    Jv = Zn() + 500;
  }
  var Fp = false, Qv = null, $o = null, zp = false, Yo = null, Bp = 0, Nf = 0, ey = null, Vp = -1, Hp = 0;
  function Oi() {
    return Et & 6 ? Zn() : Vp !== -1 ? Vp : Vp = Zn();
  }
  function qo(u) {
    return u.mode & 1 ? Et & 2 && ui !== 0 ? ui & -ui : aO.transition !== null ? (Hp === 0 && (u = tp, tp <<= 1, !(tp & 4194240) && (tp = 64), Hp = u), Hp) : (u = It, u !== 0 ? u : me()) : 1;
  }
  function Xr(u, c, _) {
    if (50 < Nf) throw Nf = 0, ey = null, Error(o(185));
    var T = Gp(u, c);
    return T === null ? null : (gf(T, c, _), (!(Et & 2) || T !== On) && (T === On && (!(Et & 2) && (kp |= c), Gn === 4 && Ko(T, ui)), Ki(T, _), c === 1 && Et === 0 && !(u.mode & 1) && (wu(), sp && Ds())), T);
  }
  function Gp(u, c) {
    u.lanes |= c;
    var _ = u.alternate;
    for (_ !== null && (_.lanes |= c), _ = u, u = u.return; u !== null; ) u.childLanes |= c, _ = u.alternate, _ !== null && (_.childLanes |= c), _ = u, u = u.return;
    return _.tag === 3 ? _.stateNode : null;
  }
  function Ki(u, c) {
    var _ = u.callbackNode;
    JD(u, c);
    var T = ip(u, u === On ? ui : 0);
    if (T === 0) _ !== null && AE(_), u.callbackNode = null, u.callbackPriority = 0;
    else if (c = T & -T, u.callbackPriority !== c) {
      if (_ != null && AE(_), c === 1) u.tag === 0 ? oO(HT.bind(null, u)) : bE(HT.bind(null, u)), Ne ? U(function() {
        Et === 0 && Ds();
      }) : lv(uv, Ds), _ = null;
      else {
        switch (TE(T)) {
          case 1:
            _ = uv;
            break;
          case 4:
            _ = nO;
            break;
          case 16:
            _ = cv;
            break;
          case 536870912:
            _ = iO;
            break;
          default:
            _ = cv;
        }
        _ = ZT(_, VT.bind(null, u));
      }
      u.callbackPriority = c, u.callbackNode = _;
    }
  }
  function VT(u, c) {
    if (Vp = -1, Hp = 0, Et & 6) throw Error(o(327));
    var _ = u.callbackNode;
    if (tl() && u.callbackNode !== _) return null;
    var T = ip(u, u === On ? ui : 0);
    if (T === 0) return null;
    if (T & 30 || T & u.expiredLanes || c) c = Wp(u, T);
    else {
      c = T;
      var b = Et;
      Et |= 2;
      var I = XT();
      (On !== u || ui !== c) && (wu(), Qa(u, c));
      do
        try {
          CO();
          break;
        } catch (K) {
          WT(u, K);
        }
      while (true);
      dv(), Up.current = I, Et = b, Un !== null ? c = 0 : (On = null, ui = 0, c = Gn);
    }
    if (c !== 0) {
      if (c === 2 && (b = sv(u), b !== 0 && (T = b, c = ty(u, b))), c === 1) throw _ = Lf, Qa(u, 0), Ko(u, T), Ki(u, Zn()), _;
      if (c === 6) Ko(u, T);
      else {
        if (b = u.current.alternate, !(T & 30) && !AO(b) && (c = Wp(u, T), c === 2 && (I = sv(u), I !== 0 && (T = I, c = ty(u, I))), c === 1)) throw _ = Lf, Qa(u, 0), Ko(u, T), Ki(u, Zn()), _;
        switch (u.finishedWork = b, u.finishedLanes = T, c) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            el(u, qi);
            break;
          case 3:
            if (Ko(u, T), (T & 130023424) === T && (c = Zv + 500 - Zn(), 10 < c)) {
              if (ip(u, 0) !== 0) break;
              if (b = u.suspendedLanes, (b & T) !== T) {
                Oi(), u.pingedLanes |= u.suspendedLanes & b;
                break;
              }
              u.timeoutHandle = Ie(el.bind(null, u, qi), c);
              break;
            }
            el(u, qi);
            break;
          case 4:
            if (Ko(u, T), (T & 4194240) === T) break;
            for (c = u.eventTimes, b = -1; 0 < T; ) {
              var H = 31 - hr(T);
              I = 1 << H, H = c[H], H > b && (b = H), T &= ~I;
            }
            if (T = b, T = Zn() - T, T = (120 > T ? 120 : 480 > T ? 480 : 1080 > T ? 1080 : 1920 > T ? 1920 : 3e3 > T ? 3e3 : 4320 > T ? 4320 : 1960 * TO(T / 1960)) - T, 10 < T) {
              u.timeoutHandle = Ie(el.bind(null, u, qi), T);
              break;
            }
            el(u, qi);
            break;
          case 5:
            el(u, qi);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Ki(u, Zn()), u.callbackNode === _ ? VT.bind(null, u) : null;
  }
  function ty(u, c) {
    var _ = If;
    return u.current.memoizedState.isDehydrated && (Qa(u, c).flags |= 256), u = Wp(u, c), u !== 2 && (c = qi, qi = _, c !== null && ny(c)), u;
  }
  function ny(u) {
    qi === null ? qi = u : qi.push.apply(qi, u);
  }
  function AO(u) {
    for (var c = u; ; ) {
      if (c.flags & 16384) {
        var _ = c.updateQueue;
        if (_ !== null && (_ = _.stores, _ !== null)) for (var T = 0; T < _.length; T++) {
          var b = _[T], I = b.getSnapshot;
          b = b.value;
          try {
            if (!Ns(I(), b)) return false;
          } catch {
            return false;
          }
        }
      }
      if (_ = c.child, c.subtreeFlags & 16384 && _ !== null) _.return = c, c = _;
      else {
        if (c === u) break;
        for (; c.sibling === null; ) {
          if (c.return === null || c.return === u) return true;
          c = c.return;
        }
        c.sibling.return = c.return, c = c.sibling;
      }
    }
    return true;
  }
  function Ko(u, c) {
    for (c &= ~Kv, c &= ~kp, u.suspendedLanes |= c, u.pingedLanes &= ~c, u = u.expirationTimes; 0 < c; ) {
      var _ = 31 - hr(c), T = 1 << _;
      u[_] = -1, c &= ~T;
    }
  }
  function HT(u) {
    if (Et & 6) throw Error(o(327));
    tl();
    var c = ip(u, 0);
    if (!(c & 1)) return Ki(u, Zn()), null;
    var _ = Wp(u, c);
    if (u.tag !== 0 && _ === 2) {
      var T = sv(u);
      T !== 0 && (c = T, _ = ty(u, T));
    }
    if (_ === 1) throw _ = Lf, Qa(u, 0), Ko(u, c), Ki(u, Zn()), _;
    if (_ === 6) throw Error(o(345));
    return u.finishedWork = u.current.alternate, u.finishedLanes = c, el(u, qi), Ki(u, Zn()), null;
  }
  function GT(u) {
    Yo !== null && Yo.tag === 0 && !(Et & 6) && tl();
    var c = Et;
    Et |= 1;
    var _ = bn.transition, T = It;
    try {
      if (bn.transition = null, It = 1, u) return u();
    } finally {
      It = T, bn.transition = _, Et = c, !(Et & 6) && Ds();
    }
  }
  function iy() {
    gr = Su.current, ot(Su);
  }
  function Qa(u, c) {
    u.finishedWork = null, u.finishedLanes = 0;
    var _ = u.timeoutHandle;
    if (_ !== Oe && (u.timeoutHandle = Oe, Ze(_)), Un !== null) for (_ = Un.return; _ !== null; ) {
      var T = _;
      switch (xv(T), T.tag) {
        case 1:
          T = T.type.childContextTypes, T != null && An();
          break;
        case 3:
          yu(), ot(_n), ot(wt), bv();
          break;
        case 5:
          Tv(T);
          break;
        case 4:
          yu();
          break;
        case 13:
          ot(un);
          break;
        case 19:
          ot(un);
          break;
        case 10:
          pv(T.type._context);
          break;
        case 22:
        case 23:
          iy();
      }
      _ = _.return;
    }
    if (On = u, Un = u = Zo(u.current, null), ui = gr = c, Gn = 0, Lf = null, Kv = kp = Mu = 0, qi = If = null, Os !== null) {
      for (c = 0; c < Os.length; c++) if (_ = Os[c], T = _.interleaved, T !== null) {
        _.interleaved = null;
        var b = T.next, I = _.pending;
        if (I !== null) {
          var H = I.next;
          I.next = b, T.next = H;
        }
        _.pending = T;
      }
      Os = null;
    }
    return u;
  }
  function WT(u, c) {
    do {
      var _ = Un;
      try {
        if (dv(), gp.current = Mp, _p) {
          for (var T = vn.memoizedState; T !== null; ) {
            var b = T.queue;
            b !== null && (b.pending = null), T = T.next;
          }
          _p = false;
        }
        if (xu = 0, Jn = mi = vn = null, Mf = false, wf = 0, qv.current = null, _ === null || _.return === null) {
          Gn = 1, Lf = c, Un = null;
          break;
        }
        e: {
          var I = u, H = _.return, K = _, he = c;
          if (c = ui, K.flags |= 32768, he !== null && typeof he == "object" && typeof he.then == "function") {
            var Te = he, Xe = K, pt = Xe.tag;
            if (!(Xe.mode & 1) && (pt === 0 || pt === 11 || pt === 15)) {
              var it = Xe.alternate;
              it ? (Xe.updateQueue = it.updateQueue, Xe.memoizedState = it.memoizedState, Xe.lanes = it.lanes) : (Xe.updateQueue = null, Xe.memoizedState = null);
            }
            var Yt = fT(H);
            if (Yt !== null) {
              Yt.flags &= -257, hT(Yt, H, K, I, c), Yt.mode & 1 && cT(I, Te, c), c = Yt, he = Te;
              var Qe = c.updateQueue;
              if (Qe === null) {
                var vi = /* @__PURE__ */ new Set();
                vi.add(he), c.updateQueue = vi;
              } else Qe.add(he);
              break e;
            } else {
              if (!(c & 1)) {
                cT(I, Te, c), ry();
                break e;
              }
              he = Error(o(426));
            }
          } else if (rn && K.mode & 1) {
            var $r = fT(H);
            if ($r !== null) {
              !($r.flags & 65536) && ($r.flags |= 256), hT($r, H, K, I, c), wv(he);
              break e;
            }
          }
          I = he, Gn !== 4 && (Gn = 2), If === null ? If = [I] : If.push(I), he = Dv(he, K), K = H;
          do {
            switch (K.tag) {
              case 3:
                K.flags |= 65536, c &= -c, K.lanes |= c;
                var se = lT(K, he, c);
                PE(K, se);
                break e;
              case 1:
                I = he;
                var Q = K.type, fe = K.stateNode;
                if (!(K.flags & 128) && (typeof Q.getDerivedStateFromError == "function" || fe !== null && typeof fe.componentDidCatch == "function" && ($o === null || !$o.has(fe)))) {
                  K.flags |= 65536, c &= -c, K.lanes |= c;
                  var Ue = uT(K, I, c);
                  PE(K, Ue);
                  break e;
                }
            }
            K = K.return;
          } while (K !== null);
        }
        $T(_);
      } catch (Ke) {
        c = Ke, Un === _ && _ !== null && (Un = _ = _.return);
        continue;
      }
      break;
    } while (true);
  }
  function XT() {
    var u = Up.current;
    return Up.current = Mp, u === null ? Mp : u;
  }
  function ry() {
    (Gn === 0 || Gn === 3 || Gn === 2) && (Gn = 4), On === null || !(Mu & 268435455) && !(kp & 268435455) || Ko(On, ui);
  }
  function Wp(u, c) {
    var _ = Et;
    Et |= 2;
    var T = XT();
    On === u && ui === c || Qa(u, c);
    do
      try {
        bO();
        break;
      } catch (b) {
        WT(u, b);
      }
    while (true);
    if (dv(), Et = _, Up.current = T, Un !== null) throw Error(o(261));
    return On = null, ui = 0, Gn;
  }
  function bO() {
    for (; Un !== null; ) jT(Un);
  }
  function CO() {
    for (; Un !== null && !eO(); ) jT(Un);
  }
  function jT(u) {
    var c = KT(u.alternate, u, gr);
    u.memoizedProps = u.pendingProps, c === null ? $T(u) : Un = c, qv.current = null;
  }
  function $T(u) {
    var c = u;
    do {
      var _ = c.alternate;
      if (u = c.return, c.flags & 32768) {
        if (_ = xO(_, c), _ !== null) {
          _.flags &= 32767, Un = _;
          return;
        }
        if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null;
        else {
          Gn = 6, Un = null;
          return;
        }
      } else if (_ = _O(_, c, gr), _ !== null) {
        Un = _;
        return;
      }
      if (c = c.sibling, c !== null) {
        Un = c;
        return;
      }
      Un = c = u;
    } while (c !== null);
    Gn === 0 && (Gn = 5);
  }
  function el(u, c) {
    var _ = It, T = bn.transition;
    try {
      bn.transition = null, It = 1, RO(u, c, _);
    } finally {
      bn.transition = T, It = _;
    }
    return null;
  }
  function RO(u, c, _) {
    do
      tl();
    while (Yo !== null);
    if (Et & 6) throw Error(o(327));
    var T = u.finishedWork, b = u.finishedLanes;
    if (T === null) return null;
    if (u.finishedWork = null, u.finishedLanes = 0, T === u.current) throw Error(o(177));
    u.callbackNode = null, u.callbackPriority = 0;
    var I = T.lanes | T.childLanes;
    if (QD(u, I), u === On && (Un = On = null, ui = 0), !(T.subtreeFlags & 2064) && !(T.flags & 2064) || zp || (zp = true, ZT(cv, function() {
      return tl(), null;
    })), I = (T.flags & 15990) !== 0, T.subtreeFlags & 15990 || I) {
      I = bn.transition, bn.transition = null;
      var H = It;
      It = 1;
      var K = Et;
      Et |= 4, qv.current = null, MO(u, T), wO(u, T), $(u.containerInfo), u.current = T, EO(T), tO(), Et = K, It = H, bn.transition = I;
    } else u.current = T;
    if (zp && (zp = false, Yo = u, Bp = b), I = u.pendingLanes, I === 0 && ($o = null), rO(T.stateNode), Ki(u, Zn()), c !== null) for (_ = u.onRecoverableError, T = 0; T < c.length; T++) _(c[T]);
    if (Fp) throw Fp = false, u = Qv, Qv = null, u;
    return Bp & 1 && u.tag !== 0 && tl(), I = u.pendingLanes, I & 1 ? u === ey ? Nf++ : (Nf = 0, ey = u) : Nf = 0, Ds(), null;
  }
  function tl() {
    if (Yo !== null) {
      var u = TE(Bp), c = bn.transition, _ = It;
      try {
        if (bn.transition = null, It = 16 > u ? 16 : u, Yo === null) var T = false;
        else {
          if (u = Yo, Yo = null, Bp = 0, Et & 6) throw Error(o(331));
          var b = Et;
          for (Et |= 4, De = u.current; De !== null; ) {
            var I = De, H = I.child;
            if (De.flags & 16) {
              var K = I.deletions;
              if (K !== null) {
                for (var he = 0; he < K.length; he++) {
                  var Te = K[he];
                  for (De = Te; De !== null; ) {
                    var Xe = De;
                    switch (Xe.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Ja(8, Xe, I);
                    }
                    var pt = Xe.child;
                    if (pt !== null) pt.return = Xe, De = pt;
                    else for (; De !== null; ) {
                      Xe = De;
                      var it = Xe.sibling, Yt = Xe.return;
                      if (LT(Xe), Xe === Te) {
                        De = null;
                        break;
                      }
                      if (it !== null) {
                        it.return = Yt, De = it;
                        break;
                      }
                      De = Yt;
                    }
                  }
                }
                var Qe = I.alternate;
                if (Qe !== null) {
                  var vi = Qe.child;
                  if (vi !== null) {
                    Qe.child = null;
                    do {
                      var $r = vi.sibling;
                      vi.sibling = null, vi = $r;
                    } while (vi !== null);
                  }
                }
                De = I;
              }
            }
            if (I.subtreeFlags & 2064 && H !== null) H.return = I, De = H;
            else e: for (; De !== null; ) {
              if (I = De, I.flags & 2048) switch (I.tag) {
                case 0:
                case 11:
                case 15:
                  Ja(9, I, I.return);
              }
              var se = I.sibling;
              if (se !== null) {
                se.return = I.return, De = se;
                break e;
              }
              De = I.return;
            }
          }
          var Q = u.current;
          for (De = Q; De !== null; ) {
            H = De;
            var fe = H.child;
            if (H.subtreeFlags & 2064 && fe !== null) fe.return = H, De = fe;
            else e: for (H = Q; De !== null; ) {
              if (K = De, K.flags & 2048) try {
                switch (K.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Rf(9, K);
                }
              } catch (Ke) {
                Zi(K, K.return, Ke);
              }
              if (K === H) {
                De = null;
                break e;
              }
              var Ue = K.sibling;
              if (Ue !== null) {
                Ue.return = K.return, De = Ue;
                break e;
              }
              De = K.return;
            }
          }
          if (Et = b, Ds(), Is && typeof Is.onPostCommitFiberRoot == "function") try {
            Is.onPostCommitFiberRoot(rp, u);
          } catch {
          }
          T = true;
        }
        return T;
      } finally {
        It = _, bn.transition = c;
      }
    }
    return false;
  }
  function YT(u, c, _) {
    c = Dv(_, c), c = lT(u, c, 1), jo(u, c), c = Oi(), u = Gp(u, 1), u !== null && (gf(u, 1, c), Ki(u, c));
  }
  function Zi(u, c, _) {
    if (u.tag === 3) YT(u, u, _);
    else for (; c !== null; ) {
      if (c.tag === 3) {
        YT(c, u, _);
        break;
      } else if (c.tag === 1) {
        var T = c.stateNode;
        if (typeof c.type.getDerivedStateFromError == "function" || typeof T.componentDidCatch == "function" && ($o === null || !$o.has(T))) {
          u = Dv(_, u), u = uT(c, u, 1), jo(c, u), u = Oi(), c = Gp(c, 1), c !== null && (gf(c, 1, u), Ki(c, u));
          break;
        }
      }
      c = c.return;
    }
  }
  function PO(u, c, _) {
    var T = u.pingCache;
    T !== null && T.delete(c), c = Oi(), u.pingedLanes |= u.suspendedLanes & _, On === u && (ui & _) === _ && (Gn === 4 || Gn === 3 && (ui & 130023424) === ui && 500 > Zn() - Zv ? Qa(u, 0) : Kv |= _), Ki(u, c);
  }
  function qT(u, c) {
    c === 0 && (u.mode & 1 ? (c = np, np <<= 1, !(np & 130023424) && (np = 4194304)) : c = 1);
    var _ = Oi();
    u = Gp(u, c), u !== null && (gf(u, c, _), Ki(u, _));
  }
  function LO(u) {
    var c = u.memoizedState, _ = 0;
    c !== null && (_ = c.retryLane), qT(u, _);
  }
  function IO(u, c) {
    var _ = 0;
    switch (u.tag) {
      case 13:
        var T = u.stateNode, b = u.memoizedState;
        b !== null && (_ = b.retryLane);
        break;
      case 19:
        T = u.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    T !== null && T.delete(c), qT(u, _);
  }
  var KT;
  KT = function(u, c, _) {
    if (u !== null) if (u.memoizedProps !== c.pendingProps || _n.current) mr = true;
    else {
      if (!(u.lanes & _) && !(c.flags & 128)) return mr = false, yO(u, c, _);
      mr = !!(u.flags & 131072);
    }
    else mr = false, rn && c.flags & 1048576 && UE(c, dp, c.index);
    switch (c.lanes = 0, c.tag) {
      case 2:
        var T = c.type;
        u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), u = c.pendingProps;
        var b = zr(c, wt.current);
        du(c, _), b = Rv(null, c, T, u, b, _);
        var I = Pv();
        return c.flags |= 1, typeof b == "object" && b !== null && typeof b.render == "function" && b.$$typeof === void 0 ? (c.tag = 1, c.memoizedState = null, c.updateQueue = null, Kn(T) ? (I = true, li(c)) : I = false, c.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, gv(c), b.updater = fp, c.stateNode = b, b._reactInternals = c, vv(c, T, u, _), c = kv(null, c, T, true, I, _)) : (c.tag = 0, rn && I && yv(c), Di(null, c, b, _), c = c.child), c;
      case 16:
        T = c.elementType;
        e: {
          switch (u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), u = c.pendingProps, b = T._init, T = b(T._payload), c.type = T, b = c.tag = DO(T), u = fs(T, u), b) {
            case 0:
              c = Uv(null, c, T, u, _);
              break e;
            case 1:
              c = xT(null, c, T, u, _);
              break e;
            case 11:
              c = mT(null, c, T, u, _);
              break e;
            case 14:
              c = gT(null, c, T, fs(T.type, u), _);
              break e;
          }
          throw Error(o(306, T, ""));
        }
        return c;
      case 0:
        return T = c.type, b = c.pendingProps, b = c.elementType === T ? b : fs(T, b), Uv(u, c, T, b, _);
      case 1:
        return T = c.type, b = c.pendingProps, b = c.elementType === T ? b : fs(T, b), xT(u, c, T, b, _);
      case 3:
        e: {
          if (ST(c), u === null) throw Error(o(387));
          T = c.pendingProps, I = c.memoizedState, b = I.element, RE(u, c), cp(c, T, null, _);
          var H = c.memoizedState;
          if (T = H.element, Se && I.isDehydrated) if (I = { element: T, isDehydrated: false, cache: H.cache, transitions: H.transitions }, c.updateQueue.baseState = I, c.memoizedState = I, c.flags & 256) {
            b = Error(o(423)), c = MT(u, c, T, _, b);
            break e;
          } else if (T !== b) {
            b = Error(o(424)), c = MT(u, c, T, _, b);
            break e;
          } else for (Se && (pr = Jd(c.stateNode.containerInfo), dr = c, rn = true, hs = null, _f = false), _ = HE(c, null, T, _), c.child = _; _; ) _.flags = _.flags & -3 | 4096, _ = _.sibling;
          else {
            if (gu(), T === b) {
              c = po(u, c, _);
              break e;
            }
            Di(u, c, T, _);
          }
          c = c.child;
        }
        return c;
      case 5:
        return GE(c), u === null && Mv(c), T = c.type, b = c.pendingProps, I = u !== null ? u.memoizedProps : null, H = b.children, de(T, b) ? H = null : I !== null && de(T, I) && (c.flags |= 32), yT(u, c), Di(u, c, H, _), c.child;
      case 6:
        return u === null && Mv(c), null;
      case 13:
        return wT(u, c, _);
      case 4:
        return Ev(c, c.stateNode.containerInfo), T = c.pendingProps, u === null ? c.child = _u(c, null, T, _) : Di(u, c, T, _), c.child;
      case 11:
        return T = c.type, b = c.pendingProps, b = c.elementType === T ? b : fs(T, b), mT(u, c, T, b, _);
      case 7:
        return Di(u, c, c.pendingProps, _), c.child;
      case 8:
        return Di(u, c, c.pendingProps.children, _), c.child;
      case 12:
        return Di(u, c, c.pendingProps.children, _), c.child;
      case 10:
        e: {
          if (T = c.type._context, b = c.pendingProps, I = c.memoizedProps, H = b.value, CE(c, T, H), I !== null) if (Ns(I.value, H)) {
            if (I.children === b.children && !_n.current) {
              c = po(u, c, _);
              break e;
            }
          } else for (I = c.child, I !== null && (I.return = c); I !== null; ) {
            var K = I.dependencies;
            if (K !== null) {
              H = I.child;
              for (var he = K.firstContext; he !== null; ) {
                if (he.context === T) {
                  if (I.tag === 1) {
                    he = uo(-1, _ & -_), he.tag = 2;
                    var Te = I.updateQueue;
                    if (Te !== null) {
                      Te = Te.shared;
                      var Xe = Te.pending;
                      Xe === null ? he.next = he : (he.next = Xe.next, Xe.next = he), Te.pending = he;
                    }
                  }
                  I.lanes |= _, he = I.alternate, he !== null && (he.lanes |= _), mv(I.return, _, c), K.lanes |= _;
                  break;
                }
                he = he.next;
              }
            } else if (I.tag === 10) H = I.type === c.type ? null : I.child;
            else if (I.tag === 18) {
              if (H = I.return, H === null) throw Error(o(341));
              H.lanes |= _, K = H.alternate, K !== null && (K.lanes |= _), mv(H, _, c), H = I.sibling;
            } else H = I.child;
            if (H !== null) H.return = I;
            else for (H = I; H !== null; ) {
              if (H === c) {
                H = null;
                break;
              }
              if (I = H.sibling, I !== null) {
                I.return = H.return, H = I;
                break;
              }
              H = H.return;
            }
            I = H;
          }
          Di(u, c, b.children, _), c = c.child;
        }
        return c;
      case 9:
        return b = c.type, T = c.pendingProps.children, du(c, _), b = Br(b), T = T(b), c.flags |= 1, Di(u, c, T, _), c.child;
      case 14:
        return T = c.type, b = fs(T, c.pendingProps), b = fs(T.type, b), gT(u, c, T, b, _);
      case 15:
        return _T(u, c, c.type, c.pendingProps, _);
      case 17:
        return T = c.type, b = c.pendingProps, b = c.elementType === T ? b : fs(T, b), u !== null && (u.alternate = null, c.alternate = null, c.flags |= 2), c.tag = 1, Kn(T) ? (u = true, li(c)) : u = false, du(c, _), DE(c, T, b), vv(c, T, b, _), kv(null, c, T, true, u, _);
      case 19:
        return bT(u, c, _);
      case 22:
        return vT(u, c, _);
    }
    throw Error(o(156, c.tag));
  };
  function ZT(u, c) {
    return lv(u, c);
  }
  function NO(u, c, _, T) {
    this.tag = u, this.key = _, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = c, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = T, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function jr(u, c, _, T) {
    return new NO(u, c, _, T);
  }
  function sy(u) {
    return u = u.prototype, !(!u || !u.isReactComponent);
  }
  function DO(u) {
    if (typeof u == "function") return sy(u) ? 1 : 0;
    if (u != null) {
      if (u = u.$$typeof, u === S) return 11;
      if (u === w) return 14;
    }
    return 2;
  }
  function Zo(u, c) {
    var _ = u.alternate;
    return _ === null ? (_ = jr(u.tag, c, u.key, u.mode), _.elementType = u.elementType, _.type = u.type, _.stateNode = u.stateNode, _.alternate = u, u.alternate = _) : (_.pendingProps = c, _.type = u.type, _.flags = 0, _.subtreeFlags = 0, _.deletions = null), _.flags = u.flags & 14680064, _.childLanes = u.childLanes, _.lanes = u.lanes, _.child = u.child, _.memoizedProps = u.memoizedProps, _.memoizedState = u.memoizedState, _.updateQueue = u.updateQueue, c = u.dependencies, _.dependencies = c === null ? null : { lanes: c.lanes, firstContext: c.firstContext }, _.sibling = u.sibling, _.index = u.index, _.ref = u.ref, _;
  }
  function Xp(u, c, _, T, b, I) {
    var H = 2;
    if (T = u, typeof u == "function") sy(u) && (H = 1);
    else if (typeof u == "string") H = 5;
    else e: switch (u) {
      case h:
        return nl(_.children, b, I, c);
      case d:
        H = 8, b |= 8;
        break;
      case p:
        return u = jr(12, _, c, b | 2), u.elementType = p, u.lanes = I, u;
      case M:
        return u = jr(13, _, c, b), u.elementType = M, u.lanes = I, u;
      case m:
        return u = jr(19, _, c, b), u.elementType = m, u.lanes = I, u;
      case A:
        return jp(_, b, I, c);
      default:
        if (typeof u == "object" && u !== null) switch (u.$$typeof) {
          case g:
            H = 10;
            break e;
          case v:
            H = 9;
            break e;
          case S:
            H = 11;
            break e;
          case w:
            H = 14;
            break e;
          case E:
            H = 16, T = null;
            break e;
        }
        throw Error(o(130, u == null ? u : typeof u, ""));
    }
    return c = jr(H, _, c, b), c.elementType = u, c.type = T, c.lanes = I, c;
  }
  function nl(u, c, _, T) {
    return u = jr(7, u, T, c), u.lanes = _, u;
  }
  function jp(u, c, _, T) {
    return u = jr(22, u, T, c), u.elementType = A, u.lanes = _, u.stateNode = {}, u;
  }
  function oy(u, c, _) {
    return u = jr(6, u, null, c), u.lanes = _, u;
  }
  function ay(u, c, _) {
    return c = jr(4, u.children !== null ? u.children : [], u.key, c), c.lanes = _, c.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, c;
  }
  function OO(u, c, _, T, b) {
    this.tag = c, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Oe, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = ov(0), this.expirationTimes = ov(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ov(0), this.identifierPrefix = T, this.onRecoverableError = b, Se && (this.mutableSourceEagerHydrationData = null);
  }
  function JT(u, c, _, T, b, I, H, K, he) {
    return u = new OO(u, c, _, K, he), c === 1 ? (c = 1, I === true && (c |= 8)) : c = 0, I = jr(3, null, null, c), u.current = I, I.stateNode = u, I.memoizedState = { element: T, isDehydrated: _, cache: null, transitions: null }, gv(I), u;
  }
  function QT(u) {
    if (!u) return Fr;
    u = u._reactInternals;
    e: {
      if (F(u) !== u || u.tag !== 1) throw Error(o(170));
      var c = u;
      do {
        switch (c.tag) {
          case 3:
            c = c.stateNode.context;
            break e;
          case 1:
            if (Kn(c.type)) {
              c = c.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        c = c.return;
      } while (c !== null);
      throw Error(o(171));
    }
    if (u.tag === 1) {
      var _ = u.type;
      if (Kn(_)) return cu(u, _, c);
    }
    return c;
  }
  function eA(u) {
    var c = u._reactInternals;
    if (c === void 0) throw typeof u.render == "function" ? Error(o(188)) : (u = Object.keys(u).join(","), Error(o(268, u)));
    return u = j(c), u === null ? null : u.stateNode;
  }
  function tA(u, c) {
    if (u = u.memoizedState, u !== null && u.dehydrated !== null) {
      var _ = u.retryLane;
      u.retryLane = _ !== 0 && _ < c ? _ : c;
    }
  }
  function ly(u, c) {
    tA(u, c), (u = u.alternate) && tA(u, c);
  }
  function UO(u) {
    return u = j(u), u === null ? null : u.stateNode;
  }
  function kO() {
    return null;
  }
  return t.attemptContinuousHydration = function(u) {
    if (u.tag === 13) {
      var c = Oi();
      Xr(u, 134217728, c), ly(u, 134217728);
    }
  }, t.attemptHydrationAtCurrentPriority = function(u) {
    if (u.tag === 13) {
      var c = Oi(), _ = qo(u);
      Xr(u, _, c), ly(u, _);
    }
  }, t.attemptSynchronousHydration = function(u) {
    switch (u.tag) {
      case 3:
        var c = u.stateNode;
        if (c.current.memoizedState.isDehydrated) {
          var _ = mf(c.pendingLanes);
          _ !== 0 && (av(c, _ | 1), Ki(c, Zn()), !(Et & 6) && (wu(), Ds()));
        }
        break;
      case 13:
        var T = Oi();
        GT(function() {
          return Xr(u, 1, T);
        }), ly(u, 1);
    }
  }, t.batchedUpdates = function(u, c) {
    var _ = Et;
    Et |= 1;
    try {
      return u(c);
    } finally {
      Et = _, Et === 0 && (wu(), sp && Ds());
    }
  }, t.createComponentSelector = function(u) {
    return { $$typeof: Lp, value: u };
  }, t.createContainer = function(u, c, _, T, b, I, H) {
    return JT(u, c, false, null, _, T, b, I, H);
  }, t.createHasPseudoClassSelector = function(u) {
    return { $$typeof: Ip, value: u };
  }, t.createHydrationContainer = function(u, c, _, T, b, I, H, K, he) {
    return u = JT(_, T, true, u, b, I, H, K, he), u.context = QT(null), _ = u.current, T = Oi(), b = qo(_), I = uo(T, b), I.callback = c ?? null, jo(_, I), u.current.lanes = b, gf(u, b, T), Ki(u, T), u;
  }, t.createPortal = function(u, c, _) {
    var T = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: f, key: T == null ? null : "" + T, children: u, containerInfo: c, implementation: _ };
  }, t.createRoleSelector = function(u) {
    return { $$typeof: Np, value: u };
  }, t.createTestNameSelector = function(u) {
    return { $$typeof: Dp, value: u };
  }, t.createTextSelector = function(u) {
    return { $$typeof: Op, value: u };
  }, t.deferredUpdates = function(u) {
    var c = It, _ = bn.transition;
    try {
      return bn.transition = null, It = 16, u();
    } finally {
      It = c, bn.transition = _;
    }
  }, t.discreteUpdates = function(u, c, _, T, b) {
    var I = It, H = bn.transition;
    try {
      return bn.transition = null, It = 1, u(c, _, T, b);
    } finally {
      It = I, bn.transition = H, Et === 0 && wu();
    }
  }, t.findAllNodes = Yv, t.findBoundingRects = function(u, c) {
    if (!O) throw Error(o(363));
    c = Yv(u, c), u = [];
    for (var _ = 0; _ < c.length; _++) u.push(xe(c[_]));
    for (c = u.length - 1; 0 < c; c--) {
      _ = u[c];
      for (var T = _.x, b = T + _.width, I = _.y, H = I + _.height, K = c - 1; 0 <= K; K--) if (c !== K) {
        var he = u[K], Te = he.x, Xe = Te + he.width, pt = he.y, it = pt + he.height;
        if (T >= Te && I >= pt && b <= Xe && H <= it) {
          u.splice(c, 1);
          break;
        } else if (T !== Te || _.width !== he.width || it < I || pt > H) {
          if (!(I !== pt || _.height !== he.height || Xe < T || Te > b)) {
            Te > T && (he.width += Te - T, he.x = T), Xe < b && (he.width = b - Te), u.splice(c, 1);
            break;
          }
        } else {
          pt > I && (he.height += pt - I, he.y = I), it < H && (he.height = H - pt), u.splice(c, 1);
          break;
        }
      }
    }
    return u;
  }, t.findHostInstance = eA, t.findHostInstanceWithNoPortals = function(u) {
    return u = N(u), u = u !== null ? G(u) : null, u === null ? null : u.stateNode;
  }, t.findHostInstanceWithWarning = function(u) {
    return eA(u);
  }, t.flushControlled = function(u) {
    var c = Et;
    Et |= 1;
    var _ = bn.transition, T = It;
    try {
      bn.transition = null, It = 1, u();
    } finally {
      It = T, bn.transition = _, Et = c, Et === 0 && (wu(), Ds());
    }
  }, t.flushPassiveEffects = tl, t.flushSync = GT, t.focusWithin = function(u, c) {
    if (!O) throw Error(o(363));
    for (u = Xv(u), c = BT(u, c), c = Array.from(c), u = 0; u < c.length; ) {
      var _ = c[u++];
      if (!ge(_)) {
        if (_.tag === 5 && Le(_.stateNode)) return true;
        for (_ = _.child; _ !== null; ) c.push(_), _ = _.sibling;
      }
    }
    return false;
  }, t.getCurrentUpdatePriority = function() {
    return It;
  }, t.getFindAllNodesFailureDescription = function(u, c) {
    if (!O) throw Error(o(363));
    var _ = 0, T = [];
    u = [Xv(u), 0];
    for (var b = 0; b < u.length; ) {
      var I = u[b++], H = u[b++], K = c[H];
      if ((I.tag !== 5 || !ge(I)) && (jv(I, K) && (T.push($v(K)), H++, H > _ && (_ = H)), H < c.length)) for (I = I.child; I !== null; ) u.push(I, H), I = I.sibling;
    }
    if (_ < c.length) {
      for (u = []; _ < c.length; _++) u.push($v(c[_]));
      return `findAllNodes was able to match part of the selector:
  ` + (T.join(" > ") + `

No matching component was found for:
  `) + u.join(" > ");
    }
    return null;
  }, t.getPublicRootInstance = function(u) {
    if (u = u.current, !u.child) return null;
    switch (u.child.tag) {
      case 5:
        return q(u.child.stateNode);
      default:
        return u.child.stateNode;
    }
  }, t.injectIntoDevTools = function(u) {
    if (u = { bundleType: u.bundleType, version: u.version, rendererPackageName: u.rendererPackageName, rendererConfig: u.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: a.ReactCurrentDispatcher, findHostInstanceByFiber: UO, findFiberByHostInstance: u.findFiberByHostInstance || kO, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.0.0-fc46dba67-20220329" }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") u = false;
    else {
      var c = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (c.isDisabled || !c.supportsFiber) u = true;
      else {
        try {
          rp = c.inject(u), Is = c;
        } catch {
        }
        u = !!c.checkDCE;
      }
    }
    return u;
  }, t.isAlreadyRendering = function() {
    return false;
  }, t.observeVisibleRects = function(u, c, _, T) {
    if (!O) throw Error(o(363));
    u = Yv(u, c);
    var b = ke(u, _, T).disconnect;
    return { disconnect: function() {
      b();
    } };
  }, t.registerMutableSourceForHydration = function(u, c) {
    var _ = c._getVersion;
    _ = _(c._source), u.mutableSourceEagerHydrationData == null ? u.mutableSourceEagerHydrationData = [c, _] : u.mutableSourceEagerHydrationData.push(c, _);
  }, t.runWithPriority = function(u, c) {
    var _ = It;
    try {
      return It = u, c();
    } finally {
      It = _;
    }
  }, t.shouldError = function() {
    return null;
  }, t.shouldSuspend = function() {
    return false;
  }, t.updateContainer = function(u, c, _, T) {
    var b = c.current, I = Oi(), H = qo(b);
    return _ = QT(_), c.context === null ? c.context = _ : c.pendingContext = _, c = uo(I, H), c.payload = { element: u }, T = T === void 0 ? null : T, T !== null && (c.callback = T), jo(b, c), u = Xr(b, H, I), u !== null && up(u, b, H), H;
  }, t;
};
EN.exports = m7;
var g7 = EN.exports;
const _7 = JS(g7), iE = {}, v7 = (n24) => void Object.assign(iE, n24);
function y7(n24, e) {
  function t(h, { args: d = [], attach: p, ...g }, v) {
    let S = `${h[0].toUpperCase()}${h.slice(1)}`, M;
    if (h === "primitive") {
      if (g.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
      const m = g.object;
      M = ec(m, { type: h, root: v, attach: p, primitive: true });
    } else {
      const m = iE[S];
      if (!m) throw new Error(`R3F: ${S} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
      if (!Array.isArray(d)) throw new Error("R3F: The args prop must be an array!");
      M = ec(new m(...d), { type: h, root: v, attach: p, memoizedProps: { args: d } });
    }
    return M.__r3f.attach === void 0 && (M.isBufferGeometry ? M.__r3f.attach = "geometry" : M.isMaterial && (M.__r3f.attach = "material")), S !== "inject" && Tx(M, g), M;
  }
  function i(h, d) {
    let p = false;
    if (d) {
      var g, v;
      (g = d.__r3f) != null && g.attach ? Ex(h, d, d.__r3f.attach) : d.isObject3D && h.isObject3D && (h.add(d), p = true), p || (v = h.__r3f) == null || v.objects.push(d), d.__r3f || ec(d, {}), d.__r3f.parent = h, IS(d), tc(d);
    }
  }
  function r(h, d, p) {
    let g = false;
    if (d) {
      var v, S;
      if ((v = d.__r3f) != null && v.attach) Ex(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        d.parent = h, d.dispatchEvent({ type: "added" }), h.dispatchEvent({ type: "childadded", child: d });
        const M = h.children.filter((w) => w !== d), m = M.indexOf(p);
        h.children = [...M.slice(0, m), d, ...M.slice(m)], g = true;
      }
      g || (S = h.__r3f) == null || S.objects.push(d), d.__r3f || ec(d, {}), d.__r3f.parent = h, IS(d), tc(d);
    }
  }
  function s(h, d, p = false) {
    h && [...h].forEach((g) => o(d, g, p));
  }
  function o(h, d, p) {
    if (d) {
      var g, v, S;
      if (d.__r3f && (d.__r3f.parent = null), (g = h.__r3f) != null && g.objects && (h.__r3f.objects = h.__r3f.objects.filter((A) => A !== d)), (v = d.__r3f) != null && v.attach) M2(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var M;
        h.remove(d), (M = d.__r3f) != null && M.root && A7(Ig(d), d);
      }
      const w = (S = d.__r3f) == null ? void 0 : S.primitive, E = !w && (p === void 0 ? d.dispose !== null : p);
      if (!w) {
        var m;
        s((m = d.__r3f) == null ? void 0 : m.objects, d, E), s(d.children, d, E);
      }
      if (delete d.__r3f, E && d.dispose && d.type !== "Scene") {
        const A = () => {
          try {
            d.dispose();
          } catch {
          }
        };
        typeof IS_REACT_ACT_ENVIRONMENT > "u" ? PS.unstable_scheduleCallback(PS.unstable_IdlePriority, A) : A();
      }
      tc(h);
    }
  }
  function a(h, d, p, g) {
    var v;
    const S = (v = h.__r3f) == null ? void 0 : v.parent;
    if (!S) return;
    const M = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const m of h.children) m.__r3f && i(M, m);
      h.children = h.children.filter((m) => !m.__r3f);
    }
    h.__r3f.objects.forEach((m) => i(M, m)), h.__r3f.objects = [], h.__r3f.autoRemovedBeforeAppend || o(S, h), M.parent && (M.__r3f.autoRemovedBeforeAppend = true), i(S, M), M.raycast && M.__r3f.eventCount && Ig(M).getState().internal.interaction.push(M), [g, g.alternate].forEach((m) => {
      m !== null && (m.stateNode = M, m.ref && (typeof m.ref == "function" ? m.ref(M) : m.ref.current = M));
    });
  }
  const l = () => {
  };
  return { reconciler: _7({ createInstance: t, removeChild: o, appendChild: i, appendInitialChild: i, insertBefore: r, supportsMutation: true, isPrimaryRenderer: false, supportsPersistence: false, supportsHydration: false, noTimeout: -1, appendChildToContainer: (h, d) => {
    if (!d) return;
    const p = h.getState().scene;
    p.__r3f && (p.__r3f.root = h, i(p, d));
  }, removeChildFromContainer: (h, d) => {
    d && o(h.getState().scene, d);
  }, insertInContainerBefore: (h, d, p) => {
    if (!d || !p) return;
    const g = h.getState().scene;
    g.__r3f && r(g, d, p);
  }, getRootHostContext: () => null, getChildHostContext: (h) => h, finalizeInitialChildren(h) {
    var d;
    return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
  }, prepareUpdate(h, d, p, g) {
    var v;
    if (((v = h == null ? void 0 : h.__r3f) != null ? v : {}).primitive && g.object && g.object !== h) return [true];
    {
      const { args: M = [], children: m, ...w } = g, { args: E = [], children: A, ...P } = p;
      if (!Array.isArray(M)) throw new Error("R3F: the args prop must be an array!");
      if (M.some((L, D) => L !== E[D])) return [true];
      const R = NN(h, w, P, true);
      return R.changes.length ? [false, R] : null;
    }
  }, commitUpdate(h, [d, p], g, v, S, M) {
    d ? a(h, g, S, M) : Tx(h, p);
  }, commitMount(h, d, p, g) {
    var v;
    const S = (v = h.__r3f) != null ? v : {};
    h.raycast && S.handlers && S.eventCount && Ig(h).getState().internal.interaction.push(h);
  }, getPublicInstance: (h) => h, prepareForCommit: () => null, preparePortalMount: (h) => ec(h.getState().scene), resetAfterCommit: () => {
  }, shouldSetTextContent: () => false, clearContainer: () => false, hideInstance(h) {
    var d;
    const { attach: p, parent: g } = (d = h.__r3f) != null ? d : {};
    p && g && M2(g, h, p), h.isObject3D && (h.visible = false), tc(h);
  }, unhideInstance(h, d) {
    var p;
    const { attach: g, parent: v } = (p = h.__r3f) != null ? p : {};
    g && v && Ex(v, h, g), (h.isObject3D && d.visible == null || d.visible) && (h.visible = true), tc(h);
  }, createTextInstance: l, hideTextInstance: l, unhideTextInstance: l, getCurrentEventPriority: () => e ? e() : yc.DefaultEventPriority, beforeActiveInstanceBlur: () => {
  }, afterActiveInstanceBlur: () => {
  }, detachDeletedInstance: () => {
  }, now: typeof performance < "u" && tn.fun(performance.now) ? performance.now : tn.fun(Date.now) ? Date.now : () => 0, scheduleTimeout: tn.fun(setTimeout) ? setTimeout : void 0, cancelTimeout: tn.fun(clearTimeout) ? clearTimeout : void 0 }), applyProps: Tx };
}
var v2, y2;
const wx = (n24) => "colorSpace" in n24 || "outputColorSpace" in n24, bN = () => {
  var n24;
  return (n24 = iE.ColorManagement) != null ? n24 : null;
}, CN = (n24) => n24 && n24.isOrthographicCamera, x7 = (n24) => n24 && n24.hasOwnProperty("current"), Kd = typeof window < "u" && ((v2 = window.document) != null && v2.createElement || ((y2 = window.navigator) == null ? void 0 : y2.product) === "ReactNative") ? ne.useLayoutEffect : ne.useEffect;
function RN(n24) {
  const e = ne.useRef(n24);
  return Kd(() => void (e.current = n24), [n24]), e;
}
function S7({ set: n24 }) {
  return Kd(() => (n24(new Promise(() => null)), () => n24(false)), [n24]), null;
}
class PN extends ne.Component {
  constructor(...e) {
    super(...e), this.state = { error: false };
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
PN.getDerivedStateFromError = () => ({ error: true });
const LN = "__default", x2 = /* @__PURE__ */ new Map(), M7 = (n24) => n24 && !!n24.memoized && !!n24.changes;
function IN(n24) {
  var e;
  const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
  return Array.isArray(n24) ? Math.min(Math.max(n24[0], t), n24[1]) : n24;
}
const th = (n24) => {
  var e;
  return (e = n24.__r3f) == null ? void 0 : e.root.getState();
};
function Ig(n24) {
  let e = n24.__r3f.root;
  for (; e.getState().previousRoot; ) e = e.getState().previousRoot;
  return e;
}
const tn = { obj: (n24) => n24 === Object(n24) && !tn.arr(n24) && typeof n24 != "function", fun: (n24) => typeof n24 == "function", str: (n24) => typeof n24 == "string", num: (n24) => typeof n24 == "number", boo: (n24) => typeof n24 == "boolean", und: (n24) => n24 === void 0, arr: (n24) => Array.isArray(n24), equ(n24, e, { arrays: t = "shallow", objects: i = "reference", strict: r = true } = {}) {
  if (typeof n24 != typeof e || !!n24 != !!e) return false;
  if (tn.str(n24) || tn.num(n24) || tn.boo(n24)) return n24 === e;
  const s = tn.obj(n24);
  if (s && i === "reference") return n24 === e;
  const o = tn.arr(n24);
  if (o && t === "reference") return n24 === e;
  if ((o || s) && n24 === e) return true;
  let a;
  for (a in n24) if (!(a in e)) return false;
  if (s && t === "shallow" && i === "shallow") {
    for (a in r ? e : n24) if (!tn.equ(n24[a], e[a], { strict: r, objects: "reference" })) return false;
  } else for (a in r ? e : n24) if (n24[a] !== e[a]) return false;
  if (tn.und(a)) {
    if (o && n24.length === 0 && e.length === 0 || s && Object.keys(n24).length === 0 && Object.keys(e).length === 0) return true;
    if (n24 !== e) return false;
  }
  return true;
} };
function w7(n24) {
  n24.dispose && n24.type !== "Scene" && n24.dispose();
  for (const e in n24) e.dispose == null || e.dispose(), delete n24[e];
}
function ec(n24, e) {
  const t = n24;
  return t.__r3f = { type: "", root: null, previousAttach: null, memoizedProps: {}, eventCount: 0, handlers: {}, objects: [], parent: null, ...e }, n24;
}
function LS(n24, e) {
  let t = n24;
  if (e.includes("-")) {
    const i = e.split("-"), r = i.pop();
    return t = i.reduce((s, o) => s[o], n24), { target: t, key: r };
  } else return { target: t, key: e };
}
const S2 = /-\d+$/;
function Ex(n24, e, t) {
  if (tn.str(t)) {
    if (S2.test(t)) {
      const s = t.replace(S2, ""), { target: o, key: a } = LS(n24, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = LS(n24, t);
    e.__r3f.previousAttach = i[r], i[r] = e;
  } else e.__r3f.previousAttach = t(n24, e);
}
function M2(n24, e, t) {
  var i, r;
  if (tn.str(t)) {
    const { target: s, key: o } = LS(n24, t), a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : s[o] = a;
  } else (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n24, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function NN(n24, { children: e, key: t, ref: i, ...r }, { children: s, key: o, ref: a, ...l } = {}, f = false) {
  const h = n24.__r3f, d = Object.entries(r), p = [];
  if (f) {
    const v = Object.keys(l);
    for (let S = 0; S < v.length; S++) r.hasOwnProperty(v[S]) || d.unshift([v[S], LN + "remove"]);
  }
  d.forEach(([v, S]) => {
    var M;
    if ((M = n24.__r3f) != null && M.primitive && v === "object" || tn.equ(S, l[v])) return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(v)) return p.push([v, S, true, []]);
    let m = [];
    v.includes("-") && (m = v.split("-")), p.push([v, S, false, m]);
    for (const w in r) {
      const E = r[w];
      w.startsWith(`${v}-`) && p.push([w, E, false, w.split("-")]);
    }
  });
  const g = { ...r };
  return h != null && h.memoizedProps && h != null && h.memoizedProps.args && (g.args = h.memoizedProps.args), h != null && h.memoizedProps && h != null && h.memoizedProps.attach && (g.attach = h.memoizedProps.attach), { memoized: g, changes: p };
}
function Tx(n24, e) {
  var t;
  const i = n24.__r3f, r = i == null ? void 0 : i.root, s = r == null || r.getState == null ? void 0 : r.getState(), { memoized: o, changes: a } = M7(e) ? e : NN(n24, e), l = i == null ? void 0 : i.eventCount;
  n24.__r3f && (n24.__r3f.memoizedProps = o);
  for (let p = 0; p < a.length; p++) {
    let [g, v, S, M] = a[p];
    if (wx(n24)) {
      const A = "srgb", P = "srgb-linear";
      g === "encoding" ? (g = "colorSpace", v = v === 3001 ? A : P) : g === "outputEncoding" && (g = "outputColorSpace", v = v === 3001 ? A : P);
    }
    let m = n24, w = m[g];
    if (M.length && (w = M.reduce((E, A) => E[A], n24), !(w && w.set))) {
      const [E, ...A] = M.reverse();
      m = A.reverse().reduce((P, R) => P[R], n24), g = E;
    }
    if (v === LN + "remove") if (m.constructor) {
      let E = x2.get(m.constructor);
      E || (E = new m.constructor(), x2.set(m.constructor, E)), v = E[g];
    } else v = 0;
    if (S && i) v ? i.handlers[g] = v : delete i.handlers[g], i.eventCount = Object.keys(i.handlers).length;
    else if (w && w.set && (w.copy || w instanceof kl)) {
      if (Array.isArray(v)) w.fromArray ? w.fromArray(v) : w.set(...v);
      else if (w.copy && v && v.constructor && w.constructor === v.constructor) w.copy(v);
      else if (v !== void 0) {
        var f;
        const E = (f = w) == null ? void 0 : f.isColor;
        !E && w.setScalar ? w.setScalar(v) : w instanceof kl && v instanceof kl ? w.mask = v.mask : w.set(v), !bN() && s && !s.linear && E && w.convertSRGBToLinear();
      }
    } else {
      var h;
      if (m[g] = v, (h = m[g]) != null && h.isTexture && m[g].format === zi && m[g].type === to && s) {
        const E = m[g];
        wx(E) && wx(s.gl) ? E.colorSpace = s.gl.outputColorSpace : E.encoding = s.gl.outputEncoding;
      }
    }
    tc(n24);
  }
  if (i && i.parent && n24.raycast && l !== i.eventCount) {
    const p = Ig(n24).getState().internal, g = p.interaction.indexOf(n24);
    g > -1 && p.interaction.splice(g, 1), i.eventCount && p.interaction.push(n24);
  }
  return !(a.length === 1 && a[0][0] === "onUpdate") && a.length && (t = n24.__r3f) != null && t.parent && IS(n24), n24;
}
function tc(n24) {
  var e, t;
  const i = (e = n24.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function IS(n24) {
  n24.onUpdate == null || n24.onUpdate(n24);
}
function E7(n24, e) {
  n24.manual || (CN(n24) ? (n24.left = e.width / -2, n24.right = e.width / 2, n24.top = e.height / 2, n24.bottom = e.height / -2) : n24.aspect = e.width / e.height, n24.updateProjectionMatrix(), n24.updateMatrixWorld());
}
function sg(n24) {
  return (n24.eventObject || n24.object).uuid + "/" + n24.index + n24.instanceId;
}
function T7() {
  var n24;
  const e = typeof self < "u" && self || typeof window < "u" && window;
  if (!e) return yc.DefaultEventPriority;
  switch ((n24 = e.event) == null ? void 0 : n24.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return yc.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return yc.ContinuousEventPriority;
    default:
      return yc.DefaultEventPriority;
  }
}
function DN(n24, e, t, i) {
  const r = t.get(e);
  r && (t.delete(e), t.size === 0 && (n24.delete(i), r.target.releasePointerCapture(i)));
}
function A7(n24, e) {
  const { internal: t } = n24.getState();
  t.interaction = t.interaction.filter((i) => i !== e), t.initialHits = t.initialHits.filter((i) => i !== e), t.hovered.forEach((i, r) => {
    (i.eventObject === e || i.object === e) && t.hovered.delete(r);
  }), t.capturedMap.forEach((i, r) => {
    DN(t.capturedMap, e, i, r);
  });
}
function b7(n24) {
  function e(l) {
    const { internal: f } = n24.getState(), h = l.offsetX - f.initialClick[0], d = l.offsetY - f.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(l) {
    return l.filter((f) => ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
      var d;
      return (d = f.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
    }));
  }
  function i(l, f) {
    const h = n24.getState(), d = /* @__PURE__ */ new Set(), p = [], g = f ? f(h.internal.interaction) : h.internal.interaction;
    for (let m = 0; m < g.length; m++) {
      const w = th(g[m]);
      w && (w.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(l, h);
    function v(m) {
      const w = th(m);
      if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
      if (w.raycaster.camera === void 0) {
        var E;
        w.events.compute == null || w.events.compute(l, w, (E = w.previousRoot) == null ? void 0 : E.getState()), w.raycaster.camera === void 0 && (w.raycaster.camera = null);
      }
      return w.raycaster.camera ? w.raycaster.intersectObject(m, true) : [];
    }
    let S = g.flatMap(v).sort((m, w) => {
      const E = th(m.object), A = th(w.object);
      return !E || !A ? m.distance - w.distance : A.events.priority - E.events.priority || m.distance - w.distance;
    }).filter((m) => {
      const w = sg(m);
      return d.has(w) ? false : (d.add(w), true);
    });
    h.events.filter && (S = h.events.filter(S, h));
    for (const m of S) {
      let w = m.object;
      for (; w; ) {
        var M;
        (M = w.__r3f) != null && M.eventCount && p.push({ ...m, eventObject: w }), w = w.parent;
      }
    }
    if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId)) for (let m of h.internal.capturedMap.get(l.pointerId).values()) d.has(sg(m.intersection)) || p.push(m.intersection);
    return p;
  }
  function r(l, f, h, d) {
    const p = n24.getState();
    if (l.length) {
      const g = { stopped: false };
      for (const v of l) {
        const S = th(v.object) || p, { raycaster: M, pointer: m, camera: w, internal: E } = S, A = new V(m.x, m.y, 0).unproject(w), P = (C) => {
          var N, j;
          return (N = (j = E.capturedMap.get(C)) == null ? void 0 : j.has(v.eventObject)) != null ? N : false;
        }, R = (C) => {
          const N = { intersection: v, target: f.target };
          E.capturedMap.has(C) ? E.capturedMap.get(C).set(v.eventObject, N) : E.capturedMap.set(C, /* @__PURE__ */ new Map([[v.eventObject, N]])), f.target.setPointerCapture(C);
        }, L = (C) => {
          const N = E.capturedMap.get(C);
          N && DN(E.capturedMap, v.eventObject, N, C);
        };
        let D = {};
        for (let C in f) {
          let N = f[C];
          typeof N != "function" && (D[C] = N);
        }
        let F = { ...v, ...D, pointer: m, intersections: l, stopped: g.stopped, delta: h, unprojectedPoint: A, ray: M.ray, camera: w, stopPropagation() {
          const C = "pointerId" in f && E.capturedMap.get(f.pointerId);
          if ((!C || C.has(v.eventObject)) && (F.stopped = g.stopped = true, E.hovered.size && Array.from(E.hovered.values()).find((N) => N.eventObject === v.eventObject))) {
            const N = l.slice(0, l.indexOf(v));
            s([...N, v]);
          }
        }, target: { hasPointerCapture: P, setPointerCapture: R, releasePointerCapture: L }, currentTarget: { hasPointerCapture: P, setPointerCapture: R, releasePointerCapture: L }, nativeEvent: f };
        if (d(F), g.stopped === true) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: f } = n24.getState();
    for (const h of f.hovered.values()) if (!l.length || !l.find((d) => d.object === h.object && d.index === h.index && d.instanceId === h.instanceId)) {
      const p = h.eventObject.__r3f, g = p == null ? void 0 : p.handlers;
      if (f.hovered.delete(sg(h)), p != null && p.eventCount) {
        const v = { ...h, intersections: l };
        g.onPointerOut == null || g.onPointerOut(v), g.onPointerLeave == null || g.onPointerLeave(v);
      }
    }
  }
  function o(l, f) {
    for (let h = 0; h < f.length; h++) {
      const d = f[h].__r3f;
      d == null || d.handlers.onPointerMissed == null || d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (f) => {
          const { internal: h } = n24.getState();
          "pointerId" in f && h.capturedMap.has(f.pointerId) && requestAnimationFrame(() => {
            h.capturedMap.has(f.pointerId) && (h.capturedMap.delete(f.pointerId), s([]));
          });
        };
    }
    return function(h) {
      const { onPointerMissed: d, internal: p } = n24.getState();
      p.lastEvent.current = h;
      const g = l === "onPointerMove", v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick", M = i(h, g ? t : void 0), m = v ? e(h) : 0;
      l === "onPointerDown" && (p.initialClick = [h.offsetX, h.offsetY], p.initialHits = M.map((E) => E.eventObject)), v && !M.length && m <= 2 && (o(h, p.interaction), d && d(h)), g && s(M);
      function w(E) {
        const A = E.eventObject, P = A.__r3f, R = P == null ? void 0 : P.handlers;
        if (P != null && P.eventCount) if (g) {
          if (R.onPointerOver || R.onPointerEnter || R.onPointerOut || R.onPointerLeave) {
            const L = sg(E), D = p.hovered.get(L);
            D ? D.stopped && E.stopPropagation() : (p.hovered.set(L, E), R.onPointerOver == null || R.onPointerOver(E), R.onPointerEnter == null || R.onPointerEnter(E));
          }
          R.onPointerMove == null || R.onPointerMove(E);
        } else {
          const L = R[l];
          L ? (!v || p.initialHits.includes(A)) && (o(h, p.interaction.filter((D) => !p.initialHits.includes(D))), L(E)) : v && p.initialHits.includes(A) && o(h, p.interaction.filter((D) => !p.initialHits.includes(D)));
        }
      }
      r(M, h, m, w);
    };
  }
  return { handlePointer: a };
}
const ON = (n24) => !!(n24 != null && n24.render), UN = ne.createContext(null), C7 = (n24, e) => {
  const t = p7((a, l) => {
    const f = new V(), h = new V(), d = new V();
    function p(m = l().camera, w = h, E = l().size) {
      const { width: A, height: P, top: R, left: L } = E, D = A / P;
      w.isVector3 ? d.copy(w) : d.set(...w);
      const F = m.getWorldPosition(f).distanceTo(d);
      if (CN(m)) return { width: A / m.zoom, height: P / m.zoom, top: R, left: L, factor: 1, distance: F, aspect: D };
      {
        const C = m.fov * Math.PI / 180, N = 2 * Math.tan(C / 2) * F, j = N * (A / P);
        return { width: j, height: N, top: R, left: L, factor: A / j, distance: F, aspect: D };
      }
    }
    let g;
    const v = (m) => a((w) => ({ performance: { ...w.performance, current: m } })), S = new _e();
    return { set: a, get: l, gl: null, camera: null, raycaster: null, events: { priority: 1, enabled: true, connected: false }, xr: null, scene: null, invalidate: (m = 1) => n24(l(), m), advance: (m, w) => e(m, w, l()), legacy: false, linear: false, flat: false, controls: null, clock: new Qw(), pointer: S, mouse: S, frameloop: "always", onPointerMissed: void 0, performance: { current: 1, min: 0.5, max: 1, debounce: 200, regress: () => {
      const m = l();
      g && clearTimeout(g), m.performance.current !== m.performance.min && v(m.performance.min), g = setTimeout(() => v(l().performance.max), m.performance.debounce);
    } }, size: { width: 0, height: 0, top: 0, left: 0, updateStyle: false }, viewport: { initialDpr: 0, dpr: 0, width: 0, height: 0, top: 0, left: 0, aspect: 0, distance: 0, factor: 0, getCurrentViewport: p }, setEvents: (m) => a((w) => ({ ...w, events: { ...w.events, ...m } })), setSize: (m, w, E, A, P) => {
      const R = l().camera, L = { width: m, height: w, top: A || 0, left: P || 0, updateStyle: E };
      a((D) => ({ size: L, viewport: { ...D.viewport, ...p(R, h, L) } }));
    }, setDpr: (m) => a((w) => {
      const E = IN(m);
      return { viewport: { ...w.viewport, dpr: E, initialDpr: w.viewport.initialDpr || E } };
    }), setFrameloop: (m = "always") => {
      const w = l().clock;
      w.stop(), w.elapsedTime = 0, m !== "never" && (w.start(), w.elapsedTime = 0), a(() => ({ frameloop: m }));
    }, previousRoot: void 0, internal: { active: false, priority: 0, frames: 0, lastEvent: ne.createRef(), interaction: [], hovered: /* @__PURE__ */ new Map(), subscribers: [], initialClick: [0, 0], initialHits: [], capturedMap: /* @__PURE__ */ new Map(), subscribe: (m, w, E) => {
      const A = l().internal;
      return A.priority = A.priority + (w > 0 ? 1 : 0), A.subscribers.push({ ref: m, priority: w, store: E }), A.subscribers = A.subscribers.sort((P, R) => P.priority - R.priority), () => {
        const P = l().internal;
        P != null && P.subscribers && (P.priority = P.priority - (w > 0 ? 1 : 0), P.subscribers = P.subscribers.filter((R) => R.ref !== m));
      };
    } } };
  }), i = t.getState();
  let r = i.size, s = i.viewport.dpr, o = i.camera;
  return t.subscribe(() => {
    const { camera: a, size: l, viewport: f, gl: h, set: d } = t.getState();
    if (l.width !== r.width || l.height !== r.height || f.dpr !== s) {
      var p;
      r = l, s = f.dpr, E7(a, l), h.setPixelRatio(f.dpr);
      const g = (p = l.updateStyle) != null ? p : typeof HTMLCanvasElement < "u" && h.domElement instanceof HTMLCanvasElement;
      h.setSize(l.width, l.height, g);
    }
    a !== o && (o = a, d((g) => ({ viewport: { ...g.viewport, ...g.viewport.getCurrentViewport(a) } })));
  }), t.subscribe((a) => n24(a)), t;
};
let og, R7 = /* @__PURE__ */ new Set(), P7 = /* @__PURE__ */ new Set(), L7 = /* @__PURE__ */ new Set();
function Ax(n24, e) {
  if (n24.size) for (const { callback: t } of n24.values()) t(e);
}
function nh(n24, e) {
  switch (n24) {
    case "before":
      return Ax(R7, e);
    case "after":
      return Ax(P7, e);
    case "tail":
      return Ax(L7, e);
  }
}
let bx, Cx;
function Rx(n24, e, t) {
  let i = e.clock.getDelta();
  for (e.frameloop === "never" && typeof n24 == "number" && (i = n24 - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n24), bx = e.internal.subscribers, og = 0; og < bx.length; og++) Cx = bx[og], Cx.ref.current(Cx.store.getState(), i, t);
  return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames;
}
function I7(n24) {
  let e = false, t = false, i, r, s;
  function o(f) {
    r = requestAnimationFrame(o), e = true, i = 0, nh("before", f), t = true;
    for (const d of n24.values()) {
      var h;
      s = d.store.getState(), s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((h = s.gl.xr) != null && h.isPresenting) && (i += Rx(f, s));
    }
    if (t = false, nh("after", f), i === 0) return nh("tail", f), e = false, cancelAnimationFrame(r);
  }
  function a(f, h = 1) {
    var d;
    if (!f) return n24.forEach((p) => a(p.store.getState(), h));
    (d = f.gl.xr) != null && d.isPresenting || !f.internal.active || f.frameloop === "never" || (h > 1 ? f.internal.frames = Math.min(60, f.internal.frames + h) : t ? f.internal.frames = 2 : f.internal.frames = 1, e || (e = true, requestAnimationFrame(o)));
  }
  function l(f, h = true, d, p) {
    if (h && nh("before", f), d) Rx(f, d, p);
    else for (const g of n24.values()) Rx(f, g.store.getState());
    h && nh("after", f);
  }
  return { loop: o, invalidate: a, advance: l };
}
function kN() {
  const n24 = ne.useContext(UN);
  if (!n24) throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n24;
}
function N7(n24 = (t) => t, e) {
  return kN()(n24, e);
}
function FN(n24, e = 0) {
  const t = kN(), i = t.getState().internal.subscribe, r = RN(n24);
  return Kd(() => i(r, e, t), [e, i, t]), null;
}
const jc = /* @__PURE__ */ new Map(), { invalidate: w2, advance: E2 } = I7(jc), { reconciler: _0, applyProps: Zu } = y7(jc, T7), Ju = { objects: "shallow", strict: false }, D7 = (n24, e) => {
  const t = typeof n24 == "function" ? n24(e) : n24;
  return ON(t) ? t : new Ow({ powerPreference: "high-performance", canvas: e, antialias: true, alpha: true, ...n24 });
};
function O7(n24, e) {
  const t = typeof HTMLCanvasElement < "u" && n24 instanceof HTMLCanvasElement;
  if (e) {
    const { width: i, height: r, top: s, left: o, updateStyle: a = t } = e;
    return { width: i, height: r, top: s, left: o, updateStyle: a };
  } else if (typeof HTMLCanvasElement < "u" && n24 instanceof HTMLCanvasElement && n24.parentElement) {
    const { width: i, height: r, top: s, left: o } = n24.parentElement.getBoundingClientRect();
    return { width: i, height: r, top: s, left: o, updateStyle: t };
  } else if (typeof OffscreenCanvas < "u" && n24 instanceof OffscreenCanvas) return { width: n24.width, height: n24.height, top: 0, left: 0, updateStyle: t };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function U7(n24) {
  const e = jc.get(n24), t = e == null ? void 0 : e.fiber, i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error, s = i || C7(w2, E2), o = t || _0.createContainer(s, yc.ConcurrentRoot, null, false, null, "", r, null);
  e || jc.set(n24, { fiber: o, store: s });
  let a, l = false, f;
  return { configure(h = {}) {
    let { gl: d, size: p, scene: g, events: v, onCreated: S, shadows: M = false, linear: m = false, flat: w = false, legacy: E = false, orthographic: A = false, frameloop: P = "always", dpr: R = [1, 2], performance: L, raycaster: D, camera: F, onPointerMissed: C } = h, N = s.getState(), j = N.gl;
    N.gl || N.set({ gl: j = D7(d, n24) });
    let Z = N.raycaster;
    Z || N.set({ raycaster: Z = new SN() });
    const { params: G, ...J } = D || {};
    if (tn.equ(J, Z, Ju) || Zu(Z, { ...J }), tn.equ(G, Z.params, Ju) || Zu(Z, { params: { ...Z.params, ...G } }), !N.camera || N.camera === f && !tn.equ(f, F, Ju)) {
      f = F;
      const $ = F instanceof Hd, ee = $ ? F : A ? new Xd(0, 0, 0, 0, 0.1, 1e3) : new ni(75, 0, 0.1, 1e3);
      $ || (ee.position.z = 5, F && (Zu(ee, F), ("aspect" in F || "left" in F || "right" in F || "bottom" in F || "top" in F) && (ee.manual = true, ee.updateProjectionMatrix())), !N.camera && !(F != null && F.rotation) && ee.lookAt(0, 0, 0)), N.set({ camera: ee }), Z.camera = ee;
    }
    if (!N.scene) {
      let $;
      g != null && g.isScene ? $ = g : ($ = new Uw(), g && Zu($, g)), N.set({ scene: ec($) });
    }
    if (!N.xr) {
      var q;
      const $ = (Ae, te) => {
        const de = s.getState();
        de.frameloop !== "never" && E2(Ae, true, de, te);
      }, ee = () => {
        const Ae = s.getState();
        Ae.gl.xr.enabled = Ae.gl.xr.isPresenting, Ae.gl.xr.setAnimationLoop(Ae.gl.xr.isPresenting ? $ : null), Ae.gl.xr.isPresenting || w2(Ae);
      }, ue = { connect() {
        const Ae = s.getState().gl;
        Ae.xr.addEventListener("sessionstart", ee), Ae.xr.addEventListener("sessionend", ee);
      }, disconnect() {
        const Ae = s.getState().gl;
        Ae.xr.removeEventListener("sessionstart", ee), Ae.xr.removeEventListener("sessionend", ee);
      } };
      typeof ((q = j.xr) == null ? void 0 : q.addEventListener) == "function" && ue.connect(), N.set({ xr: ue });
    }
    if (j.shadowMap) {
      const $ = j.shadowMap.enabled, ee = j.shadowMap.type;
      if (j.shadowMap.enabled = !!M, tn.boo(M)) j.shadowMap.type = wh;
      else if (tn.str(M)) {
        var ae;
        const ue = { basic: dL, percentage: E_, soft: wh, variance: vs };
        j.shadowMap.type = (ae = ue[M]) != null ? ae : wh;
      } else tn.obj(M) && Object.assign(j.shadowMap, M);
      ($ !== j.shadowMap.enabled || ee !== j.shadowMap.type) && (j.shadowMap.needsUpdate = true);
    }
    const B = bN();
    B && ("enabled" in B ? B.enabled = !E : "legacyMode" in B && (B.legacyMode = E)), l || Zu(j, { outputEncoding: m ? 3e3 : 3001, toneMapping: w ? eo : mw }), N.legacy !== E && N.set(() => ({ legacy: E })), N.linear !== m && N.set(() => ({ linear: m })), N.flat !== w && N.set(() => ({ flat: w })), d && !tn.fun(d) && !ON(d) && !tn.equ(d, j, Ju) && Zu(j, d), v && !N.events.handlers && N.set({ events: v(s) });
    const Y = O7(n24, p);
    return tn.equ(Y, N.size, Ju) || N.setSize(Y.width, Y.height, Y.updateStyle, Y.top, Y.left), R && N.viewport.dpr !== IN(R) && N.setDpr(R), N.frameloop !== P && N.setFrameloop(P), N.onPointerMissed || N.set({ onPointerMissed: C }), L && !tn.equ(L, N.performance, Ju) && N.set(($) => ({ performance: { ...$.performance, ...L } })), a = S, l = true, this;
  }, render(h) {
    return l || this.configure(), _0.updateContainer(Be.jsx(k7, { store: s, children: h, onCreated: a, rootElement: n24 }), o, null, () => {
    }), s;
  }, unmount() {
    zN(n24);
  } };
}
function k7({ store: n24, children: e, onCreated: t, rootElement: i }) {
  return Kd(() => {
    const r = n24.getState();
    r.set((s) => ({ internal: { ...s.internal, active: true } })), t && t(r), n24.getState().events.connected || r.events.connect == null || r.events.connect(i);
  }, []), Be.jsx(UN.Provider, { value: n24, children: e });
}
function zN(n24, e) {
  const t = jc.get(n24), i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = false), _0.updateContainer(null, i, null, () => {
      r && setTimeout(() => {
        try {
          var s, o, a, l;
          r.events.disconnect == null || r.events.disconnect(), (s = r.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = r.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = r.gl) != null && l.xr && r.xr.disconnect(), w7(r), jc.delete(n24);
        } catch {
        }
      }, 500);
    });
  }
}
_0.injectIntoDevTools({ bundleType: 0, rendererPackageName: "@react-three/fiber", version: ne.version });
const Px = { onClick: ["click", false], onContextMenu: ["contextmenu", false], onDoubleClick: ["dblclick", false], onWheel: ["wheel", true], onPointerDown: ["pointerdown", true], onPointerUp: ["pointerup", true], onPointerLeave: ["pointerleave", true], onPointerMove: ["pointermove", true], onPointerCancel: ["pointercancel", true], onLostPointerCapture: ["lostpointercapture", true] };
function F7(n24) {
  const { handlePointer: e } = b7(n24);
  return { priority: 1, enabled: true, compute(t, i, r) {
    i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera);
  }, connected: void 0, handlers: Object.keys(Px).reduce((t, i) => ({ ...t, [i]: e(i) }), {}), update: () => {
    var t;
    const { events: i, internal: r } = n24.getState();
    (t = r.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(r.lastEvent.current);
  }, connect: (t) => {
    var i;
    const { set: r, events: s } = n24.getState();
    s.disconnect == null || s.disconnect(), r((o) => ({ events: { ...o.events, connected: t } })), Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
      const [l, f] = Px[o];
      t.addEventListener(l, a, { passive: f });
    });
  }, disconnect: () => {
    const { set: t, events: i } = n24.getState();
    if (i.connected) {
      var r;
      Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
        if (i && i.connected instanceof HTMLElement) {
          const [a] = Px[s];
          i.connected.removeEventListener(a, o);
        }
      }), t((s) => ({ events: { ...s.events, connected: void 0 } }));
    }
  } };
}
function T2(n24, e) {
  let t;
  return (...i) => {
    window.clearTimeout(t), t = window.setTimeout(() => n24(...i), e);
  };
}
function z7({ debounce: n24, scroll: e, polyfill: t, offsetSize: i } = { debounce: 0, scroll: false, offsetSize: false }) {
  const r = t || (typeof window > "u" ? class {
  } : window.ResizeObserver);
  if (!r) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [s, o] = ne.useState({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), a = ne.useRef({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: s, orientationHandler: null }), l = n24 ? typeof n24 == "number" ? n24 : n24.scroll : null, f = n24 ? typeof n24 == "number" ? n24 : n24.resize : null, h = ne.useRef(false);
  ne.useEffect(() => (h.current = true, () => void (h.current = false)));
  const [d, p, g] = ne.useMemo(() => {
    const m = () => {
      if (!a.current.element) return;
      const { left: w, top: E, width: A, height: P, bottom: R, right: L, x: D, y: F } = a.current.element.getBoundingClientRect(), C = { left: w, top: E, width: A, height: P, bottom: R, right: L, x: D, y: F };
      a.current.element instanceof HTMLElement && i && (C.height = a.current.element.offsetHeight, C.width = a.current.element.offsetWidth), Object.freeze(C), h.current && !G7(a.current.lastBounds, C) && o(a.current.lastBounds = C);
    };
    return [m, f ? T2(m, f) : m, l ? T2(m, l) : m];
  }, [o, i, l, f]);
  function v() {
    a.current.scrollContainers && (a.current.scrollContainers.forEach((m) => m.removeEventListener("scroll", g, true)), a.current.scrollContainers = null), a.current.resizeObserver && (a.current.resizeObserver.disconnect(), a.current.resizeObserver = null), a.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", a.current.orientationHandler));
  }
  function S() {
    a.current.element && (a.current.resizeObserver = new r(g), a.current.resizeObserver.observe(a.current.element), e && a.current.scrollContainers && a.current.scrollContainers.forEach((m) => m.addEventListener("scroll", g, { capture: true, passive: true })), a.current.orientationHandler = () => {
      g();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", a.current.orientationHandler));
  }
  const M = (m) => {
    !m || m === a.current.element || (v(), a.current.element = m, a.current.scrollContainers = BN(m), S());
  };
  return V7(g, !!e), B7(p), ne.useEffect(() => {
    v(), S();
  }, [e, g, p]), ne.useEffect(() => v, []), [M, s, d];
}
function B7(n24) {
  ne.useEffect(() => {
    const e = n24;
    return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e);
  }, [n24]);
}
function V7(n24, e) {
  ne.useEffect(() => {
    if (e) {
      const t = n24;
      return window.addEventListener("scroll", t, { capture: true, passive: true }), () => void window.removeEventListener("scroll", t, true);
    }
  }, [n24, e]);
}
function BN(n24) {
  const e = [];
  if (!n24 || n24 === document.body) return e;
  const { overflow: t, overflowX: i, overflowY: r } = window.getComputedStyle(n24);
  return [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n24), [...e, ...BN(n24.parentElement)];
}
const H7 = ["x", "y", "top", "bottom", "left", "right", "width", "height"], G7 = (n24, e) => H7.every((t) => n24[t] === e[t]);
var W7 = Object.defineProperty, X7 = Object.defineProperties, j7 = Object.getOwnPropertyDescriptors, A2 = Object.getOwnPropertySymbols, $7 = Object.prototype.hasOwnProperty, Y7 = Object.prototype.propertyIsEnumerable, b2 = (n24, e, t) => e in n24 ? W7(n24, e, { enumerable: true, configurable: true, writable: true, value: t }) : n24[e] = t, C2 = (n24, e) => {
  for (var t in e || (e = {})) $7.call(e, t) && b2(n24, t, e[t]);
  if (A2) for (var t of A2(e)) Y7.call(e, t) && b2(n24, t, e[t]);
  return n24;
}, q7 = (n24, e) => X7(n24, j7(e)), R2, P2;
typeof window < "u" && ((R2 = window.document) != null && R2.createElement || ((P2 = window.navigator) == null ? void 0 : P2.product) === "ReactNative") ? ne.useLayoutEffect : ne.useEffect;
function VN(n24, e, t) {
  if (!n24) return;
  if (t(n24) === true) return n24;
  let i = n24.child;
  for (; i; ) {
    const r = VN(i, e, t);
    if (r) return r;
    i = i.sibling;
  }
}
function HN(n24) {
  try {
    return Object.defineProperties(n24, { _currentRenderer: { get() {
      return null;
    }, set() {
    } }, _currentRenderer2: { get() {
      return null;
    }, set() {
    } } });
  } catch {
    return n24;
  }
}
const L2 = console.error;
console.error = function() {
  const n24 = [...arguments].join("");
  if ((n24 == null ? void 0 : n24.startsWith("Warning:")) && n24.includes("useContext")) {
    console.error = L2;
    return;
  }
  return L2.apply(this, arguments);
};
const rE = HN(ne.createContext(null));
class GN extends ne.Component {
  render() {
    return ne.createElement(rE.Provider, { value: this._reactInternals }, this.props.children);
  }
}
function K7() {
  const n24 = ne.useContext(rE);
  if (n24 === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
  const e = ne.useId();
  return ne.useMemo(() => {
    for (const i of [n24, n24 == null ? void 0 : n24.alternate]) {
      if (!i) continue;
      const r = VN(i, false, (s) => {
        let o = s.memoizedState;
        for (; o; ) {
          if (o.memoizedState === e) return true;
          o = o.next;
        }
      });
      if (r) return r;
    }
  }, [n24, e]);
}
function Z7() {
  const n24 = K7(), [e] = ne.useState(() => /* @__PURE__ */ new Map());
  e.clear();
  let t = n24;
  for (; t; ) {
    if (t.type && typeof t.type == "object") {
      const r = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
      r && r !== rE && !e.has(r) && e.set(r, ne.useContext(HN(r)));
    }
    t = t.return;
  }
  return e;
}
function J7() {
  const n24 = Z7();
  return ne.useMemo(() => Array.from(n24.keys()).reduce((e, t) => (i) => ne.createElement(e, null, ne.createElement(t.Provider, q7(C2({}, i), { value: n24.get(t) }))), (e) => ne.createElement(GN, C2({}, e))), [n24]);
}
const Q7 = ne.forwardRef(function({ children: e, fallback: t, resize: i, style: r, gl: s, events: o = F7, eventSource: a, eventPrefix: l, shadows: f, linear: h, flat: d, legacy: p, orthographic: g, frameloop: v, dpr: S, performance: M, raycaster: m, camera: w, scene: E, onPointerMissed: A, onCreated: P, ...R }, L) {
  ne.useMemo(() => v7(f7), []);
  const D = J7(), [F, C] = z7({ scroll: true, debounce: { scroll: 50, resize: 0 }, ...i }), N = ne.useRef(null), j = ne.useRef(null);
  ne.useImperativeHandle(L, () => N.current);
  const Z = RN(A), [G, J] = ne.useState(false), [q, ae] = ne.useState(false);
  if (G) throw G;
  if (q) throw q;
  const B = ne.useRef(null);
  Kd(() => {
    const $ = N.current;
    C.width > 0 && C.height > 0 && $ && (B.current || (B.current = U7($)), B.current.configure({ gl: s, events: o, shadows: f, linear: h, flat: d, legacy: p, orthographic: g, frameloop: v, dpr: S, performance: M, raycaster: m, camera: w, scene: E, size: C, onPointerMissed: (...ee) => Z.current == null ? void 0 : Z.current(...ee), onCreated: (ee) => {
      ee.events.connect == null || ee.events.connect(a ? x7(a) ? a.current : a : j.current), l && ee.setEvents({ compute: (ue, Ae) => {
        const te = ue[l + "X"], de = ue[l + "Y"];
        Ae.pointer.set(te / Ae.size.width * 2 - 1, -(de / Ae.size.height) * 2 + 1), Ae.raycaster.setFromCamera(Ae.pointer, Ae.camera);
      } }), P == null ? void 0 : P(ee);
    } }), B.current.render(Be.jsx(D, { children: Be.jsx(PN, { set: ae, children: Be.jsx(ne.Suspense, { fallback: Be.jsx(S7, { set: J }), children: e ?? null }) }) })));
  }), ne.useEffect(() => {
    const $ = N.current;
    if ($) return () => zN($);
  }, []);
  const Y = a ? "none" : "auto";
  return Be.jsx("div", { ref: j, style: { position: "relative", width: "100%", height: "100%", overflow: "hidden", pointerEvents: Y, ...r }, ...R, children: Be.jsx("div", { ref: F, style: { width: "100%", height: "100%" }, children: Be.jsx("canvas", { ref: N, style: { display: "block" }, children: t }) }) });
}), eX = ne.forwardRef(function(e, t) {
  return Be.jsx(GN, { children: Be.jsx(Q7, { ...e, ref: t }) });
});
function tX(n24, e) {
  const t = n24 + "Geometry";
  return ne.forwardRef(({ args: i, children: r, ...s }, o) => {
    const a = ne.useRef(null);
    return ne.useImperativeHandle(o, () => a.current), ne.useLayoutEffect(() => void (e == null ? void 0 : e(a.current))), ne.createElement("mesh", dt({ ref: a }, s), ne.createElement(t, { attach: "geometry", args: i }), r);
  });
}
const nX = tX("icosahedron"), iX = {}, I2 = (n24) => {
  let e;
  const t = /* @__PURE__ */ new Set(), i = (h, d) => {
    const p = typeof h == "function" ? h(e) : h;
    if (!Object.is(p, e)) {
      const g = e;
      e = d ?? (typeof p != "object" || p === null) ? p : Object.assign({}, e, p), t.forEach((v) => v(e, g));
    }
  }, r = () => e, l = { setState: i, getState: r, getInitialState: () => f, subscribe: (h) => (t.add(h), () => t.delete(h)), destroy: () => {
    (iX ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), t.clear();
  } }, f = e = n24(i, r, l);
  return l;
}, rX = (n24) => n24 ? I2(n24) : I2;
var WN = { exports: {} }, XN = {}, jN = { exports: {} }, $N = {};
/**
* @license React
* use-sync-external-store-shim.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var $c = ne;
function sX(n24, e) {
  return n24 === e && (n24 !== 0 || 1 / n24 === 1 / e) || n24 !== n24 && e !== e;
}
var oX = typeof Object.is == "function" ? Object.is : sX, aX = $c.useState, lX = $c.useEffect, uX = $c.useLayoutEffect, cX = $c.useDebugValue;
function fX(n24, e) {
  var t = e(), i = aX({ inst: { value: t, getSnapshot: e } }), r = i[0].inst, s = i[1];
  return uX(function() {
    r.value = t, r.getSnapshot = e, Lx(r) && s({ inst: r });
  }, [n24, t, e]), lX(function() {
    return Lx(r) && s({ inst: r }), n24(function() {
      Lx(r) && s({ inst: r });
    });
  }, [n24]), cX(t), t;
}
function Lx(n24) {
  var e = n24.getSnapshot;
  n24 = n24.value;
  try {
    var t = e();
    return !oX(n24, t);
  } catch {
    return true;
  }
}
function hX(n24, e) {
  return e();
}
var dX = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? hX : fX;
$N.useSyncExternalStore = $c.useSyncExternalStore !== void 0 ? $c.useSyncExternalStore : dX;
jN.exports = $N;
var pX = jN.exports;
/**
* @license React
* use-sync-external-store-shim/with-selector.production.js
*
* Copyright (c) Meta Platforms, Inc. and affiliates.
*
* This source code is licensed under the MIT license found in the
* LICENSE file in the root directory of this source tree.
*/
var Z_ = ne, mX = pX;
function gX(n24, e) {
  return n24 === e && (n24 !== 0 || 1 / n24 === 1 / e) || n24 !== n24 && e !== e;
}
var _X = typeof Object.is == "function" ? Object.is : gX, vX = mX.useSyncExternalStore, yX = Z_.useRef, xX = Z_.useEffect, SX = Z_.useMemo, MX = Z_.useDebugValue;
XN.useSyncExternalStoreWithSelector = function(n24, e, t, i, r) {
  var s = yX(null);
  if (s.current === null) {
    var o = { hasValue: false, value: null };
    s.current = o;
  } else o = s.current;
  s = SX(function() {
    function l(g) {
      if (!f) {
        if (f = true, h = g, g = i(g), r !== void 0 && o.hasValue) {
          var v = o.value;
          if (r(v, g)) return d = v;
        }
        return d = g;
      }
      if (v = d, _X(h, g)) return v;
      var S = i(g);
      return r !== void 0 && r(v, S) ? (h = g, v) : (h = g, d = S);
    }
    var f = false, h, d, p = t === void 0 ? null : t;
    return [function() {
      return l(e());
    }, p === null ? void 0 : function() {
      return l(p());
    }];
  }, [e, t, i, r]);
  var a = vX(n24, s[0], s[1]);
  return xX(function() {
    o.hasValue = true, o.value = a;
  }, [a]), MX(a), a;
};
WN.exports = XN;
var wX = WN.exports;
const EX = JS(wX), YN = {}, { useDebugValue: TX } = Ml, { useSyncExternalStoreWithSelector: AX } = EX;
let N2 = false;
const bX = (n24) => n24;
function CX(n24, e = bX, t) {
  (YN ? "production" : void 0) !== "production" && t && !N2 && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), N2 = true);
  const i = AX(n24.subscribe, n24.getState, n24.getServerState || n24.getInitialState, e, t);
  return TX(i), i;
}
const D2 = (n24) => {
  (YN ? "production" : void 0) !== "production" && typeof n24 != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
  const e = typeof n24 == "function" ? rX(n24) : n24, t = (i, r) => CX(e, i, r);
  return Object.assign(t, e), t;
}, RX = (n24) => n24 ? D2(n24) : D2;
function Mo(n24) {
  if (n24 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n24;
}
function qN(n24, e) {
  n24.prototype = Object.create(e.prototype), n24.prototype.constructor = n24, n24.__proto__ = e;
}
/*!
 * GSAP 3.12.7
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var Pr = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Yc = { duration: 0.5, overwrite: false, delay: 0 }, sE, di, an, io = 1e8, Ci = 1 / io, NS = Math.PI * 2, PX = NS / 4, LX = 0, KN = Math.sqrt, IX = Math.cos, NX = Math.sin, ri = function(e) {
  return typeof e == "string";
}, En = function(e) {
  return typeof e == "function";
}, Bo = function(e) {
  return typeof e == "number";
}, oE = function(e) {
  return typeof e > "u";
}, oo = function(e) {
  return typeof e == "object";
}, sr = function(e) {
  return e !== false;
}, aE = function() {
  return typeof window < "u";
}, ag = function(e) {
  return En(e) || ri(e);
}, ZN = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
}, Pi = Array.isArray, DS = /(?:-?\.?\d|\.)+/gi, JN = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, xc = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Ix = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, QN = /[+-]=-?[.\d]+/, eD = /[^,'"\[\]\s]+/gi, DX = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, hn, Vs, OS, lE, Ir = {}, v0 = {}, tD, nD = function(e) {
  return (v0 = qc(e, Ir)) && cr;
}, uE = function(e, t) {
  return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()");
}, xd = function(e, t) {
  return !t && console.warn(e);
}, iD = function(e, t) {
  return e && (Ir[e] = t) && v0 && (v0[e] = t) || Ir;
}, Sd = function() {
  return 0;
}, OX = { suppressEvents: true, isStart: true, kill: false }, Ng = { suppressEvents: true, kill: false }, UX = { suppressEvents: true }, cE = {}, La = [], US = {}, rD, xr = {}, Nx = {}, O2 = 30, Dg = [], fE = "", hE = function(e) {
  var t = e[0], i, r;
  if (oo(t) || En(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
    for (r = Dg.length; r-- && !Dg[r].targetTest(t); ) ;
    i = Dg[r];
  }
  for (r = e.length; r--; ) e[r] && (e[r]._gsap || (e[r]._gsap = new CD(e[r], i))) || e.splice(r, 1);
  return e;
}, Bl = function(e) {
  return e._gsap || hE(rs(e))[0]._gsap;
}, sD = function(e, t, i) {
  return (i = e[t]) && En(i) ? e[t]() : oE(i) && e.getAttribute && e.getAttribute(t) || i;
}, or = function(e, t) {
  return (e = e.split(",")).forEach(t) || e;
}, Rn = function(e) {
  return Math.round(e * 1e5) / 1e5 || 0;
}, zn = function(e) {
  return Math.round(e * 1e7) / 1e7 || 0;
}, Lc = function(e, t) {
  var i = t.charAt(0), r = parseFloat(t.substr(2));
  return e = parseFloat(e), i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r;
}, kX = function(e, t) {
  for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i; ) ;
  return r < i;
}, y0 = function() {
  var e = La.length, t = La.slice(0), i, r;
  for (US = {}, La.length = 0, i = 0; i < e; i++) r = t[i], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], true)._lazy = 0);
}, oD = function(e, t, i, r) {
  La.length && !di && y0(), e.render(t, i, di && t < 0 && (e._initted || e._startAt)), La.length && !di && y0();
}, aD = function(e) {
  var t = parseFloat(e);
  return (t || t === 0) && (e + "").match(eD).length < 2 ? t : ri(e) ? e.trim() : e;
}, lD = function(e) {
  return e;
}, Nr = function(e, t) {
  for (var i in t) i in e || (e[i] = t[i]);
  return e;
}, FX = function(e) {
  return function(t, i) {
    for (var r in i) r in t || r === "duration" && e || r === "ease" || (t[r] = i[r]);
  };
}, qc = function(e, t) {
  for (var i in t) e[i] = t[i];
  return e;
}, U2 = function n10(e, t) {
  for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = oo(t[i]) ? n10(e[i] || (e[i] = {}), t[i]) : t[i]);
  return e;
}, x0 = function(e, t) {
  var i = {}, r;
  for (r in e) r in t || (i[r] = e[r]);
  return i;
}, Ch = function(e) {
  var t = e.parent || hn, i = e.keyframes ? FX(Pi(e.keyframes)) : Nr;
  if (sr(e.inherit)) for (; t; ) i(e, t.vars.defaults), t = t.parent || t._dp;
  return e;
}, zX = function(e, t) {
  for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i]; ) ;
  return i < 0;
}, uD = function(e, t, i, r, s) {
  var o = e[r], a;
  if (s) for (a = t[s]; o && o[s] > a; ) o = o._prev;
  return o ? (t._next = o._next, o._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = o, t.parent = t._dp = e, t;
}, J_ = function(e, t, i, r) {
  i === void 0 && (i = "_first"), r === void 0 && (r = "_last");
  var s = t._prev, o = t._next;
  s ? s._next = o : e[i] === t && (e[i] = o), o ? o._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null;
}, ka = function(e, t) {
  e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0;
}, Vl = function(e, t) {
  if (e && (!t || t._end > e._dur || t._start < 0)) for (var i = e; i; ) i._dirty = 1, i = i.parent;
  return e;
}, BX = function(e) {
  for (var t = e.parent; t && t.parent; ) t._dirty = 1, t.totalDuration(), t = t.parent;
  return e;
}, kS = function(e, t, i, r) {
  return e._startAt && (di ? e._startAt.revert(Ng) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, true, r));
}, VX = function n11(e) {
  return !e || e._ts && n11(e.parent);
}, k2 = function(e) {
  return e._repeat ? Kc(e._tTime, e = e.duration() + e._rDelay) * e : 0;
}, Kc = function(e, t) {
  var i = Math.floor(e = zn(e / t));
  return e && i === e ? i - 1 : i;
}, S0 = function(e, t) {
  return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur);
}, Q_ = function(e) {
  return e._end = zn(e._start + (e._tDur / Math.abs(e._ts || e._rts || Ci) || 0));
}, ev = function(e, t) {
  var i = e._dp;
  return i && i.smoothChildTiming && e._ts && (e._start = zn(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Q_(e), i._dirty || Vl(i, e)), e;
}, cD = function(e, t) {
  var i;
  if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = S0(e.rawTime(), t), (!t._dur || Zd(0, t.totalDuration(), i) - t._tTime > Ci) && t.render(i, true)), Vl(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
    if (e._dur < e.duration()) for (i = e; i._dp; ) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
    e._zTime = -1e-8;
  }
}, js = function(e, t, i, r) {
  return t.parent && ka(t), t._start = zn((Bo(i) ? i : i || e !== hn ? qr(e, i, t) : e._time) + t._delay), t._end = zn(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), uD(e, t, "_first", "_last", e._sort ? "_start" : 0), FS(t) || (e._recent = t), r || cD(e, t), e._ts < 0 && ev(e, e._tTime), e;
}, fD = function(e, t) {
  return (Ir.ScrollTrigger || uE("scrollTrigger", t)) && Ir.ScrollTrigger.create(t, e);
}, hD = function(e, t, i, r, s) {
  if (pE(e, t, s), !e._initted) return 1;
  if (!i && e._pt && !di && (e._dur && e.vars.lazy !== false || !e._dur && e.vars.lazy) && rD !== Er.frame) return La.push(e), e._lazy = [s, r], 1;
}, HX = function n12(e) {
  var t = e.parent;
  return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n12(t));
}, FS = function(e) {
  var t = e.data;
  return t === "isFromStart" || t === "isStart";
}, GX = function(e, t, i, r) {
  var s = e.ratio, o = t < 0 || !t && (!e._start && HX(e) && !(!e._initted && FS(e)) || (e._ts < 0 || e._dp._ts < 0) && !FS(e)) ? 0 : 1, a = e._rDelay, l = 0, f, h, d;
  if (a && e._repeat && (l = Zd(0, e._tDur, t), h = Kc(l, a), e._yoyo && h & 1 && (o = 1 - o), h !== Kc(e._tTime, a) && (s = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== s || di || r || e._zTime === Ci || !t && e._zTime) {
    if (!e._initted && hD(e, t, r, i, l)) return;
    for (d = e._zTime, e._zTime = t || (i ? Ci : 0), i || (i = t && !d), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, f = e._pt; f; ) f.r(o, f.d), f = f._next;
    t < 0 && kS(e, t, i, true), e._onUpdate && !i && Ar(e, "onUpdate"), l && e._repeat && !i && e.parent && Ar(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && ka(e, 1), !i && !di && (Ar(e, o ? "onComplete" : "onReverseComplete", true), e._prom && e._prom()));
  } else e._zTime || (e._zTime = t);
}, WX = function(e, t, i) {
  var r;
  if (i > t) for (r = e._first; r && r._start <= i; ) {
    if (r.data === "isPause" && r._start > t) return r;
    r = r._next;
  }
  else for (r = e._last; r && r._start >= i; ) {
    if (r.data === "isPause" && r._start < t) return r;
    r = r._prev;
  }
}, Zc = function(e, t, i, r) {
  var s = e._repeat, o = zn(t) || 0, a = e._tTime / e._tDur;
  return a && !r && (e._time *= o / e._dur), e._dur = o, e._tDur = s ? s < 0 ? 1e10 : zn(o * (s + 1) + e._rDelay * s) : o, a > 0 && !r && ev(e, e._tTime = e._tDur * a), e.parent && Q_(e), i || Vl(e.parent, e), e;
}, F2 = function(e) {
  return e instanceof Vi ? Vl(e) : Zc(e, e._dur);
}, XX = { _start: 0, endTime: Sd, totalDuration: Sd }, qr = function n13(e, t, i) {
  var r = e.labels, s = e._recent || XX, o = e.duration() >= io ? s.endTime(false) : e._dur, a, l, f;
  return ri(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), f = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (f ? (a < 0 ? s : i).totalDuration() / 100 : 1)) : a < 0 ? (t in r || (r[t] = o), r[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), f && i && (l = l / 100 * (Pi(i) ? i[0] : i).totalDuration()), a > 1 ? n13(e, t.substr(0, a - 1), i) + l : o + l)) : t == null ? o : +t;
}, Rh = function(e, t, i) {
  var r = Bo(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), o = t[s], a, l;
  if (r && (o.duration = t[1]), o.parent = i, e) {
    for (a = o, l = i; l && !("immediateRender" in a); ) a = l.vars.defaults || {}, l = sr(l.vars.inherit) && l.parent;
    o.immediateRender = sr(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1];
  }
  return new Fn(t[0], o, t[s + 1]);
}, $a = function(e, t) {
  return e || e === 0 ? t(e) : t;
}, Zd = function(e, t, i) {
  return i < e ? e : i > t ? t : i;
}, bi = function(e, t) {
  return !ri(e) || !(t = DX.exec(e)) ? "" : t[1];
}, jX = function(e, t, i) {
  return $a(i, function(r) {
    return Zd(e, t, r);
  });
}, zS = [].slice, dD = function(e, t) {
  return e && oo(e) && "length" in e && (!t && !e.length || e.length - 1 in e && oo(e[0])) && !e.nodeType && e !== Vs;
}, $X = function(e, t, i) {
  return i === void 0 && (i = []), e.forEach(function(r) {
    var s;
    return ri(r) && !t || dD(r, 1) ? (s = i).push.apply(s, rs(r)) : i.push(r);
  }) || i;
}, rs = function(e, t, i) {
  return an && !t && an.selector ? an.selector(e) : ri(e) && !i && (OS || !Jc()) ? zS.call((t || lE).querySelectorAll(e), 0) : Pi(e) ? $X(e, i) : dD(e) ? zS.call(e, 0) : e ? [e] : [];
}, BS = function(e) {
  return e = rs(e)[0] || xd("Invalid scope") || {}, function(t) {
    var i = e.current || e.nativeElement || e;
    return rs(t, i.querySelectorAll ? i : i === e ? xd("Invalid scope") || lE.createElement("div") : e);
  };
}, pD = function(e) {
  return e.sort(function() {
    return 0.5 - Math.random();
  });
}, mD = function(e) {
  if (En(e)) return e;
  var t = oo(e) ? e : { each: e }, i = Hl(t.ease), r = t.from || 0, s = parseFloat(t.base) || 0, o = {}, a = r > 0 && r < 1, l = isNaN(r) || a, f = t.axis, h = r, d = r;
  return ri(r) ? h = d = { center: 0.5, edges: 0.5, end: 1 }[r] || 0 : !a && l && (h = r[0], d = r[1]), function(p, g, v) {
    var S = (v || t).length, M = o[S], m, w, E, A, P, R, L, D, F;
    if (!M) {
      if (F = t.grid === "auto" ? 0 : (t.grid || [1, io])[1], !F) {
        for (L = -1e8; L < (L = v[F++].getBoundingClientRect().left) && F < S; ) ;
        F < S && F--;
      }
      for (M = o[S] = [], m = l ? Math.min(F, S) * h - 0.5 : r % F, w = F === io ? 0 : l ? S * d / F - 0.5 : r / F | 0, L = 0, D = io, R = 0; R < S; R++) E = R % F - m, A = w - (R / F | 0), M[R] = P = f ? Math.abs(f === "y" ? A : E) : KN(E * E + A * A), P > L && (L = P), P < D && (D = P);
      r === "random" && pD(M), M.max = L - D, M.min = D, M.v = S = (parseFloat(t.amount) || parseFloat(t.each) * (F > S ? S - 1 : f ? f === "y" ? S / F : F : Math.max(F, S / F)) || 0) * (r === "edges" ? -1 : 1), M.b = S < 0 ? s - S : s, M.u = bi(t.amount || t.each) || 0, i = i && S < 0 ? TD(i) : i;
    }
    return S = (M[p] - M.min) / M.max || 0, zn(M.b + (i ? i(S) : S) * M.v) + M.u;
  };
}, VS = function(e) {
  var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
  return function(i) {
    var r = zn(Math.round(parseFloat(i) / e) * e * t);
    return (r - r % 1) / t + (Bo(i) ? 0 : bi(i));
  };
}, gD = function(e, t) {
  var i = Pi(e), r, s;
  return !i && oo(e) && (r = i = e.radius || io, e.values ? (e = rs(e.values), (s = !Bo(e[0])) && (r *= r)) : e = VS(e.increment)), $a(t, i ? En(e) ? function(o) {
    return s = e(o), Math.abs(s - o) <= r ? s : o;
  } : function(o) {
    for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), f = io, h = 0, d = e.length, p, g; d--; ) s ? (p = e[d].x - a, g = e[d].y - l, p = p * p + g * g) : p = Math.abs(e[d] - a), p < f && (f = p, h = d);
    return h = !r || f <= r ? e[h] : o, s || h === o || Bo(o) ? h : h + bi(o);
  } : VS(e));
}, _D = function(e, t, i, r) {
  return $a(Pi(e) ? !t : i === true ? !!(i = 0) : !r, function() {
    return Pi(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * 0.99)) / i) * i * r) / r;
  });
}, YX = function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
  return function(r) {
    return t.reduce(function(s, o) {
      return o(s);
    }, r);
  };
}, qX = function(e, t) {
  return function(i) {
    return e(parseFloat(i)) + (t || bi(i));
  };
}, KX = function(e, t, i) {
  return yD(e, t, 0, 1, i);
}, vD = function(e, t, i) {
  return $a(i, function(r) {
    return e[~~t(r)];
  });
}, ZX = function n14(e, t, i) {
  var r = t - e;
  return Pi(e) ? vD(e, n14(0, e.length), t) : $a(i, function(s) {
    return (r + (s - e) % r) % r + e;
  });
}, JX = function n15(e, t, i) {
  var r = t - e, s = r * 2;
  return Pi(e) ? vD(e, n15(0, e.length - 1), t) : $a(i, function(o) {
    return o = (s + (o - e) % s) % s || 0, e + (o > r ? s - o : o);
  });
}, Md = function(e) {
  for (var t = 0, i = "", r, s, o, a; ~(r = e.indexOf("random(", t)); ) o = e.indexOf(")", r), a = e.charAt(r + 7) === "[", s = e.substr(r + 7, o - r - 7).match(a ? eD : DS), i += e.substr(t, r - t) + _D(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5), t = o + 1;
  return i + e.substr(t, e.length - t);
}, yD = function(e, t, i, r, s) {
  var o = t - e, a = r - i;
  return $a(s, function(l) {
    return i + ((l - e) / o * a || 0);
  });
}, QX = function n16(e, t, i, r) {
  var s = isNaN(e + t) ? 0 : function(g) {
    return (1 - g) * e + g * t;
  };
  if (!s) {
    var o = ri(e), a = {}, l, f, h, d, p;
    if (i === true && (r = 1) && (i = null), o) e = { p: e }, t = { p: t };
    else if (Pi(e) && !Pi(t)) {
      for (h = [], d = e.length, p = d - 2, f = 1; f < d; f++) h.push(n16(e[f - 1], e[f]));
      d--, s = function(v) {
        v *= d;
        var S = Math.min(p, ~~v);
        return h[S](v - S);
      }, i = t;
    } else r || (e = qc(Pi(e) ? [] : {}, e));
    if (!h) {
      for (l in t) dE.call(a, e, l, "get", t[l]);
      s = function(v) {
        return _E(v, a) || (o ? e.p : e);
      };
    }
  }
  return $a(i, s);
}, z2 = function(e, t, i) {
  var r = e.labels, s = io, o, a, l;
  for (o in r) a = r[o] - t, a < 0 == !!i && a && s > (a = Math.abs(a)) && (l = o, s = a);
  return l;
}, Ar = function(e, t, i) {
  var r = e.vars, s = r[t], o = an, a = e._ctx, l, f, h;
  if (s) return l = r[t + "Params"], f = r.callbackScope || e, i && La.length && y0(), a && (an = a), h = l ? s.apply(f, l) : s.call(f), an = o, h;
}, ch = function(e) {
  return ka(e), e.scrollTrigger && e.scrollTrigger.kill(!!di), e.progress() < 1 && Ar(e, "onInterrupt"), e;
}, Sc, xD = [], SD = function(e) {
  if (e) if (e = !e.name && e.default || e, aE() || e.headless) {
    var t = e.name, i = En(e), r = t && !i && e.init ? function() {
      this._props = [];
    } : e, s = { init: Sd, render: _E, add: dE, kill: mj, modifier: pj, rawVars: 0 }, o = { targetTest: 0, get: 0, getSetter: gE, aliases: {}, register: 0 };
    if (Jc(), e !== r) {
      if (xr[t]) return;
      Nr(r, Nr(x0(e, s), o)), qc(r.prototype, qc(s, x0(e, o))), xr[r.prop = t] = r, e.targetTest && (Dg.push(r), cE[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin";
    }
    iD(t, r), e.register && e.register(cr, r, ar);
  } else xD.push(e);
}, qt = 255, fh = { aqua: [0, qt, qt], lime: [0, qt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, qt], navy: [0, 0, 128], white: [qt, qt, qt], olive: [128, 128, 0], yellow: [qt, qt, 0], orange: [qt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [qt, 0, 0], pink: [qt, 192, 203], cyan: [0, qt, qt], transparent: [qt, qt, qt, 0] }, Dx = function(e, t, i) {
  return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < 0.5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * qt + 0.5 | 0;
}, MD = function(e, t, i) {
  var r = e ? Bo(e) ? [e >> 16, e >> 8 & qt, e & qt] : 0 : fh.black, s, o, a, l, f, h, d, p, g, v;
  if (!r) {
    if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), fh[e]) r = fh[e];
    else if (e.charAt(0) === "#") {
      if (e.length < 6 && (s = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & qt, r & qt, parseInt(e.substr(7), 16) / 255];
      e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & qt, e & qt];
    } else if (e.substr(0, 3) === "hsl") {
      if (r = v = e.match(DS), !t) l = +r[0] % 360 / 360, f = +r[1] / 100, h = +r[2] / 100, o = h <= 0.5 ? h * (f + 1) : h + f - h * f, s = h * 2 - o, r.length > 3 && (r[3] *= 1), r[0] = Dx(l + 1 / 3, s, o), r[1] = Dx(l, s, o), r[2] = Dx(l - 1 / 3, s, o);
      else if (~e.indexOf("=")) return r = e.match(JN), i && r.length < 4 && (r[3] = 1), r;
    } else r = e.match(DS) || fh.transparent;
    r = r.map(Number);
  }
  return t && !v && (s = r[0] / qt, o = r[1] / qt, a = r[2] / qt, d = Math.max(s, o, a), p = Math.min(s, o, a), h = (d + p) / 2, d === p ? l = f = 0 : (g = d - p, f = h > 0.5 ? g / (2 - d - p) : g / (d + p), l = d === s ? (o - a) / g + (o < a ? 6 : 0) : d === o ? (a - s) / g + 2 : (s - o) / g + 4, l *= 60), r[0] = ~~(l + 0.5), r[1] = ~~(f * 100 + 0.5), r[2] = ~~(h * 100 + 0.5)), i && r.length < 4 && (r[3] = 1), r;
}, wD = function(e) {
  var t = [], i = [], r = -1;
  return e.split(Ia).forEach(function(s) {
    var o = s.match(xc) || [];
    t.push.apply(t, o), i.push(r += o.length + 1);
  }), t.c = i, t;
}, B2 = function(e, t, i) {
  var r = "", s = (e + r).match(Ia), o = t ? "hsla(" : "rgba(", a = 0, l, f, h, d;
  if (!s) return e;
  if (s = s.map(function(p) {
    return (p = MD(p, t, 1)) && o + (t ? p[0] + "," + p[1] + "%," + p[2] + "%," + p[3] : p.join(",")) + ")";
  }), i && (h = wD(e), l = i.c, l.join(r) !== h.c.join(r))) for (f = e.replace(Ia, "1").split(xc), d = f.length - 1; a < d; a++) r += f[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (h.length ? h : s.length ? s : i).shift());
  if (!f) for (f = e.split(Ia), d = f.length - 1; a < d; a++) r += f[a] + s[a];
  return r + f[d];
}, Ia = function() {
  var n24 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
  for (e in fh) n24 += "|" + e + "\\b";
  return new RegExp(n24 + ")", "gi");
}(), ej = /hsl[a]?\(/, ED = function(e) {
  var t = e.join(" "), i;
  if (Ia.lastIndex = 0, Ia.test(t)) return i = ej.test(t), e[1] = B2(e[1], i), e[0] = B2(e[0], i, wD(e[1])), true;
}, wd, Er = function() {
  var n24 = Date.now, e = 500, t = 33, i = n24(), r = i, s = 1e3 / 240, o = s, a = [], l, f, h, d, p, g, v = function S(M) {
    var m = n24() - r, w = M === true, E, A, P, R;
    if ((m > e || m < 0) && (i += m - t), r += m, P = r - i, E = P - o, (E > 0 || w) && (R = ++d.frame, p = P - d.time * 1e3, d.time = P = P / 1e3, o += E + (E >= s ? 4 : s - E), A = 1), w || (l = f(S)), A) for (g = 0; g < a.length; g++) a[g](P, p, R, M);
  };
  return d = { time: 0, frame: 0, tick: function() {
    v(true);
  }, deltaRatio: function(M) {
    return p / (1e3 / (M || 60));
  }, wake: function() {
    tD && (!OS && aE() && (Vs = OS = window, lE = Vs.document || {}, Ir.gsap = cr, (Vs.gsapVersions || (Vs.gsapVersions = [])).push(cr.version), nD(v0 || Vs.GreenSockGlobals || !Vs.gsap && Vs || {}), xD.forEach(SD)), h = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), f = h || function(M) {
      return setTimeout(M, o - d.time * 1e3 + 1 | 0);
    }, wd = 1, v(2));
  }, sleep: function() {
    (h ? cancelAnimationFrame : clearTimeout)(l), wd = 0, f = Sd;
  }, lagSmoothing: function(M, m) {
    e = M || 1 / 0, t = Math.min(m || 33, e);
  }, fps: function(M) {
    s = 1e3 / (M || 240), o = d.time * 1e3 + s;
  }, add: function(M, m, w) {
    var E = m ? function(A, P, R, L) {
      M(A, P, R, L), d.remove(E);
    } : M;
    return d.remove(M), a[w ? "unshift" : "push"](E), Jc(), E;
  }, remove: function(M, m) {
    ~(m = a.indexOf(M)) && a.splice(m, 1) && g >= m && g--;
  }, _listeners: a }, d;
}(), Jc = function() {
  return !wd && Er.wake();
}, Ct = {}, tj = /^[\d.\-M][\d.\-,\s]/, nj = /["']/g, ij = function(e) {
  for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, o = i.length, a, l, f; s < o; s++) l = i[s], a = s !== o - 1 ? l.lastIndexOf(",") : l.length, f = l.substr(0, a), t[r] = isNaN(f) ? f.replace(nj, "").trim() : +f, r = l.substr(a + 1).trim();
  return t;
}, rj = function(e) {
  var t = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", t);
  return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i);
}, sj = function(e) {
  var t = (e + "").split("("), i = Ct[t[0]];
  return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [ij(t[1])] : rj(e).split(",").map(aD)) : Ct._CE && tj.test(e) ? Ct._CE("", e) : i;
}, TD = function(e) {
  return function(t) {
    return 1 - e(1 - t);
  };
}, AD = function n17(e, t) {
  for (var i = e._first, r; i; ) i instanceof Vi ? n17(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n17(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next;
}, Hl = function(e, t) {
  return e && (En(e) ? e : Ct[e] || sj(e)) || t;
}, au = function(e, t, i, r) {
  i === void 0 && (i = function(l) {
    return 1 - t(1 - l);
  }), r === void 0 && (r = function(l) {
    return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
  });
  var s = { easeIn: t, easeOut: i, easeInOut: r }, o;
  return or(e, function(a) {
    Ct[a] = Ir[a] = s, Ct[o = a.toLowerCase()] = i;
    for (var l in s) Ct[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Ct[a + "." + l] = s[l];
  }), s;
}, bD = function(e) {
  return function(t) {
    return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
  };
}, Ox = function n18(e, t, i) {
  var r = t >= 1 ? t : 1, s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), o = s / NS * (Math.asin(1 / r) || 0), a = function(h) {
    return h === 1 ? 1 : r * Math.pow(2, -10 * h) * NX((h - o) * s) + 1;
  }, l = e === "out" ? a : e === "in" ? function(f) {
    return 1 - a(1 - f);
  } : bD(a);
  return s = NS / s, l.config = function(f, h) {
    return n18(e, f, h);
  }, l;
}, Ux = function n19(e, t) {
  t === void 0 && (t = 1.70158);
  var i = function(o) {
    return o ? --o * o * ((t + 1) * o + t) + 1 : 0;
  }, r = e === "out" ? i : e === "in" ? function(s) {
    return 1 - i(1 - s);
  } : bD(i);
  return r.config = function(s) {
    return n19(e, s);
  }, r;
};
or("Linear,Quad,Cubic,Quart,Quint,Strong", function(n24, e) {
  var t = e < 5 ? e + 1 : e;
  au(n24 + ",Power" + (t - 1), e ? function(i) {
    return Math.pow(i, t);
  } : function(i) {
    return i;
  }, function(i) {
    return 1 - Math.pow(1 - i, t);
  }, function(i) {
    return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
  });
});
Ct.Linear.easeNone = Ct.none = Ct.Linear.easeIn;
au("Elastic", Ox("in"), Ox("out"), Ox());
(function(n24, e) {
  var t = 1 / e, i = 2 * t, r = 2.5 * t, s = function(a) {
    return a < t ? n24 * a * a : a < i ? n24 * Math.pow(a - 1.5 / e, 2) + 0.75 : a < r ? n24 * (a -= 2.25 / e) * a + 0.9375 : n24 * Math.pow(a - 2.625 / e, 2) + 0.984375;
  };
  au("Bounce", function(o) {
    return 1 - s(1 - o);
  }, s);
})(7.5625, 2.75);
au("Expo", function(n24) {
  return Math.pow(2, 10 * (n24 - 1)) * n24 + n24 * n24 * n24 * n24 * n24 * n24 * (1 - n24);
});
au("Circ", function(n24) {
  return -(KN(1 - n24 * n24) - 1);
});
au("Sine", function(n24) {
  return n24 === 1 ? 1 : -IX(n24 * PX) + 1;
});
au("Back", Ux("in"), Ux("out"), Ux());
Ct.SteppedEase = Ct.steps = Ir.SteppedEase = { config: function(e, t) {
  e === void 0 && (e = 1);
  var i = 1 / e, r = e + (t ? 0 : 1), s = t ? 1 : 0, o = 1 - Ci;
  return function(a) {
    return ((r * Zd(0, o, a) | 0) + s) * i;
  };
} };
Yc.ease = Ct["quad.out"];
or("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n24) {
  return fE += n24 + "," + n24 + "Params,";
});
var CD = function(e, t) {
  this.id = LX++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : sD, this.set = t ? t.getSetter : gE;
}, Ed = function() {
  function n24(t) {
    this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Zc(this, +t.duration, 1, 1), this.data = t.data, an && (this._ctx = an, an.data.push(this)), wd || Er.wake();
  }
  var e = n24.prototype;
  return e.delay = function(i) {
    return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay;
  }, e.duration = function(i) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur;
  }, e.totalDuration = function(i) {
    return arguments.length ? (this._dirty = 0, Zc(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, e.totalTime = function(i, r) {
    if (Jc(), !arguments.length) return this._tTime;
    var s = this._dp;
    if (s && s.smoothChildTiming && this._ts) {
      for (ev(this, i), !s._dp || s.parent || cD(s, this); s && s.parent; ) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, true), s = s.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && js(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === Ci || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), oD(this, i, r)), this;
  }, e.time = function(i, r) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + k2(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time;
  }, e.totalProgress = function(i, r) {
    return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
  }, e.progress = function(i, r) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + k2(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, e.iteration = function(i, r) {
    var s = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? Kc(this._tTime, s) + 1 : 1;
  }, e.timeScale = function(i, r) {
    if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
    if (this._rts === i) return this;
    var s = this.parent && this._ts ? S0(this.parent._time, this) : this._tTime;
    return this._rts = +i || 0, this._ts = this._ps || i === -1e-8 ? 0 : this._rts, this.totalTime(Zd(-Math.abs(this._delay), this._tDur, s), r !== false), Q_(this), BX(this);
  }, e.paused = function(i) {
    return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Jc(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Ci && (this._tTime -= Ci)))), this) : this._ps;
  }, e.startTime = function(i) {
    if (arguments.length) {
      this._start = i;
      var r = this.parent || this._dp;
      return r && (r._sort || !this.parent) && js(r, this, i - this._delay), this;
    }
    return this._start;
  }, e.endTime = function(i) {
    return this._start + (sr(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, e.rawTime = function(i) {
    var r = this.parent || this._dp;
    return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? S0(r.rawTime(i), this) : this._tTime : this._tTime;
  }, e.revert = function(i) {
    i === void 0 && (i = UX);
    var r = di;
    return di = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-0.01, i.suppressEvents)), this.data !== "nested" && i.kill !== false && this.kill(), di = r, this;
  }, e.globalTime = function(i) {
    for (var r = this, s = arguments.length ? i : r.rawTime(); r; ) s = r._start + s / (Math.abs(r._ts) || 1), r = r._dp;
    return !this.parent && this._sat ? this._sat.globalTime(i) : s;
  }, e.repeat = function(i) {
    return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, F2(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, e.repeatDelay = function(i) {
    if (arguments.length) {
      var r = this._time;
      return this._rDelay = i, F2(this), r ? this.time(r) : this;
    }
    return this._rDelay;
  }, e.yoyo = function(i) {
    return arguments.length ? (this._yoyo = i, this) : this._yoyo;
  }, e.seek = function(i, r) {
    return this.totalTime(qr(this, i), sr(r));
  }, e.restart = function(i, r) {
    return this.play().totalTime(i ? -this._delay : 0, sr(r)), this._dur || (this._zTime = -1e-8), this;
  }, e.play = function(i, r) {
    return i != null && this.seek(i, r), this.reversed(false).paused(false);
  }, e.reverse = function(i, r) {
    return i != null && this.seek(i || this.totalDuration(), r), this.reversed(true).paused(false);
  }, e.pause = function(i, r) {
    return i != null && this.seek(i, r), this.paused(true);
  }, e.resume = function() {
    return this.paused(false);
  }, e.reversed = function(i) {
    return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -1e-8 : 0)), this) : this._rts < 0;
  }, e.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -1e-8, this;
  }, e.isActive = function() {
    var i = this.parent || this._dp, r = this._start, s;
    return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(true)) >= r && s < this.endTime(true) - Ci);
  }, e.eventCallback = function(i, r, s) {
    var o = this.vars;
    return arguments.length > 1 ? (r ? (o[i] = r, s && (o[i + "Params"] = s), i === "onUpdate" && (this._onUpdate = r)) : delete o[i], this) : o[i];
  }, e.then = function(i) {
    var r = this;
    return new Promise(function(s) {
      var o = En(i) ? i : lD, a = function() {
        var f = r.then;
        r.then = null, En(o) && (o = o(r)) && (o.then || o === r) && (r.then = f), s(o), r.then = f;
      };
      r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? a() : r._prom = a;
    });
  }, e.kill = function() {
    ch(this);
  }, n24;
}();
Nr(Ed.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: false, parent: null, _initted: false, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -1e-8, _prom: 0, _ps: false, _rts: 1 });
var Vi = function(n24) {
  qN(e, n24);
  function e(i, r) {
    var s;
    return i === void 0 && (i = {}), s = n24.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = sr(i.sortChildren), hn && js(i.parent || hn, Mo(s), r), i.reversed && s.reverse(), i.paused && s.paused(true), i.scrollTrigger && fD(Mo(s), i.scrollTrigger), s;
  }
  var t = e.prototype;
  return t.to = function(r, s, o) {
    return Rh(0, arguments, this), this;
  }, t.from = function(r, s, o) {
    return Rh(1, arguments, this), this;
  }, t.fromTo = function(r, s, o, a) {
    return Rh(2, arguments, this), this;
  }, t.set = function(r, s, o) {
    return s.duration = 0, s.parent = this, Ch(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Fn(r, s, qr(this, o), 1), this;
  }, t.call = function(r, s, o) {
    return js(this, Fn.delayedCall(0, r, s), o);
  }, t.staggerTo = function(r, s, o, a, l, f, h) {
    return o.duration = s, o.stagger = o.stagger || a, o.onComplete = f, o.onCompleteParams = h, o.parent = this, new Fn(r, o, qr(this, l)), this;
  }, t.staggerFrom = function(r, s, o, a, l, f, h) {
    return o.runBackwards = 1, Ch(o).immediateRender = sr(o.immediateRender), this.staggerTo(r, s, o, a, l, f, h);
  }, t.staggerFromTo = function(r, s, o, a, l, f, h, d) {
    return a.startAt = o, Ch(a).immediateRender = sr(a.immediateRender), this.staggerTo(r, s, a, l, f, h, d);
  }, t.render = function(r, s, o) {
    var a = this._time, l = this._dirty ? this.totalDuration() : this._tDur, f = this._dur, h = r <= 0 ? 0 : zn(r), d = this._zTime < 0 != r < 0 && (this._initted || !f), p, g, v, S, M, m, w, E, A, P, R, L;
    if (this !== hn && h > l && r >= 0 && (h = l), h !== this._tTime || o || d) {
      if (a !== this._time && f && (h += this._time - a, r += this._time - a), p = h, A = this._start, E = this._ts, m = !E, d && (f || (a = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) {
        if (R = this._yoyo, M = f + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(M * 100 + r, s, o);
        if (p = zn(h % M), h === l ? (S = this._repeat, p = f) : (P = zn(h / M), S = ~~P, S && S === P && (p = f, S--), p > f && (p = f)), P = Kc(this._tTime, M), !a && this._tTime && P !== S && this._tTime - P * M - this._dur <= 0 && (P = S), R && S & 1 && (p = f - p, L = 1), S !== P && !this._lock) {
          var D = R && P & 1, F = D === (R && S & 1);
          if (S < P && (D = !D), a = D ? 0 : h % f ? f : h, this._lock = 1, this.render(a || (L ? 0 : zn(S * M)), s, !f)._lock = 0, this._tTime = h, !s && this.parent && Ar(this, "onRepeat"), this.vars.repeatRefresh && !L && (this.invalidate()._lock = 1), a && a !== this._time || m !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
          if (f = this._dur, l = this._tDur, F && (this._lock = 2, a = D ? f : -1e-4, this.render(a, true), this.vars.repeatRefresh && !L && this.invalidate()), this._lock = 0, !this._ts && !m) return this;
          AD(this, L);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (w = WX(this, zn(a), zn(p)), w && (h -= p - (p = w._start))), this._tTime = h, this._time = p, this._act = !E, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, a = 0), !a && p && !s && !S && (Ar(this, "onStart"), this._tTime !== h)) return this;
      if (p >= a && r >= 0) for (g = this._first; g; ) {
        if (v = g._next, (g._act || p >= g._start) && g._ts && w !== g) {
          if (g.parent !== this) return this.render(r, s, o);
          if (g.render(g._ts > 0 ? (p - g._start) * g._ts : (g._dirty ? g.totalDuration() : g._tDur) + (p - g._start) * g._ts, s, o), p !== this._time || !this._ts && !m) {
            w = 0, v && (h += this._zTime = -1e-8);
            break;
          }
        }
        g = v;
      }
      else {
        g = this._last;
        for (var C = r < 0 ? r : p; g; ) {
          if (v = g._prev, (g._act || C <= g._end) && g._ts && w !== g) {
            if (g.parent !== this) return this.render(r, s, o);
            if (g.render(g._ts > 0 ? (C - g._start) * g._ts : (g._dirty ? g.totalDuration() : g._tDur) + (C - g._start) * g._ts, s, o || di && (g._initted || g._startAt)), p !== this._time || !this._ts && !m) {
              w = 0, v && (h += this._zTime = C ? -1e-8 : Ci);
              break;
            }
          }
          g = v;
        }
      }
      if (w && !s && (this.pause(), w.render(p >= a ? 0 : -1e-8)._zTime = p >= a ? 1 : -1, this._ts)) return this._start = A, Q_(this), this.render(r, s, o);
      this._onUpdate && !s && Ar(this, "onUpdate", true), (h === l && this._tTime >= this.totalDuration() || !h && a) && (A === this._start || Math.abs(E) !== Math.abs(this._ts)) && (this._lock || ((r || !f) && (h === l && this._ts > 0 || !h && this._ts < 0) && ka(this, 1), !s && !(r < 0 && !a) && (h || a || !l) && (Ar(this, h === l && r >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(h < l && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, t.add = function(r, s) {
    var o = this;
    if (Bo(s) || (s = qr(this, s, r)), !(r instanceof Ed)) {
      if (Pi(r)) return r.forEach(function(a) {
        return o.add(a, s);
      }), this;
      if (ri(r)) return this.addLabel(r, s);
      if (En(r)) r = Fn.delayedCall(0, r);
      else return this;
    }
    return this !== r ? js(this, r, s) : this;
  }, t.getChildren = function(r, s, o, a) {
    r === void 0 && (r = true), s === void 0 && (s = true), o === void 0 && (o = true), a === void 0 && (a = -1e8);
    for (var l = [], f = this._first; f; ) f._start >= a && (f instanceof Fn ? s && l.push(f) : (o && l.push(f), r && l.push.apply(l, f.getChildren(true, s, o)))), f = f._next;
    return l;
  }, t.getById = function(r) {
    for (var s = this.getChildren(1, 1, 1), o = s.length; o--; ) if (s[o].vars.id === r) return s[o];
  }, t.remove = function(r) {
    return ri(r) ? this.removeLabel(r) : En(r) ? this.killTweensOf(r) : (r.parent === this && J_(this, r), r === this._recent && (this._recent = this._last), Vl(this));
  }, t.totalTime = function(r, s) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = zn(Er.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), n24.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime;
  }, t.addLabel = function(r, s) {
    return this.labels[r] = qr(this, s), this;
  }, t.removeLabel = function(r) {
    return delete this.labels[r], this;
  }, t.addPause = function(r, s, o) {
    var a = Fn.delayedCall(0, s || Sd, o);
    return a.data = "isPause", this._hasPause = 1, js(this, a, qr(this, r));
  }, t.removePause = function(r) {
    var s = this._first;
    for (r = qr(this, r); s; ) s._start === r && s.data === "isPause" && ka(s), s = s._next;
  }, t.killTweensOf = function(r, s, o) {
    for (var a = this.getTweensOf(r, o), l = a.length; l--; ) _a !== a[l] && a[l].kill(r, s);
    return this;
  }, t.getTweensOf = function(r, s) {
    for (var o = [], a = rs(r), l = this._first, f = Bo(s), h; l; ) l instanceof Fn ? kX(l._targets, a) && (f ? (!_a || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (h = l.getTweensOf(a, s)).length && o.push.apply(o, h), l = l._next;
    return o;
  }, t.tweenTo = function(r, s) {
    s = s || {};
    var o = this, a = qr(o, r), l = s, f = l.startAt, h = l.onStart, d = l.onStartParams, p = l.immediateRender, g, v = Fn.to(o, Nr({ ease: s.ease || "none", lazy: false, immediateRender: false, time: a, overwrite: "auto", duration: s.duration || Math.abs((a - (f && "time" in f ? f.time : o._time)) / o.timeScale()) || Ci, onStart: function() {
      if (o.pause(), !g) {
        var M = s.duration || Math.abs((a - (f && "time" in f ? f.time : o._time)) / o.timeScale());
        v._dur !== M && Zc(v, M, 0, 1).render(v._time, true, true), g = 1;
      }
      h && h.apply(v, d || []);
    } }, s));
    return p ? v.render(0) : v;
  }, t.tweenFromTo = function(r, s, o) {
    return this.tweenTo(s, Nr({ startAt: { time: qr(this, r) } }, o));
  }, t.recent = function() {
    return this._recent;
  }, t.nextLabel = function(r) {
    return r === void 0 && (r = this._time), z2(this, qr(this, r));
  }, t.previousLabel = function(r) {
    return r === void 0 && (r = this._time), z2(this, qr(this, r), 1);
  }, t.currentLabel = function(r) {
    return arguments.length ? this.seek(r, true) : this.previousLabel(this._time + Ci);
  }, t.shiftChildren = function(r, s, o) {
    o === void 0 && (o = 0);
    for (var a = this._first, l = this.labels, f; a; ) a._start >= o && (a._start += r, a._end += r), a = a._next;
    if (s) for (f in l) l[f] >= o && (l[f] += r);
    return Vl(this);
  }, t.invalidate = function(r) {
    var s = this._first;
    for (this._lock = 0; s; ) s.invalidate(r), s = s._next;
    return n24.prototype.invalidate.call(this, r);
  }, t.clear = function(r) {
    r === void 0 && (r = true);
    for (var s = this._first, o; s; ) o = s._next, this.remove(s), s = o;
    return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), Vl(this);
  }, t.totalDuration = function(r) {
    var s = 0, o = this, a = o._last, l = io, f, h, d;
    if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -r : r));
    if (o._dirty) {
      for (d = o.parent; a; ) f = a._prev, a._dirty && a.totalDuration(), h = a._start, h > l && o._sort && a._ts && !o._lock ? (o._lock = 1, js(o, a, h - a._delay, 1)._lock = 0) : l = h, h < 0 && a._ts && (s -= h, (!d && !o._dp || d && d.smoothChildTiming) && (o._start += h / o._ts, o._time -= h, o._tTime -= h), o.shiftChildren(-h, false, -1 / 0), l = 0), a._end > s && a._ts && (s = a._end), a = f;
      Zc(o, o === hn && o._time > s ? o._time : s, 1, 1), o._dirty = 0;
    }
    return o._tDur;
  }, e.updateRoot = function(r) {
    if (hn._ts && (oD(hn, S0(r, hn)), rD = Er.frame), Er.frame >= O2) {
      O2 += Pr.autoSleep || 120;
      var s = hn._first;
      if ((!s || !s._ts) && Pr.autoSleep && Er._listeners.length < 2) {
        for (; s && !s._ts; ) s = s._next;
        s || Er.sleep();
      }
    }
  }, e;
}(Ed);
Nr(Vi.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var oj = function(e, t, i, r, s, o, a) {
  var l = new ar(this._pt, e, t, 0, 1, DD, null, s), f = 0, h = 0, d, p, g, v, S, M, m, w;
  for (l.b = i, l.e = r, i += "", r += "", (m = ~r.indexOf("random(")) && (r = Md(r)), o && (w = [i, r], o(w, e, t), i = w[0], r = w[1]), p = i.match(Ix) || []; d = Ix.exec(r); ) v = d[0], S = r.substring(f, d.index), g ? g = (g + 1) % 5 : S.substr(-5) === "rgba(" && (g = 1), v !== p[h++] && (M = parseFloat(p[h - 1]) || 0, l._pt = { _next: l._pt, p: S || h === 1 ? S : ",", s: M, c: v.charAt(1) === "=" ? Lc(M, v) - M : parseFloat(v) - M, m: g && g < 4 ? Math.round : 0 }, f = Ix.lastIndex);
  return l.c = f < r.length ? r.substring(f, r.length) : "", l.fp = a, (QN.test(r) || m) && (l.e = 0), this._pt = l, l;
}, dE = function(e, t, i, r, s, o, a, l, f, h) {
  En(r) && (r = r(s || 0, e, o));
  var d = e[t], p = i !== "get" ? i : En(d) ? f ? e[t.indexOf("set") || !En(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](f) : e[t]() : d, g = En(d) ? f ? fj : ID : mE, v;
  if (ri(r) && (~r.indexOf("random(") && (r = Md(r)), r.charAt(1) === "=" && (v = Lc(p, r) + (bi(p) || 0), (v || v === 0) && (r = v))), !h || p !== r || HS) return !isNaN(p * r) && r !== "" ? (v = new ar(this._pt, e, t, +p || 0, r - (p || 0), typeof d == "boolean" ? dj : ND, 0, g), f && (v.fp = f), a && v.modifier(a, this, e), this._pt = v) : (!d && !(t in e) && uE(t, r), oj.call(this, e, t, p, r, g, l || Pr.stringFilter, f));
}, aj = function(e, t, i, r, s) {
  if (En(e) && (e = Ph(e, s, t, i, r)), !oo(e) || e.style && e.nodeType || Pi(e) || ZN(e)) return ri(e) ? Ph(e, s, t, i, r) : e;
  var o = {}, a;
  for (a in e) o[a] = Ph(e[a], s, t, i, r);
  return o;
}, RD = function(e, t, i, r, s, o) {
  var a, l, f, h;
  if (xr[e] && (a = new xr[e]()).init(s, a.rawVars ? t[e] : aj(t[e], r, s, o, i), i, r, o) !== false && (i._pt = l = new ar(i._pt, s, e, 0, 1, a.render, a, 0, a.priority), i !== Sc)) for (f = i._ptLookup[i._targets.indexOf(s)], h = a._props.length; h--; ) f[a._props[h]] = l;
  return a;
}, _a, HS, pE = function n20(e, t, i) {
  var r = e.vars, s = r.ease, o = r.startAt, a = r.immediateRender, l = r.lazy, f = r.onUpdate, h = r.runBackwards, d = r.yoyoEase, p = r.keyframes, g = r.autoRevert, v = e._dur, S = e._startAt, M = e._targets, m = e.parent, w = m && m.data === "nested" ? m.vars.targets : M, E = e._overwrite === "auto" && !sE, A = e.timeline, P, R, L, D, F, C, N, j, Z, G, J, q, ae;
  if (A && (!p || !s) && (s = "none"), e._ease = Hl(s, Yc.ease), e._yEase = d ? TD(Hl(d === true ? s : d, Yc.ease)) : 0, d && e._yoyo && !e._repeat && (d = e._yEase, e._yEase = e._ease, e._ease = d), e._from = !A && !!r.runBackwards, !A || p && !r.stagger) {
    if (j = M[0] ? Bl(M[0]).harness : 0, q = j && r[j.prop], P = x0(r, cE), S && (S._zTime < 0 && S.progress(1), t < 0 && h && a && !g ? S.render(-1, true) : S.revert(h && v ? Ng : OX), S._lazy = 0), o) {
      if (ka(e._startAt = Fn.set(M, Nr({ data: "isStart", overwrite: false, parent: m, immediateRender: true, lazy: !S && sr(l), startAt: null, delay: 0, onUpdate: f && function() {
        return Ar(e, "onUpdate");
      }, stagger: 0 }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (di || !a && !g) && e._startAt.revert(Ng), a && v && t <= 0 && i <= 0) {
        t && (e._zTime = t);
        return;
      }
    } else if (h && v && !S) {
      if (t && (a = false), L = Nr({ overwrite: false, data: "isFromStart", lazy: a && !S && sr(l), immediateRender: a, stagger: 0, parent: m }, P), q && (L[j.prop] = q), ka(e._startAt = Fn.set(M, L)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (di ? e._startAt.revert(Ng) : e._startAt.render(-1, true)), e._zTime = t, !a) n20(e._startAt, Ci, Ci);
      else if (!t) return;
    }
    for (e._pt = e._ptCache = 0, l = v && sr(l) || l && !v, R = 0; R < M.length; R++) {
      if (F = M[R], N = F._gsap || hE(M)[R]._gsap, e._ptLookup[R] = G = {}, US[N.id] && La.length && y0(), J = w === M ? R : w.indexOf(F), j && (Z = new j()).init(F, q || P, e, J, w) !== false && (e._pt = D = new ar(e._pt, F, Z.name, 0, 1, Z.render, Z, 0, Z.priority), Z._props.forEach(function(B) {
        G[B] = D;
      }), Z.priority && (C = 1)), !j || q) for (L in P) xr[L] && (Z = RD(L, P, e, J, F, w)) ? Z.priority && (C = 1) : G[L] = D = dE.call(e, F, L, "get", P[L], J, w, 0, r.stringFilter);
      e._op && e._op[R] && e.kill(F, e._op[R]), E && e._pt && (_a = e, hn.killTweensOf(F, G, e.globalTime(t)), ae = !e.parent, _a = 0), e._pt && l && (US[N.id] = 1);
    }
    C && OD(e), e._onInit && e._onInit(e);
  }
  e._onUpdate = f, e._initted = (!e._op || e._pt) && !ae, p && t <= 0 && A.render(io, true, true);
}, lj = function(e, t, i, r, s, o, a, l) {
  var f = (e._pt && e._ptCache || (e._ptCache = {}))[t], h, d, p, g;
  if (!f) for (f = e._ptCache[t] = [], p = e._ptLookup, g = e._targets.length; g--; ) {
    if (h = p[g][t], h && h.d && h.d._pt) for (h = h.d._pt; h && h.p !== t && h.fp !== t; ) h = h._next;
    if (!h) return HS = 1, e.vars[t] = "+=0", pE(e, a), HS = 0, l ? xd(t + " not eligible for reset") : 1;
    f.push(h);
  }
  for (g = f.length; g--; ) d = f[g], h = d._pt || d, h.s = (r || r === 0) && !s ? r : h.s + (r || 0) + o * h.c, h.c = i - h.s, d.e && (d.e = Rn(i) + bi(d.e)), d.b && (d.b = h.s + bi(d.b));
}, uj = function(e, t) {
  var i = e[0] ? Bl(e[0]).harness : 0, r = i && i.aliases, s, o, a, l;
  if (!r) return t;
  s = qc({}, t);
  for (o in r) if (o in s) for (l = r[o].split(","), a = l.length; a--; ) s[l[a]] = s[o];
  return s;
}, cj = function(e, t, i, r) {
  var s = t.ease || r || "power1.inOut", o, a;
  if (Pi(t)) a = i[e] || (i[e] = []), t.forEach(function(l, f) {
    return a.push({ t: f / (t.length - 1) * 100, v: l, e: s });
  });
  else for (o in t) a = i[o] || (i[o] = []), o === "ease" || a.push({ t: parseFloat(e), v: t[o], e: s });
}, Ph = function(e, t, i, r, s) {
  return En(e) ? e.call(t, i, r, s) : ri(e) && ~e.indexOf("random(") ? Md(e) : e;
}, PD = fE + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", LD = {};
or(PD + ",id,stagger,delay,duration,paused,scrollTrigger", function(n24) {
  return LD[n24] = 1;
});
var Fn = function(n24) {
  qN(e, n24);
  function e(i, r, s, o) {
    var a;
    typeof r == "number" && (s.duration = r, r = s, s = null), a = n24.call(this, o ? r : Ch(r)) || this;
    var l = a.vars, f = l.duration, h = l.delay, d = l.immediateRender, p = l.stagger, g = l.overwrite, v = l.keyframes, S = l.defaults, M = l.scrollTrigger, m = l.yoyoEase, w = r.parent || hn, E = (Pi(i) || ZN(i) ? Bo(i[0]) : "length" in r) ? [i] : rs(i), A, P, R, L, D, F, C, N;
    if (a._targets = E.length ? hE(E) : xd("GSAP target " + i + " not found. https://gsap.com", !Pr.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = g, v || p || ag(f) || ag(h)) {
      if (r = a.vars, A = a.timeline = new Vi({ data: "nested", defaults: S || {}, targets: w && w.data === "nested" ? w.vars.targets : E }), A.kill(), A.parent = A._dp = Mo(a), A._start = 0, p || ag(f) || ag(h)) {
        if (L = E.length, C = p && mD(p), oo(p)) for (D in p) ~PD.indexOf(D) && (N || (N = {}), N[D] = p[D]);
        for (P = 0; P < L; P++) R = x0(r, LD), R.stagger = 0, m && (R.yoyoEase = m), N && qc(R, N), F = E[P], R.duration = +Ph(f, Mo(a), P, F, E), R.delay = (+Ph(h, Mo(a), P, F, E) || 0) - a._delay, !p && L === 1 && R.delay && (a._delay = h = R.delay, a._start += h, R.delay = 0), A.to(F, R, C ? C(P, F, E) : 0), A._ease = Ct.none;
        A.duration() ? f = h = 0 : a.timeline = 0;
      } else if (v) {
        Ch(Nr(A.vars.defaults, { ease: "none" })), A._ease = Hl(v.ease || r.ease || "none");
        var j = 0, Z, G, J;
        if (Pi(v)) v.forEach(function(q) {
          return A.to(E, q, ">");
        }), A.duration();
        else {
          R = {};
          for (D in v) D === "ease" || D === "easeEach" || cj(D, v[D], R, v.easeEach);
          for (D in R) for (Z = R[D].sort(function(q, ae) {
            return q.t - ae.t;
          }), j = 0, P = 0; P < Z.length; P++) G = Z[P], J = { ease: G.e, duration: (G.t - (P ? Z[P - 1].t : 0)) / 100 * f }, J[D] = G.v, A.to(E, J, j), j += J.duration;
          A.duration() < f && A.to({}, { duration: f - A.duration() });
        }
      }
      f || a.duration(f = A.duration());
    } else a.timeline = 0;
    return g === true && !sE && (_a = Mo(a), hn.killTweensOf(E), _a = 0), js(w, Mo(a), s), r.reversed && a.reverse(), r.paused && a.paused(true), (d || !f && !v && a._start === zn(w._time) && sr(d) && VX(Mo(a)) && w.data !== "nested") && (a._tTime = -1e-8, a.render(Math.max(0, -h) || 0)), M && fD(Mo(a), M), a;
  }
  var t = e.prototype;
  return t.render = function(r, s, o) {
    var a = this._time, l = this._tDur, f = this._dur, h = r < 0, d = r > l - Ci && !h ? l : r < Ci ? 0 : r, p, g, v, S, M, m, w, E, A;
    if (!f) GX(this, r, s, o);
    else if (d !== this._tTime || !r || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== h || this._lazy) {
      if (p = d, E = this.timeline, this._repeat) {
        if (S = f + this._rDelay, this._repeat < -1 && h) return this.totalTime(S * 100 + r, s, o);
        if (p = zn(d % S), d === l ? (v = this._repeat, p = f) : (M = zn(d / S), v = ~~M, v && v === M ? (p = f, v--) : p > f && (p = f)), m = this._yoyo && v & 1, m && (A = this._yEase, p = f - p), M = Kc(this._tTime, S), p === a && !o && this._initted && v === M) return this._tTime = d, this;
        v !== M && (E && this._yEase && AD(E, m), this.vars.repeatRefresh && !m && !this._lock && p !== S && this._initted && (this._lock = o = 1, this.render(zn(S * v), true).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (hD(this, h ? r : p, o, s, d)) return this._tTime = 0, this;
        if (a !== this._time && !(o && this.vars.repeatRefresh && v !== M)) return this;
        if (f !== this._dur) return this.render(r, s, o);
      }
      if (this._tTime = d, this._time = p, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = w = (A || this._ease)(p / f), this._from && (this.ratio = w = 1 - w), p && !a && !s && !v && (Ar(this, "onStart"), this._tTime !== d)) return this;
      for (g = this._pt; g; ) g.r(w, g.d), g = g._next;
      E && E.render(r < 0 ? r : E._dur * E._ease(p / this._dur), s, o) || this._startAt && (this._zTime = r), this._onUpdate && !s && (h && kS(this, r, s, o), Ar(this, "onUpdate")), this._repeat && v !== M && this.vars.onRepeat && !s && this.parent && Ar(this, "onRepeat"), (d === this._tDur || !d) && this._tTime === d && (h && !this._onUpdate && kS(this, r, true, true), (r || !f) && (d === this._tDur && this._ts > 0 || !d && this._ts < 0) && ka(this, 1), !s && !(h && !a) && (d || a || m) && (Ar(this, d === l ? "onComplete" : "onReverseComplete", true), this._prom && !(d < l && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, t.targets = function() {
    return this._targets;
  }, t.invalidate = function(r) {
    return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), n24.prototype.invalidate.call(this, r);
  }, t.resetTo = function(r, s, o, a, l) {
    wd || Er.wake(), this._ts || this.play();
    var f = Math.min(this._dur, (this._dp._time - this._start) * this._ts), h;
    return this._initted || pE(this, f), h = this._ease(f / this._dur), lj(this, r, s, o, a, h, f, l) ? this.resetTo(r, s, o, a, 1) : (ev(this, 0), this.parent || uD(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, t.kill = function(r, s) {
    if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? ch(this) : this.scrollTrigger && this.scrollTrigger.kill(!!di), this;
    if (this.timeline) {
      var o = this.timeline.totalDuration();
      return this.timeline.killTweensOf(r, s, _a && _a.vars.overwrite !== true)._first || ch(this), this.parent && o !== this.timeline.totalDuration() && Zc(this, this._dur * this.timeline._tDur / o, 0, 1), this;
    }
    var a = this._targets, l = r ? rs(r) : a, f = this._ptLookup, h = this._pt, d, p, g, v, S, M, m;
    if ((!s || s === "all") && zX(a, l)) return s === "all" && (this._pt = 0), ch(this);
    for (d = this._op = this._op || [], s !== "all" && (ri(s) && (S = {}, or(s, function(w) {
      return S[w] = 1;
    }), s = S), s = uj(a, s)), m = a.length; m--; ) if (~l.indexOf(a[m])) {
      p = f[m], s === "all" ? (d[m] = s, v = p, g = {}) : (g = d[m] = d[m] || {}, v = s);
      for (S in v) M = p && p[S], M && ((!("kill" in M.d) || M.d.kill(S) === true) && J_(this, M, "_pt"), delete p[S]), g !== "all" && (g[S] = 1);
    }
    return this._initted && !this._pt && h && ch(this), this;
  }, e.to = function(r, s) {
    return new e(r, s, arguments[2]);
  }, e.from = function(r, s) {
    return Rh(1, arguments);
  }, e.delayedCall = function(r, s, o, a) {
    return new e(s, 0, { immediateRender: false, lazy: false, overwrite: false, delay: r, onComplete: s, onReverseComplete: s, onCompleteParams: o, onReverseCompleteParams: o, callbackScope: a });
  }, e.fromTo = function(r, s, o) {
    return Rh(2, arguments);
  }, e.set = function(r, s) {
    return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s);
  }, e.killTweensOf = function(r, s, o) {
    return hn.killTweensOf(r, s, o);
  }, e;
}(Ed);
Nr(Fn.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
or("staggerTo,staggerFrom,staggerFromTo", function(n24) {
  Fn[n24] = function() {
    var e = new Vi(), t = zS.call(arguments, 0);
    return t.splice(n24 === "staggerFromTo" ? 5 : 4, 0, 0), e[n24].apply(e, t);
  };
});
var mE = function(e, t, i) {
  return e[t] = i;
}, ID = function(e, t, i) {
  return e[t](i);
}, fj = function(e, t, i, r) {
  return e[t](r.fp, i);
}, hj = function(e, t, i) {
  return e.setAttribute(t, i);
}, gE = function(e, t) {
  return En(e[t]) ? ID : oE(e[t]) && e.setAttribute ? hj : mE;
}, ND = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
}, dj = function(e, t) {
  return t.set(t.t, t.p, !!(t.s + t.c * e), t);
}, DD = function(e, t) {
  var i = t._pt, r = "";
  if (!e && t.b) r = t.b;
  else if (e === 1 && t.e) r = t.e;
  else {
    for (; i; ) r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r, i = i._next;
    r += t.c;
  }
  t.set(t.t, t.p, r, t);
}, _E = function(e, t) {
  for (var i = t._pt; i; ) i.r(e, i.d), i = i._next;
}, pj = function(e, t, i, r) {
  for (var s = this._pt, o; s; ) o = s._next, s.p === r && s.modifier(e, t, i), s = o;
}, mj = function(e) {
  for (var t = this._pt, i, r; t; ) r = t._next, t.p === e && !t.op || t.op === e ? J_(this, t, "_pt") : t.dep || (i = 1), t = r;
  return !i;
}, gj = function(e, t, i, r) {
  r.mSet(e, t, r.m.call(r.tween, i, r.mt), r);
}, OD = function(e) {
  for (var t = e._pt, i, r, s, o; t; ) {
    for (i = t._next, r = s; r && r.pr > t.pr; ) r = r._next;
    (t._prev = r ? r._prev : o) ? t._prev._next = t : s = t, (t._next = r) ? r._prev = t : o = t, t = i;
  }
  e._pt = s;
}, ar = function() {
  function n24(t, i, r, s, o, a, l, f, h) {
    this.t = i, this.s = s, this.c = o, this.p = r, this.r = a || ND, this.d = l || this, this.set = f || mE, this.pr = h || 0, this._next = t, t && (t._prev = this);
  }
  var e = n24.prototype;
  return e.modifier = function(i, r, s) {
    this.mSet = this.mSet || this.set, this.set = gj, this.m = i, this.mt = s, this.tween = r;
  }, n24;
}();
or(fE + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n24) {
  return cE[n24] = 1;
});
Ir.TweenMax = Ir.TweenLite = Fn;
Ir.TimelineLite = Ir.TimelineMax = Vi;
hn = new Vi({ sortChildren: false, defaults: Yc, autoRemoveChildren: true, id: "root", smoothChildTiming: true });
Pr.stringFilter = ED;
var Gl = [], Og = {}, _j = [], V2 = 0, vj = 0, kx = function(e) {
  return (Og[e] || _j).map(function(t) {
    return t();
  });
}, GS = function() {
  var e = Date.now(), t = [];
  e - V2 > 2 && (kx("matchMediaInit"), Gl.forEach(function(i) {
    var r = i.queries, s = i.conditions, o, a, l, f;
    for (a in r) o = Vs.matchMedia(r[a]).matches, o && (l = 1), o !== s[a] && (s[a] = o, f = 1);
    f && (i.revert(), l && t.push(i));
  }), kx("matchMediaRevert"), t.forEach(function(i) {
    return i.onMatch(i, function(r) {
      return i.add(null, r);
    });
  }), V2 = e, kx("matchMedia"));
}, UD = function() {
  function n24(t, i) {
    this.selector = i && BS(i), this.data = [], this._r = [], this.isReverted = false, this.id = vj++, t && this.add(t);
  }
  var e = n24.prototype;
  return e.add = function(i, r, s) {
    En(i) && (s = r, r = i, i = En);
    var o = this, a = function() {
      var f = an, h = o.selector, d;
      return f && f !== o && f.data.push(o), s && (o.selector = BS(s)), an = o, d = r.apply(o, arguments), En(d) && o._r.push(d), an = f, o.selector = h, o.isReverted = false, d;
    };
    return o.last = a, i === En ? a(o, function(l) {
      return o.add(null, l);
    }) : i ? o[i] = a : a;
  }, e.ignore = function(i) {
    var r = an;
    an = null, i(this), an = r;
  }, e.getTweens = function() {
    var i = [];
    return this.data.forEach(function(r) {
      return r instanceof n24 ? i.push.apply(i, r.getTweens()) : r instanceof Fn && !(r.parent && r.parent.data === "nested") && i.push(r);
    }), i;
  }, e.clear = function() {
    this._r.length = this.data.length = 0;
  }, e.kill = function(i, r) {
    var s = this;
    if (i ? function() {
      for (var a = s.getTweens(), l = s.data.length, f; l--; ) f = s.data[l], f.data === "isFlip" && (f.revert(), f.getChildren(true, true, false).forEach(function(h) {
        return a.splice(a.indexOf(h), 1);
      }));
      for (a.map(function(h) {
        return { g: h._dur || h._delay || h._sat && !h._sat.vars.immediateRender ? h.globalTime(0) : -1 / 0, t: h };
      }).sort(function(h, d) {
        return d.g - h.g || -1 / 0;
      }).forEach(function(h) {
        return h.t.revert(i);
      }), l = s.data.length; l--; ) f = s.data[l], f instanceof Vi ? f.data !== "nested" && (f.scrollTrigger && f.scrollTrigger.revert(), f.kill()) : !(f instanceof Fn) && f.revert && f.revert(i);
      s._r.forEach(function(h) {
        return h(i, s);
      }), s.isReverted = true;
    }() : this.data.forEach(function(a) {
      return a.kill && a.kill();
    }), this.clear(), r) for (var o = Gl.length; o--; ) Gl[o].id === this.id && Gl.splice(o, 1);
  }, e.revert = function(i) {
    this.kill(i || {});
  }, n24;
}(), yj = function() {
  function n24(t) {
    this.contexts = [], this.scope = t, an && an.data.push(this);
  }
  var e = n24.prototype;
  return e.add = function(i, r, s) {
    oo(i) || (i = { matches: i });
    var o = new UD(0, s || this.scope), a = o.conditions = {}, l, f, h;
    an && !o.selector && (o.selector = an.selector), this.contexts.push(o), r = o.add("onMatch", r), o.queries = i;
    for (f in i) f === "all" ? h = 1 : (l = Vs.matchMedia(i[f]), l && (Gl.indexOf(o) < 0 && Gl.push(o), (a[f] = l.matches) && (h = 1), l.addListener ? l.addListener(GS) : l.addEventListener("change", GS)));
    return h && r(o, function(d) {
      return o.add(null, d);
    }), this;
  }, e.revert = function(i) {
    this.kill(i || {});
  }, e.kill = function(i) {
    this.contexts.forEach(function(r) {
      return r.kill(i, true);
    });
  }, n24;
}(), M0 = { registerPlugin: function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
  t.forEach(function(r) {
    return SD(r);
  });
}, timeline: function(e) {
  return new Vi(e);
}, getTweensOf: function(e, t) {
  return hn.getTweensOf(e, t);
}, getProperty: function(e, t, i, r) {
  ri(e) && (e = rs(e)[0]);
  var s = Bl(e || {}).get, o = i ? lD : aD;
  return i === "native" && (i = ""), e && (t ? o((xr[t] && xr[t].get || s)(e, t, i, r)) : function(a, l, f) {
    return o((xr[a] && xr[a].get || s)(e, a, l, f));
  });
}, quickSetter: function(e, t, i) {
  if (e = rs(e), e.length > 1) {
    var r = e.map(function(h) {
      return cr.quickSetter(h, t, i);
    }), s = r.length;
    return function(h) {
      for (var d = s; d--; ) r[d](h);
    };
  }
  e = e[0] || {};
  var o = xr[t], a = Bl(e), l = a.harness && (a.harness.aliases || {})[t] || t, f = o ? function(h) {
    var d = new o();
    Sc._pt = 0, d.init(e, i ? h + i : h, Sc, 0, [e]), d.render(1, d), Sc._pt && _E(1, Sc);
  } : a.set(e, l);
  return o ? f : function(h) {
    return f(e, l, i ? h + i : h, a, 1);
  };
}, quickTo: function(e, t, i) {
  var r, s = cr.to(e, Nr((r = {}, r[t] = "+=0.1", r.paused = true, r.stagger = 0, r), i || {})), o = function(l, f, h) {
    return s.resetTo(t, l, f, h);
  };
  return o.tween = s, o;
}, isTweening: function(e) {
  return hn.getTweensOf(e, true).length > 0;
}, defaults: function(e) {
  return e && e.ease && (e.ease = Hl(e.ease, Yc.ease)), U2(Yc, e || {});
}, config: function(e) {
  return U2(Pr, e || {});
}, registerEffect: function(e) {
  var t = e.name, i = e.effect, r = e.plugins, s = e.defaults, o = e.extendTimeline;
  (r || "").split(",").forEach(function(a) {
    return a && !xr[a] && !Ir[a] && xd(t + " effect requires " + a + " plugin.");
  }), Nx[t] = function(a, l, f) {
    return i(rs(a), Nr(l || {}, s), f);
  }, o && (Vi.prototype[t] = function(a, l, f) {
    return this.add(Nx[t](a, oo(l) ? l : (f = l) && {}, this), f);
  });
}, registerEase: function(e, t) {
  Ct[e] = Hl(t);
}, parseEase: function(e, t) {
  return arguments.length ? Hl(e, t) : Ct;
}, getById: function(e) {
  return hn.getById(e);
}, exportRoot: function(e, t) {
  e === void 0 && (e = {});
  var i = new Vi(e), r, s;
  for (i.smoothChildTiming = sr(e.smoothChildTiming), hn.remove(i), i._dp = 0, i._time = i._tTime = hn._time, r = hn._first; r; ) s = r._next, (t || !(!r._dur && r instanceof Fn && r.vars.onComplete === r._targets[0])) && js(i, r, r._start - r._delay), r = s;
  return js(hn, i, 0), i;
}, context: function(e, t) {
  return e ? new UD(e, t) : an;
}, matchMedia: function(e) {
  return new yj(e);
}, matchMediaRefresh: function() {
  return Gl.forEach(function(e) {
    var t = e.conditions, i, r;
    for (r in t) t[r] && (t[r] = false, i = 1);
    i && e.revert();
  }) || GS();
}, addEventListener: function(e, t) {
  var i = Og[e] || (Og[e] = []);
  ~i.indexOf(t) || i.push(t);
}, removeEventListener: function(e, t) {
  var i = Og[e], r = i && i.indexOf(t);
  r >= 0 && i.splice(r, 1);
}, utils: { wrap: ZX, wrapYoyo: JX, distribute: mD, random: _D, snap: gD, normalize: KX, getUnit: bi, clamp: jX, splitColor: MD, toArray: rs, selector: BS, mapRange: yD, pipe: YX, unitize: qX, interpolate: QX, shuffle: pD }, install: nD, effects: Nx, ticker: Er, updateRoot: Vi.updateRoot, plugins: xr, globalTimeline: hn, core: { PropTween: ar, globals: iD, Tween: Fn, Timeline: Vi, Animation: Ed, getCache: Bl, _removeLinkedListItem: J_, reverting: function() {
  return di;
}, context: function(e) {
  return e && an && (an.data.push(e), e._ctx = an), an;
}, suppressOverwrites: function(e) {
  return sE = e;
} } };
or("to,from,fromTo,delayedCall,set,killTweensOf", function(n24) {
  return M0[n24] = Fn[n24];
});
Er.add(Vi.updateRoot);
Sc = M0.to({}, { duration: 0 });
var xj = function(e, t) {
  for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t; ) i = i._next;
  return i;
}, Sj = function(e, t) {
  var i = e._targets, r, s, o;
  for (r in t) for (s = i.length; s--; ) o = e._ptLookup[s][r], o && (o = o.d) && (o._pt && (o = xj(o, r)), o && o.modifier && o.modifier(t[r], e, i[s], r));
}, Fx = function(e, t) {
  return { name: e, rawVars: 1, init: function(r, s, o) {
    o._onInit = function(a) {
      var l, f;
      if (ri(s) && (l = {}, or(s, function(h) {
        return l[h] = 1;
      }), s = l), t) {
        l = {};
        for (f in s) l[f] = t(s[f]);
        s = l;
      }
      Sj(a, s);
    };
  } };
}, cr = M0.registerPlugin({ name: "attr", init: function(e, t, i, r, s) {
  var o, a, l;
  this.tween = i;
  for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], r, s, 0, 0, o), a.op = o, a.b = l, this._props.push(o);
}, render: function(e, t) {
  for (var i = t._pt; i; ) di ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next;
} }, { name: "endArray", init: function(e, t) {
  for (var i = t.length; i--; ) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1);
} }, Fx("roundProps", VS), Fx("modifiers"), Fx("snap", gD)) || M0;
Fn.version = Vi.version = cr.version = "3.12.7";
tD = 1;
aE() && Jc();
Ct.Power0;
Ct.Power1;
Ct.Power2;
Ct.Power3;
Ct.Power4;
Ct.Linear;
Ct.Quad;
Ct.Cubic;
Ct.Quart;
Ct.Quint;
Ct.Strong;
Ct.Elastic;
Ct.Back;
Ct.SteppedEase;
Ct.Bounce;
Ct.Sine;
Ct.Expo;
Ct.Circ;
/*!
 * CSSPlugin 3.12.7
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/
var H2, va, Ic, vE, Pl, G2, yE, Mj = function() {
  return typeof window < "u";
}, Vo = {}, yl = 180 / Math.PI, Nc = Math.PI / 180, Qu = Math.atan2, W2 = 1e8, xE = /([A-Z])/g, wj = /(left|right|width|margin|padding|x)/i, Ej = /[\s,\(]\S/, qs = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, WS = function(e, t) {
  return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Tj = function(e, t) {
  return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
}, Aj = function(e, t) {
  return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t);
}, bj = function(e, t) {
  var i = t.s + t.c * e;
  t.set(t.t, t.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + t.u, t);
}, kD = function(e, t) {
  return t.set(t.t, t.p, e ? t.e : t.b, t);
}, FD = function(e, t) {
  return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
}, Cj = function(e, t, i) {
  return e.style[t] = i;
}, Rj = function(e, t, i) {
  return e.style.setProperty(t, i);
}, Pj = function(e, t, i) {
  return e._gsap[t] = i;
}, Lj = function(e, t, i) {
  return e._gsap.scaleX = e._gsap.scaleY = i;
}, Ij = function(e, t, i, r, s) {
  var o = e._gsap;
  o.scaleX = o.scaleY = i, o.renderTransform(s, o);
}, Nj = function(e, t, i, r, s) {
  var o = e._gsap;
  o[t] = i, o.renderTransform(s, o);
}, pn = "transform", lr = pn + "Origin", Dj = function n21(e, t) {
  var i = this, r = this.target, s = r.style, o = r._gsap;
  if (e in Vo && s) {
    if (this.tfm = this.tfm || {}, e !== "transform") e = qs[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
      return i.tfm[a] = Eo(r, a);
    }) : this.tfm[e] = o.x ? o[e] : Eo(r, e), e === lr && (this.tfm.zOrigin = o.zOrigin);
    else return qs.transform.split(",").forEach(function(a) {
      return n21.call(i, a, t);
    });
    if (this.props.indexOf(pn) >= 0) return;
    o.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(lr, t, "")), e = pn;
  }
  (s || t) && this.props.push(e, t, s[e]);
}, zD = function(e) {
  e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"));
}, Oj = function() {
  var e = this.props, t = this.target, i = t.style, r = t._gsap, s, o;
  for (s = 0; s < e.length; s += 3) e[s + 1] ? e[s + 1] === 2 ? t[e[s]](e[s + 2]) : t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(xE, "-$1").toLowerCase());
  if (this.tfm) {
    for (o in this.tfm) r[o] = this.tfm[o];
    r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = yE(), (!s || !s.isStart) && !i[pn] && (zD(i), r.zOrigin && i[lr] && (i[lr] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1);
  }
}, BD = function(e, t) {
  var i = { target: e, props: [], revert: Oj, save: Dj };
  return e._gsap || cr.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function(r) {
    return i.save(r);
  }), i;
}, VD, XS = function(e, t) {
  var i = va.createElementNS ? va.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : va.createElement(e);
  return i && i.style ? i : va.createElement(e);
}, ro = function n22(e, t, i) {
  var r = getComputedStyle(e);
  return r[t] || r.getPropertyValue(t.replace(xE, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n22(e, Qc(t) || t, 1) || "";
}, X2 = "O,Moz,ms,Ms,Webkit".split(","), Qc = function(e, t, i) {
  var r = t || Pl, s = r.style, o = 5;
  if (e in s && !i) return e;
  for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(X2[o] + e in s); ) ;
  return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? X2[o] : "") + e;
}, jS = function() {
  Mj() && window.document && (H2 = window, va = H2.document, Ic = va.documentElement, Pl = XS("div") || { style: {} }, XS("div"), pn = Qc(pn), lr = pn + "Origin", Pl.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", VD = !!Qc("perspective"), yE = cr.core.reverting, vE = 1);
}, j2 = function(e) {
  var t = e.ownerSVGElement, i = XS("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), r = e.cloneNode(true), s;
  r.style.display = "block", i.appendChild(r), Ic.appendChild(i);
  try {
    s = r.getBBox();
  } catch {
  }
  return i.removeChild(r), Ic.removeChild(i), s;
}, $2 = function(e, t) {
  for (var i = t.length; i--; ) if (e.hasAttribute(t[i])) return e.getAttribute(t[i]);
}, HD = function(e) {
  var t, i;
  try {
    t = e.getBBox();
  } catch {
    t = j2(e), i = 1;
  }
  return t && (t.width || t.height) || i || (t = j2(e)), t && !t.width && !t.x && !t.y ? { x: +$2(e, ["x", "cx", "x1"]) || 0, y: +$2(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t;
}, GD = function(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && HD(e));
}, Ql = function(e, t) {
  if (t) {
    var i = e.style, r;
    t in Vo && t !== lr && (t = pn), i.removeProperty ? (r = t.substr(0, 2), (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(r === "--" ? t : t.replace(xE, "-$1").toLowerCase())) : i.removeAttribute(t);
  }
}, ya = function(e, t, i, r, s, o) {
  var a = new ar(e._pt, t, i, 0, 1, o ? FD : kD);
  return e._pt = a, a.b = r, a.e = s, e._props.push(i), a;
}, Y2 = { deg: 1, rad: 1, turn: 1 }, Uj = { grid: 1, flex: 1 }, Fa = function n23(e, t, i, r) {
  var s = parseFloat(i) || 0, o = (i + "").trim().substr((s + "").length) || "px", a = Pl.style, l = wj.test(t), f = e.tagName.toLowerCase() === "svg", h = (f ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, p = r === "px", g = r === "%", v, S, M, m;
  if (r === o || !s || Y2[r] || Y2[o]) return s;
  if (o !== "px" && !p && (s = n23(e, t, i, "px")), m = e.getCTM && GD(e), (g || o === "%") && (Vo[t] || ~t.indexOf("adius"))) return v = m ? e.getBBox()[l ? "width" : "height"] : e[h], Rn(g ? s / v * d : s / 100 * v);
  if (a[l ? "width" : "height"] = d + (p ? o : r), S = r !== "rem" && ~t.indexOf("adius") || r === "em" && e.appendChild && !f ? e : e.parentNode, m && (S = (e.ownerSVGElement || {}).parentNode), (!S || S === va || !S.appendChild) && (S = va.body), M = S._gsap, M && g && M.width && l && M.time === Er.time && !M.uncache) return Rn(s / M.width * d);
  if (g && (t === "height" || t === "width")) {
    var w = e.style[t];
    e.style[t] = d + r, v = e[h], w ? e.style[t] = w : Ql(e, t);
  } else (g || o === "%") && !Uj[ro(S, "display")] && (a.position = ro(e, "position")), S === e && (a.position = "static"), S.appendChild(Pl), v = Pl[h], S.removeChild(Pl), a.position = "absolute";
  return l && g && (M = Bl(S), M.time = Er.time, M.width = S[h]), Rn(p ? v * s / d : v && s ? d / v * s : 0);
}, Eo = function(e, t, i, r) {
  var s;
  return vE || jS(), t in qs && t !== "transform" && (t = qs[t], ~t.indexOf(",") && (t = t.split(",")[0])), Vo[t] && t !== "transform" ? (s = Ad(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : E0(ro(e, lr)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = w0[t] && w0[t](e, t, i) || ro(e, t) || sD(e, t) || (t === "opacity" ? 1 : 0))), i && !~(s + "").trim().indexOf(" ") ? Fa(e, t, s, i) + i : s;
}, kj = function(e, t, i, r) {
  if (!i || i === "none") {
    var s = Qc(t, e, 1), o = s && ro(e, s, 1);
    o && o !== i ? (t = s, i = o) : t === "borderColor" && (i = ro(e, "borderTopColor"));
  }
  var a = new ar(this._pt, e.style, t, 0, 1, DD), l = 0, f = 0, h, d, p, g, v, S, M, m, w, E, A, P;
  if (a.b = i, a.e = r, i += "", r += "", r === "auto" && (S = e.style[t], e.style[t] = r, r = ro(e, t) || r, S ? e.style[t] = S : Ql(e, t)), h = [i, r], ED(h), i = h[0], r = h[1], p = i.match(xc) || [], P = r.match(xc) || [], P.length) {
    for (; d = xc.exec(r); ) M = d[0], w = r.substring(l, d.index), v ? v = (v + 1) % 5 : (w.substr(-5) === "rgba(" || w.substr(-5) === "hsla(") && (v = 1), M !== (S = p[f++] || "") && (g = parseFloat(S) || 0, A = S.substr((g + "").length), M.charAt(1) === "=" && (M = Lc(g, M) + A), m = parseFloat(M), E = M.substr((m + "").length), l = xc.lastIndex - E.length, E || (E = E || Pr.units[t] || A, l === r.length && (r += E, a.e += E)), A !== E && (g = Fa(e, t, S, E) || 0), a._pt = { _next: a._pt, p: w || f === 1 ? w : ",", s: g, c: m - g, m: v && v < 4 || t === "zIndex" ? Math.round : 0 });
    a.c = l < r.length ? r.substring(l, r.length) : "";
  } else a.r = t === "display" && r === "none" ? FD : kD;
  return QN.test(r) && (a.e = 0), this._pt = a, a;
}, q2 = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, Fj = function(e) {
  var t = e.split(" "), i = t[0], r = t[1] || "50%";
  return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i, i = r, r = e), t[0] = q2[i] || i, t[1] = q2[r] || r, t.join(" ");
}, zj = function(e, t) {
  if (t.tween && t.tween._time === t.tween._dur) {
    var i = t.t, r = i.style, s = t.u, o = i._gsap, a, l, f;
    if (s === "all" || s === true) r.cssText = "", l = 1;
    else for (s = s.split(","), f = s.length; --f > -1; ) a = s[f], Vo[a] && (l = 1, a = a === "transformOrigin" ? lr : pn), Ql(i, a);
    l && (Ql(i, pn), o && (o.svg && i.removeAttribute("transform"), r.scale = r.rotate = r.translate = "none", Ad(i, 1), o.uncache = 1, zD(r)));
  }
}, w0 = { clearProps: function(e, t, i, r, s) {
  if (s.data !== "isFromStart") {
    var o = e._pt = new ar(e._pt, t, i, 0, 0, zj);
    return o.u = r, o.pr = -10, o.tween = s, e._props.push(i), 1;
  }
} }, Td = [1, 0, 0, 1, 0, 0], WD = {}, XD = function(e) {
  return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
}, K2 = function(e) {
  var t = ro(e, pn);
  return XD(t) ? Td : t.substr(7).match(JN).map(Rn);
}, SE = function(e, t) {
  var i = e._gsap || Bl(e), r = e.style, s = K2(e), o, a, l, f;
  return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? Td : s) : (s === Td && !e.offsetParent && e !== Ic && !i.svg && (l = r.display, r.display = "block", o = e.parentNode, (!o || !e.offsetParent && !e.getBoundingClientRect().width) && (f = 1, a = e.nextElementSibling, Ic.appendChild(e)), s = K2(e), l ? r.display = l : Ql(e, "display"), f && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Ic.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
}, $S = function(e, t, i, r, s, o) {
  var a = e._gsap, l = s || SE(e, true), f = a.xOrigin || 0, h = a.yOrigin || 0, d = a.xOffset || 0, p = a.yOffset || 0, g = l[0], v = l[1], S = l[2], M = l[3], m = l[4], w = l[5], E = t.split(" "), A = parseFloat(E[0]) || 0, P = parseFloat(E[1]) || 0, R, L, D, F;
  i ? l !== Td && (L = g * M - v * S) && (D = A * (M / L) + P * (-S / L) + (S * w - M * m) / L, F = A * (-v / L) + P * (g / L) - (g * w - v * m) / L, A = D, P = F) : (R = HD(e), A = R.x + (~E[0].indexOf("%") ? A / 100 * R.width : A), P = R.y + (~(E[1] || E[0]).indexOf("%") ? P / 100 * R.height : P)), r || r !== false && a.smooth ? (m = A - f, w = P - h, a.xOffset = d + (m * g + w * S) - m, a.yOffset = p + (m * v + w * M) - w) : a.xOffset = a.yOffset = 0, a.xOrigin = A, a.yOrigin = P, a.smooth = !!r, a.origin = t, a.originIsAbsolute = !!i, e.style[lr] = "0px 0px", o && (ya(o, a, "xOrigin", f, A), ya(o, a, "yOrigin", h, P), ya(o, a, "xOffset", d, a.xOffset), ya(o, a, "yOffset", p, a.yOffset)), e.setAttribute("data-svg-origin", A + " " + P);
}, Ad = function(e, t) {
  var i = e._gsap || new CD(e);
  if ("x" in i && !t && !i.uncache) return i;
  var r = e.style, s = i.scaleX < 0, o = "px", a = "deg", l = getComputedStyle(e), f = ro(e, lr) || "0", h, d, p, g, v, S, M, m, w, E, A, P, R, L, D, F, C, N, j, Z, G, J, q, ae, B, Y, $, ee, ue, Ae, te, de;
  return h = d = p = S = M = m = w = E = A = 0, g = v = 1, i.svg = !!(e.getCTM && GD(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[pn] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[pn] !== "none" ? l[pn] : "")), r.scale = r.rotate = r.translate = "none"), L = SE(e, i.svg), i.svg && (i.uncache ? (B = e.getBBox(), f = i.xOrigin - B.x + "px " + (i.yOrigin - B.y) + "px", ae = "") : ae = !t && e.getAttribute("data-svg-origin"), $S(e, ae || f, !!ae || i.originIsAbsolute, i.smooth !== false, L)), P = i.xOrigin || 0, R = i.yOrigin || 0, L !== Td && (N = L[0], j = L[1], Z = L[2], G = L[3], h = J = L[4], d = q = L[5], L.length === 6 ? (g = Math.sqrt(N * N + j * j), v = Math.sqrt(G * G + Z * Z), S = N || j ? Qu(j, N) * yl : 0, w = Z || G ? Qu(Z, G) * yl + S : 0, w && (v *= Math.abs(Math.cos(w * Nc))), i.svg && (h -= P - (P * N + R * Z), d -= R - (P * j + R * G))) : (de = L[6], Ae = L[7], $ = L[8], ee = L[9], ue = L[10], te = L[11], h = L[12], d = L[13], p = L[14], D = Qu(de, ue), M = D * yl, D && (F = Math.cos(-D), C = Math.sin(-D), ae = J * F + $ * C, B = q * F + ee * C, Y = de * F + ue * C, $ = J * -C + $ * F, ee = q * -C + ee * F, ue = de * -C + ue * F, te = Ae * -C + te * F, J = ae, q = B, de = Y), D = Qu(-Z, ue), m = D * yl, D && (F = Math.cos(-D), C = Math.sin(-D), ae = N * F - $ * C, B = j * F - ee * C, Y = Z * F - ue * C, te = G * C + te * F, N = ae, j = B, Z = Y), D = Qu(j, N), S = D * yl, D && (F = Math.cos(D), C = Math.sin(D), ae = N * F + j * C, B = J * F + q * C, j = j * F - N * C, q = q * F - J * C, N = ae, J = B), M && Math.abs(M) + Math.abs(S) > 359.9 && (M = S = 0, m = 180 - m), g = Rn(Math.sqrt(N * N + j * j + Z * Z)), v = Rn(Math.sqrt(q * q + de * de)), D = Qu(J, q), w = Math.abs(D) > 2e-4 ? D * yl : 0, A = te ? 1 / (te < 0 ? -te : te) : 0), i.svg && (ae = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !XD(ro(e, pn)), ae && e.setAttribute("transform", ae))), Math.abs(w) > 90 && Math.abs(w) < 270 && (s ? (g *= -1, w += S <= 0 ? 180 : -180, S += S <= 0 ? 180 : -180) : (v *= -1, w += w <= 0 ? 180 : -180)), t = t || i.uncache, i.x = h - ((i.xPercent = h && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-h) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + o, i.y = d - ((i.yPercent = d && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + o, i.z = p + o, i.scaleX = Rn(g), i.scaleY = Rn(v), i.rotation = Rn(S) + a, i.rotationX = Rn(M) + a, i.rotationY = Rn(m) + a, i.skewX = w + a, i.skewY = E + a, i.transformPerspective = A + o, (i.zOrigin = parseFloat(f.split(" ")[2]) || !t && i.zOrigin || 0) && (r[lr] = E0(f)), i.xOffset = i.yOffset = 0, i.force3D = Pr.force3D, i.renderTransform = i.svg ? Vj : VD ? jD : Bj, i.uncache = 0, i;
}, E0 = function(e) {
  return (e = e.split(" "))[0] + " " + e[1];
}, zx = function(e, t, i) {
  var r = bi(t);
  return Rn(parseFloat(t) + parseFloat(Fa(e, "x", i + "px", r))) + r;
}, Bj = function(e, t) {
  t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, jD(e, t);
}, dl = "0deg", ih = "0px", pl = ") ", jD = function(e, t) {
  var i = t || this, r = i.xPercent, s = i.yPercent, o = i.x, a = i.y, l = i.z, f = i.rotation, h = i.rotationY, d = i.rotationX, p = i.skewX, g = i.skewY, v = i.scaleX, S = i.scaleY, M = i.transformPerspective, m = i.force3D, w = i.target, E = i.zOrigin, A = "", P = m === "auto" && e && e !== 1 || m === true;
  if (E && (d !== dl || h !== dl)) {
    var R = parseFloat(h) * Nc, L = Math.sin(R), D = Math.cos(R), F;
    R = parseFloat(d) * Nc, F = Math.cos(R), o = zx(w, o, L * F * -E), a = zx(w, a, -Math.sin(R) * -E), l = zx(w, l, D * F * -E + E);
  }
  M !== ih && (A += "perspective(" + M + pl), (r || s) && (A += "translate(" + r + "%, " + s + "%) "), (P || o !== ih || a !== ih || l !== ih) && (A += l !== ih || P ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + pl), f !== dl && (A += "rotate(" + f + pl), h !== dl && (A += "rotateY(" + h + pl), d !== dl && (A += "rotateX(" + d + pl), (p !== dl || g !== dl) && (A += "skew(" + p + ", " + g + pl), (v !== 1 || S !== 1) && (A += "scale(" + v + ", " + S + pl), w.style[pn] = A || "translate(0, 0)";
}, Vj = function(e, t) {
  var i = t || this, r = i.xPercent, s = i.yPercent, o = i.x, a = i.y, l = i.rotation, f = i.skewX, h = i.skewY, d = i.scaleX, p = i.scaleY, g = i.target, v = i.xOrigin, S = i.yOrigin, M = i.xOffset, m = i.yOffset, w = i.forceCSS, E = parseFloat(o), A = parseFloat(a), P, R, L, D, F;
  l = parseFloat(l), f = parseFloat(f), h = parseFloat(h), h && (h = parseFloat(h), f += h, l += h), l || f ? (l *= Nc, f *= Nc, P = Math.cos(l) * d, R = Math.sin(l) * d, L = Math.sin(l - f) * -p, D = Math.cos(l - f) * p, f && (h *= Nc, F = Math.tan(f - h), F = Math.sqrt(1 + F * F), L *= F, D *= F, h && (F = Math.tan(h), F = Math.sqrt(1 + F * F), P *= F, R *= F)), P = Rn(P), R = Rn(R), L = Rn(L), D = Rn(D)) : (P = d, D = p, R = L = 0), (E && !~(o + "").indexOf("px") || A && !~(a + "").indexOf("px")) && (E = Fa(g, "x", o, "px"), A = Fa(g, "y", a, "px")), (v || S || M || m) && (E = Rn(E + v - (v * P + S * L) + M), A = Rn(A + S - (v * R + S * D) + m)), (r || s) && (F = g.getBBox(), E = Rn(E + r / 100 * F.width), A = Rn(A + s / 100 * F.height)), F = "matrix(" + P + "," + R + "," + L + "," + D + "," + E + "," + A + ")", g.setAttribute("transform", F), w && (g.style[pn] = F);
}, Hj = function(e, t, i, r, s) {
  var o = 360, a = ri(s), l = parseFloat(s) * (a && ~s.indexOf("rad") ? yl : 1), f = l - r, h = r + f + "deg", d, p;
  return a && (d = s.split("_")[1], d === "short" && (f %= o, f !== f % (o / 2) && (f += f < 0 ? o : -360)), d === "cw" && f < 0 ? f = (f + o * W2) % o - ~~(f / o) * o : d === "ccw" && f > 0 && (f = (f - o * W2) % o - ~~(f / o) * o)), e._pt = p = new ar(e._pt, t, i, r, f, Tj), p.e = h, p.u = "deg", e._props.push(i), p;
}, Z2 = function(e, t) {
  for (var i in t) e[i] = t[i];
  return e;
}, Gj = function(e, t, i) {
  var r = Z2({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", o = i.style, a, l, f, h, d, p, g, v;
  r.svg ? (f = i.getAttribute("transform"), i.setAttribute("transform", ""), o[pn] = t, a = Ad(i, 1), Ql(i, pn), i.setAttribute("transform", f)) : (f = getComputedStyle(i)[pn], o[pn] = t, a = Ad(i, 1), o[pn] = f);
  for (l in Vo) f = r[l], h = a[l], f !== h && s.indexOf(l) < 0 && (g = bi(f), v = bi(h), d = g !== v ? Fa(i, l, f, v) : parseFloat(f), p = parseFloat(h), e._pt = new ar(e._pt, a, l, d, p - d, WS), e._pt.u = v || 0, e._props.push(l));
  Z2(a, r);
};
or("padding,margin,Width,Radius", function(n24, e) {
  var t = "Top", i = "Right", r = "Bottom", s = "Left", o = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function(a) {
    return e < 2 ? n24 + a : "border" + a + n24;
  });
  w0[e > 1 ? "border" + n24 : n24] = function(a, l, f, h, d) {
    var p, g;
    if (arguments.length < 4) return p = o.map(function(v) {
      return Eo(a, v, f);
    }), g = p.join(" "), g.split(p[0]).length === 5 ? p[0] : g;
    p = (h + "").split(" "), g = {}, o.forEach(function(v, S) {
      return g[v] = p[S] = p[S] || p[(S - 1) / 2 | 0];
    }), a.init(l, g, d);
  };
});
var $D = { name: "css", register: jS, targetTest: function(e) {
  return e.style && e.nodeType;
}, init: function(e, t, i, r, s) {
  var o = this._props, a = e.style, l = i.vars.startAt, f, h, d, p, g, v, S, M, m, w, E, A, P, R, L, D;
  vE || jS(), this.styles = this.styles || BD(e), D = this.styles.props, this.tween = i;
  for (S in t) if (S !== "autoRound" && (h = t[S], !(xr[S] && RD(S, t, i, r, e, s)))) {
    if (g = typeof h, v = w0[S], g === "function" && (h = h.call(i, r, e, s), g = typeof h), g === "string" && ~h.indexOf("random(") && (h = Md(h)), v) v(this, e, S, h, i) && (L = 1);
    else if (S.substr(0, 2) === "--") f = (getComputedStyle(e).getPropertyValue(S) + "").trim(), h += "", Ia.lastIndex = 0, Ia.test(f) || (M = bi(f), m = bi(h)), m ? M !== m && (f = Fa(e, S, f, m) + m) : M && (h += M), this.add(a, "setProperty", f, h, r, s, 0, 0, S), o.push(S), D.push(S, 0, a[S]);
    else if (g !== "undefined") {
      if (l && S in l ? (f = typeof l[S] == "function" ? l[S].call(i, r, e, s) : l[S], ri(f) && ~f.indexOf("random(") && (f = Md(f)), bi(f + "") || f === "auto" || (f += Pr.units[S] || bi(Eo(e, S)) || ""), (f + "").charAt(1) === "=" && (f = Eo(e, S))) : f = Eo(e, S), p = parseFloat(f), w = g === "string" && h.charAt(1) === "=" && h.substr(0, 2), w && (h = h.substr(2)), d = parseFloat(h), S in qs && (S === "autoAlpha" && (p === 1 && Eo(e, "visibility") === "hidden" && d && (p = 0), D.push("visibility", 0, a.visibility), ya(this, a, "visibility", p ? "inherit" : "hidden", d ? "inherit" : "hidden", !d)), S !== "scale" && S !== "transform" && (S = qs[S], ~S.indexOf(",") && (S = S.split(",")[0]))), E = S in Vo, E) {
        if (this.styles.save(S), A || (P = e._gsap, P.renderTransform && !t.parseTransform || Ad(e, t.parseTransform), R = t.smoothOrigin !== false && P.smooth, A = this._pt = new ar(this._pt, a, pn, 0, 1, P.renderTransform, P, 0, -1), A.dep = 1), S === "scale") this._pt = new ar(this._pt, P, "scaleY", P.scaleY, (w ? Lc(P.scaleY, w + d) : d) - P.scaleY || 0, WS), this._pt.u = 0, o.push("scaleY", S), S += "X";
        else if (S === "transformOrigin") {
          D.push(lr, 0, a[lr]), h = Fj(h), P.svg ? $S(e, h, 0, R, 0, this) : (m = parseFloat(h.split(" ")[2]) || 0, m !== P.zOrigin && ya(this, P, "zOrigin", P.zOrigin, m), ya(this, a, S, E0(f), E0(h)));
          continue;
        } else if (S === "svgOrigin") {
          $S(e, h, 1, R, 0, this);
          continue;
        } else if (S in WD) {
          Hj(this, P, S, p, w ? Lc(p, w + h) : h);
          continue;
        } else if (S === "smoothOrigin") {
          ya(this, P, "smooth", P.smooth, h);
          continue;
        } else if (S === "force3D") {
          P[S] = h;
          continue;
        } else if (S === "transform") {
          Gj(this, h, e);
          continue;
        }
      } else S in a || (S = Qc(S) || S);
      if (E || (d || d === 0) && (p || p === 0) && !Ej.test(h) && S in a) M = (f + "").substr((p + "").length), d || (d = 0), m = bi(h) || (S in Pr.units ? Pr.units[S] : M), M !== m && (p = Fa(e, S, f, m)), this._pt = new ar(this._pt, E ? P : a, S, p, (w ? Lc(p, w + d) : d) - p, !E && (m === "px" || S === "zIndex") && t.autoRound !== false ? bj : WS), this._pt.u = m || 0, M !== m && m !== "%" && (this._pt.b = f, this._pt.r = Aj);
      else if (S in a) kj.call(this, e, S, f, w ? w + h : h);
      else if (S in e) this.add(e, S, f || e[S], w ? w + h : h, r, s);
      else if (S !== "parseTransform") {
        uE(S, h);
        continue;
      }
      E || (S in a ? D.push(S, 0, a[S]) : typeof e[S] == "function" ? D.push(S, 2, e[S]()) : D.push(S, 1, f || e[S])), o.push(S);
    }
  }
  L && OD(this);
}, render: function(e, t) {
  if (t.tween._time || !yE()) for (var i = t._pt; i; ) i.r(e, i.d), i = i._next;
  else t.styles.revert();
}, get: Eo, aliases: qs, getSetter: function(e, t, i) {
  var r = qs[t];
  return r && r.indexOf(",") < 0 && (t = r), t in Vo && t !== lr && (e._gsap.x || Eo(e, "x")) ? i && G2 === i ? t === "scale" ? Lj : Pj : (G2 = i || {}) && (t === "scale" ? Ij : Nj) : e.style && !oE(e.style[t]) ? Cj : ~t.indexOf("-") ? Rj : gE(e, t);
}, core: { _removeProperty: Ql, _getMatrix: SE } };
cr.utils.checkPrefix = Qc;
cr.core.getStyleSaver = BD;
(function(n24, e, t, i) {
  var r = or(n24 + "," + e + "," + t, function(s) {
    Vo[s] = 1;
  });
  or(e, function(s) {
    Pr.units[s] = "deg", WD[s] = 1;
  }), qs[r[13]] = n24 + "," + e, or(i, function(s) {
    var o = s.split(":");
    qs[o[1]] = r[o[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
or("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n24) {
  Pr.units[n24] = "px";
});
cr.registerPlugin($D);
var T0 = cr.registerPlugin($D) || cr;
T0.core.Tween;
const rh = (n24) => n24 * (Math.PI / 180);
function hh(n24, e = 100, t = [0, 0, 0], i = [90, 0, 0]) {
  return [e * Math.cos(rh(n24[0] - i[0])) * Math.cos(rh(n24[2] - i[2])), e * Math.sin(rh(n24[0] - i[0])) * Math.cos(rh(n24[2] - i[2])), e * Math.sin(rh(n24[2] - i[2]))].map((o, a) => o + t[a]);
}
function YS(n24, e = [x, y, z]) {
  return n24.map((t, i) => e[i] != null ? e[i] - (t - e[i]) : t);
}
function qS(n24, e, t, i) {
  return i < 0.5 ? n24.map((r, s) => SS.lerp(n24[s], e[s], i * 2)) : e.map((r, s) => SS.lerp(e[s], t[s], (i - 0.5) * 2));
}
function Wj({ u: n24, r: e, res: t = { x: 36, y: 18 }, width: i = 360, height: r = 180, arrowFactor: s = 0.1 }) {
  const o = ne.useRef(), a = ne.useMemo(() => (t.x + 1) * (t.y + 1) * 4, [t]), l = ne.useMemo(() => {
    const f = new Float32Array(a * 2 * 3);
    return new xt().setAttribute("position", new zt(f, 3));
  }, [a]);
  return FN(() => {
    if (!o.current) return;
    const f = o.current.geometry.attributes.position.array;
    let h = 0;
    const d = i / t.x, p = r / t.y, g = i / 2, v = r / 2;
    for (let S = 0; S <= t.x; S++) {
      const M = -g + S * d;
      for (let m = 0; m <= t.y; m++) {
        const w = -v + m * p, E = [];
        if (!(S == 0 && S == t.x && m == 0 && m == t.y)) {
          E.push([M, 0, w + p / 2]), E.push([M + d / 2, 0, w]), E.push([M, 0, w - p / 2]), E.push([M - d / 2, 0, w]);
          for (const A of E) {
            const P = [M, 0, w], R = A, L = hh(P, e, [0, e, 0]), D = hh(R, e, [0, e, 0]), F = YS(hh(P, e, [0, e, 0]), [null, 0, null]), C = YS(hh(R, e, [0, e, 0]), [null, 0, null]), N = qS(L, P.map((Z) => Z * 2), F.map((Z, G) => C[G] + (Z - C[G]) * (s * 8)), n24), j = qS(D.map((Z, G) => L[G] + (Z - L[G]) * s), R.map((Z) => Z * 2), C, n24);
            f.set(N, h), h += 3, f.set(j, h), h += 3;
          }
        }
      }
    }
    o.current.geometry.attributes.position.needsUpdate = true;
  }), Be.jsx("lineSegments", { ref: o, geometry: l, children: Be.jsx("lineBasicMaterial", { attach: "material", color: "gray" }) });
}
function Xj({ u: n24, r: e, offset: t = 0.1 }) {
  return Be.jsx(Be.Fragment, { children: Be.jsx(nX, { args: [e - t, 100], scale: 1, position: [0, e, 0], "material-transparent": true, "material-opacity": 1 - n24 * 2, "material-color": "black" }) });
}
let Es = RX((n24, e) => ({ scales: ["xs", "m", "xl"], scale: "xl", cameraSettings: [], cameraLock: false, setScale: (t) => {
  const i = e().cameraOptions[t];
  console.log(i), n24({ scale: t, cameraSettings: i });
}, cameraOptions: { xl: { fov: 100, rot: false, zoom: false, pan: false, position: [0, 0, 100] }, m: { fov: 50, rot: false, zoom: false, pan: true, position: [0, 0, 100] }, xs: { fov: 100, rot: true, zoom: false, pan: false, position: [0, 0, 140] } }, hoverClasses: [".MuiToggleButton-root"] }));
function jj({ u: n24, r: e }) {
  const t = ne.useRef(), [i, r] = ne.useState([]), s = { x: 36, y: 18 }, o = 1, a = ne.useMemo(() => {
    const h = new iu(360, 180, s.x, s.y);
    return h.rotateX(-Math.PI / 2), h.scale(1, 1, -1), h;
  }, []);
  return ne.useEffect(() => {
    const l = a.attributes.position.array, f = [];
    for (let h = 0; h < l.length; h += 3) {
      const d = [l[h], l[h + 1], l[h + 2]], p = d.map((S) => S * o), g = hh([d[0], 0, d[2]], e, [0, e, 0]), v = YS(g, [null, 0, null]);
      f.push([g, p, v]);
    }
    r(f);
  }, [a]), ne.useEffect(() => {
    if (!t.current || i.length === 0) return;
    const l = t.current.geometry.attributes.position;
    for (let f = 0; f < i.length; f++) {
      const [h, d, p] = i[f], g = qS(h, d, p, n24);
      l.setXYZ(f, ...g);
    }
    l.needsUpdate = true, t.current.geometry.computeVertexNormals();
  }, [n24, i]), Be.jsx(Be.Fragment, { children: Be.jsx("mesh", { ref: t, geometry: a, children: Be.jsx("meshStandardMaterial", { wireframe: true, transparent: true, opacity: 0 }) }) });
}
function $j() {
  const n24 = Es((r) => r.scale), e = 100, [t, i] = ne.useState(0);
  return ne.useEffect(() => {
    const r = n24 === "xl" ? 0 : n24 === "m" ? 0.5 : 1;
    T0.to({ u: t }, { u: r, duration: 2, ease: "power3.out", onUpdate: function() {
      i(this.targets()[0].u);
    } });
  }, [n24]), Be.jsxs(Be.Fragment, { children: [Be.jsx(Wj, { u: t, r: e }), Be.jsx(jj, { u: t, r: e }), Be.jsx(Xj, { u: t, r: e }), Be.jsx("ambientLight", {}), Be.jsx("pointLight", { position: [10, 10, 10] })] });
}
function Yj() {
  const { camera: n24, pointer: e } = N7(), t = Es((o) => o.cameraSettings), i = Es((o) => o.cameraLock), r = ne.useRef({ x: 0, y: 0 }), s = ne.useRef({ x: 0, y: 0 });
  return ne.useEffect(() => {
    n24.position.set(0, 0, 100), n24.lookAt(0, 0, 0);
  }, [n24]), ne.useEffect(() => {
    t.fov !== void 0 && (T0.to(n24.position, { duration: 1, x: t.position[0], y: t.position[1], z: t.position[2], onUpdate: () => {
      n24.lookAt(0, 0, 0);
    } }), T0.to(n24, { duration: 1, fov: t.fov, onUpdate: () => {
      n24.updateProjectionMatrix();
    } }));
  }, [t]), ne.useEffect(() => {
  }, [i]), FN(() => {
    if (i === false) {
      if (t.rot) {
        const l = e.y * 0.2, f = e.x * 0.5;
        r.current.x += (l - r.current.x) * 0.05, r.current.y += (f - r.current.y) * 0.05, n24.rotation.x = r.current.x, n24.rotation.y = -r.current.y;
      }
      if (t.pan) {
        const l = e.x * 100, f = e.y * 100;
        s.current.x += (l - s.current.x) * 0.02, s.current.y += (f - s.current.y) * 0.02, n24.position.set(s.current.x, s.current.y, n24.position.z);
      }
    }
  }), null;
}
function qj() {
  return Be.jsx(Be.Fragment, { children: Be.jsx(eX, { camera: { near: 0.01, far: 1e3 }, id: "canvas", children: Be.jsxs("group", { rotation: [-Math.PI / 2, 0, 0], children: [Be.jsx($j, {}), Be.jsx(Yj, {})] }) }) });
}
function ME(n24) {
  return n4(n24);
}
function KS(n24, e) {
  return KS = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, i) {
    return t.__proto__ = i, t;
  }, KS(n24, e);
}
function Kj(n24, e) {
  n24.prototype = Object.create(e.prototype), n24.prototype.constructor = n24, KS(n24, e);
}
const J2 = Ml.createContext(null);
function Zj(n24) {
  if (n24 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n24;
}
function wE(n24, e) {
  var t = function(s) {
    return e && ne.isValidElement(s) ? e(s) : s;
  }, i = /* @__PURE__ */ Object.create(null);
  return n24 && ne.Children.map(n24, function(r) {
    return r;
  }).forEach(function(r) {
    i[r.key] = t(r);
  }), i;
}
function Jj(n24, e) {
  n24 = n24 || {}, e = e || {};
  function t(h) {
    return h in e ? e[h] : n24[h];
  }
  var i = /* @__PURE__ */ Object.create(null), r = [];
  for (var s in n24) s in e ? r.length && (i[s] = r, r = []) : r.push(s);
  var o, a = {};
  for (var l in e) {
    if (i[l]) for (o = 0; o < i[l].length; o++) {
      var f = i[l][o];
      a[i[l][o]] = t(f);
    }
    a[l] = t(l);
  }
  for (o = 0; o < r.length; o++) a[r[o]] = t(r[o]);
  return a;
}
function Ll(n24, e, t) {
  return t[e] != null ? t[e] : n24.props[e];
}
function Qj(n24, e) {
  return wE(n24.children, function(t) {
    return ne.cloneElement(t, { onExited: e.bind(null, t), in: true, appear: Ll(t, "appear", n24), enter: Ll(t, "enter", n24), exit: Ll(t, "exit", n24) });
  });
}
function e$(n24, e, t) {
  var i = wE(n24.children), r = Jj(e, i);
  return Object.keys(r).forEach(function(s) {
    var o = r[s];
    if (ne.isValidElement(o)) {
      var a = s in e, l = s in i, f = e[s], h = ne.isValidElement(f) && !f.props.in;
      l && (!a || h) ? r[s] = ne.cloneElement(o, { onExited: t.bind(null, o), in: true, exit: Ll(o, "exit", n24), enter: Ll(o, "enter", n24) }) : !l && a && !h ? r[s] = ne.cloneElement(o, { in: false }) : l && a && ne.isValidElement(f) && (r[s] = ne.cloneElement(o, { onExited: t.bind(null, o), in: f.props.in, exit: Ll(o, "exit", n24), enter: Ll(o, "enter", n24) }));
    }
  }), r;
}
var t$ = Object.values || function(n24) {
  return Object.keys(n24).map(function(e) {
    return n24[e];
  });
}, n$ = { component: "div", childFactory: function(e) {
  return e;
} }, EE = function(n24) {
  Kj(e, n24);
  function e(i, r) {
    var s;
    s = n24.call(this, i, r) || this;
    var o = s.handleExited.bind(Zj(s));
    return s.state = { contextValue: { isMounting: true }, handleExited: o, firstRender: true }, s;
  }
  var t = e.prototype;
  return t.componentDidMount = function() {
    this.mounted = true, this.setState({ contextValue: { isMounting: false } });
  }, t.componentWillUnmount = function() {
    this.mounted = false;
  }, e.getDerivedStateFromProps = function(r, s) {
    var o = s.children, a = s.handleExited, l = s.firstRender;
    return { children: l ? Qj(r, a) : e$(r, o, a), firstRender: false };
  }, t.handleExited = function(r, s) {
    var o = wE(this.props.children);
    r.key in o || (r.props.onExited && r.props.onExited(s), this.mounted && this.setState(function(a) {
      var l = dt({}, a.children);
      return delete l[r.key], { children: l };
    }));
  }, t.render = function() {
    var r = this.props, s = r.component, o = r.childFactory, a = Xi(r, ["component", "childFactory"]), l = this.state.contextValue, f = t$(this.state.children).map(o);
    return delete a.appear, delete a.enter, delete a.exit, s === null ? Ml.createElement(J2.Provider, { value: l }, f) : Ml.createElement(J2.Provider, { value: l }, Ml.createElement(s, a, f));
  }, e;
}(Ml.Component);
EE.propTypes = {};
EE.defaultProps = n$;
function i$(n24) {
  const { className: e, classes: t, pulsate: i = false, rippleX: r, rippleY: s, rippleSize: o, in: a, onExited: l, timeout: f } = n24, [h, d] = ne.useState(false), p = Zr(e, t.ripple, t.rippleVisible, i && t.ripplePulsate), g = { width: o, height: o, top: -(o / 2) + s, left: -(o / 2) + r }, v = Zr(t.child, h && t.childLeaving, i && t.childPulsate);
  return !a && !h && d(true), ne.useEffect(() => {
    if (!a && l != null) {
      const S = setTimeout(l, f);
      return () => {
        clearTimeout(S);
      };
    }
  }, [l, a, f]), Be.jsx("span", { className: p, style: g, children: Be.jsx("span", { className: v }) });
}
const Jr = u_("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]), r$ = ["center", "classes", "className"];
let tv = (n24) => n24, Q2, eR, tR, nR;
const ZS = 550, s$ = 80, o$ = n_(Q2 || (Q2 = tv`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)), a$ = n_(eR || (eR = tv`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)), l$ = n_(tR || (tR = tv`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)), u$ = M_("span", { name: "MuiTouchRipple", slot: "Root" })({ overflow: "hidden", pointerEvents: "none", position: "absolute", zIndex: 0, top: 0, right: 0, bottom: 0, left: 0, borderRadius: "inherit" }), c$ = M_(i$, { name: "MuiTouchRipple", slot: "Ripple" })(nR || (nR = tv`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), Jr.rippleVisible, o$, ZS, ({ theme: n24 }) => n24.transitions.easing.easeInOut, Jr.ripplePulsate, ({ theme: n24 }) => n24.transitions.duration.shorter, Jr.child, Jr.childLeaving, a$, ZS, ({ theme: n24 }) => n24.transitions.easing.easeInOut, Jr.childPulsate, l$, ({ theme: n24 }) => n24.transitions.easing.easeInOut), f$ = ne.forwardRef(function(e, t) {
  const i = ME({ props: e, name: "MuiTouchRipple" }), { center: r = false, classes: s = {}, className: o } = i, a = Xi(i, r$), [l, f] = ne.useState([]), h = ne.useRef(0), d = ne.useRef(null);
  ne.useEffect(() => {
    d.current && (d.current(), d.current = null);
  }, [l]);
  const p = ne.useRef(false), g = FB(), v = ne.useRef(null), S = ne.useRef(null), M = ne.useCallback((A) => {
    const { pulsate: P, rippleX: R, rippleY: L, rippleSize: D, cb: F } = A;
    f((C) => [...C, Be.jsx(c$, { classes: { ripple: Zr(s.ripple, Jr.ripple), rippleVisible: Zr(s.rippleVisible, Jr.rippleVisible), ripplePulsate: Zr(s.ripplePulsate, Jr.ripplePulsate), child: Zr(s.child, Jr.child), childLeaving: Zr(s.childLeaving, Jr.childLeaving), childPulsate: Zr(s.childPulsate, Jr.childPulsate) }, timeout: ZS, pulsate: P, rippleX: R, rippleY: L, rippleSize: D }, h.current)]), h.current += 1, d.current = F;
  }, [s]), m = ne.useCallback((A = {}, P = {}, R = () => {
  }) => {
    const { pulsate: L = false, center: D = r || P.pulsate, fakeElement: F = false } = P;
    if ((A == null ? void 0 : A.type) === "mousedown" && p.current) {
      p.current = false;
      return;
    }
    (A == null ? void 0 : A.type) === "touchstart" && (p.current = true);
    const C = F ? null : S.current, N = C ? C.getBoundingClientRect() : { width: 0, height: 0, left: 0, top: 0 };
    let j, Z, G;
    if (D || A === void 0 || A.clientX === 0 && A.clientY === 0 || !A.clientX && !A.touches) j = Math.round(N.width / 2), Z = Math.round(N.height / 2);
    else {
      const { clientX: J, clientY: q } = A.touches && A.touches.length > 0 ? A.touches[0] : A;
      j = Math.round(J - N.left), Z = Math.round(q - N.top);
    }
    if (D) G = Math.sqrt((2 * N.width ** 2 + N.height ** 2) / 3), G % 2 === 0 && (G += 1);
    else {
      const J = Math.max(Math.abs((C ? C.clientWidth : 0) - j), j) * 2 + 2, q = Math.max(Math.abs((C ? C.clientHeight : 0) - Z), Z) * 2 + 2;
      G = Math.sqrt(J ** 2 + q ** 2);
    }
    A != null && A.touches ? v.current === null && (v.current = () => {
      M({ pulsate: L, rippleX: j, rippleY: Z, rippleSize: G, cb: R });
    }, g.start(s$, () => {
      v.current && (v.current(), v.current = null);
    })) : M({ pulsate: L, rippleX: j, rippleY: Z, rippleSize: G, cb: R });
  }, [r, M, g]), w = ne.useCallback(() => {
    m({}, { pulsate: true });
  }, [m]), E = ne.useCallback((A, P) => {
    if (g.clear(), (A == null ? void 0 : A.type) === "touchend" && v.current) {
      v.current(), v.current = null, g.start(0, () => {
        E(A, P);
      });
      return;
    }
    v.current = null, f((R) => R.length > 0 ? R.slice(1) : R), d.current = P;
  }, [g]);
  return ne.useImperativeHandle(t, () => ({ pulsate: w, start: m, stop: E }), [w, m, E]), Be.jsx(u$, dt({ className: Zr(Jr.root, s.root, o), ref: S }, a, { children: Be.jsx(EE, { component: null, exit: true, children: l }) }));
});
function h$(n24) {
  return lw("MuiButtonBase", n24);
}
const d$ = u_("MuiButtonBase", ["root", "disabled", "focusVisible"]), p$ = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"], m$ = (n24) => {
  const { disabled: e, focusVisible: t, focusVisibleClassName: i, classes: r } = n24, o = J3({ root: ["root", e && "disabled", t && "focusVisible"] }, h$, r);
  return t && i && (o.root += ` ${i}`), o;
}, g$ = M_("button", { name: "MuiButtonBase", slot: "Root", overridesResolver: (n24, e) => e.root })({ display: "inline-flex", alignItems: "center", justifyContent: "center", position: "relative", boxSizing: "border-box", WebkitTapHighlightColor: "transparent", backgroundColor: "transparent", outline: 0, border: 0, margin: 0, borderRadius: 0, padding: 0, cursor: "pointer", userSelect: "none", verticalAlign: "middle", MozAppearance: "none", WebkitAppearance: "none", textDecoration: "none", color: "inherit", "&::-moz-focus-inner": { borderStyle: "none" }, [`&.${d$.disabled}`]: { pointerEvents: "none", cursor: "default" }, "@media print": { colorAdjust: "exact" } }), _$ = ne.forwardRef(function(e, t) {
  const i = ME({ props: e, name: "MuiButtonBase" }), { action: r, centerRipple: s = false, children: o, className: a, component: l = "button", disabled: f = false, disableRipple: h = false, disableTouchRipple: d = false, focusRipple: p = false, LinkComponent: g = "a", onBlur: v, onClick: S, onContextMenu: M, onDragLeave: m, onFocus: w, onFocusVisible: E, onKeyDown: A, onKeyUp: P, onMouseDown: R, onMouseLeave: L, onMouseUp: D, onTouchEnd: F, onTouchMove: C, onTouchStart: N, tabIndex: j = 0, TouchRippleProps: Z, touchRippleRef: G, type: J } = i, q = Xi(i, p$), ae = ne.useRef(null), B = ne.useRef(null), Y = Cb(B, G), { isFocusVisibleRef: $, onFocus: ee, onBlur: ue, ref: Ae } = jB(), [te, de] = ne.useState(false);
  f && te && de(false), ne.useImperativeHandle(r, () => ({ focusVisible: () => {
    de(true), ae.current.focus();
  } }), []);
  const [Ee, Ie] = ne.useState(false);
  ne.useEffect(() => {
    Ie(true);
  }, []);
  const Ze = Ee && !h && !f;
  ne.useEffect(() => {
    te && p && !h && Ee && B.current.pulsate();
  }, [h, p, te, Ee]);
  function Oe(Re, ye, bt = d) {
    return hm((gt) => (ye && ye(gt), !bt && B.current && B.current[Re](gt), true));
  }
  const at = Oe("start", R), Ge = Oe("stop", M), X = Oe("stop", m), Se = Oe("stop", D), pe = Oe("stop", (Re) => {
    te && Re.preventDefault(), L && L(Re);
  }), we = Oe("start", N), me = Oe("stop", F), qe = Oe("stop", C), Ne = Oe("stop", (Re) => {
    ue(Re), $.current === false && de(false), v && v(Re);
  }, false), U = hm((Re) => {
    ae.current || (ae.current = Re.currentTarget), ee(Re), $.current === true && (de(true), E && E(Re)), w && w(Re);
  }), O = () => {
    const Re = ae.current;
    return l && l !== "button" && !(Re.tagName === "A" && Re.href);
  }, ie = ne.useRef(false), xe = hm((Re) => {
    p && !ie.current && te && B.current && Re.key === " " && (ie.current = true, B.current.stop(Re, () => {
      B.current.start(Re);
    })), Re.target === Re.currentTarget && O() && Re.key === " " && Re.preventDefault(), A && A(Re), Re.target === Re.currentTarget && O() && Re.key === "Enter" && !f && (Re.preventDefault(), S && S(Re));
  }), ve = hm((Re) => {
    p && Re.key === " " && B.current && te && !Re.defaultPrevented && (ie.current = false, B.current.stop(Re, () => {
      B.current.pulsate(Re);
    })), P && P(Re), S && Re.target === Re.currentTarget && O() && Re.key === " " && !Re.defaultPrevented && S(Re);
  });
  let ge = l;
  ge === "button" && (q.href || q.to) && (ge = g);
  const ze = {};
  ge === "button" ? (ze.type = J === void 0 ? "button" : J, ze.disabled = f) : (!q.href && !q.to && (ze.role = "button"), f && (ze["aria-disabled"] = f));
  const Le = Cb(t, Ae, ae), ke = dt({}, i, { centerRipple: s, component: l, disabled: f, disableRipple: h, disableTouchRipple: d, focusRipple: p, tabIndex: j, focusVisible: te }), et = m$(ke);
  return Be.jsxs(g$, dt({ as: ge, className: Zr(et.root, a), ownerState: ke, onBlur: Ne, onClick: S, onContextMenu: Ge, onFocus: U, onKeyDown: xe, onKeyUp: ve, onMouseDown: at, onMouseLeave: pe, onMouseUp: Se, onDragLeave: X, onTouchEnd: me, onTouchMove: qe, onTouchStart: we, ref: Le, tabIndex: f ? -1 : j, type: J }, ze, q, { children: [o, Ze ? Be.jsx(f$, dt({ ref: Y, center: s }, Z)) : null] }));
}), v$ = u_("MuiBox", ["root"]), y$ = pw(), YD = MB({ themeId: o0, defaultTheme: y$, defaultClassName: v$.root, generateClassName: X3.generate });
function x$(n24) {
  return lw("MuiToggleButton", n24);
}
const iR = u_("MuiToggleButton", ["root", "disabled", "selected", "standard", "primary", "secondary", "sizeSmall", "sizeMedium", "sizeLarge", "fullWidth"]), S$ = ne.createContext({}), M$ = ne.createContext(void 0);
function w$(n24, e) {
  return e === void 0 || n24 === void 0 ? false : Array.isArray(e) ? e.indexOf(n24) >= 0 : n24 === e;
}
const E$ = ["value"], T$ = ["children", "className", "color", "disabled", "disableFocusRipple", "fullWidth", "onChange", "onClick", "selected", "size", "value"], A$ = (n24) => {
  const { classes: e, fullWidth: t, selected: i, disabled: r, size: s, color: o } = n24, a = { root: ["root", i && "selected", r && "disabled", t && "fullWidth", `size${Nd(s)}`, o] };
  return J3(a, x$, e);
}, b$ = M_(_$, { name: "MuiToggleButton", slot: "Root", overridesResolver: (n24, e) => {
  const { ownerState: t } = n24;
  return [e.root, e[`size${Nd(t.size)}`]];
} })(({ theme: n24, ownerState: e }) => {
  let t = e.color === "standard" ? n24.palette.text.primary : n24.palette[e.color].main, i;
  return n24.vars && (t = e.color === "standard" ? n24.vars.palette.text.primary : n24.vars.palette[e.color].main, i = e.color === "standard" ? n24.vars.palette.text.primaryChannel : n24.vars.palette[e.color].mainChannel), dt({}, n24.typography.button, { borderRadius: (n24.vars || n24).shape.borderRadius, padding: 11, border: `1px solid ${(n24.vars || n24).palette.divider}`, color: (n24.vars || n24).palette.action.active }, e.fullWidth && { width: "100%" }, { [`&.${iR.disabled}`]: { color: (n24.vars || n24).palette.action.disabled, border: `1px solid ${(n24.vars || n24).palette.action.disabledBackground}` }, "&:hover": { textDecoration: "none", backgroundColor: n24.vars ? `rgba(${n24.vars.palette.text.primaryChannel} / ${n24.vars.palette.action.hoverOpacity})` : fm(n24.palette.text.primary, n24.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: "transparent" } }, [`&.${iR.selected}`]: { color: t, backgroundColor: n24.vars ? `rgba(${i} / ${n24.vars.palette.action.selectedOpacity})` : fm(t, n24.palette.action.selectedOpacity), "&:hover": { backgroundColor: n24.vars ? `rgba(${i} / calc(${n24.vars.palette.action.selectedOpacity} + ${n24.vars.palette.action.hoverOpacity}))` : fm(t, n24.palette.action.selectedOpacity + n24.palette.action.hoverOpacity), "@media (hover: none)": { backgroundColor: n24.vars ? `rgba(${i} / ${n24.vars.palette.action.selectedOpacity})` : fm(t, n24.palette.action.selectedOpacity) } } } }, e.size === "small" && { padding: 7, fontSize: n24.typography.pxToRem(13) }, e.size === "large" && { padding: 15, fontSize: n24.typography.pxToRem(15) });
}), C$ = ne.forwardRef(function(e, t) {
  const i = ne.useContext(S$), { value: r } = i, s = Xi(i, E$), o = ne.useContext(M$), a = u0(dt({}, s, { selected: w$(e.value, r) }), e), l = ME({ props: a, name: "MuiToggleButton" }), { children: f, className: h, color: d = "standard", disabled: p = false, disableFocusRipple: g = false, fullWidth: v = false, onChange: S, onClick: M, selected: m, size: w = "medium", value: E } = l, A = Xi(l, T$), P = dt({}, l, { color: d, disabled: p, disableFocusRipple: g, fullWidth: v, size: w }), R = A$(P), L = (F) => {
    M && (M(F, E), F.defaultPrevented) || S && S(F, E);
  }, D = o || "";
  return Be.jsx(b$, dt({ className: Zr(s.className, R.root, h, D), disabled: p, focusRipple: !g, ref: t, onClick: L, onChange: S, value: E, ownerState: P, "aria-pressed": m }, A, { children: f }));
});
function R$() {
  const n24 = Es.getState().scales, e = Es.getState().scale, t = Es((f) => f.setScale), [i, r] = ne.useState(n24.indexOf(e)), s = ne.useRef(false), o = ne.useRef(0), a = 200, l = (f) => {
    o.current += f.deltaY, !s.current && Math.abs(o.current) >= a && (s.current = true, setTimeout(() => {
      s.current = false;
    }, 0), r((h) => o.current > 0 && h < 2 ? (o.current = 0, h + 1) : o.current < 0 && h > 0 ? (o.current = 0, h - 1) : (o.current = 0, h)));
  };
  return ne.useEffect(() => {
    t(n24[i]);
  }, [i]), ne.useEffect(() => (window.addEventListener("wheel", l), () => window.removeEventListener("wheel", l)), []), null;
}
function P$() {
  const n24 = Es((a) => a.scale), e = Es((a) => a.setScale), [t, i] = ne.useState(Es.getState().scale), r = "5vh", s = [{ value: "xs", label: "Pavillion" }, { value: "m", label: "Fieldwork" }, { value: "xl", label: "World" }], o = (a, l) => {
    l !== null && (i(l), e(l));
  };
  return ne.useEffect(() => {
    i(n24);
  }, [n24]), Be.jsx(Be.Fragment, { children: Be.jsx(YD, { sx: { mb: r, backgroundColor: "whitesmoke", border: "1px solid grey", backgroundBlendMode: "darken", borderRadius: r, display: "flex", justifyContent: "center", alignItems: "center", pointerEvents: "auto", p: 1 }, children: s.map((a, l) => Be.jsx(C$, { sx: { borderRadius: r, px: 10, ml: l === 0 ? 0 : 1, mr: l === s.length - 1 ? 0 : 1 }, onChange: o, size: "small", value: a.value, selected: t === a.value, children: a.label })) }) });
}
function L$() {
  const [n24, e] = ne.useState({ x: 0, y: 0 }), [t, i] = ne.useState(false), r = Es.getState().hoverClasses;
  return ne.useEffect(() => {
    const s = (a) => {
      e({ x: a.clientX, y: a.clientY });
    }, o = (a) => {
      const l = a.target.closest(r.join(", "));
      i(!!l);
    };
    return window.addEventListener("mousemove", s), window.addEventListener("mouseover", o), () => {
      window.removeEventListener("mousemove", s), window.removeEventListener("mouseover", o);
    };
  }, []), Be.jsx("div", { style: { position: "fixed", top: n24.y, left: n24.x, width: `${16 + t * 10}px`, height: `${16 + t * 10}px`, border: `1px solid ${t ? "black" : "whitesmoke"}`, backgroundColor: t ? "whitesmoke" : "black", borderRadius: "50%", pointerEvents: "none", transform: "translate(-50%, -50%)", zIndex: 9999, transition: "all 150ms ease, top 0ms, left 0ms" } });
}
function I$() {
  return Be.jsx(Be.Fragment, { children: Be.jsxs(YD, { sx: { top: 0, left: 0, position: "absolute", width: "100vw", height: "100vh", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "flex-end", zIndex: 10, pointerEvents: "none" }, children: [Be.jsx(L$, {}), Be.jsx(R$, {}), Be.jsx(P$, {})] }) });
}
const N$ = Bx.createRoot(document.querySelector("#root")), D$ = Es.getState().setScale;
O$();
N$.render(Be.jsx(Be.Fragment, { children: Be.jsxs(p5, { theme: m5, children: [Be.jsx(I$, {}), Be.jsx(qj, {})] }) }));
async function O$() {
  D$("m");
}
